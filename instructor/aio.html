<!DOCTYPE html>
<!-- START: inst/pkgdown/templates/layout.html --><!-- Generated by pkgdown: do not edit by hand --><html lang="en" data-bs-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Trustworthy AI: Explainability, Bias, Fairness, and Safety: All in One View</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="../assets/themetoggle.js"></script><link rel="stylesheet" type="text/css" href="../assets/styles.css">
<script src="../assets/scripts.js" type="text/javascript"></script><!-- mathjax --><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      config: ["MMLorHTML.js"],
      jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [['\\(', '\\)']],
        displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
        processEscapes: true
      }
    });
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><!-- Responsive Favicon for The Carpentries --><link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="manifest" href="../site.webmanifest">
<link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="white">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="black">
</head>
<body>
    <header id="top" class="navbar navbar-expand-md top-nav incubator"><svg xmlns="http://www.w3.org/2000/svg" class="d-none"><symbol id="check2" viewbox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path></symbol><symbol id="circle-half" viewbox="0 0 16 16"><path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path></symbol><symbol id="moon-stars-fill" viewbox="0 0 16 16"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path><path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"></path></symbol><symbol id="sun-fill" viewbox="0 0 16 16"><path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></symbol></svg><a class="visually-hidden-focusable skip-link" href="#main-content">Skip to main content</a>
  <div class="container-fluid top-nav-container">
    <div class="col-md-8">
      <div class="large-logo">
        <img id="incubator-logo" alt="Carpentries Incubator" src="../assets/images/incubator-logo.svg"><span class="badge text-bg-danger">
          <abbr title="This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.">
            <a href="https://cdh.carpentries.org/the-lesson-life-cycle.html#early-development-pre-alpha-through-alpha" class="external-link alert-link">
              <i aria-hidden="true" class="icon" data-feather="alert-octagon" style="border-radius: 5px"></i>
              Pre-Alpha
            </a>
            <span class="visually-hidden">This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.</span>
          </abbr>
        </span>

      </div>
    </div>
    <div class="selector-container">
      <div id="theme-selector">
        <li class="nav-item dropdown" id="theme-button-list">
          <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
            <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="bd-theme-text">
<li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                Light
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                Dark
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                Auto
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
          </ul>
</li>
      </div>

      <div class="dropdown" id="instructor-dropdown">
        <button class="btn btn-secondary dropdown-toggle bordered-button" type="button" id="dropdownMenu1" data-bs-toggle="dropdown" aria-expanded="false">
          <i aria-hidden="true" class="icon" data-feather="eye"></i> Instructor View <i data-feather="chevron-down"></i>
        </button>
        <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
<li><button class="dropdown-item" type="button" onclick="window.location.href='../aio.html';">Learner View</button></li>
        </ul>
</div>
    </div>
  </div>
  <hr></header><nav class="navbar navbar-expand-xl bottom-nav incubator" aria-label="Main Navigation"><div class="container-fluid nav-container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle Navigation">
      <span class="navbar-toggler-icon"></span>
      <span class="menu-title">Menu</span>
    </button>
    <div class="nav-logo">
      <img class="small-logo" alt="Carpentries Incubator" src="../assets/images/incubator-logo-sm.svg">
</div>
    <div class="lesson-title-md">
      Trustworthy AI: Explainability, Bias, Fairness, and Safety
    </div>
    <div class="search-icon-sm">
      <!-- TODO: do not show until we have search
        <i role="img" aria-label="Search the All In One page" data-feather="search"></i>
      -->
    </div>
    <div class="desktop-nav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
<li class="nav-item">
          <span class="lesson-title">
            Trustworthy AI: Explainability, Bias, Fairness, and Safety
          </span>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/key-points.html">Key Points</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/instructor-notes.html">Instructor Notes</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/images.html">Extract All Images</a>
        </li>
        <li class="nav-item dropdown">
          <button class="nav-link dropdown-toggle" id="navbarDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            More <i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
<hr>
<li><a class="dropdown-item" href="reference.html">Reference</a></li>
          </ul>
</li>
      </ul>
</div>
    <!--
    <form class="d-flex col-md-2 search-form">
      <fieldset disabled>
      <input class="form-control me-2 searchbox" type="search" placeholder="" aria-label="">
        <button class="btn btn-outline-success tablet-search-button"  type="submit">
          <i class="search-icon" data-feather="search" role="img" aria-label="Search the All In One page"></i>
        </button>
      </fieldset>
    </form>
    -->
    <a id="search-button" class="btn btn-primary" href="../instructor/aio.html" role="button" aria-label="Search the All In One page">Search the All In One page</a>
  </div>
<!--/div.container-fluid -->
</nav><div class="col-md-12 mobile-title">
  Trustworthy AI: Explainability, Bias, Fairness, and Safety
</div>

<aside class="col-md-12 lesson-progress"><div style="width: %" class="percentage">
    %
  </div>
  <div class="progress incubator">
    <div class="progress-bar incubator" role="progressbar" style="width: %" aria-valuenow="" aria-label="Lesson Progress" aria-valuemin="0" aria-valuemax="100">
    </div>
  </div>
</aside><div class="container">
      <div class="row">
        <!-- START: inst/pkgdown/templates/navbar.html -->
<div id="sidebar-col" class="col-lg-4">
  <div id="sidebar" class="sidebar">
      <nav aria-labelledby="flush-headingEleven"><button role="button" aria-label="close menu" alt="close menu" aria-expanded="true" aria-controls="sidebar" class="collapse-toggle" data-collapse="Collapse " data-episodes="Episodes ">
          <i class="search-icon" data-feather="x" role="img"></i>
        </button>
        <div class="sidebar-inner">
          <div class="row mobile-row" id="theme-row-mobile">
            <div class="col" id="theme-selector">
              <li class="nav-item dropdown" id="theme-button-list">
                <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
                  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><span class="d-lg-none ms-1" id="bd-theme-text">Toggle Theme</span>
                </button>
                <ul class="dropdown-menu dropdown-menu-right" aria-labelledby="bd-theme-text">
<li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                      Light
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                      Dark
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                      <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                      Auto
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                </ul>
</li>
            </div>
          </div>
          <div class="row mobile-row">
            <div class="col">
              <div class="sidenav-view-selector">
                <div class="accordion accordion-flush" id="accordionFlush9">
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingNine">
                      <button class="accordion-button collapsed" id="instructor" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <i id="eye" aria-hidden="true" class="icon" data-feather="eye"></i> Instructor View
                      </button>
                    </h2>
                    <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlush2">
                      <div class="accordion-body">
                        <a href="../aio.html">Learner View</a>
                      </div>
                    </div>
                  </div>
<!--/div.accordion-item-->
                </div>
<!--/div.accordion-flush-->
              </div>
<!--div.sidenav-view-selector -->
            </div>
<!--/div.col -->

            <hr>
</div>
<!--/div.mobile-row -->

          <div class="accordion accordion-flush" id="accordionFlush11">
            <div class="accordion-item">

              <button id="chapters" class="accordion-button show" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                <h2 class="accordion-header chapters" id="flush-headingEleven">
                  EPISODES
                </h2>
              </button>
              <div id="flush-collapseEleven" class="accordion-collapse show collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlush11">

                <div class="accordion-body">
                  <div class="accordion accordion-flush" id="accordionFlush1">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading1">
        <a href="index.html">Summary and Schedule</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush2">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading2">
        <a href="0-introduction.html">1. Overview</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush3">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading3">
        <a href="1-preparing-to-train.html">2. Preparing to train a model</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush4">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading4">
        <a href="2-model-fitting.html">3. Scientific validity in the modeling process</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush5">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading5">
        <a href="3-model-eval-and-fairness.html">4. Model evaluation and fairness</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush6">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading6">
        <a href="4-explainability-vs-interpretability.html">5. Interpretablility versus explainability</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush7">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading7">
        <a href="5a-explainable-AI-method-overview.html">6. Explainability methods overview</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush8">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading8">
        <a href="5b-deep-dive-into-methods.html">7. Explainability methods: deep dive</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush9">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading9">
        <a href="5c-probes.html">8. Explainability methods: linear probe</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush10">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading10">
        <a href="5d-gradcam.html">9. Explainability methods: GradCAM</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush11">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading11">
        <a href="6-confidence-intervals.html">10. Estimating model uncertainty</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush12">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading12">
        <a href="7a-OOD-detection-output-based.html">11. OOD detection: overview, output-based methods</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush13">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading13">
        <a href="7b-OOD-detection-distance-based.html">12. OOD detection: distance-based and contrastive learning</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush14">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading14">
        <a href="7c-OOD-detection-algo-design.html">13. OOD detection: training-time regularization</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush15">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading15">
        <a href="8-releasing-a-model.html">14. Documenting and releasing a model</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

                </div>
              </div>
            </div>

            <hr class="half-width">
<div class="accordion accordion-flush lesson-resources" id="accordionFlush12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingTwelve">
                  <button class="accordion-button collapsed" id="lesson-resources" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                    RESOURCES
                  </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlush12">
                  <div class="accordion-body">
                    <ul>
<li>
                        <a href="../instructor/key-points.html">Key Points</a>
                      </li>
                      <li>
                        <a href="../instructor/instructor-notes.html">Instructor Notes</a>
                      </li>
                      <li>
                        <a href="../instructor/images.html">Extract All Images</a>
                      </li>
                      <hr>
<li><a class="dropdown-item" href="reference.html">Reference</a></li>
                    </ul>
</div>
                </div>
              </div>
            </div>
            <hr class="half-width lesson-resources">
<a href="../instructor/aio.html">See all in one page</a>


            <hr class="d-none d-sm-block d-md-none">
<div class="d-grid gap-1">

            </div>
          </div>
<!-- /div.accordion -->
        </div>
<!-- /div.sidebar-inner -->
      </nav>
</div>
<!-- /div.sidebar -->
  </div>
<!-- /div.sidebar-col -->
<!-- END:   inst/pkgdown/templates/navbar.html-->

        <!-- START: inst/pkgdown/templates/content-extra.html -->
  <div class="col-xl-8 col-lg-12 primary-content">
    <main id="main-content" class="main-content"><div class="container lesson-content">
        
        
<section id="aio-0-introduction"><p>Content from <a href="0-introduction.html">Overview</a></p>
<hr>
<p>Last updated on 2024-06-19 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/0-introduction.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 31 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<div id="accordionInstructor1" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor1" aria-expanded="false" aria-controls="collapseInstructor1">
  <h3 class="accordion-header" id="headingInstructor1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Instructor Note </h3>
</button>
<div id="collapseInstructor1" class="accordion-collapse collapse" aria-labelledby="headingInstructor1" data-bs-parent="#accordionInstructor1">
<div class="accordion-body">
<p>Inline instructor notes can help inform instructors of timing
challenges associated with the lessons. They appear in the “Instructor
View”</p>
</div>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-1-preparing-to-train"><p>Content from <a href="1-preparing-to-train.html">Preparing to train a model</a></p>
<hr>
<p>Last updated on 2024-07-31 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/1-preparing-to-train.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>For what prediction tasks is machine learning an appropriate
tool?</li>
<li>How can inappropriate target variable choice lead to suboptimal
outcomes in a machine learning pipeline?</li>
<li>What forms of “bias” can occur in machine learning, and where do
these biases come from?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Judge what tasks are appropriate for machine learning</li>
<li>Understand why the choice of prediction task / target variable is
important.</li>
<li>Describe how bias can appear in training data and algorithms.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="choosing-appropriate-tasks">Choosing appropriate tasks<a class="anchor" aria-label="anchor" href="#choosing-appropriate-tasks"></a>
</h2>
<hr class="half-width">
<p>Machine learning is a rapidly advancing, powerful technology that is
helping to drive innovation. Before embarking on a machine learning
project, we need to consider the task carefully. Many machine learning
efforts are not solving problems that need to be solved. Or, the problem
may be valid, but the machine learning approach makes incorrect
assumptions and fails to solve the problem effectively. Worse, many
applications of machine learning are not for the public good.</p>
<p>We will start by considering the <a href="https://www.nih.gov/health-information/nih-clinical-research-trials-you/guiding-principles-ethical-research" class="external-link">NIH
Guiding Principles for Ethical Research</a>, which provide a useful set
of considerations for any project.</p>
<div id="discussion1" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Take a look at the <a href="https://www.nih.gov/health-information/nih-clinical-research-trials-you/guiding-principles-ethical-research" class="external-link">NIH
Guiding Principles for Ethical Research</a>.</p>
<p>What are the main principles?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<p>A summary of the principles is listed below:</p>
<ul>
<li>Social and clinical value: Does the social or clinical value of
developing and implementing the model outweigh the risk and burden of
the people involved?</li>
<li>Scientific validity: Once created, will the model provide valid,
meaningful outputs?</li>
<li>Fair subject selection: Are the people who contribute and benefit
from the model selected fairly, and not through vulnerability,
privilege, or other unrelated factors?</li>
<li>Favorable risk-benefit ratio: Do the potential benefits of of
developing and implementing the model outweigh the risks?</li>
<li>Independent review: Has the project been reviewed by someone
independent of the project, and has an Institutional Review Board (IRB)
been approached where appropriate?</li>
<li>Informed consent: Are participants whose data contributes to
development and implementation of the model, as well as downstream
recipients of the model, kept informed?</li>
<li>Respect for potential and enrolled subjects: Is the privacy of
participants respected and are steps taken to continuously monitor the
effect of the model on downstream participants?</li>
</ul>
</div>
</div>
</div>
</div>
<p>AI tasks are often most controversial when they involve human
subjects, and especially visual representations of people. We’ll discuss
two case studies that use people’s faces as a prediction tool, and
discuss whether these uses of AI are appropriate.</p>
<div class="section level3">
<h3 id="case-study-1-physiognomy">Case study 1: Physiognomy<a class="anchor" aria-label="anchor" href="#case-study-1-physiognomy"></a>
</h3>
<p>In 2019, Nature Medicine <a href="https://www.nature.com/articles/s41591-018-0279-0.epdf" class="external-link">published
a paper</a> that describes a model that can identify genetic disorders
from a photograph of a patient’s face. The abstract of the paper is
copied below:</p>
<blockquote>
<p>Syndromic genetic conditions, in aggregate, affect 8% of the
population. Many syndromes have recognizable facial features that are
highly informative to clinical geneticists. Recent studies show that
facial analysis technologies measured up to the capabilities of expert
clinicians in syndrome identification. However, these technologies
identified only a few disease phenotypes, limiting their role in
clinical settings, where hundreds of diagnoses must be considered. Here
we present a facial image analysis framework, DeepGestalt, using
computer vision and deep-learning algorithms, that quantifies
similarities to hundreds of syndromes.</p>
<p>DeepGestalt outperformed clinicians in three initial experiments, two
with the goal of distinguishing subjects with a target syndrome from
other syndromes, and one of separating different genetic sub-types in
Noonan syndrome. On the final experiment reflecting a real clinical
setting problem, DeepGestalt achieved 91% top-10 accuracy in identifying
the correct syndrome on 502 different images. The model was trained on a
dataset of over 17,000 images representing more than 200 syndromes,
curated through a community-driven phenotyping platform. DeepGestalt
potentially adds considerable value to phenotypic evaluations in
clinical genetics, genetic testing, research and precision medicine.</p>
</blockquote>
<ul>
<li>What is the proposed value of the algorithm?</li>
<li>What are the potential risks?</li>
<li>Are you supportive of this kind of research?</li>
<li>What safeguards, if any, would you want to be used when developing
and using this algorithm?</li>
</ul>
<p>Media reports about this paper were largely positive, e.g., <a href="https://www.genengnews.com/insights/a-i-gets-in-the-face-of-rare-genetic-diseases/" class="external-link">reporting
that clinicians are excited about the new technology</a>.</p>
</div>
<div class="section level3">
<h3 id="case-study-2">Case study 2:<a class="anchor" aria-label="anchor" href="#case-study-2"></a>
</h3>
<p>There is a long history of physiognomy, the “science” of trying to
read someone’s character from their face. With the advent of machine
learning, this discredited area of research has made a comeback. There
have been numerous studies attempting to guess characteristics such as
trustworthness, criminality, and political and sexual orientation.</p>
<p>In 2018, for example, researchers suggested that neural networks
could be used to detect sexual orientation from facial images. The
abstract is copied below:</p>
<blockquote>
<p>We show that faces contain much more information about sexual
orientation than can be perceived and interpreted by the human brain. We
used deep neural networks to extract features from 35,326 facial images.
These features were entered into a logistic regression aimed at
classifying sexual orientation. Given a single facial image, a
classifier could correctly distinguish between gay and heterosexual men
in 81% of cases, and in 74% of cases for women. Human judges achieved
much lower accuracy: 61% for men and 54% for women. The accuracy of the
algorithm increased to 91% and 83%, respectively, given five facial
images per person.</p>
<p>Facial features employed by the classifier included both fixed (e.g.,
nose shape) and transient facial features (e.g., grooming style).
Consistent with the prenatal hormone theory of sexual orientation, gay
men and women tended to have gender-atypical facial morphology,
expression, and grooming styles. Prediction models aimed at gender alone
allowed for detecting gay males with 57% accuracy and gay females with
58% accuracy. Those findings advance our understanding of the origins of
sexual orientation and the limits of human perception. Additionally,
given that companies and governments are increasingly using computer
vision algorithms to detect people’s intimate traits, our findings
expose a threat to the privacy and safety of gay men and women.</p>
</blockquote>
<ul>
<li>What is the proposed value of the algorithm?</li>
<li>What are the potential risks?</li>
<li>Are you supportive of this kind of research?</li>
<li>What distinguishes this use of AI from the use of AI described in
Case Study 1?</li>
</ul>
<p>Media reports of this algorithm were largely negative, with a <a href="https://www.scientificamerican.com/blog/observations/can-we-read-a-persons-character-from-facial-images/" class="external-link">Scientific
American article</a> highlighting the connections to physiognomy and
raising concern over government use of these algorithms:</p>
<blockquote>
<p>This is precisely the kind of “scientific” claim that can motivate
repressive governments to apply AI algorithms to images of their
citizens. And what is it to stop them from “reading” intelligence,
political orientation and criminal inclinations from these images?</p>
</blockquote>
</div>
</section><section><h2 class="section-heading" id="choosing-the-outcome-variable">Choosing the outcome variable<a class="anchor" aria-label="anchor" href="#choosing-the-outcome-variable"></a>
</h2>
<hr class="half-width">
<p>Sometimes, choosing the outcome variable is easy: for instance, when
building a model to predict how warm it will be out tomorrow, the
temperature can be the outcome variable because it’s measurable (i.e.,
you know what temperature it was yesterday and today) and your
predictions won’t cause a feedback loop (e.g., given a set of past
weather data, the weather next Monday won’t change based on what your
model predicts tomorrow’s temperature to be).</p>
<p>By contrast, sometimes it’s not possible to measure the target
prediction subject directly, and sometimes predictions can cause
feedback loops.</p>
<div class="section level3">
<h3 id="case-study-proxy-variables">Case Study: Proxy variables<a class="anchor" aria-label="anchor" href="#case-study-proxy-variables"></a>
</h3>
<p>Consider the scenario described in the challenge below.</p>
<div id="discussion2" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Suppose that you work for a hospital and are asked to build a model
to predict which patients are high-risk and need extra care to prevent
negative health outcomes.</p>
<p>Discuss the following with a partner or small group: 1. What is the
goal target variable? 2. What are challenges in measuring the target
variable in the training data (i.e., former patients)? 3. Are there
other variables that are easier to measure, but can approximate the
target variable, that could serve as proxies? 3. How do social
inequities interplay with the value of the target variable versus the
value of the proxies?</p>
</div>
</div>
</div>
<p>The “challenge” scenario is not hypothetical: A well-known <a href="https://escholarship.org/content/qt6h92v832/qt6h92v832.pdf" class="external-link">study
by Obermeyer et al.</a> analyzed an algorithm that hospitals used to
assign patients risk scores for various conditions. The algorithm had
access to various patient data, such as demographics (e.g., age and
sex), the number of chronic conditions, insurance type, diagnoses, and
medical costs. The algorithm did not have access to the patient’s race.
The patient risk score determined the level of care the patient should
receive, with higher-risk patients receiving additional care.</p>
<p>Ideally, the target variable would be health needs, but this can be
challenging to measure: how do you compare the severity of two different
conditions? Do you count chronic and acute conditions equally? In the
system described by Obermeyer et al., the hospital decided to use
<strong>health-care costs</strong> as a proxy for health needs, perhaps
reasoning that this data is at least standardized across patients and
doctors.</p>
<p>However, Obermeyer et al. reveal that the algorithm is biased against
Black patients. That is, if there are two individuals – one white and
one Black – with equal health, the algorithm tends to assign a higher
risk score to the white patient, thus giving them access to higher care
quality. The authors blame the choice of proxy variable for the racial
disparities.</p>
<p>The authors go on to describe how, due to how health-care access is
structured in the US, richer patients have more healthcare expenses,
even if they are equally (un)healthy to a lower-income patient. The
richer patients are also more likely to be white.</p>
<p>Consider the following:</p>
<ul>
<li>How could the algorithm developers have caught this problem
earlier?</li>
<li>Is this a technical mistake or a process-based mistake? Why?</li>
</ul>
</div>
<div class="section level3">
<h3 id="case-study-feedback-loop">Case study: Feedback loop<a class="anchor" aria-label="anchor" href="#case-study-feedback-loop"></a>
</h3>
<p>Consider social media, like Instagram or TikTok’s “for you page” or
Facebook or Twitter’s newsfeed. The algorithms that determine what to
show are complex (and proprietary!) but a large part of the algorithms’
objective is engagement: the number of clicks, views, or re-posts. For
instance, this focus on engagement can create an “echo chamber” where
individual users solely see content that aligns with their political
ideology, thereby maximizing the positive engagement with each post. But
the impact of social media feedback loops spreads beyond politics: <a href="https://arxiv.org/pdf/2305.11316" class="external-link">researchers have explored</a>
how similar feedback loops exist for mental health conditions such as
eating disorders. If someone finds themselves in this area of social
media, it’s likely because they have, or have risk factors for, an
eating disorder, and seeing pro-eating disorder content can drive
engagement, but ultimately be very bad for mental health.</p>
<p>Consider the following questions:</p>
<ul>
<li>Why do social media companies optimize for engagement?</li>
<li>What would be an alternative optimization target? How would the
outcomes differ, both for users and for the companies’ profits?</li>
</ul>
</div>
</section><section><h2 class="section-heading" id="understanding-bias">Understanding bias<a class="anchor" aria-label="anchor" href="#understanding-bias"></a>
</h2>
<hr class="half-width">
<p>The term “bias” is overloaded, and can have the following
definitions:</p>
<ul>
<li>(Statistical) bias: the tendency of an algorithm to produce one
solution over another, even though some alternatives may be just as
good, or better. Statistical bias can have multiple sources, which we’ll
get into below.</li>
<li>(Social) bias: outcomes are unfair to one or more social groups.
Social bias can be the result of statistical bias (i.e., an algorithm
giving preferential treatment to one social group over others), but can
also occur outside of a machine learning context.</li>
</ul>
<div class="section level3">
<h3 id="sources-of-statistical-bias">Sources of statistical bias<a class="anchor" aria-label="anchor" href="#sources-of-statistical-bias"></a>
</h3>
<div class="section level4">
<h4 id="algorithmic-bias">Algorithmic bias<a class="anchor" aria-label="anchor" href="#algorithmic-bias"></a>
</h4>
<p>Algorithmic bias is the tendency of an algorithm to favor one
solution over another. Algorithmic bias is not always bad, and may
sometimes be encoded for by algorithm developers. For instance, linear
regression with L0-regularization displays algorithmic bias towards
sparse classifiers (i.e., classifiers where most weights are 0). This
bias may be desirable in settings where human interpretability is
important.</p>
<p>But algorithmic bias can also occur unintentionally: for instance, if
there is data bias (described below), this may lead algorithm developers
to select an algorithm that is ill-suited to underrepresented groups.
Then, even if the data bias is rectified, sticking with the original
algorithm choice may not fix biased outcomes.</p>
</div>
<div class="section level4">
<h4 id="data-bias">Data bias:<a class="anchor" aria-label="anchor" href="#data-bias"></a>
</h4>
<p>Data bias is when the available training data is not accurate or
representative of the target population. Data bias is extremely common
(it’s often hard to collect perfectly-representative, and
perfectly-accurate data), and care arise in multiple ways:</p>
<ul>
<li>Measurement error - if a tool is not well calibrated, measurements
taken by that tool won’t be accurate. Likewise, human biases can lead to
measurement error, for instance, if people systematically over-report
their height on dating apps, or if doctors do not believe patient’s
self-reports of their pain levels.</li>
<li>Response bias - for instance, when conducting a survey about
customer satisfaction, customers who had very positive or very negative
experiences may be more likely to respond.</li>
<li>Representation bias - the data is not well representative of the
whole population. For instance, doing clinical trials primarily on white
men means that women and other races are not well represented in
data.</li>
</ul>
<p>Through the rest of this lesson, if we use the term “bias” without
any additional context, we will be referring to social bias that stems
from statistical bias.</p>
<div id="case-study" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="case-study" class="callout-inner">
<h3 class="callout-title">Case Study</h3>
<div class="callout-content">
<p>With a partner or small group, choose one of the three case study
options. Read or watch individually, then discuss as a group how bias
manifested in the training data, and what strategies could correct for
it.</p>
<p>After the discussion, share with the whole workshop what you
discussed.</p>
<ol style="list-style-type: decimal">
<li><a href="https://www.technologyreview.com/2019/02/13/137444/predictive-policing-algorithms-ai-crime-dirty-data/" class="external-link">Predictive
policing</a></li>
<li>
<a href="http://gendershades.org/" class="external-link">Facial recognition</a> (video, 5
min.)</li>
<li><a href="https://www.aclu.org/news/womens-rights/why-amazons-automated-hiring-tool-discriminated-against" class="external-link">Amazon
hiring tool</a></li>
</ol>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Some tasks are not appropriate for machine learning due to ethical
concerns.</li>
<li>Machine learning tasks should have a valid prediction target that
maps clearly to the real-world goal.</li>
<li>Training data can be biased due to societal inequities, errors in
the data collection process, and lack of attention to careful sampling
practices.</li>
<li>“Bias” also refers to statistical bias, and certain algorithms can
be biased towards some solutions.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div>
</section></section><section id="aio-2-model-fitting"><p>Content from <a href="2-model-fitting.html">Scientific validity in the modeling process</a></p>
<hr>
<p>Last updated on 2024-06-19 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/2-model-fitting.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What impact does overfitting and underfitting have on model
performance?</li>
<li>What is data leakage?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Implement at least two types of machine learning models in
Python.</li>
<li>Describe the risks of, identify, and understand mitigation steps for
overfitting and underfitting.</li>
<li>Understand why data leakage is harmful to scientific validity and
how it can appear in machine learning pipelines.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Overfitting is characterized by worse performance on the test set
than on the train set and can be fixed by switching to a simpler model
architecture or by adding regularization.</li>
<li>Underfitting is characterized by poor performance on both the
training and test datasets. It can be fixed by collecting more training
data, switching to a more complex model architecture, or improving
feature quality.</li>
<li>Data leakage occurs when the model has access to the test data
during training and results in overconfidence in the model’s
performance.</li>
</ul>
</div>
</div>
</div></section><section id="aio-3-model-eval-and-fairness"><p>Content from <a href="3-model-eval-and-fairness.html">Model evaluation and fairness</a></p>
<hr>
<p>Last updated on 2024-06-19 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/3-model-eval-and-fairness.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How do we define fairness and bias in machine learning
outcomes?</li>
<li>What types of bias and unfairness can occur in generative AI?</li>
<li>How can we improve the fairness of machine learning models?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Reason about model performance through standard evaluation
metrics.</li>
<li>Understand and distinguish between various notions of fairness in
machine learning.</li>
<li>Describe and implement two different ways of modifying the machine
learning modeling process to improve the fairness of a model.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="accuracy-metrics">Accuracy metrics<a class="anchor" aria-label="anchor" href="#accuracy-metrics"></a>
</h2>
<hr class="half-width">
<p>Stakeholders often want to know the accuracy of a machine learning
model – what percent of predictions are correct? Accuracy can be
decomposed into further metrics: e.g., in a binary prediction setting,
recall (the fraction of positive samples that are classified correctly)
and precision (the fraction of samples classified as positive that
actually are positive) are commonly-used metrics.</p>
<p>Suppose we have a model that performs binary classification (+, -) on
a test dataset of 1000 samples (let <span class="math inline">\(n\)</span>=1000). A <em>confusion matrix</em>
defines how many predictions we make in each of four quadrants: true
positive with positive prediction (++), true positive with negative
prediction (+-), true negative with positive prediction (-+), and true
negative with negative prediction (–).</p>
<table class="table">
<thead><tr class="header">
<th></th>
<th>True +</th>
<th>True -</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Predicted +</td>
<td>300</td>
<td>80</td>
</tr>
<tr class="even">
<td>Predicted -</td>
<td>25</td>
<td>595</td>
</tr>
</tbody>
</table>
<p>So, for instance, 80 samples have a true class of + but get predicted
as members of -.</p>
<p>We can compute the following metrics:</p>
<ul>
<li>Accuracy: What fraction of predictions are correct?
<ul>
<li>(300 + 595) / 100 = 0.895</li>
<li>Accuracy is 89.5%</li>
</ul>
</li>
<li>Precision: What fraction of predicted positives are true positives?
<ul>
<li>300 / (300 + 80) = 0.789</li>
<li>Precision is 78.9%</li>
</ul>
</li>
<li>Recall: What fraction of true positives are classified as positive?
<ul>
<li>300 / (300 + 25) = 0.923</li>
<li>Recall is 92.3%</li>
</ul>
</li>
</ul>
<div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>We’ve discussed binary classification but for other types of tasks
there are different metrics. For example,</p>
<ul>
<li>Multi-class problems often use <a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.top_k_accuracy_score.html" class="external-link">Top-K
accuracy</a>, a metric of how often the true response appears in their
top-K guesses.</li>
<li>Regression tasks often use the <a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" class="external-link">Area
Under the ROC curve (AUC ROC)</a> as a measure of how well the
classifier performs at different thresholds.</li>
</ul>
</div>
</div>
</div>
<div id="what-accuracy-metric-to-use" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="what-accuracy-metric-to-use" class="callout-inner">
<h3 class="callout-title">What accuracy metric to use?</h3>
<div class="callout-content">
<p>Different accuracy metrics may be more relevant in different
situations. Discuss with a partner or small groups whether precision,
recall, or some combination of the two is most relevant in the following
prediction tasks:</p>
<ol style="list-style-type: decimal">
<li>Deciding what patients are high risk for a disease and who should
get additional low-cost screening.</li>
<li>Deciding what patients are high risk for a disease and should start
taking medication to lower the disease risk. The medication is expensive
and can have unpleasant side effects.</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li><p>It is best if all patients who need the screening get it, and
there is little downside for doing screenings unnecessarily because the
screening costs are low. Thus, a high recall score is optimal.</p></li>
<li><p>Given the costs and side effects of the medicine, we do not want
patients not at risk for the disease to take the medication. So, a high
precision score is ideal.</p></li>
</ol>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="how-do-we-measure-fairness">How do we measure fairness?<a class="anchor" aria-label="anchor" href="#how-do-we-measure-fairness"></a>
</h2>
<hr class="half-width">
<p>What does it mean for a machine learning model to be fair or
unbiased? There is no single definition of fairness, and we can talk
about fairness at several levels (ranging from training data, to model
internals, to how a model is deployed in practice). Similarly, bias is
often used as a catch-all term for any behavior that we think is unfair.
Even though there is no tidy definition of unfairness or bias, we can
use aggregate model outputs to gain an overall understanding of how
models behave with respect to different demographic groups – an approach
called group fairness.</p>
<p>In general, if there are no differences between groups in the real
world (e.g., if we lived in a utopia with no racial or gender gaps),
achieving fairness is easy. But, in practice, in many social settings
where prediction tools are used, there are differences between groups,
e.g., due to historical and current discrimination.</p>
<p>For instance, in a loan prediction setting in the United States, the
average white applicant may be better positioned to repay a loan than
the average Black applicant due to differences in generational wealth,
education opportunities, and other factors stemming from anti-Black
racism. Suppose that a bank uses a machine learning model to decide who
gets a loan. Suppose that 50% of white applicants are granted a loan,
with a precision of 90% and a recall of 70% – in other words, 90% of
white people granted loans end up repaying them, and 70% of all people
who would have repaid the loan, if given the opportunity, get the loan.
Consider the following scenarios:</p>
<ul>
<li>(Demographic parity) We give loans to 50% of Black applicants in a
way that maximizes overall accuracy</li>
<li>(Equalized odds) We give loans to X% of Black applicants, where X is
chosen to maximize accuracy subject to keeping precision equal to
90%.</li>
<li>(Group level calibration) We give loans to X% of Black applicants,
where X is chosen to maximize accuracy while keeping recall equal to
70%.</li>
</ul>
<p>There are <em>many</em> notions of statistical group fairness, but
most boil down to one of the three above options: demographic parity,
equalized odds, and group-level calibration. All three are forms of
<em>distributional</em> (or <em>outcome</em>) fairness. Another
dimension, though, is <em>procedural</em> fairness: whether decisions
are made in a just way, regardless of final outcomes. Procedural
fairness contains many facets, but one way to operationalize it is to
consider individual fairness (also called counterfactual fairness),
which was suggested in 2012 by <a href="https://dl.acm.org/doi/abs/10.1145/2090236.2090255" class="external-link">Dwork et
al.</a> as a way to ensure that “similar individuals [are treated]
similarly”. For instance, if two individuals differ only on their race
or gender, they should receive the same outcome from an algorithm that
decides whether to approve a loan application.</p>
<p>In practice, it’s hard to use individual fairness because defining a
complete set of rules about when two individuals are sufficiently
“similar” is challenging.</p>
<div id="matching-fairness-terminology-with-definitions" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="matching-fairness-terminology-with-definitions" class="callout-inner">
<h3 class="callout-title">Matching fairness terminology with definitions</h3>
<div class="callout-content">
<p>Match the following types of formal fairness with their definitions.
(A) Individual fairness, (B) Equalized odds, (C) Demographic parity, and
(D) Group-level calibration</p>
<ol style="list-style-type: decimal">
<li>The model is equally accurate across all demographic groups.</li>
<li>Different demographic groups have the same true positive rates and
false positive rates.</li>
<li>Similar people are treated similarly.</li>
<li>People from different demographic groups receive each outcome at the
same rate.</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<p>A - 3, B - 2, C - 4, D - 1</p>
</div>
</div>
</div>
</div>
<p>But some types of unfairness cannot be directly measured by
group-level statistical data. In particular, generative AI opens up new
opportunities for bias and unfairness. Bias can occur through
representational harms (e.g., creating content that over-represents one
population subgroup at the expense of another), or through stereotypes
(e.g., creating content that reinforces real-world stereotypes about a
group of people). We’ll discuss some specific examples of bias in
generative models next.</p>
</section><section><h2 class="section-heading" id="fairness-in-generative-ai">Fairness in generative AI<a class="anchor" aria-label="anchor" href="#fairness-in-generative-ai"></a>
</h2>
<hr class="half-width">
<p>Generative models learn from statistical patterns in real-world data.
These statistical patterns reflect instances of bias in real-world data
- what data is available on the internet, what stereotypes does it
reinforce, and what forms of representation are missing?</p>
<div class="section level3">
<h3 id="natural-language">Natural language<a class="anchor" aria-label="anchor" href="#natural-language"></a>
</h3>
<p>One set of social stereotypes that large AI models can learn is
gender based. For instance, certain occupations are associated with men,
and others with women. For instance, in the U.S., doctors are
historically and stereotypically usually men.</p>
<p>In 2016, Caliskan et al. <a href="https://www.fatml.org/schedule/2016/presentation/semantics-derived-automatically-language-corpora" class="external-link">showed
that machine translation systems exhibit gender bias</a>, for instance,
by reverting to stereotypical gendered pronouns in ambiguous
translations, like in Turkish – a language without gendered pronouns –
to English.</p>
<p>In response, Google <a href="https://blog.research.google/2018/12/providing-gender-specific-translations.html" class="external-link">tweaked
their translator algorithms</a> to identify and correct for gender
stereotypes in Turkish and several other widely-spoken languages. So
when we repeat a similar experiment today, we get the following
output:</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e4-turkish-nlp-stereotypes.png" alt='Screenshot of Google Translate output. The English sentence "The doctor is on her lunch break" is translated to Turkish, and then the Turkish output is translated back to English as either "The doctor is on his lunch break" or "The doctor is on his lunch break".' class="figure mx-auto d-block"><div class="figcaption">Turkish Google Translate example (screenshot
from 1/9/2024)</div>
</figure><p>But for other, less widely-spoken languages, the original problem
persists:</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e4-norwegian-nlp-stereotypes.png" alt='Screenshot of Google Translate output. The English sentence "The doctor is on her lunch break" is translated to Norwegian, and then the Norwegian output is translated back to English as "The doctor is on his lunch break".' class="figure mx-auto d-block"><div class="figcaption">Norwegian Google Translate example (screenshot
from 1/9/2024)</div>
</figure><p>We’re not trying to slander Google Translate here – the translation,
without additional context, is ambiguous. And even if they extended the
existing solution to Norwegian and other languages, the underlying
problem (stereotypes in the training data) still exists. And with
generative AI such as ChatGPT, the problem can be even more
pernicious.</p>
<div id="red-teaming-large-language-models" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="red-teaming-large-language-models" class="callout-inner">
<h3 class="callout-title">Red-teaming large language models</h3>
<div class="callout-content">
<p>In cybersecurity, “red-teaming” is when well-intentioned people think
like a hacker in order to make a system safer. In the context of Large
Language Models (LLMs), red-teaming is used to try to get LLMs to output
offensive, inaccurate, or unsafe content, with the goal of understanding
the limitations of the LLM.</p>
<p>Try out red-teaming with ChatGPT or another LLM. Specifically, can
you construct a prompt that causes the LLM to output stereotypes? Here
are some example prompts, but feel free to get creative!</p>
<ul>
<li><p>“Tell me a story about a doctor” (or other profession with
gender)</p></li>
<li><p>If you speak a language other than English, how does are
ambiguous gendered pronouns handled? For instance, try the prompt
“Translate ‘The doctor is here’ to Spanish”. Is a masculine or feminine
pronoun used for the doctor in Spanish?</p></li>
</ul>
<p>If you use LLMs in your research, consider whether any of these
issues are likely to be present for your use cases. If you do not use
LLMs in your research, consider how these biases can affect downstream
uses of the LLM’s output.</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" data-bs-parent="#accordionSolution3" aria-labelledby="headingSolution3">
<div class="accordion-body">
<p>Most publicly-available LLM providers set up guardrails to avoid
propagating biases present in their training data. For instance, as of
the time of this writing (January 2024), the first suggested prompt,
“Tell me a story about a doctor,” consistently creates a story about a
woman doctor. Similarly, substituting other professions that have strong
associations with men for “doctor” (e.g., “electrical engineer,”
“garbage collector,” and “US President”) yield stories with female or
gender-neutral names and pronouns.</p>
</div>
</div>
</div>
</div>
<div id="discussing-other-fairness-issues" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="discussing-other-fairness-issues" class="callout-inner">
<h3 class="callout-title">Discussing other fairness issues</h3>
<div class="callout-content">
<p>If you use LLMs in your research, consider whether any of these
issues are likely to be present for your use cases. Share your thoughts
in small groups with other workshop participants.</p>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="image-generation">Image generation<a class="anchor" aria-label="anchor" href="#image-generation"></a>
</h3>
<p>The same problems that language modeling face also affect image
generation. Consider, for instance, Melon et al. <a href="https://arxiv.org/pdf/2003.03808.pdf" class="external-link">developed an algorithm
called Pulse</a> that can convert blurry images to higher resolution.
But, biases were quickly unearthed and <a href="https://twitter.com/Chicken3gg/status/1274314622447820801?s=20&amp;t=_oORPJBJRaBW_J0zresFJQ" class="external-link">shared
via social media</a>.</p>
<div id="discussion5" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Who is shown in this blurred picture? <img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e4-obama.png" alt="blurry image of Barack Obama" class="figure"></p>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" data-bs-parent="#accordionSolution4" aria-labelledby="headingSolution4">
<div class="accordion-body">
<p>While the picture is of Barack Obama, the upsampled image shows a
white face. <img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e4-obama-upsampled.png" alt="Unblurred version of the pixelated picture of Obama. Instead of showing Obama, it shows a white man." class="figure"></p>
<p>You can <a href="https://colab.research.google.com/github/tg-bomze/Face-Depixelizer/blob/master/Face_Depixelizer_Eng.ipynb#scrollTo=fU0aGtD4Nl4W" class="external-link">try
the model here</a>.</p>
</div>
</div>
</div>
</div>
<p>Menon and colleagues subsequently updated their paper to discuss this
issue of bias. They assert that the problems inherent in the PULSE model
are largely a result of the <a href="https://arxiv.org/abs/1812.04948" class="external-link">underlying StyleGAN model</a>,
which they had used in their work.</p>
<blockquote>
<p>Overall, it seems that sampling from StyleGAN yields white faces much
more frequently than faces of people of color … This bias extends to any
downstream application of StyleGAN, including the implementation of
PULSE using StyleGAN.</p>
<p>…</p>
<p>Results indicate a racial bias among the generated pictures, with
close to three-fourths (72.6%) of the pictures representing White
people. Asian (13.8%) and Black (10.1%) are considerably less frequent,
while Indians represent only a minor fraction of the pictures
(3.4%).</p>
</blockquote>
<p>These remarks get at a central issue: biases in any building block of
a system (data, base models, etc.) get propagated forwards. In
generative AI, such as text-to-image systems, this can result in
representational harms, <a href="https://arxiv.org/pdf/2211.03759.pdf" class="external-link">as documented by Bianchi et
al.</a> Fixing these issues of bias is still an active area of research.
One important step is to be careful in data collection, and try to get a
balanced dataset that does not contain harmful stereotypes. But large
language models use massive training datasets, so it is not possible to
manually verify data quality. Instead, researchers use heuristic
approaches to improve data quality, and then rely on various techniques
to improve models’ fairness, which we discuss next.</p>
</div>
</section><section><h2 class="section-heading" id="improving-fairness-of-models">Improving fairness of models<a class="anchor" aria-label="anchor" href="#improving-fairness-of-models"></a>
</h2>
<hr class="half-width">
<p>Model developers frequently try to improve the fairness of there
model by intervening at one of three stages: pre-processing,
in-processing, or post-processing. We’ll cover techniques within each of
these paradigms in turn.</p>
<p>We start, though, by discussing why removing the sensitive
attribute(s) is not sufficient. Consider the task of deciding which loan
applicants are funded. Suppose we are concerned with racial bias in the
model outputs. If we remove race from the set of attributes available to
the model, the model cannot make <em>overly</em> racist decisions.
However, it could instead make decisions based on zip code, which in the
US is a very good proxy for race.</p>
<p>Can we simply remove all proxy variables? We could likely remove zip
code, if we cannot identify a causal relationship between where someone
lives and whether they will be able to repay a loan. But what about an
attribute like educational achievement? Someone with a college degree
(compared with someone with, say, less than a high school degree) has
better employment opportunities and therefore might reasonably be
expected to be more likely to be able to repay a loan. However,
educational attainment is still a proxy for race in the United States
due to historical (and ongoing) discrimination.</p>
<p><strong>Pre-processing</strong> generally modifies the dataset used
for learning. Techniques in this category include:</p>
<ul>
<li><p>Oversampling/undersampling: instead of training a machine
learning model on all of the data, <em>undersample</em> the majority
class by removing some of the majority class samples from the dataset in
order to have a more balanced dataset. Alternatively,
<em>oversample</em> the minority class by duplicating samples belonging
to this group.</p></li>
<li><p>Data augmentation: the number of samples from minority groups may
be increased by generating synthetic data with a generative adversarial
network (GAN). We won’t cover this method in this workshop (using a GAN
can be more computationally expensive than other techniques). If you’re
interested, you can learn more about this method from the paper <a href="https://link.springer.com/chapter/10.1007/978-3-030-58542-6_23" class="external-link">Inclusive
GAN: Improving Data and Minority Coverage in Generative
Models</a>.</p></li>
<li><p>Changing feature representations: various techniques have been
proposed to increase fairness by removing unfairness from the data
directly. To do so, the data is converted into an alternate
representation so that differences between demographic groups are
minimized, yet enough information is maintained in order to be able to
learn a model that performs well. An advantage of this method is that it
is model-agnostic, however, a challenge is it reduces the
interpretability of interpretable models and makes post-hoc
explainability less meaningful for black-box models.</p></li>
</ul>
<div id="pros-and-cons-of-preprocessing-options" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="pros-and-cons-of-preprocessing-options" class="callout-inner">
<h3 class="callout-title">Pros and cons of preprocessing options</h3>
<div class="callout-content">
<p>Discuss what you think the pros and cons of the different
pre-processing options are. What techniques might work better in
different settings?</p>
</div>
</div>
</div>
<div id="accordionSolution5" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution5" aria-expanded="false" aria-controls="collapseSolution5">
  <h4 class="accordion-header" id="headingSolution5"> Show me the solution </h4>
</button>
<div id="collapseSolution5" class="accordion-collapse collapse" data-bs-parent="#accordionSolution5" aria-labelledby="headingSolution5">
<div class="accordion-body">
<p>A downside of oversampling is that it may violate statistical
assumptions about independence of samples. A downside of undersampling
is that the total amount of data is reduced, potentially resulting in
models that perform less well overall.</p>
<p>A downside of using GANs to generate additional data is that this
process may be expensive and require higher levels of ML expertise.</p>
<p>A challenge with all techniques is that if there is not sufficient
data from minority groups, it may be hard to achieve good performance on
the groups without simply collecting more or higher-quality data.</p>
</div>
</div>
</div>
</div>
<p><strong>In-processing</strong> modifies the learning algorithm. Some
specific in-processing techniques include:</p>
<ul>
<li><p>Reweighting samples: many machine learning models allow for
reweighting individual samples, i.e., indicating that misclassifying
certain, rarer, samples should be penalized more severely in the loss
function. In the code example, we show how to reweight samples using
AIF360’s <a href="https://aif360.readthedocs.io/en/latest/modules/generated/aif360.algorithms.preprocessing.Reweighing.html" class="external-link">Reweighting</a>
function.</p></li>
<li><p>Incorporating fairness into the loss function: reweighting
explicitly instructs the loss function to penalize the misclassification
of certain samples more harshly. However, another option is to add a
term to the loss function corresponding to the fairness metric of
interest.</p></li>
</ul>
<p><strong>Post-processing</strong> modifies an existing model to
increase its fairness. Techniques in this category often compute a
custom <em>threshold</em> for each demographic group in order to satisfy
a specific notion of group fairness. For instance, if a machine learning
model for a binary prediction task uses 0.5 as a cutoff (e.g., raw
scores less than 0.5 get a prediction of 0 and others get a prediction
of 1), fair post-processing techniques may select different thresholds,
e.g., 0.4 or 0.6 for different demographic groups.</p>
<p>In the code, we explore two different bias mitigations strategies
implemented in the <a href="https://aif360.readthedocs.io/en/stable/" class="external-link">AIF360 Fairness
Toolkit</a>.</p>
<hr>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Markdown, display</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> make_pipeline</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a><span class="im">from</span> aif360.metrics <span class="im">import</span> BinaryLabelDatasetMetric</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a><span class="im">from</span> aif360.metrics <span class="im">import</span> ClassificationMetric</span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a><span class="im">from</span> aif360.explainers <span class="im">import</span> MetricTextExplainer</span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a><span class="im">from</span> aif360.algorithms.preprocessing <span class="im">import</span> Reweighing</span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a><span class="im">from</span> aif360.algorithms.preprocessing <span class="im">import</span> OptimPreproc</span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a><span class="im">from</span> aif360.datasets <span class="im">import</span> MEPSDataset19</span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a><span class="im">from</span> fairlearn.postprocessing <span class="im">import</span> ThresholdOptimizer</span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span></code></pre>
</div>
<p>This notebook is adapted from AIF360’s <a href="https://github.com/Trusted-AI/AIF360/blob/master/examples/tutorial_medical_expenditure.ipynb" class="external-link">Medical
Expenditure Tutorial</a>.</p>
<p>The tutorial uses data from the <a href="https://meps.ahrq.gov/mepsweb/" class="external-link">Medical Expenditure Panel
Survey</a>. We include a short description of the data below. For more
details, especially on the preprocessing, please see the AIF360
tutorial. ## Scenario and data</p>
<p>The goal is to develop a healthcare utilization scoring model – i.e.,
to predict which patients will have the highest utilization of
healthcare resources.</p>
<p>The original dataset contains information about various types of
medical visits; the AIF360 preprocessing created a single output feature
‘UTILIZATION’ that combines utilization across all visit types. Then,
this feature is binarized based on whether utilization is high, defined
as &gt;= 10 visits. Around 17% of the dataset has high utilization.</p>
<p>The sensitive feature (that we will base fairness scores on) is
defined as race. Other predictors include demographics, health
assessment data, past diagnoses, and physical/mental limitations.</p>
<p>The data is divided into years (we follow the lead of AIF360’s
tutorial and use 2015), and further divided into Panels. We use Panel 19
(the first half of 2015). ### Loading the data</p>
<p>First, the data needs to be moved into the correct location for the
AIF360 library to find it. If you haven’t yet, run <code>setup.sh</code>
to complete that step. (Then, restart the kernel and re-load the
packages at the top of this file.)</p>
<p>First, we load the data. Next, we create the train/validation/test
splits and setup information about the privileged and unprivileged
groups. (Recall, we focus on race as the sensitive feature.)</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>(dataset_orig_panel19_train,</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a> dataset_orig_panel19_val,</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a> dataset_orig_panel19_test) <span class="op">=</span> MEPSDataset19().split([<span class="fl">0.5</span>, <span class="fl">0.8</span>], shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>sens_ind <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>sens_attr <span class="op">=</span> dataset_orig_panel19_train.protected_attribute_names[sens_ind]</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>unprivileged_groups <span class="op">=</span> [{sens_attr: v} <span class="cf">for</span> v <span class="kw">in</span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>                       dataset_orig_panel19_train.unprivileged_protected_attributes[sens_ind]]</span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>privileged_groups <span class="op">=</span> [{sens_attr: v} <span class="cf">for</span> v <span class="kw">in</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>                     dataset_orig_panel19_train.privileged_protected_attributes[sens_ind]]</span></code></pre>
</div>
<p>Show details about the data.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="kw">def</span> describe(train<span class="op">=</span><span class="va">None</span>, val<span class="op">=</span><span class="va">None</span>, test<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>    <span class="cf">if</span> train <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>        display(Markdown(<span class="st">"#### Training Dataset shape"</span>))</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>        <span class="bu">print</span>(train.features.shape)</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>    <span class="cf">if</span> val <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>        display(Markdown(<span class="st">"#### Validation Dataset shape"</span>))</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>        <span class="bu">print</span>(val.features.shape)</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Test Dataset shape"</span>))</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>    <span class="bu">print</span>(test.features.shape)</span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Favorable and unfavorable labels"</span>))</span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a>    <span class="bu">print</span>(test.favorable_label, test.unfavorable_label)</span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Protected attribute names"</span>))</span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a>    <span class="bu">print</span>(test.protected_attribute_names)</span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Privileged and unprivileged protected attribute values"</span>))</span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a>    <span class="bu">print</span>(test.privileged_protected_attributes, </span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a>          test.unprivileged_protected_attributes)</span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Dataset feature names</span><span class="ch">\n</span><span class="st"> See [MEPS documentation](https://meps.ahrq.gov/data_stats/download_data/pufs/h181/h181doc.pdf) for details on the various features"</span>))</span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a>    <span class="bu">print</span>(test.feature_names)</span>
<span id="cb3-19"><a href="#cb3-19" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" tabindex="-1"></a>describe(dataset_orig_panel19_train, dataset_orig_panel19_val, dataset_orig_panel19_test)</span></code></pre>
</div>
<p>Next, we will look at whether the dataset contains bias; i.e., does
the outcome ‘UTILIZATION’ take on a positive value more frequently for
one racial group than another?</p>
<p>The disparate impact score will be between 0 and 1, where 1 indicates
<em>no bias</em>.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>metric_orig_panel19_train <span class="op">=</span> BinaryLabelDatasetMetric(</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>        dataset_orig_panel19_train,</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>        unprivileged_groups<span class="op">=</span>unprivileged_groups,</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>        privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>explainer_orig_panel19_train <span class="op">=</span> MetricTextExplainer(metric_orig_panel19_train)</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="bu">print</span>(explainer_orig_panel19_train.disparate_impact())</span></code></pre>
</div>
<p>We see that the disparate impact is about 0.48, which means the
privileged group has the favorable outcome at about 2x the rate as the
unprivileged group does.</p>
<p>(In this case, the “favorable” outcome is label=1, i.e., high
utilization) ## Train a model</p>
<p>We will train a logistic regression classifier.</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>dataset <span class="op">=</span> dataset_orig_panel19_train</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>model <span class="op">=</span> make_pipeline(StandardScaler(),</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>                      LogisticRegression(solver<span class="op">=</span><span class="st">'liblinear'</span>, random_state<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>fit_params <span class="op">=</span> {<span class="st">'logisticregression__sample_weight'</span>: dataset.instance_weights}</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>lr_orig_panel19 <span class="op">=</span> model.fit(dataset.features, dataset.labels.ravel(), <span class="op">**</span>fit_params)</span></code></pre>
</div>
<div class="section level3">
<h3 id="validate-the-model">Validate the model<a class="anchor" aria-label="anchor" href="#validate-the-model"></a>
</h3>
<p>Recall that a logistic regression model can output probabilities
(i.e., <code>model.predict(dataset).scores</code>) and we can determine
our own threshold for predicting class 0 or 1.</p>
<p>The following function, <code>test</code>, computes performance on
the logistic regression model based on a variety of thresholds, as
indicated by <code>thresh_arr</code>, an array of threshold values. We
will continue to focus on disparate impact, but all other metrics are
described in the <a href="https://aif360.readthedocs.io/en/stable/modules/generated/aif360.metrics.ClassificationMetric.html#aif360.metrics.ClassificationMetric" class="external-link">AIF360
documentation</a>.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="kw">def</span> test(dataset, model, thresh_arr):</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>        <span class="co"># sklearn classifier</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>        y_val_pred_prob <span class="op">=</span> model.predict_proba(dataset.features)</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>        pos_ind <span class="op">=</span> np.where(model.classes_ <span class="op">==</span> dataset.favorable_label)[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">AttributeError</span> <span class="im">as</span> e:</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>        <span class="bu">print</span>(e)</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>        <span class="co"># aif360 inprocessing algorithm</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>        y_val_pred_prob <span class="op">=</span> model.predict(dataset).scores</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>        pos_ind <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>        </span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>    pos_ind <span class="op">=</span> np.where(model.classes_ <span class="op">==</span> dataset.favorable_label)[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>    metric_arrs <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>    </span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a>    <span class="cf">for</span> thresh <span class="kw">in</span> thresh_arr:</span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a>        y_val_pred <span class="op">=</span> (y_val_pred_prob[:, pos_ind] <span class="op">&gt;</span> thresh).astype(np.float64)</span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" tabindex="-1"></a>        dataset_pred <span class="op">=</span> dataset.copy()</span>
<span id="cb6-19"><a href="#cb6-19" tabindex="-1"></a>        dataset_pred.labels <span class="op">=</span> y_val_pred</span>
<span id="cb6-20"><a href="#cb6-20" tabindex="-1"></a>        metric <span class="op">=</span> ClassificationMetric(</span>
<span id="cb6-21"><a href="#cb6-21" tabindex="-1"></a>                dataset, dataset_pred,</span>
<span id="cb6-22"><a href="#cb6-22" tabindex="-1"></a>                unprivileged_groups<span class="op">=</span>unprivileged_groups,</span>
<span id="cb6-23"><a href="#cb6-23" tabindex="-1"></a>                privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb6-24"><a href="#cb6-24" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" tabindex="-1"></a>        <span class="co"># various metrics - can look up what they are on your own</span></span>
<span id="cb6-26"><a href="#cb6-26" tabindex="-1"></a>        metric_arrs[<span class="st">'bal_acc'</span>].append((metric.true_positive_rate()</span>
<span id="cb6-27"><a href="#cb6-27" tabindex="-1"></a>                                     <span class="op">+</span> metric.true_negative_rate()) <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb6-28"><a href="#cb6-28" tabindex="-1"></a>        metric_arrs[<span class="st">'avg_odds_diff'</span>].append(metric.average_odds_difference())</span>
<span id="cb6-29"><a href="#cb6-29" tabindex="-1"></a>        metric_arrs[<span class="st">'disp_imp'</span>].append(metric.disparate_impact())</span>
<span id="cb6-30"><a href="#cb6-30" tabindex="-1"></a>        metric_arrs[<span class="st">'stat_par_diff'</span>].append(metric.statistical_parity_difference())</span>
<span id="cb6-31"><a href="#cb6-31" tabindex="-1"></a>        metric_arrs[<span class="st">'eq_opp_diff'</span>].append(metric.equal_opportunity_difference())</span>
<span id="cb6-32"><a href="#cb6-32" tabindex="-1"></a>        metric_arrs[<span class="st">'theil_ind'</span>].append(metric.theil_index())</span>
<span id="cb6-33"><a href="#cb6-33" tabindex="-1"></a>    </span>
<span id="cb6-34"><a href="#cb6-34" tabindex="-1"></a>    <span class="cf">return</span> metric_arrs</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>thresh_arr <span class="op">=</span> np.linspace(<span class="fl">0.01</span>, <span class="fl">0.5</span>, <span class="dv">50</span>)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>val_metrics <span class="op">=</span> test(dataset<span class="op">=</span>dataset_orig_panel19_val,</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>                   model<span class="op">=</span>lr_orig_panel19,</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>                   thresh_arr<span class="op">=</span>thresh_arr)</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>lr_orig_best_ind <span class="op">=</span> np.argmax(val_metrics[<span class="st">'bal_acc'</span>])</span></code></pre>
</div>
<p>We will plot <code>val_metrics</code>. The x-axis will be the
threshold we use to output the label 1 (i.e., if the raw score is larger
than the threshold, we output 1).</p>
<p>The y-axis will show both balanced accuracy (in blue) and disparate
impact (in red).</p>
<p>Note that we plot 1 - Disparate Impact, so now a score of 0 indicates
no bias.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="kw">def</span> plot(x, x_name, y_left, y_left_name, y_right, y_right_name):</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>    fig, ax1 <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">7</span>))</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>    ax1.plot(x, y_left)</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>    ax1.set_xlabel(x_name, fontsize<span class="op">=</span><span class="dv">16</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>    ax1.set_ylabel(y_left_name, color<span class="op">=</span><span class="st">'b'</span>, fontsize<span class="op">=</span><span class="dv">16</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>    ax1.xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>    ax1.yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>    ax1.set_ylim(<span class="fl">0.5</span>, <span class="fl">0.8</span>)</span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a>    ax2 <span class="op">=</span> ax1.twinx()</span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>    ax2.plot(x, y_right, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a>    ax2.set_ylabel(y_right_name, color<span class="op">=</span><span class="st">'r'</span>, fontsize<span class="op">=</span><span class="dv">16</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'DI'</span> <span class="kw">in</span> y_right_name:</span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a>        ax2.set_ylim(<span class="fl">0.</span>, <span class="fl">0.7</span>)</span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a>        ax2.set_ylim(<span class="op">-</span><span class="fl">0.25</span>, <span class="fl">0.1</span>)</span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a>    best_ind <span class="op">=</span> np.argmax(y_left)</span>
<span id="cb8-19"><a href="#cb8-19" tabindex="-1"></a>    ax2.axvline(np.array(x)[best_ind], color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">':'</span>)</span>
<span id="cb8-20"><a href="#cb8-20" tabindex="-1"></a>    ax2.yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb8-21"><a href="#cb8-21" tabindex="-1"></a>    ax2.grid(<span class="va">True</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>disp_imp <span class="op">=</span> np.array(val_metrics[<span class="st">'disp_imp'</span>])</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>disp_imp_err <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> disp_imp</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>plot(thresh_arr, <span class="st">'Classification Thresholds'</span>,</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>     val_metrics[<span class="st">'bal_acc'</span>], <span class="st">'Balanced Accuracy'</span>,</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>     disp_imp_err, <span class="st">'1 - DI'</span>)</span></code></pre>
</div>
<p>If you like, you can plot other metrics, e.g., average odds
difference.</p>
<p>In the next cell, we write a function to print out a variety of other
metrics. Since we look at 1 - disparate impact, <strong>all of these
metrics have a value of 0 if they are perfectly fair</strong>. Again,
you can learn more details about the various metrics in the <a href="https://aif360.readthedocs.io/en/stable/modules/generated/aif360.metrics.ClassificationMetric.html#aif360.metrics.ClassificationMetric" class="external-link">AIF360
documentation</a>.</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="kw">def</span> describe_metrics(metrics, thresh_arr):</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>    best_ind <span class="op">=</span> np.argmax(metrics[<span class="st">'bal_acc'</span>])</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Threshold corresponding to Best balanced accuracy: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(thresh_arr[best_ind]))</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Best balanced accuracy: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'bal_acc'</span>][best_ind]))</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>    disp_imp_at_best_ind <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> metrics[<span class="st">'disp_imp'</span>][best_ind]</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Corresponding 1-DI value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(disp_imp_at_best_ind))</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Corresponding average odds difference value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'avg_odds_diff'</span>][best_ind]))</span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Corresponding statistical parity difference value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'stat_par_diff'</span>][best_ind]))</span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Corresponding equal opportunity difference value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'eq_opp_diff'</span>][best_ind]))</span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Corresponding Theil index value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'theil_ind'</span>][best_ind]))</span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>describe_metrics(val_metrics, thresh_arr)</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="test-the-model">Test the model<a class="anchor" aria-label="anchor" href="#test-the-model"></a>
</h3>
<p>Now that we have used the validation data to select the best
threshold, we will evaluate the test the model on the test data.</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>lr_metrics <span class="op">=</span> test(dataset<span class="op">=</span>dataset_orig_panel19_test,</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>                       model<span class="op">=</span>lr_orig_panel19,</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>                       thresh_arr<span class="op">=</span>[thresh_arr[lr_orig_best_ind]])</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>describe_metrics(lr_metrics, [thresh_arr[lr_orig_best_ind]])</span></code></pre>
</div>
</div>
</section><section><h2 class="section-heading" id="mitigate-bias-with-in-processing">Mitigate bias with in-processing<a class="anchor" aria-label="anchor" href="#mitigate-bias-with-in-processing"></a>
</h2>
<hr class="half-width">
<p>We will use reweighting as an in-processing step to try to increase
fairness. AIF360 has a function that performs reweighting that we will
use. If you’re interested, you can look at details about how it works in
<a href="https://aif360.readthedocs.io/en/latest/modules/generated/aif360.algorithms.preprocessing.Reweighing.html" class="external-link">the
documentation</a>.</p>
<p>If you look at the documentation, you will see that AIF360 classifies
reweighting as a preprocessing, not an in-processing intervention.
Technically, AIF360’s implementation modifies the dataset, not the
learning algorithm so it is pre-processing. But, it is functionally
equivalent to modifying the learning algorithm’s loss function, so we
follow the convention of the fair ML field and call it
in-processing.</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="co"># Reweighting is a AIF360 class to reweight the data </span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>RW <span class="op">=</span> Reweighing(unprivileged_groups<span class="op">=</span>unprivileged_groups,</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>                privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>dataset_transf_panel19_train <span class="op">=</span> RW.fit_transform(dataset_orig_panel19_train)</span></code></pre>
</div>
<p>We’ll also define metrics for the reweighted data and print out the
disparate impact of the dataset.</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>metric_transf_panel19_train <span class="op">=</span> BinaryLabelDatasetMetric(</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>        dataset_transf_panel19_train,</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>        unprivileged_groups<span class="op">=</span>unprivileged_groups,</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a>        privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>explainer_transf_panel19_train <span class="op">=</span> MetricTextExplainer(metric_transf_panel19_train)</span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="bu">print</span>(explainer_transf_panel19_train.disparate_impact())</span></code></pre>
</div>
<p>Then, we’ll train a model, validate it, and evaluate of the test
data.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="co"># train</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>dataset <span class="op">=</span> dataset_transf_panel19_train</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>model <span class="op">=</span> make_pipeline(StandardScaler(),</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>                      LogisticRegression(solver<span class="op">=</span><span class="st">'liblinear'</span>, random_state<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>fit_params <span class="op">=</span> {<span class="st">'logisticregression__sample_weight'</span>: dataset.instance_weights}</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a>lr_transf_panel19 <span class="op">=</span> model.fit(dataset.features, dataset.labels.ravel(), <span class="op">**</span>fit_params)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="co"># validate</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>thresh_arr <span class="op">=</span> np.linspace(<span class="fl">0.01</span>, <span class="fl">0.5</span>, <span class="dv">50</span>)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>val_metrics <span class="op">=</span> test(dataset<span class="op">=</span>dataset_orig_panel19_val,</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>                   model<span class="op">=</span>lr_transf_panel19,</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>                   thresh_arr<span class="op">=</span>thresh_arr)</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>lr_transf_best_ind <span class="op">=</span> np.argmax(val_metrics[<span class="st">'bal_acc'</span>])</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="co"># plot validation results</span></span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>disp_imp <span class="op">=</span> np.array(val_metrics[<span class="st">'disp_imp'</span>])</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>disp_imp_err <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> np.minimum(disp_imp, <span class="dv">1</span><span class="op">/</span>disp_imp)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>plot(thresh_arr, <span class="st">'Classification Thresholds'</span>,</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>     val_metrics[<span class="st">'bal_acc'</span>], <span class="st">'Balanced Accuracy'</span>,</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a>     disp_imp_err, <span class="st">'1 - min(DI, 1/DI)'</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="co"># describe validation results</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>describe_metrics(val_metrics, thresh_arr)</span></code></pre>
</div>
<div class="section level3">
<h3 id="test">Test<a class="anchor" aria-label="anchor" href="#test"></a>
</h3>
<p>lr_transf_metrics = test(dataset=dataset_orig_panel19_test,
model=lr_transf_panel19, thresh_arr=[thresh_arr[lr_transf_best_ind]])
describe_metrics(lr_transf_metrics, [thresh_arr[lr_transf_best_ind]]) We
see that the disparate impact score on the test data is better after
reweighting than it was originally.</p>
<p>How do the other fairness metrics compare? ## Mitigate bias with
preprocessing We will use a method, <a href="https://fairlearn.org/main/api_reference/generated/fairlearn.postprocessing.ThresholdOptimizer.html#fairlearn.postprocessing.ThresholdOptimizer" class="external-link">ThresholdOptimizer</a>,
that is implemented in the library <a href="https://fairlearn.org/" class="external-link">Fairlearn</a>. ThresholdOptimizer finds
custom thresholds for each demographic group so as to achieve parity in
the desired group fairness metric.</p>
<p>We will focus on demographic parity, but feel free to try other
metrics if you’re curious on how it does.</p>
<p>The first step is creating the ThresholdOptimizer object. We pass in
the demographic parity constraint, and indicate that we would like to
optimize the balanced accuracy score (other options include accuracy,
and true or false positive rate – see <a href="https://fairlearn.org/main/api_reference/generated/fairlearn.postprocessing.ThresholdOptimizer.html#fairlearn.postprocessing.ThresholdOptimizer" class="external-link">the
documentation</a> for more details).</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>to <span class="op">=</span> ThresholdOptimizer(estimator<span class="op">=</span>model, constraints<span class="op">=</span><span class="st">"demographic_parity"</span>, objective<span class="op">=</span><span class="st">"balanced_accuracy_score"</span>, prefit<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<p>Next, we fit the ThresholdOptimizer object to the validation
data.</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>to.fit(dataset_orig_panel19_val.features, dataset_orig_panel19_val.labels, </span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>       sensitive_features<span class="op">=</span>dataset_orig_panel19_val.protected_attributes[:,<span class="dv">0</span>])</span></code></pre>
</div>
<p>Then, we’ll create a helper function, <code>mini_test</code> to allow
us to call the <code>describe_metrics</code> function even though we are
no longer evaluating our method as a variety of thresholds.</p>
<p>After that, we call the ThresholdOptimizer’s predict function on the
validation and test data, and then compute metrics and print the
results.</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="kw">def</span> mini_test(dataset, preds):</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>    metric_arrs <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a>    dataset_pred <span class="op">=</span> dataset.copy()</span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>    dataset_pred.labels <span class="op">=</span> preds</span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a>    metric <span class="op">=</span> ClassificationMetric(</span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a>            dataset, dataset_pred,</span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a>            unprivileged_groups<span class="op">=</span>unprivileged_groups,</span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a>            privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a>    <span class="co"># various metrics - can look up what they are on your own</span></span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a>    metric_arrs[<span class="st">'bal_acc'</span>].append((metric.true_positive_rate()</span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a>                                    <span class="op">+</span> metric.true_negative_rate()) <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a>    metric_arrs[<span class="st">'avg_odds_diff'</span>].append(metric.average_odds_difference())</span>
<span id="cb20-14"><a href="#cb20-14" tabindex="-1"></a>    metric_arrs[<span class="st">'disp_imp'</span>].append(metric.disparate_impact())</span>
<span id="cb20-15"><a href="#cb20-15" tabindex="-1"></a>    metric_arrs[<span class="st">'stat_par_diff'</span>].append(metric.statistical_parity_difference())</span>
<span id="cb20-16"><a href="#cb20-16" tabindex="-1"></a>    metric_arrs[<span class="st">'eq_opp_diff'</span>].append(metric.equal_opportunity_difference())</span>
<span id="cb20-17"><a href="#cb20-17" tabindex="-1"></a>    metric_arrs[<span class="st">'theil_ind'</span>].append(metric.theil_index())</span>
<span id="cb20-18"><a href="#cb20-18" tabindex="-1"></a>    </span>
<span id="cb20-19"><a href="#cb20-19" tabindex="-1"></a>    <span class="cf">return</span> metric_arrs</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>to_val_preds <span class="op">=</span> to.predict(dataset_orig_panel19_val.features, sensitive_features<span class="op">=</span>dataset_orig_panel19_val.protected_attributes[:,<span class="dv">0</span>])</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>to_test_preds <span class="op">=</span> to.predict(dataset_orig_panel19_test.features, sensitive_features<span class="op">=</span>dataset_orig_panel19_test.protected_attributes[:,<span class="dv">0</span>])</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>to_val_metrics <span class="op">=</span> mini_test(dataset_orig_panel19_val, to_val_preds)</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>to_test_metrics <span class="op">=</span> mini_test(dataset_orig_panel19_test, to_test_preds)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Remember, `Threshold corresponding to Best balanced accuracy` is just a placeholder here."</span>)</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>describe_metrics(to_val_metrics, [<span class="dv">0</span>])</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb24">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Remember, `Threshold corresponding to Best balanced accuracy` is just a placeholder here."</span>)</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>describe_metrics(to_test_metrics, [<span class="dv">0</span>])</span></code></pre>
</div>
<p>Scroll up and see how these results compare with the original
classifier and with the in-processing technique.</p>
<p>A major difference is that the accuracy is lower, now. In practice,
it might be better to use an algorithm that allows a custom tradeoff
between the accuracy sacrifice and increased levels of fairness.</p>
<p>We can also see what threshold is being used for each demographic
group by examining the
<code>interpolated_thresholder_.interpretation_dict</code> property of
the ThresholdOptimzer.</p>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>threshold_rules_by_group <span class="op">=</span> to.interpolated_thresholder_.interpolation_dict</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>threshold_rules_by_group</span></code></pre>
</div>
<p>Recall that a value of 1 in the Race column corresponds to White
people, while a value of 0 corresponds to non-White people.</p>
<p>Due to the inherent randomness of the ThresholdOptimizer, you might
get slightly different results than your neighbors. When we ran the
previous cell, the output was</p>
<p><code>{0.0: {'p0': 0.9287205987170348,   'operation0': [&gt;0.5],   'p1': 0.07127940128296517,   'operation1': [&gt;-inf]},  1.0: {'p0': 0.002549618320610717,   'operation0': [&gt;inf],   'p1': 0.9974503816793893,   'operation1': [&gt;0.5]}}</code></p>
<p>This tells us that for non-White individuals:</p>
<ul>
<li><p>If the score is above 0.5, predict 1.</p></li>
<li><p>Otherwise, predict 1 with probability 0.071</p></li>
</ul>
<p>And for White individuals:</p>
<ul>
<li>If the score is above 0.5, predict 1 with probability 0.997</li>
</ul>
<p><strong>Discussion question:</strong> what are the pros and cons of
improving the model fairness by introducing randomization?</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>It’s important to consider many dimensions of model performance: a
single accuracy score is not sufficient.</li>
<li>There is no single definition of “fair machine learning”: different
notions of fairness are appropriate in different contexts.</li>
<li>Representational harms and stereotypes can be perpetuated by
generative AI.</li>
<li>The fairness of a model can be improved by using techniques like
data reweighting and model postprocessing.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-4-explainability-vs-interpretability"><p>Content from <a href="4-explainability-vs-interpretability.html">Interpretablility versus explainability</a></p>
<hr>
<p>Last updated on 2024-07-17 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/4-explainability-vs-interpretability.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 2 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are popular machine learning models?</li>
<li>What are model intepretability and model explainability? Why are
they important?</li>
<li>Which should you choose: interpretable models or explainable
models?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Showcase machine learning models that are widely used in
practice.</li>
<li>Understand and distinguish between explainable machine learning
models and interpretable machine learning models.</li>
<li>Describe two reasons when deciding which model to choose.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>
<strong>Model Explainability vs. Model Interpretability:</strong>
<ul>
<li>
<strong>Interpretability:</strong> Refers to the degree to which a
human can understand the cause of a decision made by a model. It is
essential for verifying the correctness of the model, ensuring
compliance with regulations, and enabling effective debugging.</li>
<li>
<strong>Explainability:</strong> Refers to the extent to which the
internal mechanics of a machine learning model can be explained in human
terms. It is crucial for understanding how models make decisions,
ensuring transparency, and building trust with stakeholders.</li>
</ul>
</li>
<li>
<strong>Choosing Between Explainable and Interpretable
Models:</strong>
<ul>
<li>
<strong>When Transparency is Critical:</strong> Opt for
interpretable models (e.g., linear regression, decision trees) when it
is essential to have a clear understanding of how decisions are made,
such as in healthcare or finance.</li>
<li>
<strong>When Performance is a Priority:</strong> Choose explainable
models (e.g., neural networks, gradient boosting machines) when
predictive accuracy is the primary concern, and you can use explanation
methods to understand model behavior.</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="section level3 exercise">
<h3 id="exercise-1-model-selection-for-predicting-covid-19-progression-a-study-by-giotta-et-al-">Exercise 1: Model Selection for Predicting COVID-19 Progression, a
study by <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9602523/" class="external-link">Giotta et
al.</a>
<a class="anchor" aria-label="anchor" href="#exercise-1-model-selection-for-predicting-covid-19-progression-a-study-by-giotta-et-al-"></a>
</h3>
<p><strong>Objective:</strong></p>
<p>To predict bad outcomes (death or transfer to an intensive care unit)
from COVID-19 patients using hematological, biochemical, and
inflammatory biomarkers.</p>
<p><strong>Motivation:</strong></p>
<p>In the early days of the COVID-19 pandemic, healthcare professionals
around the world faced unprecedented challenges. Predicting the
progression of the disease and identifying patients at high risk of
severe outcomes became crucial for effective treatment and resource
allocation. One such study, published on the National Center for
Biotechnology Information (NCBI) website, investigated the
characteristics of patients who either succumbed to the disease or
required intensive care compared to those who recovered.</p>
<p>This study highlighted the critical role of various biomarkers, such
as hematological, biochemical, and inflammatory markers, in
understanding disease progression. However, simply identifying these
markers was not enough. Clinicians needed tools that could not only
predict outcomes with high accuracy but also provide clear,
understandable reasons for their predictions.</p>
<p><strong>Dataset Specification:</strong> Hematological biomarkers
included white blood cells, neutrophils count, lymphocytes count,
monocytes count, eosinophils count, platelet count, cluster of
differentiation (CD)4, CD8 percentages, and hemoglobin. Biochemical
markers were albumin, alanine aminotransferase, aspartate
aminotransferase, total bilirubin, creatinine, creatinine kinase,
lactate dehydrogenase (LDH), cardiac troponin I, myoglobin, and creatine
kinase-MB. The coagulation markers were prothrombin time, activated
partial thromboplastin time (APTT), and D-dimer. The inflammatory
biomarkers were C-reactive protein (CRP), serum ferritin, procalcitonin
(PCT), erythrocyte sedimentation rate, and interleukin and tumor
necrosis factor-alpha (TNFα) levels.</p>
<p><strong>Some statistics from the dataset:</strong></p>
<p><strong>Table 1</strong>: Main characteristics of the patients
included in the study at baseline and results of comparison of
percentage between outcome using chi-square or Fisher exact test.</p>
<table class="table">
<colgroup>
<col width="24%">
<col width="44%">
<col width="23%">
<col width="7%">
</colgroup>
<thead><tr class="header">
<th></th>
<th>Death or Transferred to Intensive Care Unit (n = 32)</th>
<th>Discharged Alive (n = 113)</th>
<th>p-Value</th>
</tr></thead>
<tbody>
<tr class="odd">
<td></td>
<td>N</td>
<td>%</td>
<td>N</td>
</tr>
<tr class="even">
<td><strong>Sex</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Male</td>
<td>18</td>
<td>56.25%</td>
<td>61</td>
</tr>
<tr class="even">
<td>Female</td>
<td>14</td>
<td>43.75%</td>
<td>52</td>
</tr>
<tr class="odd">
<td><strong>Symptoms</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Dyspnea</td>
<td>12</td>
<td>37.50%</td>
<td>52</td>
</tr>
<tr class="odd">
<td>Cough</td>
<td>5</td>
<td>15.63%</td>
<td>35</td>
</tr>
<tr class="even">
<td>Fatigue</td>
<td>7</td>
<td>21.88%</td>
<td>30</td>
</tr>
<tr class="odd">
<td>Headache</td>
<td>2</td>
<td>6.25%</td>
<td>12</td>
</tr>
<tr class="even">
<td>Confusion</td>
<td>1</td>
<td>3.13%</td>
<td>9</td>
</tr>
<tr class="odd">
<td>Nausea</td>
<td>1</td>
<td>3.13%</td>
<td>8</td>
</tr>
<tr class="even">
<td>Sick</td>
<td>1</td>
<td>3.13%</td>
<td>6</td>
</tr>
<tr class="odd">
<td>Pharyngitis</td>
<td>1</td>
<td>3.13%</td>
<td>6</td>
</tr>
<tr class="even">
<td>Nasal congestion</td>
<td>1</td>
<td>3.13%</td>
<td>3</td>
</tr>
<tr class="odd">
<td>Arthralgia</td>
<td>0</td>
<td>0.00%</td>
<td>3</td>
</tr>
<tr class="even">
<td>Myalgia</td>
<td>1</td>
<td>3.13%</td>
<td>2</td>
</tr>
<tr class="odd">
<td>Arrhythmia</td>
<td>3</td>
<td>9.38%</td>
<td>12</td>
</tr>
<tr class="even">
<td><strong>Comorbidity</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Hypertension</td>
<td>12</td>
<td>37.50%</td>
<td>71</td>
</tr>
<tr class="even">
<td>Cardiovascular disease</td>
<td>12</td>
<td>37.50%</td>
<td>43</td>
</tr>
<tr class="odd">
<td>Diabetes</td>
<td>11</td>
<td>34.38%</td>
<td>35</td>
</tr>
<tr class="even">
<td>Cerebrovascular disease</td>
<td>9</td>
<td>28.13%</td>
<td>19</td>
</tr>
<tr class="odd">
<td>Chronic kidney disease</td>
<td>8</td>
<td>25.00%</td>
<td>14</td>
</tr>
<tr class="even">
<td>COPD</td>
<td>5</td>
<td>15.63%</td>
<td>14</td>
</tr>
<tr class="odd">
<td>Tumors</td>
<td>5</td>
<td>15.63%</td>
<td>11</td>
</tr>
<tr class="even">
<td>Hepatitis B</td>
<td>0</td>
<td>0.00%</td>
<td>6</td>
</tr>
<tr class="odd">
<td>Immunopathological disease</td>
<td>1</td>
<td>3.13%</td>
<td>5</td>
</tr>
</tbody>
</table>
<p><strong>Table 2</strong>: Comparison of clinical characteristics and
laboratory findings between patients who died or were transferred to ICU
and those who were discharged alive.</p>
<table class="table">
<colgroup>
<col width="27%">
<col width="42%">
<col width="22%">
<col width="7%">
</colgroup>
<thead><tr class="header">
<th></th>
<th>Patients Deaths or Transferred to ICU (n = 32)</th>
<th>Patients Alive (n = 113)</th>
<th>p-Value</th>
</tr></thead>
<tbody>
<tr class="odd">
<td></td>
<td>Median</td>
<td>Q1</td>
<td>Q3</td>
</tr>
<tr class="even">
<td><strong>Age (years)</strong></td>
<td>78.0</td>
<td>67.0</td>
<td>85.75</td>
</tr>
<tr class="odd">
<td><strong>Temperature (°C)</strong></td>
<td>36.5</td>
<td>36.0</td>
<td>36.9</td>
</tr>
<tr class="even">
<td><strong>Respiratory rate (rpm)</strong></td>
<td>20.0</td>
<td>18.0</td>
<td>20.0</td>
</tr>
<tr class="odd">
<td><strong>Cardiac frequency (rpm)</strong></td>
<td>79.0</td>
<td>70.0</td>
<td>90.0</td>
</tr>
<tr class="even">
<td><strong>Systolic blood pressure (mmHg)</strong></td>
<td>137.5</td>
<td>116.0</td>
<td>150.0</td>
</tr>
<tr class="odd">
<td><strong>Diastolic blood pressure (mmHg)</strong></td>
<td>77.5</td>
<td>65.0</td>
<td>83.0</td>
</tr>
<tr class="even">
<td><strong>Temperature at admission (°C)</strong></td>
<td>36.0</td>
<td>35.7</td>
<td>36.4</td>
</tr>
<tr class="odd">
<td><strong>Percentage of O2 saturation</strong></td>
<td>90.0</td>
<td>87.0</td>
<td>95.0</td>
</tr>
<tr class="even">
<td><strong>FiO2 (%)</strong></td>
<td>100.0</td>
<td>96.0</td>
<td>100.0</td>
</tr>
<tr class="odd">
<td>**Neutrophil count (*10^3/µL)**</td>
<td>7.98</td>
<td>4.75</td>
<td>10.5</td>
</tr>
<tr class="even">
<td>**Lymphocyte count (*10^3/µL)**</td>
<td>1.34</td>
<td>0.85</td>
<td>1.98</td>
</tr>
<tr class="odd">
<td>**Platelet count (*10^3/µL)**</td>
<td>202.00</td>
<td>147.5</td>
<td>272.25</td>
</tr>
<tr class="even">
<td><strong>Hemoglobin level (g/dL)</strong></td>
<td>12.7</td>
<td>11.8</td>
<td>14.5</td>
</tr>
<tr class="odd">
<td><strong>Procalcitonin levels (ng/mL)</strong></td>
<td>0.11</td>
<td>0.07</td>
<td>0.27</td>
</tr>
<tr class="even">
<td><strong>CRP (mg/dL)</strong></td>
<td>8.06</td>
<td>2.9</td>
<td>16.1</td>
</tr>
<tr class="odd">
<td><strong>LDH (mg/dL)</strong></td>
<td>307.0</td>
<td>258.5</td>
<td>386.0</td>
</tr>
<tr class="even">
<td><strong>Albumin (mg/dL)</strong></td>
<td>27.0</td>
<td>24.5</td>
<td>32.5</td>
</tr>
<tr class="odd">
<td><strong>ALT (mg/dL)</strong></td>
<td>23.0</td>
<td>12.0</td>
<td>47.5</td>
</tr>
<tr class="even">
<td><strong>AST (mg/dL)</strong></td>
<td>30.0</td>
<td>22.0</td>
<td>52.5</td>
</tr>
<tr class="odd">
<td><strong>ALP (mg/dL)</strong></td>
<td>70.0</td>
<td>53.5</td>
<td>88.0</td>
</tr>
<tr class="even">
<td><strong>Direct bilirubin (mg/dL)</strong></td>
<td>0.15</td>
<td>0.1</td>
<td>0.27</td>
</tr>
<tr class="odd">
<td><strong>Indirect bilirubin (mg/dL)</strong></td>
<td>0.15</td>
<td>0.012</td>
<td>0.002</td>
</tr>
<tr class="even">
<td><strong>Total bilirubin (mg/dL)</strong></td>
<td>0.3</td>
<td>0.2</td>
<td>0.6</td>
</tr>
<tr class="odd">
<td><strong>Creatinine (mg/dL)</strong></td>
<td>1.03</td>
<td>0.6</td>
<td>1.637</td>
</tr>
<tr class="even">
<td><strong>CPK (mg/dL)</strong></td>
<td>79.0</td>
<td>47.0</td>
<td>194.0</td>
</tr>
<tr class="odd">
<td><strong>Sodium (mg/dL)</strong></td>
<td>140.0</td>
<td>137.0</td>
<td>142.5</td>
</tr>
<tr class="even">
<td><strong>Potassium (mg/dL)</strong></td>
<td>4.4</td>
<td>4.0</td>
<td>5.0</td>
</tr>
<tr class="odd">
<td><strong>INR</strong></td>
<td>1.1</td>
<td>1.0</td>
<td>1.2</td>
</tr>
<tr class="even">
<td><strong>IL-6 (pg/mL)</strong></td>
<td>88.8</td>
<td>13.7</td>
<td>119.7</td>
</tr>
<tr class="odd">
<td><strong>IgM (AU/mL)</strong></td>
<td>3.4</td>
<td>0.0</td>
<td>8.1</td>
</tr>
<tr class="even">
<td><strong>IgG (AU/mL)</strong></td>
<td>12.0</td>
<td>5.7</td>
<td>13.4</td>
</tr>
<tr class="odd">
<td><strong>Length of stay (days)</strong></td>
<td>11.0</td>
<td>5.75</td>
<td>17.0</td>
</tr>
</tbody>
</table>
<p><strong>Real-World Impact:</strong></p>
<p>During the pandemic, numerous studies and models were developed to
aid in predicting COVID-19 outcomes. The study from this paper serves as
an excellent example of how detailed patient data can inform model
development. By designing a suitable machine learning model, researchers
and healthcare providers can not only achieve high predictive accuracy
but also ensure that their findings are actionable and trustworthy.</p>
<p><strong>Discussion Questions:</strong></p>
<ol style="list-style-type: decimal">
<li>
<strong>Compare the Advantages:</strong>
<ul>
<li>What are the advantages of using explainable models such as decision
trees in predicting COVID-19 outcomes?</li>
<li>What are the advantages of using black box models such as neural
networks in this scenario?</li>
</ul>
</li>
<li>
<strong>Assess the Drawbacks:</strong>
<ul>
<li>What are the potential drawbacks of using explainable models like
decision trees?</li>
<li>What are the potential drawbacks of using black box models in
healthcare settings?</li>
</ul>
</li>
<li>
<strong>Decision-Making Criteria:</strong>
<ul>
<li>In what situations might you prioritize an explainable model over a
black box model, and why?</li>
<li>Are there scenarios where the higher accuracy of black box models
justifies their use despite their lack of transparency?</li>
</ul>
</li>
<li>
<strong>Practical Application:</strong>
<ul>
<li>Design a simple decision tree based on the provided biomarkers to
predict bad outcomes.</li>
<li>Evaluate how the decision tree can aid healthcare providers in
making informed decisions.</li>
</ul>
</li>
</ol>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>
<strong>Compare the Advantages:</strong>
<ul>
<li>
<strong>Explainable Models:</strong> Allow healthcare professionals
to understand and trust the model’s decisions, providing clear insights
into which biomarkers contribute most to predicting bad outcomes. This
transparency is crucial in critical fields such as healthcare, where
understanding the decision-making process can inform treatment plans and
improve patient outcomes.</li>
<li>
<strong>Black Box Models:</strong> Often provide higher predictive
accuracy, which can be crucial for identifying patterns in complex
datasets. They can capture non-linear relationships and interactions
that simpler models might miss.</li>
</ul>
</li>
<li>
<strong>Assess the Drawbacks:</strong>
<ul>
<li>
<strong>Explainable Models:</strong> May not capture complex
relationships in the data as effectively as black box models,
potentially leading to lower predictive accuracy in some cases.</li>
<li>
<strong>Black Box Models:</strong> Can be difficult to interpret,
which hinders trust and adoption by medical professionals. Without
understanding the model’s reasoning, it becomes challenging to validate
its correctness, ensure regulatory compliance, and effectively debug or
refine the model.</li>
</ul>
</li>
<li>
<strong>Decision-Making Criteria:</strong>
<ul>
<li>
<strong>Prioritizing Explainable Models:</strong> When transparency,
trust, and regulatory compliance are critical, such as in healthcare
settings where understanding and validating decisions is essential.</li>
<li>
<strong>Using Black Box Models:</strong> When the need for high
predictive accuracy outweighs the need for transparency, and when
supplementary methods for interpreting the model’s output can be
employed.</li>
</ul>
</li>
<li>
<strong>Practical Application:</strong>
<ul>
<li>
<strong>Design a Decision Tree:</strong> Using the given biomarkers,
create a simple decision tree. Identify key split points (e.g., high CRP
levels, elevated LDH) and illustrate how these markers can be used to
predict bad outcomes. Tools like scikit-learn or any decision tree
visualization tool can be used.</li>
<li>
<strong>Example Decision Tree:</strong> Here is a <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9602523/figure/ijerph-19-13016-f003/" class="external-link">Decision
Tree</a> found by Giotta et al.</li>
</ul>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="section level3 exercise">
<h3 id="exercise2-covid-19-diagnosis-using-chest-x-rays-a-study-by-ucar-and-korkmaz">Exercise2: COVID-19 Diagnosis Using Chest X-Rays, a study by <a href="https://www.sciencedirect.com/science/article/pii/S0306987720307702" class="external-link">Ucar
and Korkmaz</a>
<a class="anchor" aria-label="anchor" href="#exercise2-covid-19-diagnosis-using-chest-x-rays-a-study-by-ucar-and-korkmaz"></a>
</h3>
<p><strong>Objective:</strong> Diagnose COVID-19 through chest
X-rays.</p>
<p><strong>Motivation:</strong></p>
<p>The COVID-19 pandemic has had an unprecedented impact on global
health, affecting millions of people worldwide. One of the critical
challenges in managing this pandemic is the rapid and accurate diagnosis
of infected individuals. Traditional methods, such as the Reverse
Transcription Polymerase Chain Reaction (RT-PCR) test, although widely
used, have several drawbacks. These tests are time-consuming, require
specialized equipment and personnel, and often suffer from low detection
rates, necessitating multiple tests to confirm a diagnosis.</p>
<p>In this context, radiological imaging, particularly chest X-rays, has
emerged as a valuable tool for COVID-19 diagnosis. Early studies have
shown that COVID-19 causes specific abnormalities in chest X-rays, such
as ground-glass opacities, which can be used as indicators of the
disease. However, interpreting these images requires expertise and time,
both of which are in short supply during a pandemic.</p>
<p>To address these challenges, researchers have turned to machine
learning techniques…</p>
<p><strong>Dataset Specification:</strong> <a href="https://ars.els-cdn.com/content/image/1-s2.0-S0306987720307702-gr5.jpg" class="external-link">Chest
X-ray images</a></p>
<p><strong>Real-World Impact:</strong></p>
<p>The COVID-19 pandemic highlighted the urgent need for rapid and
accurate diagnostic tools. Traditional methods like RT-PCR tests, while
effective, are often time-consuming and have variable detection rates.
Using chest X-rays for diagnosis offers a quicker and more accessible
alternative. By analyzing chest X-rays, healthcare providers can swiftly
identify COVID-19 cases, enabling timely treatment and isolation
measures. Developing a machine learning method that can quickly and
accurately analyze chest X-rays can significantly enhance the speed and
efficiency of the healthcare response, especially in areas with limited
access to RT-PCR testing.</p>
<p><strong>Discussion Questions:</strong></p>
<ol style="list-style-type: decimal">
<li>
<strong>Compare the Advantages:</strong>
<ul>
<li>What are the advantages of using deep neural networks in diagnosing
COVID-19 from chest X-rays?</li>
<li>What are the advantages of traditional methods, such as genomic data
analysis, for COVID-19 diagnosis?</li>
</ul>
</li>
<li>
<strong>Assess the Drawbacks:</strong>
<ul>
<li>What are the potential drawbacks of using deep neural networks for
COVID-19 diagnosis from chest X-rays?</li>
<li>How do these drawbacks compare to those of traditional methods?</li>
</ul>
</li>
<li>
<strong>Decision-Making Criteria:</strong>
<ul>
<li>In what situations might you prioritize using deep neural networks
over traditional methods, and why?</li>
<li>Are there scenarios where the rapid availability of X-ray results
justifies the use of deep neural networks despite potential
drawbacks?</li>
</ul>
</li>
<li>
<strong>Practical Application:</strong>
<ul>
<li>Design a simple deep neural network architecture for diagnosing
COVID-19 from chest X-rays.</li>
<li>Evaluate how this deep learning model can aid healthcare providers
in making informed decisions quickly.</li>
</ul>
</li>
</ol>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>
<strong>Compare the Advantages:</strong>
<ul>
<li>
<strong>Deep Neural Networks:</strong> Provide high accuracy (e.g.,
98%) in diagnosing COVID-19 from chest X-rays, offering a quick and
non-invasive diagnostic tool. They can handle large amounts of image
data and identify complex patterns that might be missed by human
eyes.</li>
<li>
<strong>Traditional Methods:</strong> Provide detailed and specific
diagnostic information by analyzing genomic data and biomarkers, which
can be crucial for understanding the virus’s behavior and patient
response.</li>
</ul>
</li>
<li>
<strong>Assess the Drawbacks:</strong>
<ul>
<li>
<strong>Deep Neural Networks:</strong> Require large labeled
datasets for training, which may not always be available. The models can
be seen as “black boxes”, making it challenging to interpret their
decisions without additional explainability methods.</li>
<li>
<strong>Traditional Methods:</strong> Time-consuming and may have
lower detection accuracy. They often require specialized equipment and
personnel, leading to delays in diagnosis.</li>
</ul>
</li>
<li>
<strong>Decision-Making Criteria:</strong>
<ul>
<li>
<strong>Prioritizing Deep Neural Networks:</strong> When rapid
diagnosis is critical, and chest X-rays are readily available. Useful in
large-scale screening scenarios where speed is more critical than the
detailed understanding provided by genomic data.</li>
<li>
<strong>Using Traditional Methods:</strong> When detailed and
specific information about the virus is needed for treatment planning,
and when the availability of genomic data and biomarkers is not a
bottleneck.</li>
</ul>
</li>
<li>
<strong>Practical Application:</strong>
<ul>
<li><p><strong>Design a Neural Network:</strong> Create a simple
convolutional neural network (CNN) architecture using tools like
TensorFlow or PyTorch. Use a dataset of labeled chest X-ray images to
train and validate the model.</p></li>
<li>
<p><strong>Example Model:</strong> Here is a <a href="https://ars.els-cdn.com/content/image/1-s2.0-S0306987720307702-ga1.jpg" class="external-link">model
proposed by Ucar and Korkmaz</a></p>
<ul>
<li>
<strong>Evaluate the Model:</strong> Train the model on your dataset
and evaluate its performance. Discuss how this model can help healthcare
providers make quick and accurate diagnoses.</li>
</ul>
</li>
</ul>
</li>
</ol>
</div>
</div>
</div>
</div></section><section id="aio-5a-explainable-AI-method-overview"><p>Content from <a href="5a-explainable-AI-method-overview.html">Explainability methods overview</a></p>
<hr>
<p>Last updated on 2024-07-10 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/5a-explainable-AI-method-overview.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="fantastic-explainability-methods-and-where-to-use-them">Fantastic Explainability Methods and Where to Use Them<a class="anchor" aria-label="anchor" href="#fantastic-explainability-methods-and-where-to-use-them"></a>
</h2>
<hr class="half-width">
<p>We will now take a bird’s-eye view of explainability methods that are
widely applied on complex models like neural networks. We will get a
sense of when to use which kind of method, and what the tradeoffs
between these methods are.</p>
</section><section><h2 class="section-heading" id="three-axes-of-use-cases-for-understanding-model-behavior">Three axes of use cases for understanding model behavior<a class="anchor" aria-label="anchor" href="#three-axes-of-use-cases-for-understanding-model-behavior"></a>
</h2>
<hr class="half-width">
<p>When deciding which explainability method to use, it is helpful to
define your setting along three axes. This helps in understanding the
context in which the model is being used, and the kind of insights you
are looking to gain from the model.</p>
<div class="section level3">
<h3 id="inherently-interpretable-vs-post-hoc-explainable">Inherently Interpretable vs Post Hoc Explainable<a class="anchor" aria-label="anchor" href="#inherently-interpretable-vs-post-hoc-explainable"></a>
</h3>
<p>Understanding the tradeoff between interpretability and complexity is
crucial in machine learning. Simple models like decision trees, random
forests, and linear regression offer transparency and ease of
understanding, making them ideal for explaining predictions to
stakeholders. In contrast, neural networks, while powerful, lack
interpretability due to their complexity. Post hoc explainable
techniques can be applied to neural networks to provide explanations for
predictions, but it’s essential to recognize that using such methods
involves a tradeoff between model complexity and interpretability.</p>
<p>Striking the right balance between these factors is key to selecting
the most suitable model for a given task, considering both its
predictive performance and the need for interpretability.</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-interpretability-vs-complexity.png" alt="_Credits: AAAI 2021 Tutorial on Explaining Machine Learning Predictions: State of the Art, Challenges, Opportunities._" class="figure mx-auto d-block"><div class="figcaption">The tradeoff between Interpretability and
Complexity</div>
</figure>
</div>
<div class="section level3">
<h3 id="local-vs-global-explanations">Local vs Global Explanations<a class="anchor" aria-label="anchor" href="#local-vs-global-explanations"></a>
</h3>
<p>Local explanations focus on describing model behavior within a
specific neighborhood, providing insights into individual predictions.
Conversely, global explanations aim to elucidate overall model behavior,
offering a broader perspective. While global explanations may be more
comprehensive, they run the risk of being overly complex.</p>
<p>Both types of explanations are valuable for uncovering biases and
ensuring that the model makes predictions for the right reasons. The
tradeoff between local and global explanations has a long history in
statistics, with methods like linear regression (global) and kernel
smoothing (local) illustrating the importance of considering both
perspectives in statistical analysis.</p>
</div>
<div class="section level3">
<h3 id="black-box-vs-white-box-approaches">Black box vs White Box Approaches<a class="anchor" aria-label="anchor" href="#black-box-vs-white-box-approaches"></a>
</h3>
<p>Techniques that require access to model internals (e.g., model
architecture and model weights) are called “white box” while techniques
that only need query access to the model are called “black box”. Even
without access to the model weights, black box or top down approaches
can shed a lot of light on model behavior. For example, by simply
evaluating the model on certain kinds of data, high level biases or
trends in the model’s decision making process can be unearthed.</p>
<p>White box approaches use the weights and activations of the model to
understand its behavior. These classes or methods are more complex and
diverse, and we will discuss them in more detail later in this episode.
Some large models are closed-source due to commercial or safety
concerns; for example, users can’t get access to the weights of GPT-4.
This limits the use of white box explanations for such models.</p>
</div>
</section><section><h2 class="section-heading" id="classes-of-explainability-methods-for-understanding-model-behavior">Classes of Explainability Methods for Understanding Model
Behavior<a class="anchor" aria-label="anchor" href="#classes-of-explainability-methods-for-understanding-model-behavior"></a>
</h2>
<hr class="half-width">
<div class="section level3">
<h3 id="diagnostic-testing">Diagnostic Testing<a class="anchor" aria-label="anchor" href="#diagnostic-testing"></a>
</h3>
<p>This is the simplest approach towards explaining model behavior. This
involves applying a series of unit tests to the model, where each test
is a sample input where you know what the correct output should be. By
identifying test examples that break the heuristics the model relies on
(called counterfactuals), you can gain insights into the high-level
behavior of the model.</p>
<p><strong>Example Methods:</strong> <a href="https://arxiv.org/abs/1902.01007" class="external-link">Counterfactuals</a>, <a href="https://arxiv.org/abs/2005.04118" class="external-link">Unit tests</a></p>
<p><strong>Pros and Cons:</strong> These methods allow for gaining
insights into the high-level behavior of the model without the needing
access to model weights. This is especially useful with recent powerful
closed-source models like GPT-4. One challenge with this approach is
that it is hard to identify in advance what heuristics a model may
depend on.</p>
</div>
<div class="section level3">
<h3 id="baking-interpretability-into-models">Baking interpretability into models<a class="anchor" aria-label="anchor" href="#baking-interpretability-into-models"></a>
</h3>
<p>Some recent research has focused on tweaking highly complex models
like neural networks, towards making them more interpretable inherently.
One such example with language models involves training the model to
generate rationales for its prediction, in addition to its original
prediction. This approach has gained some traction, and there are even
<a href="https://arxiv.org/abs/1911.03429" class="external-link">public benchmarks</a> for
evaluating the quality of these generated rationales.</p>
<p><strong>Example methods:</strong> <a href="https://arxiv.org/abs/2004.14546" class="external-link">Rationales with WT5</a>, <a href="https://arxiv.org/abs/1606.04155" class="external-link">Older approaches for
rationales</a></p>
<p><strong>Pros and cons:</strong> These models hope to achieve the best
of both worlds: complex models that are also inherently interpretable.
However, research in this direction is still new, and there are no
established and reliable approaches for real world applications just
yet.</p>
</div>
<div class="section level3">
<h3 id="identifying-decision-rules-of-the-model">Identifying Decision Rules of the Model:<a class="anchor" aria-label="anchor" href="#identifying-decision-rules-of-the-model"></a>
</h3>
<p>In this class of methods, we try find a set of rules that generally
explain the decision making process of the model. Loosely, these rules
would be of the form “if a specific condition is met, then the model
will predict a certain class”.</p>
<p><strong>Example methods:</strong> <a href="https://aaai.org/papers/11491-anchors-high-precision-model-agnostic-explanations/" class="external-link">Anchors</a>,
<a href="https://arxiv.org/abs/1908.07125" class="external-link">Universal Adversarial
Triggers</a></p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-anchors-example.png" alt='Table caption: "Generated anchors for Tabular datasets". Table shows the following rules: for the adult dataset, predict less than 50K if no capital gain or loss and never married. Predict over 50K if country is US, married, and work hours over 45. For RCDV dataset, predict not rearrested if person has no priors, no prison violations, and crime not against property. Predict re-arrested if person is male, black, has 1-5 priors, is not married, and the crime not against property. For the Lending dataset, predict bad loan if FICO score is less than 650. Predict good loan if FICO score is between 650 and 700 and loan amount is between 5400 and 10000.' class="figure mx-auto d-block"><div class="figcaption">Example use of anchors (table from <a href="https://aaai.org/papers/11491-anchors-high-precision-model-agnostic-explanations/" class="external-link">Ribeiro
et al.</a>)</div>
</figure><p><strong>Pros and cons:</strong> Some global rules help find “bugs” in
the model, or identify high level biases. But finding such broad
coverage rules is challenging. Furthermore, these rules only showcase
the model’s weaknesses, but give next to no insight as to why these
weaknesses exist.</p>
</div>
<div class="section level3">
<h3 id="visualizing-model-weights-or-representations">Visualizing model weights or representations<a class="anchor" aria-label="anchor" href="#visualizing-model-weights-or-representations"></a>
</h3>
<p>Just like how a picture tells a thousand words, visualizations can
help encapsulate complex model behavior in a simple image.
Visualizations are commonly used in explaining neural networks, where
the weights or data representations of the model are directly
visualized. Many such approaches involve reducing the high-dimensional
weights or representations to a 2D or 3D space, using techniques like
PCA, tSNE, or UMAP. Alternatively, these visualizations can retain their
high dimensional representation, but use color or size to identify which
dimensions or neurons are more important.</p>
<p><strong>Example methods:</strong> <a href="https://arxiv.org/abs/1612.08220" class="external-link">Visualizing attention
heatmaps</a>, Weight visualizations, Model activation visualizations</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-visualization-heatmap.png" alt="Image shows a grid with 3 rows and 50 columns. Each cell is colored on a scale of -1.5 (white) to 0.9 (dark blue). Darker colors are concentrated in the first row in seemingly-random columns." class="figure mx-auto d-block"><div class="figcaption">Example usage of visualizing attention heatmaps
for part-of-speech (POS) identification task using word2vec-encoded
vectors. Each cell is a unit in a neural network (each row is a layer
and each column is a dimension). Darker colors indicates that a unit is
more importance for predictive accuracy (table from <a href="https://arxiv.org/pdf/1612.08220" class="external-link">Li et al.</a>.)</div>
</figure><p><strong>Pros and cons:</strong> Gleaning model behaviour from
visualizations is very intuitive and user-friendly, and visualizations
sometimes have interactive interfaces. However, visualizations can be
misleading, especially when high-dimensional vectors are reduced to 2D,
leading to a loss of information (crowding issue).</p>
<p>An iconic debate exemplifying the validity of visualizations has
centered around attention heatmaps. Research has shown them to be <a href="https://arxiv.org/abs/1902.10186" class="external-link">unreliable</a>, and then <a href="https://arxiv.org/abs/1908.04626" class="external-link">reliable again</a>. (Check out
the titles of these papers!) Thus, visualization can only be used as an
additional step in an analysis, and not as a standalone method.</p>
</div>
<div class="section level3">
<h3 id="understanding-the-impact-of-training-examples">Understanding the impact of training examples<a class="anchor" aria-label="anchor" href="#understanding-the-impact-of-training-examples"></a>
</h3>
<p>These techniques unearth which training data instances caused the
model to generate a specific prediction for a given sample. At a high
level, these techniques mathematically identify what training samples
that – if removed from the training process – are most influential for
causing a particular prediction.</p>
<p><strong>Example methods:</strong> <a href="https://arxiv.org/abs/1703.04730" class="external-link">Influence functions</a>, <a href="https://arxiv.org/abs/1811.09720" class="external-link">Representer point
selection</a></p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-influence.png" alt="Two images. On the left, several antelope are standing in the background on a grassy field. On the right, several zebra graze in a field in the background, while there is one antelope in the foreground and other antelope in the background." class="figure mx-auto d-block"><div class="figcaption">Example usage of representer point selection.
The image on the left is a test image that is misclassified as a deer
(the true label is antelope). The image on the right is the most
influential training point. We see that this image is labeled “zebra,”
but contains both zebras and antelopes. (example adapted from <a href="https://arxiv.org/pdf/1811.09720" class="external-link">Yeh et al.</a>.)</div>
</figure><p><strong>Pros and cons:</strong> The insights from these approaches
are actionable - by identifying the data responsible for a prediction,
it can help correct labels or annotation artifacts in that data.
Unfortunately, these methods scale poorly with the size of the model and
training data, quickly becoming computationally expensive. Furthermore,
even knowing which datapoints had a high influence on a prediction, we
don’t know what it was about that datapoint that caused the
influence.</p>
</div>
<div class="section level3">
<h3 id="understanding-the-impact-of-a-single-example">Understanding the impact of a single example:<a class="anchor" aria-label="anchor" href="#understanding-the-impact-of-a-single-example"></a>
</h3>
<p>For a single input, what parts of the input were most important in
generating the model’s prediction? These methods study the signal sent
by various features to the model, and observe how the model reacts to
changes in these features.</p>
<p><strong>Example methods:</strong> <a href="https://arxiv.org/abs/1312.6034" class="external-link">Saliency Maps</a>, <a href="https://arxiv.org/abs/1602.04938" class="external-link">LIME</a>/<a href="https://arxiv.org/abs/1705.07874" class="external-link">SHAP</a>, Perturbations (<a href="https://arxiv.org/abs/1804.07781" class="external-link">Input reduction</a>, <a href="https://arxiv.org/abs/1712.06751" class="external-link">Adversarial
Perturbations</a>)</p>
<p>These methods can be further subdivided into two categories:
gradient-based methods that rely on white-box model access to directly
see the impact of changing a single input, and perturbation-based
methods that manually perturb an input and re-query the model to see how
the prediction changes.</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-smoothgrad.png" alt='Two rows images (5 images per row). Leftmost column shows two different pictures, each containing a cat and a dog. Remaining columns show the saliency maps using different techniques (VanillaGrad, InteGrad, GuidedBackProp, and SmoothGrad). Each saliency map has red dots (indicated regions that are influential for predicting "dog") and blue dots (influential for predicting "cat"). All methods except GuidedBackProp have good overlap between the respective dots and where the animals appear in the image. SmoothGrad has the most precise mapping.' class="figure mx-auto d-block"><div class="figcaption">Example saliency maps. The right 4 columns show
the result of different saliency method techniques, where red dots
indicate regions that are influential for predicting “dog” and blue dots
indicate regions that are influential for predicting “cat”. The image
creators argue that their method, SmoothGrad, is most effective at
mapping model behavior to images. (Image taken from <a href="https://arxiv.org/pdf/1706.03825" class="external-link">Smilkov et al.</a>)</div>
</figure><p><strong>Pros and cons:</strong> These methods are fast to compute,
and flexible in their use across models. However, the insights gained
from these methods are not actionable - knowing which part of the input
caused the prediction does not highlight why that part caused it. On
finding issues in the prediction process, it is also hard to pick up on
if there is an underlying issue in the model, or just the specific
inputs tested on. Relatedly, these methods can be unstable, and can even
be <a href="https://proceedings.neurips.cc/paper_files/paper/2019/hash/7fea637fd6d02b8f0adf6f7dc36aed93-Abstract.html" class="external-link">fooled
by adversarial examples</a>.</p>
</div>
<div class="section level3">
<h3 id="probing-internal-representations">Probing internal representations<a class="anchor" aria-label="anchor" href="#probing-internal-representations"></a>
</h3>
<p>As the name suggests, this class of methods aims to probe the
internals of a model, to discover what kind of information or knowledge
is stored inside the model. Probes are often administered to a specific
component of the model, like a set of neurons or layers within a neural
network.</p>
<p><strong>Example methods:</strong> <a href="https://direct.mit.edu/coli/article/48/1/207/107571/Probing-Classifiers-Promises-Shortcomings-and" class="external-link">Probing
classifiers</a>, <a href="https://proceedings.neurips.cc/paper/2020/hash/92650b2e92217715fe312e6fa7b90d82-Abstract.html" class="external-link">Causal
tracing</a></p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-probe.png" alt='The phrase "The nurse examined the farmer for injuries because PRONOUN" is shown twice, once with PRONOUN=she and once with PRONOUN=he. Each word is annotated with the importance of three different attention heads. The distribution of which heads are important with each pronoun differs for all words, but especially for nurse and farmer.' class="figure mx-auto d-block"><div class="figcaption">Example probe output. The image shows the result
from probing three attention heads. We see that gender stereotypes are
encoded into the model because the heads that are important for nurse
and farmer change depending on the final pronoun. Specifically, Head
5-10 attends to the stereotypical gender assignment while Head 4-6
attends to the anti-stereotypical gender assignment. (Image taken from
<a href="https://proceedings.neurips.cc/paper/2020/hash/92650b2e92217715fe312e6fa7b90d82-Abstract.html" class="external-link">Vig
et al.</a>)</div>
</figure><p><strong>Pros and cons:</strong> Probes have shown that it is possible
to find highly interpretable components in a complex model, e.g., MLP
layers in transformers have been shown to store factual knowledge in a
structured manner. However, there is no systematic way of finding
interpretable components, and many components may remain elusive to
humans to understand. Furthermore, the model components that have been
shown to contain certain knowledge may not actually play a role in the
model’s prediction.</p>
<div id="is-that-all" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="is-that-all" class="callout-inner">
<h3 class="callout-title">Is that all?</h3>
<div class="callout-content">
<p>Nope! We’ve discussed a few of the common explanation techniques, but
many others exist. In particular, specialized model architectures often
need their own explanation algorithms. For instance, <a href="https://ieeexplore.ieee.org/abstract/document/9875989?casa_token=BiFHRXv7_9gAAAAA:wPV-PXOpCLFg2g1qYgEQ7QF_LKZs32cOXEJBvwjK3z43sXeaGfvQ9e1QePW03MTLq4lrUsh4Jw" class="external-link">Yuan
et al.</a> give an overview of different explanation techniques for
graph neural networks (GNNs).</p>
</div>
</div>
</div>
<div id="classifying-explanation-techniques" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="classifying-explanation-techniques" class="callout-inner">
<h3 class="callout-title">Classifying explanation techniques</h3>
<div class="callout-content">
<p>For each of the explanation techniques described above, discuss the
following with a partner:</p>
<ul>
<li>Does it require black-box or white-box model access?</li>
<li>Are the explanations it provides global or local?</li>
<li>Is the technique post-hoc or does it rely on inherent
interpretability of the model?</li>
</ul>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<table class="table">
<colgroup>
<col width="54%">
<col width="21%">
<col width="10%">
<col width="13%">
</colgroup>
<thead><tr class="header">
<th>Approach</th>
<th>Post Hoc or Inherently Interpretable?</th>
<th>Local or Global?</th>
<th>White Box or Black Box?</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><a href="#diagnostic-testing">Diagnostic Testing</a></td>
<td>Post Hoc</td>
<td>Global</td>
<td>Black Box</td>
</tr>
<tr class="even">
<td><a href="#baking-interpretability-into-models">Baking
interpretability into models</a></td>
<td>Inherently Interpretable</td>
<td>Local</td>
<td>White Box</td>
</tr>
<tr class="odd">
<td><a href="#identifying-decision-rules-of-the-model">Identifying
Decision Rules of the Model</a></td>
<td>Post Hoc</td>
<td>Both</td>
<td>White Box</td>
</tr>
<tr class="even">
<td><a href="#visualizing-model-weights-or-representations">Visualizing
model weights or representations</a></td>
<td>Post Hoc</td>
<td>Global</td>
<td>White Box</td>
</tr>
<tr class="odd">
<td><a href="#understanding-the-impact-of-training-examples">Understanding the
impact of training examples</a></td>
<td>Post Hoc</td>
<td>Local</td>
<td>White Box</td>
</tr>
<tr class="even">
<td><a href="#understanding-the-impact-of-a-single-example">Understanding the
impact of a single example</a></td>
<td>Post Hoc</td>
<td>Local</td>
<td>Both</td>
</tr>
<tr class="odd">
<td><a href="#probing-internal-representations">Probing internal
representations of a model</a></td>
<td>Post Hoc</td>
<td>Global/Local</td>
<td>White Box</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<p>What explanation should you use when? There is no simple answer, as
it depends upon your goals (i.e., why you need an explanation), who the
audience is, the model architecture, and the availability of model
internals (e.g., there is no white-box access to ChatGPT unless you work
for Open AI!). The next exercise asks you to consider different
scenarios and discuss what explanation techniques are appropriate.</p>
<div id="discussion2" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Think about the following scenarios and suggest which explainability
method would be most appropriate to use, and what information could be
gained from that method. Furthermore, think about the limitations of
your findings.</p>
<p><em>Note:</em> These are open-ended questions, and there is no
correct answer. Feel free to break into discussion groups to discuss the
scenarios.</p>
<p><strong>Scenario 1</strong>: Suppose that you are an ML engineer
working at a tech company. A fast-food chain company consults with you
about sentimental analysis based on feedback they collected on Yelp and
their survey. You use an open sourced LLM such as Llama-2 and finetune
it on the review text data. The fast-food company asks to provide
explanations for the model: Is there any outlier review? How does each
review in the data affect the finetuned model? Which part of the
language in the review indicates that a customer likes or dislikes the
food? Can you score the food quality according to the reviews? Does the
review show a trend over time? What item is gaining popularity or losing
popularity? Q: Can you suggest a few explainability methods that may be
useful for answering these questions?</p>
<p><strong>Scenario 2</strong>: Suppose that you are a radiologist who
analyzes medical images of patients with the help of machine learning
models. You use black-box models (e.g., CNNs, Vision Transformers) to
complement human expertise and get useful information before making
high-stake decisions. Which areas of a medical image most likely
explains the output of a black-box? Can we visualize and understand what
features are captured by the intermediate components of the black-box
models? How do we know if there is a distribution shift? How can we tell
if an image is an out-of-distribution example? Q: Can you suggest a few
explainability methods that may be useful for answering these
questions?</p>
<p><strong>Scenario 3</strong>: Suppose that you work on genomics and
you just collected samples of single-cell data into a table: each row
records gene expression levels, and each column represents a single
cell. You are interested in scientific hypotheses about evolution of
cells. You believe that only a few genes are playing a role in your
study. What exploratory data analysis techniques would you use to
examine the dataset? How do you check whether there are potential
outliers, irregularities in the dataset? You believe that only a few
genes are playing a role in your study. What can you do to find the set
of most explanatory genes? How do you know if there is clustering, and
if there is a trajectory of changes in the cells? Q: Can you explain the
decisions you make for each method you use?</p>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<p>There are many available explanation techniques and they differ along
three dimensions: model access (white-box or black-box), explanation
scope (global or local), and approach (inherently interpretable or
post-hoc). There’s often no objectively-right answer of which
explanation technique to use in a given situation, as the different
methods have different tradeoffs.</p>
<div class="section level3">
<h3 id="references-and-further-reading">References and Further Reading<a class="anchor" aria-label="anchor" href="#references-and-further-reading"></a>
</h3>
<p>This lesson provides a gentle overview into the world of
explainability methods. If you’d like to know more, here are some
resources to get you started:</p>
<ul>
<li>Tutorials on Explainability:
<ul>
<li><a href="https://github.com/Eric-Wallace/interpretability-tutorial-emnlp2020/blob/master/tutorial_slides.pdf" class="external-link">Wallace,
E., Gardner, M., &amp; Singh, S. (2020, November). Interpreting
predictions of NLP models. In Proceedings of the 2020 Conference on
Empirical Methods in Natural Language Processing: Tutorial Abstracts
(pp. 20-23).</a></li>
<li><a href="https://explainml-tutorial.github.io/aaai21" class="external-link">Lakkaraju, H.,
Adebayo, J., &amp; Singh, S. (2020). Explaining machine learning
predictions: State-of-the-art, challenges, and opportunities. NeurIPS
Tutorial.</a></li>
<li><a href="https://sebastiangehrmann.github.io/assets/files/acl_2020_interpretability_tutorial.pdf" class="external-link">Belinkov,
Y., Gehrmann, S., &amp; Pavlick, E. (2020, July). Interpretability and
analysis in neural NLP. In Proceedings of the 58th annual meeting of the
association for computational linguistics: tutorial abstracts
(pp. 1-5).</a></li>
</ul>
</li>
<li>Research papers:
<ul>
<li><a href="https://arxiv.org/abs/2308.00189" class="external-link">Holtzman, A., West, P.,
&amp; Zettlemoyer, L. (2023). Generative Models as a Complex Systems
Science: How can we make sense of large language model behavior?. arXiv
preprint arXiv:2308.00189.</a></li>
</ul>
</li>
</ul>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-5b-deep-dive-into-methods"><p>Content from <a href="5b-deep-dive-into-methods.html">Explainability methods: deep dive</a></p>
<hr>
<p>Last updated on 2024-07-31 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/5b-deep-dive-into-methods.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="a-deep-dive-into-methods-for-understanding-model-behaviour">A Deep Dive into Methods for Understanding Model Behaviour<a class="anchor" aria-label="anchor" href="#a-deep-dive-into-methods-for-understanding-model-behaviour"></a>
</h2>
<hr class="half-width">
<p>In the previous section, we scratched the surface of explainability
methods, introducing you to the broad classes of methods designed to
understand different aspects of a model’s behavior.</p>
<p>Now, we will dive deeper into two widely used methods, each one which
answers one key question:</p>
</section><section><h2 class="section-heading" id="what-part-of-my-input-causes-this-prediction">What part of my input causes this prediction?<a class="anchor" aria-label="anchor" href="#what-part-of-my-input-causes-this-prediction"></a>
</h2>
<hr class="half-width">
<p>When a model makes a prediction, we often want to know which parts of
the input were most important in generating that prediction. This helps
confirm if the model is making its predictions for the right reasons.
Sometimes, models use features totally unrelated to the task for their
prediction - these are known as ‘spurious correlations’. For example, a
model might predict that a picture contains a dog because it was taken
in a park, and not because there is actually a dog in the picture.</p>
<p><strong><a href="https://arxiv.org/abs/1312.6034" class="external-link">Saliency
Maps</a></strong> are among the most simple and popular methods used
towards this end. We will be working with a more sophisticated version
of this method, known as <strong><a href="https://arxiv.org/abs/1610.02391" class="external-link">GradCAM</a></strong>.</p>
<div class="section level4">
<h4 id="method-and-examples">Method and Examples<a class="anchor" aria-label="anchor" href="#method-and-examples"></a>
</h4>
<p>A saliency map is a kind of visualization - it is a heatmap across
the input that shows which parts of the input are most important in
generating the model’s prediction. They can be calculated using the
gradients of a neural network, or by perturbing the input to any ML
model and observing how the model reacts to these perturbations. The key
intuition is that if a small change in a part of the input causes a
large change in the model’s prediction, then that part of the input is
important for the prediction. Gradients are useful in this because they
provide a signal towards how much the model’s prediction would change if
the input was changed slightly.</p>
<p>For example, in an image classification task, a saliency map can be
used to highlight the parts of the image that the model is focusing on
to make its prediction. In a text classification task, a saliency map
can be used to highlight the words or phrases that are most important
for the model’s prediction.</p>
<p>GradCAM is an extension of this idea, which uses the gradients of the
final layer of a convolutional neural network to generate a heatmap that
highlights the important regions of an image. This heatmap can be
overlaid on the original image to visualize which parts of the image are
most important for the model’s prediction.</p>
<p>Other variants of this method include <a href="https://arxiv.org/abs/1703.01365" class="external-link">Integrated Gradients</a>, <a href="https://arxiv.org/pdf/1806.03000" class="external-link">SmoothGrad</a>, and others,
which are designed to provide more robust and reliable explanations for
model predictions. However, GradCAM is a good starting point for
understanding how saliency maps work, and is a popularly used
approach.</p>
<p>Alternative approaches, which may not directly generate heatmaps,
include <a href="https://arxiv.org/abs/1602.04938" class="external-link">LIME</a> and <a href="https://arxiv.org/abs/1705.07874" class="external-link">SHAP</a>, which are also popular
and recommended for further reading.</p>
</div>
<div class="section level4">
<h4 id="limitations-and-extensions">Limitations and Extensions<a class="anchor" aria-label="anchor" href="#limitations-and-extensions"></a>
</h4>
<p>Gradient based saliency methods like GradCam are fast to compute,
requiring only a handful of backpropagation steps on the model to
generate the heatmap. The method is also model-agnostic, meaning it can
be applied to any model that can be trained using gradient descent.
Additionally, the results obtained from these methods are intuitive and
easy to understand, making them useful for explaining model predictions
to non-experts.</p>
<p>However, their use is limited to models that can be trained using
gradient descent, and have white-box access. It is also difficult to
apply these methods to tasks beyond classification, making their
application limited with many recent generative models (think LLMs).</p>
<p>Another limitation is that the insights gained from these methods are
not actionable - knowing which part of the input caused the prediction
does not highlight why that part caused it. On finding issues in the
prediction process, it is also hard to pick up on if there is an
underlying issue in the model, or just the specific inputs tested
on.</p>
</div>
</section><section><h2 class="section-heading" id="what-part-of-my-model-causes-this-prediction">What part of my model causes this prediction?<a class="anchor" aria-label="anchor" href="#what-part-of-my-model-causes-this-prediction"></a>
</h2>
<hr class="half-width">
<p>When a model makes a correct prediction on a task it has been trained
on (known as a ‘downstream task’), <strong><a href="https://direct.mit.edu/coli/article/48/1/207/107571/Probing-Classifiers-Promises-Shortcomings-and" class="external-link">Probing
classifiers</a></strong> can be used to identify if the model actually
contains the relevant information or knowledge required to make that
prediction, or if it is just making a lucky guess. Furthermore, probes
can be used to identify the specific components of the model that
contain this relevant information, providing crucial insights for
developing better models over time.</p>
<div class="section level4">
<h4 id="method-and-examples-1">Method and Examples<a class="anchor" aria-label="anchor" href="#method-and-examples-1"></a>
</h4>
<p>A neural network takes its input as a series of vectors, or
representations, and transforms them through a series of layers to
produce an output. The job of the main body of the neural network is to
develop representations that are as useful for the downstream task as
possible, so that the final few layers of the network can make a good
prediction.</p>
<p>This essentially means that a good quality representation is one that
<em>already</em> contains all the information required to make a good
prediction. In other words, the features or representations from the
model are easily separable by a simple classifier. And that classifier
is what we call a ‘probe’. A probe is a simple model that uses the
representations of the model as input, and tries to learn the downstream
task from them. The probe itself is designed to be too easy to learn the
task on its own. This means, that the only way the probe get perform
well on this task is if the representations it is given are already good
enough to make the prediction.</p>
<p>These representations can be taken from any part of the model.
Generally, using representations from the last layer of a neural network
help identify if the model even contains the information to make
predictions for the downstream task. However, this can be extended
further: probing the representations from different layers of the model
can help identify where in the model the information is stored, and how
it is transformed through the model.</p>
<p>Probes have been frequently used in the domain of NLP, where they
have been used to check if language models contain certain kinds of
linguistic information. These probes can be designed with varying levels
of complexity. For example, simple probes have shown language models to
contain information about simple syntactical features like <a href="https://aclanthology.org/D15-1246.pdf" class="external-link">Part of Speech tags</a>,
and more complex probes have shown models to contain entire <a href="https://aclanthology.org/N19-1419.pdf" class="external-link">Parse trees</a> of
sentences.</p>
</div>
<div class="section level4">
<h4 id="limitations-and-extensions-1">Limitations and Extensions<a class="anchor" aria-label="anchor" href="#limitations-and-extensions-1"></a>
</h4>
<p>One large challenge in using probes is identifying the correct
architectural design of the probe. Too simple, and it may not be able to
learn the downstream task at all. Too complex, and it may be able to
learn the task even if the model does not contain the information
required to make the prediction.</p>
<p>Another large limitation is that even if a probe is able to learn the
downstream task, it does not mean that the model is actually using the
information contained in the representations to make the prediction. So
essentially, a probe can only tell us if a part of the model
<em>can</em> make the prediction, not if it <em>does</em> make the
prediction.</p>
<p>A new approach known as <strong><a href="https://proceedings.neurips.cc/paper/2020/hash/92650b2e92217715fe312e6fa7b90d82-Abstract.html" class="external-link">Causal
Tracing</a></strong> addresses this limitation. The objective of this
approach is similar to probes: attempting to understand which part of a
model contains information relevant to a downstream task. The approach
involves iterating through all parts of the model being examined
(e.g. all layers of a model), and disrupting the information flow
through that part of the model. (This could be as easy as adding some
kind of noise on top of the weights of that model component). If the
model performance on the downstream task suddenly drops on disrupting a
specific model component, we know for sure that that component not only
contains the information required to make the prediction, but that the
model is actually using that information to make the prediction.</p>
<div id="discussion1" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Now, it’s time to try implementing these methods yourself! Pick one
of the following problems to work on:</p>
<ul>
<li><a href="https://carpentries-incubator.github.io/fair-explainable-ml/5c-probes.html" class="external-link">Train
your own linear probe to check if BERT stores the required knowledge for
sentiment analysis.</a></li>
<li><a href="https://carpentries-incubator.github.io/fair-explainable-ml/5d-gradcam.html" class="external-link">Use
GradCAM on a trained model to check if the model is using the right
features to make predictions.</a></li>
</ul>
<p>It’s time to get your hands dirty now. Good luck, and have fun!</p>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-5c-probes"><p>Content from <a href="5c-probes.html">Explainability methods: linear probe</a></p>
<hr>
<p>Last updated on 2024-07-03 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/5c-probes.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># Let's start by importing the necessary libraries.</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="im">import</span> logging</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Tuple</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="im">from</span> sklearn.manifold <span class="im">import</span> TSNE</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="im">from</span> datasets <span class="im">import</span> load_dataset, Dataset</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> AutoModel, AutoTokenizer, AutoConfig</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>logging.basicConfig(level<span class="op">=</span>logging.INFO)</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>os.environ[<span class="st">'TOKENIZERS_PARALLELISM'</span>] <span class="op">=</span> <span class="st">'false'</span>  <span class="co"># This is needed to avoid a warning from huggingface</span></span></code></pre>
</div>
<p>Now, let’s set the random seed to ensure reproducibility. Setting
random seeds is like setting a starting point for your machine learning
adventure. It ensures that every time you train your model, it starts
from the same place, using the same random numbers, making your results
consistent and comparable.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Set random seeds for reproducibility - pick any number of your choice to set the seed. We use 42, since that is the answer to everything, after all.</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>torch.manual_seed(<span class="dv">42</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># Set the GPU to use</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>os.environ[<span class="st">'CUDA_VISIBLE_DEVICES'</span>] <span class="op">=</span> <span class="st">'0'</span>  </span></code></pre>
</div>
<div class="section level5">
<h5 id="loading-the-dataset">Loading the Dataset<a class="anchor" aria-label="anchor" href="#loading-the-dataset"></a>
</h5>
<p>Let’s load our data: the IMDB Movie Review dataset. The dataset
contains text reviews and their corresponding sentiment labels (positive
or negative). The label 1 corresponds to a positive review, and 0
corresponds to a negative review.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="kw">def</span> load_imdb_dataset(keep_samples: <span class="bu">int</span> <span class="op">=</span> <span class="dv">100</span>) <span class="op">-&gt;</span> Tuple[Dataset, Dataset, Dataset]:</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co">    Load the IMDB dataset from huggingface.</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="co">    The dataset contains text reviews and their corresponding sentiment labels (positive or negative).</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="co">    The label 1 corresponds to a positive review, and 0 corresponds to a negative review.</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="co">    :param keep_samples: Number of samples to keep, for faster training.</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="co">    :return: train, dev, test datasets. Each can be treated as a dictionary with keys 'text' and 'label'.</span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>    dataset <span class="op">=</span> load_dataset(<span class="st">'imdb'</span>)</span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a>    <span class="co"># Keep only a subset of the data for faster training</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a>    train_dataset <span class="op">=</span> Dataset.from_dict(dataset[<span class="st">'train'</span>].shuffle(seed<span class="op">=</span><span class="dv">42</span>)[:keep_samples])</span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a>    dev_dataset <span class="op">=</span> Dataset.from_dict(dataset[<span class="st">'test'</span>].shuffle(seed<span class="op">=</span><span class="dv">42</span>)[:keep_samples])</span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a>    test_dataset <span class="op">=</span> Dataset.from_dict(dataset[<span class="st">'test'</span>].shuffle(seed<span class="op">=</span><span class="dv">42</span>)[keep_samples:<span class="dv">2</span><span class="op">*</span>keep_samples])</span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a>    <span class="co"># train_dataset[0] will return {'text': ...., 'label': 0}</span></span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a>    logging.info(<span class="ss">f'Loaded IMDB dataset: </span><span class="sc">{</span><span class="bu">len</span>(train_dataset)<span class="sc">}</span><span class="ss"> training samples, </span><span class="sc">{</span><span class="bu">len</span>(dev_dataset)<span class="sc">}</span><span class="ss"> dev samples, </span><span class="sc">{</span><span class="bu">len</span>(test_dataset)<span class="sc">}</span><span class="ss"> test samples.'</span>)</span>
<span id="cb4-18"><a href="#cb4-18" tabindex="-1"></a>    <span class="cf">return</span> train_dataset, dev_dataset, test_dataset</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>train_dataset, dev_dataset, test_dataset <span class="op">=</span> load_imdb_dataset(keep_samples<span class="op">=</span><span class="dv">50</span>)</span></code></pre>
</div>
</div>
<div class="section level5">
<h5 id="loading-the-model">Loading the Model<a class="anchor" aria-label="anchor" href="#loading-the-model"></a>
</h5>
<p>We will load a model from huggingface, and use this model to get the
embeddings for the probe. We use BERT for this example, but feel free to
explore other models from huggingface after the exercise.</p>
<p>BERT is a transformer-based model, and is known to perform well on a
variety of NLP tasks. The model is pre-trained on a large corpus of
text, and can be fine-tuned for specific tasks.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="kw">def</span> load_model(model_name: <span class="bu">str</span>) <span class="op">-&gt;</span> Tuple[AutoModel, AutoTokenizer]:</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co">    Load a model from huggingface.</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co">    :param model_name: Check huggingface for acceptable model names.</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="co">    :return: Model and tokenizer.</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>    tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(model_name)</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>    config <span class="op">=</span> AutoConfig.from_pretrained(model_name)</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>    model <span class="op">=</span> AutoModel.from_pretrained(model_name, config<span class="op">=</span>config)</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>    model.config.max_position_embeddings <span class="op">=</span> <span class="dv">128</span>  <span class="co"># Reducing from default 512 to 128 for computational efficiency</span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>    logging.info(<span class="ss">f'Loaded model and tokenizer: </span><span class="sc">{</span>model_name<span class="sc">}</span><span class="ss"> with </span><span class="sc">{</span>model<span class="sc">.</span>config<span class="sc">.</span>num_hidden_layers<span class="sc">}</span><span class="ss"> layers, '</span></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>                 <span class="ss">f'hidden size </span><span class="sc">{</span>model<span class="sc">.</span>config<span class="sc">.</span>hidden_size<span class="sc">}</span><span class="ss"> and sequence length </span><span class="sc">{</span>model<span class="sc">.</span>config<span class="sc">.</span>max_position_embeddings<span class="sc">}</span><span class="ss">.'</span>)</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>    <span class="cf">return</span> model, tokenizer</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># To play around with other models, find a list of models and their model_ids at: https://huggingface.co/models</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>model, tokenizer <span class="op">=</span> load_model(<span class="st">'bert-base-uncased'</span>)</span></code></pre>
</div>
<p>Let’s see what the model’s architecture looks like. How many layers
does it have?</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="bu">print</span>(model)</span></code></pre>
</div>
<p>Let’s see if your answer matches the actual number of layers in the
model.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>num_layers <span class="op">=</span> model.config.num_hidden_layers</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'The model has </span><span class="sc">{</span>num_layers<span class="sc">}</span><span class="ss"> layers.'</span>)</span></code></pre>
</div>
</div>
<div class="section level5">
<h5 id="setting-up-the-probe">Setting up the Probe<a class="anchor" aria-label="anchor" href="#setting-up-the-probe"></a>
</h5>
<p>Before we define the probing classifier or probe, let’s set up some
utility functions the probe will use. The probe will be trained from
hidden representations from a specific layer of the BERT model. The
<code>get_embeddings_from_model</code> function will retrieve the
intermediate layer representations (also known as embeddings) from a
user defined layer number.</p>
<p>The <code>visualize_embeddings</code> method can be used to see what
these high dimensional hidden embeddings would look like when converted
into a 2D view. The visualization is not intended to be informative in
itself, and is only an additional tool used to get a sense of what the
inputs to the probing classifier may look like.</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="kw">def</span> get_embeddings_from_model(model: AutoModel, tokenizer: AutoTokenizer, layer_num: <span class="bu">int</span>, data: <span class="bu">list</span>[<span class="bu">str</span>]) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a><span class="co">    Get the embeddings from a model.</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="co">    :param model: The model to use. This is needed to get the embeddings.</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="co">    :param tokenizer: The tokenizer to use. This is needed to convert the data to input IDs.</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="co">    :param layer_num: The layer to get embeddings from. 0 is the input embeddings, and the last layer is the output embeddings.</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="co">    :param data: The data to get embeddings for. A list of strings.</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="co">    :return: The embeddings. Shape is N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a>    logging.info(<span class="ss">f'Getting embeddings from layer </span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss"> for </span><span class="sc">{</span><span class="bu">len</span>(data)<span class="sc">}</span><span class="ss"> samples...'</span>)</span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>    <span class="co"># Batch the data for computational efficiency</span></span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a>    batch_size <span class="op">=</span> <span class="dv">32</span></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a>    batch_num <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(data), batch_size):</span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a>        batch <span class="op">=</span> data[i:i<span class="op">+</span>batch_size]</span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a>        logging.info(<span class="ss">f'Getting embeddings for batch </span><span class="sc">{</span>batch_num<span class="sc">}</span><span class="ss">...'</span>)</span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a>        batch_num <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a>        <span class="co"># Tokenize the batch of data</span></span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a>        inputs <span class="op">=</span> tokenizer(batch, return_tensors<span class="op">=</span><span class="st">'pt'</span>, padding<span class="op">=</span><span class="va">True</span>, truncation<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a>        <span class="co"># Get the embeddings from the model</span></span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a>        outputs <span class="op">=</span> model(<span class="op">**</span>inputs, output_hidden_states<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a></span>
<span id="cb10-26"><a href="#cb10-26" tabindex="-1"></a>        <span class="co"># Get the embeddings for the specific the layer</span></span>
<span id="cb10-27"><a href="#cb10-27" tabindex="-1"></a>        embeddings <span class="op">=</span> outputs.hidden_states[layer_num]</span>
<span id="cb10-28"><a href="#cb10-28" tabindex="-1"></a></span>
<span id="cb10-29"><a href="#cb10-29" tabindex="-1"></a>        <span class="co"># Concatenate the embeddings from each batch</span></span>
<span id="cb10-30"><a href="#cb10-30" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb10-31"><a href="#cb10-31" tabindex="-1"></a>            all_embeddings <span class="op">=</span> embeddings</span>
<span id="cb10-32"><a href="#cb10-32" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb10-33"><a href="#cb10-33" tabindex="-1"></a>            all_embeddings <span class="op">=</span> torch.cat([all_embeddings, embeddings], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb10-34"><a href="#cb10-34" tabindex="-1"></a></span>
<span id="cb10-35"><a href="#cb10-35" tabindex="-1"></a>    logging.info(<span class="ss">f'Got embeddings for </span><span class="sc">{</span><span class="bu">len</span>(data)<span class="sc">}</span><span class="ss"> samples from layer </span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss">. Shape: </span><span class="sc">{</span>all_embeddings<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb10-36"><a href="#cb10-36" tabindex="-1"></a>    <span class="cf">return</span> all_embeddings</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="kw">def</span> visualize_embeddings(embeddings: torch.Tensor, labels: <span class="bu">list</span>, layer_num: <span class="bu">int</span>, save_plot: <span class="bu">bool</span> <span class="op">=</span> <span class="va">False</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="co">    Visualize the embeddings using t-SNE.</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="co">    :param embeddings: The embeddings to visualize. Shape is N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a><span class="co">    :param labels: The labels for the embeddings. A list of integers.</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="co">    :return: None</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>    <span class="co"># Since we are working with sentiment analysis, which is sentence based task, we can use sentence embeddings.</span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>    <span class="co"># The sentence embeddings are simply the mean of the token embeddings of that sentence.</span></span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>    sentence_embeddings <span class="op">=</span> torch.mean(embeddings, dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># N, D</span></span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a>    <span class="co"># Convert to numpy</span></span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a>    sentence_embeddings <span class="op">=</span> sentence_embeddings.detach().numpy()</span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a>    labels <span class="op">=</span> np.array(labels)</span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a>    <span class="co"># Visualize the embeddings using t-SNE</span></span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a>    tsne <span class="op">=</span> TSNE(n_components<span class="op">=</span><span class="dv">2</span>, random_state<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb11-19"><a href="#cb11-19" tabindex="-1"></a>    embeddings_2d <span class="op">=</span> tsne.fit_transform(sentence_embeddings)</span>
<span id="cb11-20"><a href="#cb11-20" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" tabindex="-1"></a>    negative_points <span class="op">=</span> embeddings_2d[labels <span class="op">==</span> <span class="dv">0</span>]</span>
<span id="cb11-22"><a href="#cb11-22" tabindex="-1"></a>    positive_points <span class="op">=</span> embeddings_2d[labels <span class="op">==</span> <span class="dv">1</span>]</span>
<span id="cb11-23"><a href="#cb11-23" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" tabindex="-1"></a>    <span class="co"># Plot the embeddings. We want to colour the datapoints by label.</span></span>
<span id="cb11-25"><a href="#cb11-25" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb11-26"><a href="#cb11-26" tabindex="-1"></a>    ax.scatter(negative_points[:, <span class="dv">0</span>], negative_points[:, <span class="dv">1</span>], label<span class="op">=</span><span class="st">'Negative'</span>, color<span class="op">=</span><span class="st">'red'</span>, marker<span class="op">=</span><span class="st">'o'</span>, s<span class="op">=</span><span class="dv">10</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb11-27"><a href="#cb11-27" tabindex="-1"></a>    ax.scatter(positive_points[:, <span class="dv">0</span>], positive_points[:, <span class="dv">1</span>], label<span class="op">=</span><span class="st">'Positive'</span>, color<span class="op">=</span><span class="st">'blue'</span>, marker<span class="op">=</span><span class="st">'o'</span>, s<span class="op">=</span><span class="dv">10</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb11-28"><a href="#cb11-28" tabindex="-1"></a>    plt.xlabel(<span class="st">'t-SNE dimension 1'</span>)</span>
<span id="cb11-29"><a href="#cb11-29" tabindex="-1"></a>    plt.ylabel(<span class="st">'t-SNE dimension 2'</span>)</span>
<span id="cb11-30"><a href="#cb11-30" tabindex="-1"></a>    plt.title(<span class="ss">f't-SNE of Sentence Embeddings - Layer</span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb11-31"><a href="#cb11-31" tabindex="-1"></a>    plt.legend()</span>
<span id="cb11-32"><a href="#cb11-32" tabindex="-1"></a></span>
<span id="cb11-33"><a href="#cb11-33" tabindex="-1"></a>    <span class="co"># Save the plot if needed, then display it</span></span>
<span id="cb11-34"><a href="#cb11-34" tabindex="-1"></a>    <span class="cf">if</span> save_plot:</span>
<span id="cb11-35"><a href="#cb11-35" tabindex="-1"></a>        plt.savefig(<span class="ss">f'tsne_layer_</span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss">.png'</span>)</span>
<span id="cb11-36"><a href="#cb11-36" tabindex="-1"></a>    plt.show()</span>
<span id="cb11-37"><a href="#cb11-37" tabindex="-1"></a></span>
<span id="cb11-38"><a href="#cb11-38" tabindex="-1"></a>    logging.info(<span class="st">'Visualized embeddings using t-SNE.'</span>)</span></code></pre>
</div>
<p>Now, it’s finally time to define our probe! We set this up as a
class, where the probe itself is an object of this class. The class also
contains methods used to train and evaluate the probe.</p>
<p>Read through this code block in a bit more detail - from this whole
exercise, this part provides you with the most useful takeaways on ways
to define and train neural networks!</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="kw">class</span> Probe():</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, hidden_dim: <span class="bu">int</span> <span class="op">=</span> <span class="dv">768</span>, class_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">2</span>)  <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="co">        Initialize the probe.</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a><span class="co">        :param hidden_dim: The dimensionality of the hidden layer of the probe.</span></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a><span class="co">        :param num_layers: The number of layers in the probe.</span></span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a><span class="co">        :return: None</span></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>        <span class="co"># The probe is a simple linear classifier, with a hidden layer and an output layer.</span></span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a>        <span class="co"># The input to the probe is the embeddings from the model, and the output is the predicted class.</span></span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a>        <span class="co"># Exercise: Try playing around with the hidden_dim and num_layers to see how it affects the probe's performance.</span></span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a>        <span class="co"># But watch out: if a complex probe performs well on the task, we don't know if the performance</span></span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a>        <span class="co"># is because of the model embeddings, or the probe itself learning the task!</span></span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a>        <span class="va">self</span>.probe <span class="op">=</span> torch.nn.Sequential(</span>
<span id="cb12-18"><a href="#cb12-18" tabindex="-1"></a>            torch.nn.Linear(hidden_dim, hidden_dim),</span>
<span id="cb12-19"><a href="#cb12-19" tabindex="-1"></a>            torch.nn.ReLU(),</span>
<span id="cb12-20"><a href="#cb12-20" tabindex="-1"></a>            torch.nn.Linear(hidden_dim, class_size),</span>
<span id="cb12-21"><a href="#cb12-21" tabindex="-1"></a></span>
<span id="cb12-22"><a href="#cb12-22" tabindex="-1"></a>            <span class="co"># Add more layers here if needed</span></span>
<span id="cb12-23"><a href="#cb12-23" tabindex="-1"></a></span>
<span id="cb12-24"><a href="#cb12-24" tabindex="-1"></a>            <span class="co"># Sigmoid is used to convert the hidden states into a probability distribution over the classes</span></span>
<span id="cb12-25"><a href="#cb12-25" tabindex="-1"></a>            torch.nn.Sigmoid()</span>
<span id="cb12-26"><a href="#cb12-26" tabindex="-1"></a>        )</span>
<span id="cb12-27"><a href="#cb12-27" tabindex="-1"></a></span>
<span id="cb12-28"><a href="#cb12-28" tabindex="-1"></a></span>
<span id="cb12-29"><a href="#cb12-29" tabindex="-1"></a>    <span class="kw">def</span> train(<span class="va">self</span>, data_embeddings: torch.Tensor, labels: torch.Tensor, num_epochs: <span class="bu">int</span> <span class="op">=</span> <span class="dv">10</span>,</span>
<span id="cb12-30"><a href="#cb12-30" tabindex="-1"></a>              learning_rate: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.001</span>, batch_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">32</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb12-31"><a href="#cb12-31" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb12-32"><a href="#cb12-32" tabindex="-1"></a><span class="co">        Train the probe on the embeddings of data from the model.</span></span>
<span id="cb12-33"><a href="#cb12-33" tabindex="-1"></a><span class="co">        :param data_embeddings: A tensor of shape N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb12-34"><a href="#cb12-34" tabindex="-1"></a><span class="co">        :param labels: A tensor of shape N, where N is the number of samples. Each element is the label for the corresponding sample.</span></span>
<span id="cb12-35"><a href="#cb12-35" tabindex="-1"></a><span class="co">        :param num_epochs: The number of epochs to train the probe for. An epoch is one pass through the entire dataset.</span></span>
<span id="cb12-36"><a href="#cb12-36" tabindex="-1"></a><span class="co">        :param learning_rate: How fast the probe learns. A hyperparameter.</span></span>
<span id="cb12-37"><a href="#cb12-37" tabindex="-1"></a><span class="co">        :param batch_size: Used to batch the data for computational efficiency. A hyperparameter.</span></span>
<span id="cb12-38"><a href="#cb12-38" tabindex="-1"></a><span class="co">        :return:</span></span>
<span id="cb12-39"><a href="#cb12-39" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb12-40"><a href="#cb12-40" tabindex="-1"></a></span>
<span id="cb12-41"><a href="#cb12-41" tabindex="-1"></a>        <span class="co"># Setup the loss function (training objective) for the training process.</span></span>
<span id="cb12-42"><a href="#cb12-42" tabindex="-1"></a>        <span class="co"># The cross-entropy loss is used for multi-class classification, and represents the negative log likelihood of the true class.</span></span>
<span id="cb12-43"><a href="#cb12-43" tabindex="-1"></a>        criterion <span class="op">=</span> torch.nn.CrossEntropyLoss()</span>
<span id="cb12-44"><a href="#cb12-44" tabindex="-1"></a></span>
<span id="cb12-45"><a href="#cb12-45" tabindex="-1"></a>        <span class="co"># Setup the optimization algorithm to update the probe's parameters during training.</span></span>
<span id="cb12-46"><a href="#cb12-46" tabindex="-1"></a>        <span class="co"># The Adam optimizer is an extension to stochastic gradient descent, and is a popular choice.</span></span>
<span id="cb12-47"><a href="#cb12-47" tabindex="-1"></a>        optimizer <span class="op">=</span> torch.optim.Adam(<span class="va">self</span>.probe.parameters(), lr<span class="op">=</span>learning_rate)</span>
<span id="cb12-48"><a href="#cb12-48" tabindex="-1"></a></span>
<span id="cb12-49"><a href="#cb12-49" tabindex="-1"></a>        <span class="co"># Train the probe</span></span>
<span id="cb12-50"><a href="#cb12-50" tabindex="-1"></a>        logging.info(<span class="st">'Training the probe...'</span>)</span>
<span id="cb12-51"><a href="#cb12-51" tabindex="-1"></a>        <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(num_epochs):  <span class="co"># Pass over the data num_epochs times</span></span>
<span id="cb12-52"><a href="#cb12-52" tabindex="-1"></a></span>
<span id="cb12-53"><a href="#cb12-53" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(data_embeddings), batch_size):</span>
<span id="cb12-54"><a href="#cb12-54" tabindex="-1"></a></span>
<span id="cb12-55"><a href="#cb12-55" tabindex="-1"></a>                <span class="co"># Iterate through one batch of data at a time</span></span>
<span id="cb12-56"><a href="#cb12-56" tabindex="-1"></a>                batch_embeddings <span class="op">=</span> data_embeddings[i:i<span class="op">+</span>batch_size].detach()</span>
<span id="cb12-57"><a href="#cb12-57" tabindex="-1"></a>                batch_labels <span class="op">=</span> labels[i:i<span class="op">+</span>batch_size]</span>
<span id="cb12-58"><a href="#cb12-58" tabindex="-1"></a></span>
<span id="cb12-59"><a href="#cb12-59" tabindex="-1"></a>                <span class="co"># Convert to sentence embeddings, since we are performing a sentence classification task</span></span>
<span id="cb12-60"><a href="#cb12-60" tabindex="-1"></a>                batch_embeddings <span class="op">=</span> torch.mean(batch_embeddings, dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># N, D</span></span>
<span id="cb12-61"><a href="#cb12-61" tabindex="-1"></a></span>
<span id="cb12-62"><a href="#cb12-62" tabindex="-1"></a>                <span class="co"># Get the probe's predictions, given the embeddings from the model</span></span>
<span id="cb12-63"><a href="#cb12-63" tabindex="-1"></a>                outputs <span class="op">=</span> <span class="va">self</span>.probe(batch_embeddings)</span>
<span id="cb12-64"><a href="#cb12-64" tabindex="-1"></a></span>
<span id="cb12-65"><a href="#cb12-65" tabindex="-1"></a>                <span class="co"># Calculate the loss of the predictions, against the true labels</span></span>
<span id="cb12-66"><a href="#cb12-66" tabindex="-1"></a>                loss <span class="op">=</span> criterion(outputs, batch_labels)</span>
<span id="cb12-67"><a href="#cb12-67" tabindex="-1"></a></span>
<span id="cb12-68"><a href="#cb12-68" tabindex="-1"></a>                <span class="co"># Backward pass - update the probe's parameters</span></span>
<span id="cb12-69"><a href="#cb12-69" tabindex="-1"></a>                optimizer.zero_grad()</span>
<span id="cb12-70"><a href="#cb12-70" tabindex="-1"></a>                loss.backward()</span>
<span id="cb12-71"><a href="#cb12-71" tabindex="-1"></a>                optimizer.step()</span>
<span id="cb12-72"><a href="#cb12-72" tabindex="-1"></a></span>
<span id="cb12-73"><a href="#cb12-73" tabindex="-1"></a>        logging.info(<span class="st">'Trained the probe.'</span>)</span>
<span id="cb12-74"><a href="#cb12-74" tabindex="-1"></a></span>
<span id="cb12-75"><a href="#cb12-75" tabindex="-1"></a></span>
<span id="cb12-76"><a href="#cb12-76" tabindex="-1"></a>    <span class="kw">def</span> predict(<span class="va">self</span>, data_embeddings: torch.Tensor, batch_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">32</span>) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb12-77"><a href="#cb12-77" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb12-78"><a href="#cb12-78" tabindex="-1"></a><span class="co">        Get the probe's predictions on the embeddings from the model, for unseen data.</span></span>
<span id="cb12-79"><a href="#cb12-79" tabindex="-1"></a><span class="co">        :param data_embeddings: A tensor of shape N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb12-80"><a href="#cb12-80" tabindex="-1"></a><span class="co">        :param batch_size: Used to batch the data for computational efficiency.</span></span>
<span id="cb12-81"><a href="#cb12-81" tabindex="-1"></a><span class="co">        :return: A tensor of shape N, where N is the number of samples. Each element is the predicted class for the corresponding sample.</span></span>
<span id="cb12-82"><a href="#cb12-82" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb12-83"><a href="#cb12-83" tabindex="-1"></a></span>
<span id="cb12-84"><a href="#cb12-84" tabindex="-1"></a>        <span class="co"># Iterate through batches</span></span>
<span id="cb12-85"><a href="#cb12-85" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(data_embeddings), batch_size):</span>
<span id="cb12-86"><a href="#cb12-86" tabindex="-1"></a></span>
<span id="cb12-87"><a href="#cb12-87" tabindex="-1"></a>            <span class="co"># Iterate through one batch of data at a time</span></span>
<span id="cb12-88"><a href="#cb12-88" tabindex="-1"></a>            batch_embeddings <span class="op">=</span> data_embeddings[i:i<span class="op">+</span>batch_size]</span>
<span id="cb12-89"><a href="#cb12-89" tabindex="-1"></a></span>
<span id="cb12-90"><a href="#cb12-90" tabindex="-1"></a>            <span class="co"># Get the probe's predictions</span></span>
<span id="cb12-91"><a href="#cb12-91" tabindex="-1"></a>            outputs <span class="op">=</span> <span class="va">self</span>.probe(batch_embeddings)</span>
<span id="cb12-92"><a href="#cb12-92" tabindex="-1"></a></span>
<span id="cb12-93"><a href="#cb12-93" tabindex="-1"></a>            <span class="co"># Get the predicted class for each sample</span></span>
<span id="cb12-94"><a href="#cb12-94" tabindex="-1"></a>            _, predicted <span class="op">=</span> torch.<span class="bu">max</span>(outputs, <span class="dv">1</span>)</span>
<span id="cb12-95"><a href="#cb12-95" tabindex="-1"></a></span>
<span id="cb12-96"><a href="#cb12-96" tabindex="-1"></a>            <span class="co"># Concatenate the predictions from each batch</span></span>
<span id="cb12-97"><a href="#cb12-97" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb12-98"><a href="#cb12-98" tabindex="-1"></a>                all_predicted <span class="op">=</span> predicted</span>
<span id="cb12-99"><a href="#cb12-99" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb12-100"><a href="#cb12-100" tabindex="-1"></a>                all_predicted <span class="op">=</span> torch.cat([all_predicted, predicted], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-101"><a href="#cb12-101" tabindex="-1"></a></span>
<span id="cb12-102"><a href="#cb12-102" tabindex="-1"></a>        <span class="cf">return</span> all_predicted</span>
<span id="cb12-103"><a href="#cb12-103" tabindex="-1"></a></span>
<span id="cb12-104"><a href="#cb12-104" tabindex="-1"></a></span>
<span id="cb12-105"><a href="#cb12-105" tabindex="-1"></a>    <span class="kw">def</span> evaluate(<span class="va">self</span>, data_embeddings: torch.tensor, labels: torch.tensor, batch_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">32</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb12-106"><a href="#cb12-106" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb12-107"><a href="#cb12-107" tabindex="-1"></a><span class="co">        Evaluate the probe's performance by testing it on unseen data.</span></span>
<span id="cb12-108"><a href="#cb12-108" tabindex="-1"></a><span class="co">        :param data_embeddings: A tensor of shape N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb12-109"><a href="#cb12-109" tabindex="-1"></a><span class="co">        :param labels: A tensor of shape N, where N is the number of samples. Each element is the label for the corresponding sample.</span></span>
<span id="cb12-110"><a href="#cb12-110" tabindex="-1"></a><span class="co">        :return: The accuracy of the probe on the unseen data.</span></span>
<span id="cb12-111"><a href="#cb12-111" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb12-112"><a href="#cb12-112" tabindex="-1"></a></span>
<span id="cb12-113"><a href="#cb12-113" tabindex="-1"></a>        <span class="co"># Iterate through batches</span></span>
<span id="cb12-114"><a href="#cb12-114" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(data_embeddings), batch_size):</span>
<span id="cb12-115"><a href="#cb12-115" tabindex="-1"></a></span>
<span id="cb12-116"><a href="#cb12-116" tabindex="-1"></a>            <span class="co"># Iterate through one batch of data at a time</span></span>
<span id="cb12-117"><a href="#cb12-117" tabindex="-1"></a>            batch_embeddings <span class="op">=</span> data_embeddings[i:i<span class="op">+</span>batch_size]</span>
<span id="cb12-118"><a href="#cb12-118" tabindex="-1"></a>            batch_labels <span class="op">=</span> labels[i:i<span class="op">+</span>batch_size]</span>
<span id="cb12-119"><a href="#cb12-119" tabindex="-1"></a></span>
<span id="cb12-120"><a href="#cb12-120" tabindex="-1"></a>            <span class="co"># Convert to sentence embeddings, since we are performing a sentence classification task</span></span>
<span id="cb12-121"><a href="#cb12-121" tabindex="-1"></a>            batch_embeddings <span class="op">=</span> torch.mean(batch_embeddings, dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># N, D</span></span>
<span id="cb12-122"><a href="#cb12-122" tabindex="-1"></a></span>
<span id="cb12-123"><a href="#cb12-123" tabindex="-1"></a>            <span class="co"># Get the probe's predictions</span></span>
<span id="cb12-124"><a href="#cb12-124" tabindex="-1"></a>            <span class="cf">with</span> torch.no_grad():</span>
<span id="cb12-125"><a href="#cb12-125" tabindex="-1"></a>                outputs <span class="op">=</span> <span class="va">self</span>.probe(batch_embeddings)</span>
<span id="cb12-126"><a href="#cb12-126" tabindex="-1"></a></span>
<span id="cb12-127"><a href="#cb12-127" tabindex="-1"></a>            <span class="co"># Get the predicted class for each sample</span></span>
<span id="cb12-128"><a href="#cb12-128" tabindex="-1"></a>            _, predicted <span class="op">=</span> torch.<span class="bu">max</span>(outputs, dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb12-129"><a href="#cb12-129" tabindex="-1"></a></span>
<span id="cb12-130"><a href="#cb12-130" tabindex="-1"></a>            <span class="co"># Concatenate the predictions from each batch</span></span>
<span id="cb12-131"><a href="#cb12-131" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb12-132"><a href="#cb12-132" tabindex="-1"></a>                all_predicted <span class="op">=</span> predicted</span>
<span id="cb12-133"><a href="#cb12-133" tabindex="-1"></a>                all_labels <span class="op">=</span> batch_labels</span>
<span id="cb12-134"><a href="#cb12-134" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb12-135"><a href="#cb12-135" tabindex="-1"></a>                all_predicted <span class="op">=</span> torch.cat([all_predicted, predicted], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-136"><a href="#cb12-136" tabindex="-1"></a>                all_labels <span class="op">=</span> torch.cat([all_labels, batch_labels], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-137"><a href="#cb12-137" tabindex="-1"></a></span>
<span id="cb12-138"><a href="#cb12-138" tabindex="-1"></a>        <span class="co"># Calculate the accuracy of the probe</span></span>
<span id="cb12-139"><a href="#cb12-139" tabindex="-1"></a>        correct <span class="op">=</span> (all_predicted <span class="op">==</span> all_labels).<span class="bu">sum</span>().item()</span>
<span id="cb12-140"><a href="#cb12-140" tabindex="-1"></a>        accuracy <span class="op">=</span> correct <span class="op">/</span> all_labels.shape[<span class="dv">0</span>]</span>
<span id="cb12-141"><a href="#cb12-141" tabindex="-1"></a>        logging.info(<span class="ss">f'Probe accuracy: </span><span class="sc">{</span>accuracy<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb12-142"><a href="#cb12-142" tabindex="-1"></a></span>
<span id="cb12-143"><a href="#cb12-143" tabindex="-1"></a>        <span class="cf">return</span> accuracy</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="co"># Initialize the probing classifier (or probe)</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>probe <span class="op">=</span> Probe()</span></code></pre>
</div>
</div>
<div class="section level5">
<h5 id="analysing-the-model-using-probes">Analysing the model using Probes<a class="anchor" aria-label="anchor" href="#analysing-the-model-using-probes"></a>
</h5>
<p>Time to start evaluating the model using our probing tool! Let’s see
which layer has most information about sentiment analysis on IMDB. For
this, we will train the probe on embeddings from each layer of the
model, and see which layer performs the best on the dev set.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>layer_wise_accuracies <span class="op">=</span> []</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>best_probe, best_layer, best_accuracy <span class="op">=</span> <span class="va">None</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="cf">for</span> layer_num <span class="kw">in</span> <span class="bu">range</span>(num_layers):</span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>    logging.info(<span class="ss">f'</span><span class="ch">\n\n</span><span class="ss">Evaluating representations of layer </span><span class="sc">{</span>layer_num<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">...'</span>)</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>    train_embeddings <span class="op">=</span> get_embeddings_from_model(model, tokenizer, layer_num<span class="op">=</span>layer_num, data<span class="op">=</span>train_dataset[<span class="st">'text'</span>])</span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a>    dev_embeddings <span class="op">=</span> get_embeddings_from_model(model, tokenizer, layer_num<span class="op">=</span>layer_num, data<span class="op">=</span>dev_dataset[<span class="st">'text'</span>])</span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>    train_labels, dev_labels <span class="op">=</span> torch.tensor(train_dataset[<span class="st">'label'</span>],  dtype<span class="op">=</span>torch.<span class="bu">long</span>), torch.tensor(dev_dataset[<span class="st">'label'</span>],  dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a>    <span class="co"># Before training the probe, let's visualize the embeddings using t-SNE.</span></span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a>    <span class="co"># If the layer has information about sentiment analysis, would we see some structure in the embeddings?</span></span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a>    <span class="co"># Compare plots from layers where the probe does poorly, with ones where it does well. What do you notice?</span></span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a>    visualize_embeddings(embeddings<span class="op">=</span>train_embeddings, labels<span class="op">=</span>train_dataset[<span class="st">'label'</span>], layer_num<span class="op">=</span>layer_num, save_plot<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb14-15"><a href="#cb14-15" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" tabindex="-1"></a>    <span class="co"># Now, let's train the probe on the embeddings from the model.</span></span>
<span id="cb14-17"><a href="#cb14-17" tabindex="-1"></a>    <span class="co"># Feel free to play around with the training hyperparameters, and see what works best for your probe.</span></span>
<span id="cb14-18"><a href="#cb14-18" tabindex="-1"></a>    probe <span class="op">=</span> Probe()</span>
<span id="cb14-19"><a href="#cb14-19" tabindex="-1"></a>    probe.train(data_embeddings<span class="op">=</span>train_embeddings, labels<span class="op">=</span>train_labels,</span>
<span id="cb14-20"><a href="#cb14-20" tabindex="-1"></a>                num_epochs<span class="op">=</span><span class="dv">5</span>, learning_rate<span class="op">=</span><span class="fl">0.001</span>, batch_size<span class="op">=</span><span class="dv">32</span>)</span>
<span id="cb14-21"><a href="#cb14-21" tabindex="-1"></a></span>
<span id="cb14-22"><a href="#cb14-22" tabindex="-1"></a>    <span class="co"># Let's see how well our probe does on a held out dev set</span></span>
<span id="cb14-23"><a href="#cb14-23" tabindex="-1"></a>    accuracy <span class="op">=</span> probe.evaluate(data_embeddings<span class="op">=</span>dev_embeddings, labels<span class="op">=</span>dev_labels)</span>
<span id="cb14-24"><a href="#cb14-24" tabindex="-1"></a>    layer_wise_accuracies.append(accuracy)</span>
<span id="cb14-25"><a href="#cb14-25" tabindex="-1"></a></span>
<span id="cb14-26"><a href="#cb14-26" tabindex="-1"></a>    <span class="co"># Keep track of the best probe</span></span>
<span id="cb14-27"><a href="#cb14-27" tabindex="-1"></a>    <span class="cf">if</span> accuracy <span class="op">&gt;</span> best_accuracy:</span>
<span id="cb14-28"><a href="#cb14-28" tabindex="-1"></a>        best_probe, best_layer, best_accuracy <span class="op">=</span> probe, layer_num, accuracy</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="co"># Seeing a list of accuracies can be hard to interpret. Let's plot the layer-wise accuracies to see which layer is best.</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>plt.plot(layer_wise_accuracies)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>plt.xlabel(<span class="st">'Layer'</span>)</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>plt.ylabel(<span class="st">'Accuracy'</span>)</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>plt.title(<span class="st">'Probe Accuracy by Layer'</span>)</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>plt.grid(alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p>Which layer has the best accuracy? What does this tell us about the
model?</p>
<p>Let’s go ahead and stress test this. Is the best layer able to
predict sentiment for sentences outside the IMDB dataset?</p>
<p>For answering this question, you are the test set! Try to think of
challenging sequences for which the model may not be able to predict
sentiment.</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>test_sequences <span class="op">=</span> [<span class="st">'Your sentence here'</span>, <span class="st">'Here is another sentence'</span>]</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>embeddings <span class="op">=</span> get_embeddings_from_model(model<span class="op">=</span>model, tokenizer<span class="op">=</span>tokenizer, layer_num<span class="op">=</span>best_layer, data<span class="op">=</span>test_sequences)</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>preds <span class="op">=</span> probe.predict(data_embeddings<span class="op">=</span>embeddings)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>predictions <span class="op">=</span> [<span class="st">'Positive'</span> <span class="cf">if</span> pred <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="st">'Negative'</span> <span class="cf">for</span> pred <span class="kw">in</span> preds]</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Predictions for test sequences: </span><span class="sc">{</span>predictions<span class="sc">}</span><span class="ss">'</span>)</span></code></pre>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div></section><section id="aio-5d-gradcam"><p>Content from <a href="5d-gradcam.html">Explainability methods: GradCAM</a></p>
<hr>
<p>Last updated on 2024-07-03 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/5d-gradcam.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># Let's begin by installing the grad-cam package - this will significantly simplify our implementation</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="op">!</span>pip install grad<span class="op">-</span>cam</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Packages to download test images</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="im">import</span> requests</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="co"># Packages to view and process images</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="im">import</span> cv2</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="im">from</span> google.colab.patches <span class="im">import</span> cv2_imshow</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a><span class="co"># Packages to load the model</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a><span class="im">from</span> torchvision.models <span class="im">import</span> resnet50</span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a><span class="co"># GradCAM Packaes</span></span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a><span class="im">from</span> pytorch_grad_cam <span class="im">import</span> GradCAM</span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a><span class="im">from</span> pytorch_grad_cam.utils.model_targets <span class="im">import</span> ClassifierOutputTarget</span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a><span class="im">from</span> pytorch_grad_cam.utils.image <span class="im">import</span> show_cam_on_image, preprocess_image</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>device <span class="op">=</span> <span class="st">'gpu'</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">'cpu'</span></span></code></pre>
</div>
<div class="section level5">
<h5 id="load-model">Load Model<a class="anchor" aria-label="anchor" href="#load-model"></a>
</h5>
<p>We’ll load the ResNet-50 model from torchvision. This model is
pre-trained on the ImageNet dataset, which contains 1.2 million images
across 1000 classes. ResNet-50 is popular model that is a type of
convolutional neural network. You can learn more about it here: <a href="https://pytorch.org/hub/pytorch_vision_resnet/" class="external-link uri">https://pytorch.org/hub/pytorch_vision_resnet/</a></p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>model <span class="op">=</span> resnet50(pretrained<span class="op">=</span><span class="va">True</span>).to(device).<span class="bu">eval</span>()</span></code></pre>
</div>
</div>
<div class="section level5">
<h5 id="load-test-image">Load Test Image<a class="anchor" aria-label="anchor" href="#load-test-image"></a>
</h5>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># Let's first take a look at the image, which we source from the GradCAM package</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/jacobgil/pytorch-grad-cam/master/examples/both.png"</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>Image.<span class="bu">open</span>(requests.get(url, stream<span class="op">=</span><span class="va">True</span>).raw)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># Cute, isn't it? Do you prefer dogs or cats?</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co"># We will need to convert the image into a tensor to feed it into the model.</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co"># Let's create a function to do this for us.</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="kw">def</span> load_image(url):</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>    rgb_img <span class="op">=</span> np.array(Image.<span class="bu">open</span>(requests.get(url, stream<span class="op">=</span><span class="va">True</span>).raw))</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>    rgb_img <span class="op">=</span> np.float32(rgb_img) <span class="op">/</span> <span class="dv">255</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>    input_tensor <span class="op">=</span> preprocess_image(rgb_img).to(device)</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>    <span class="cf">return</span> input_tensor, rgb_img</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>input_tensor, rgb_image <span class="op">=</span> load_image(url)</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="grad-cam-time">Grad-CAM Time!<a class="anchor" aria-label="anchor" href="#grad-cam-time"></a>
</h3>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co"># Let's start by selecting which layers of the model we want to use to generate the CAM.</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="co"># For that, we will need to inspect the model architecture.</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="co"># We can do that by simply printing the model object.</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="bu">print</span>(model)</span></code></pre>
</div>
<p>Here we want to interpret what the model as a whole is doing (not
what a specific layer is doing). That means that we want to use the
embeddings of the last layer before the final classification layer. This
is the layer that contains the information about the image encoded by
the model as a whole.</p>
<p>Looking at the model, we can see that the last layer before the final
classification layer is <code>layer4</code>.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>target_layers <span class="op">=</span> [model.layer4]</span></code></pre>
</div>
<p>We also want to pick a label for the CAM - this is the class we want
to visualize the activation for. Essentially, we want to see what the
model is looking at when it is predicting a certain class.</p>
<p>Since ResNet was trained on the ImageNet dataset with 1000 classes,
let’s get an indexed list of those classes. We can then pick the index
of the class we want to visualize.</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>imagenet_categories_url <span class="op">=</span> <span class="op">\</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>     <span class="st">"https://gist.githubusercontent.com/yrevar/942d3a0ac09ec9e5eb3a/raw/238f720ff059c1f82f368259d1ca4ffa5dd8f9f5/imagenet1000_clsidx_to_labels.txt"</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>labels <span class="op">=</span> <span class="bu">eval</span>(requests.get(imagenet_categories_url).text)</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>labels</span></code></pre>
</div>
<p>Well, that’s a lot! To simplify things, we have already picked out
the indices of a few interesting classes.</p>
<ul>
<li>157: Siberian Husky</li>
<li>162: Beagle</li>
<li>245: French Bulldog</li>
<li>281: Tabby Cat</li>
<li>285: Egyptian cat</li>
<li>360: Otter</li>
<li>537: Dog Sleigh</li>
<li>799: Sliding Door</li>
<li>918: Street Sign</li>
</ul>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="co"># Specify the target class for visualization here. If you set this to None, the class with the highest score from the model will automatically be used.</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>visualized_class_id <span class="op">=</span> <span class="dv">245</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="kw">def</span> viz_gradcam(model, target_layers, class_id):</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>  <span class="cf">if</span> class_id <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>    targets <span class="op">=</span> <span class="va">None</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>    targets <span class="op">=</span> [ClassifierOutputTarget(class_id)]</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>  cam_algorithm <span class="op">=</span> GradCAM</span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>  <span class="cf">with</span> cam_algorithm(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers) <span class="im">as</span> cam:</span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>      grayscale_cam <span class="op">=</span> cam(input_tensor<span class="op">=</span>input_tensor,</span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a>                          targets<span class="op">=</span>targets)</span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a>      grayscale_cam <span class="op">=</span> grayscale_cam[<span class="dv">0</span>, :]</span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a></span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a>      cam_image <span class="op">=</span> show_cam_on_image(rgb_image, grayscale_cam, use_rgb<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a>      cam_image <span class="op">=</span> cv2.cvtColor(cam_image, cv2.COLOR_RGB2BGR)</span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a></span>
<span id="cb12-18"><a href="#cb12-18" tabindex="-1"></a>  cv2_imshow(cam_image)</span></code></pre>
</div>
<p>Finally, we can start visualizing! Let’s begin by seeing what parts
of the image the model looks at to make its most confident
prediction.</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="va">None</span>)</span></code></pre>
</div>
<p>Interesting, it looks like the model totally ignores the cat and
makes a prediction based on the dog. If we set the output class to
“French Bulldog” (<code>class_id=245</code>), we see the same
visualization - meaning that the model is indeed looking at the correct
part of the image to make the correct prediction.</p>
<p>Let’s see what the heatmap looks like when we force the model to look
at the cat.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">281</span>)</span></code></pre>
</div>
<p>The model is indeed looking at the cat when asked to predict the
class “Tabby Cat” (<code>class_id=281</code>)! But why is it still
predicting the dog? Well, the model was trained on the ImageNet dataset,
which contains a lot of images of dogs and cats. The model has learned
that the dog is a better indicator of the class “Tabby Cat” than the cat
itself.</p>
<p>Let’s see another example of this. The image has not only a dog and a
cat, but also a items in the background. Can the model correctly
identify the door?</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">799</span>)</span></code></pre>
</div>
<p>It can! However, it seems to also think of the shelf behind the dog
as a door.</p>
<p>Let’s try an unrelated object now. Where in the image does the model
see a street sign?</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">918</span>)</span></code></pre>
</div>
<p>Looks like our analysis has revealed a shortcoming of the model! It
seems to percieve cats and street signs similarly.</p>
<p>Ideally, when the target class is some unrelated object, a good model
will look at no significant part of the image. For example, the model
does a good job with the class for Dog Sleigh.</p>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">537</span>)</span></code></pre>
</div>
<p>Explaining model predictions though visualization techniques like
this can be very subjective and prone to error. However, this still
provides some degree of insight a completely black box model would not
provide.</p>
<p>Spend some time playing around with different classes and seeing
which part of the image the model looks at. Feel free to play around
with other base images as well. Have fun! <!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 --></p>
</div></section><section id="aio-6-confidence-intervals"><p>Content from <a href="6-confidence-intervals.html">Estimating model uncertainty</a></p>
<hr>
<p>Last updated on 2024-06-19 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/6-confidence-intervals.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div></section><section id="aio-7a-OOD-detection-output-based"><p>Content from <a href="7a-OOD-detection-output-based.html">OOD detection: overview, output-based methods</a></p>
<hr>
<p>Last updated on 2024-08-14 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/7a-OOD-detection-output-based.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are out-of-distribution (OOD) data and why is detecting them
important in machine learning models?</li>
<li>How do output-based methods like softmax and energy-based methods
work for OOD detection?</li>
<li>What are the limitations of output-based OOD detection methods?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand the concept of out-of-distribution data and its
significance in building trustworthy machine learning models.</li>
<li>Learn about different output-based methods for OOD detection,
including softmax and energy-based methods</li>
<li>Identify the strengths and limitations of output-based OOD detection
techniques.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="introduction-to-out-of-distribution-ood-data">Introduction to Out-of-Distribution (OOD) Data<a class="anchor" aria-label="anchor" href="#introduction-to-out-of-distribution-ood-data"></a>
</h1>
<div class="section level2">
<h2 id="what-is-ood-data">What is OOD data?<a class="anchor" aria-label="anchor" href="#what-is-ood-data"></a>
</h2>
<p>Out-of-distribution (OOD) data refers to data that significantly
differs from the training data on which a machine learning model was
built. The difference can arise from either:</p>
<ul>
<li>Semantic shift: OOD sample is drawn from a class that was not
present during training</li>
<li>Covariate shift: OOD sample is drawn from a different domain; input
feature distribution is drastically different than training data</li>
</ul>
<p><strong>TODO</strong>: Add closed/open-world image similar to Sharon
Li’s tutorial at 4:28: <a href="https://www.youtube.com/watch?v=hgLC9_9ZCJI" class="external-link uri">https://www.youtube.com/watch?v=hgLC9_9ZCJI</a></p>
</div>
<div class="section level2">
<h2 id="why-does-ood-data-matter">Why does OOD data matter?<a class="anchor" aria-label="anchor" href="#why-does-ood-data-matter"></a>
</h2>
<p>Models trained on a specific distribution might make incorrect
predictions on OOD data, leading to unreliable outputs. In critical
applications (e.g., healthcare, autonomous driving), encountering OOD
data without proper handling can have severe consequences.</p>
<div class="section level3">
<h3 id="ex1-tesla-crashes-into-jet">Ex1: Tesla crashes into jet<a class="anchor" aria-label="anchor" href="#ex1-tesla-crashes-into-jet"></a>
</h3>
<p>In April 2022, a <a href="https://www.newsweek.com/video-tesla-smart-summon-mode-ramming-3m-jet-viewed-34m-times-1700310" class="external-link">Tesla
Model Y crashed into a $3.5 million private jet</a> at an aviation trade
show in Spokane, Washington, while operating on the “Smart Summon”
feature. The feature allows Tesla vehicles to autonomously navigate
parking lots to their owners, but in this case, it resulted in a
significant mishap. - The Tesla was summoned by its owner using the
Tesla app, which requires holding down a button to keep the car moving.
The car continued to move forward even after making contact with the
jet, pushing the expensive aircraft and causing notable damage. - The
crash highlighted several issues with Tesla’s Smart Summon feature,
particularly its object detection capabilities. The system failed to
recognize and appropriately react to the presence of the jet, a problem
that has been observed in other scenarios where the car’s sensors
struggle with objects that are lifted off the ground or have unusual
shapes.</p>
</div>
<div class="section level3">
<h3 id="ex2-ibm-watson-for-oncology">Ex2: IBM Watson for Oncology<a class="anchor" aria-label="anchor" href="#ex2-ibm-watson-for-oncology"></a>
</h3>
<p>IBM Watson for Oncology faced several issues due to OOD data. The
system was primarily trained on data from Memorial Sloan Kettering
Cancer Center (MSK), which did not generalize well to other healthcare
settings. This led to the following problems: 1. Unsafe Recommendations:
Watson for Oncology provided treatment recommendations that were not
safe or aligned with standard care guidelines in many cases outside of
MSK. This happened because the training data was not representative of
the diverse medical practices and patient populations in different
regions 2. Bias in Training Data: The system’s recommendations were
biased towards the practices at MSK, failing to account for different
treatment protocols and patient needs elsewhere. This bias is a classic
example of an OOD issue, where the model encounters data (patients and
treatments) during deployment that significantly differ from its
training data</p>
</div>
<div class="section level3">
<h3 id="ex3-doctors-using-gpt3">Ex3: Doctors using GPT3<a class="anchor" aria-label="anchor" href="#ex3-doctors-using-gpt3"></a>
</h3>
<div class="section level4">
<h4 id="misdiagnosis-and-inaccurate-medical-advice">Misdiagnosis and Inaccurate Medical Advice<a class="anchor" aria-label="anchor" href="#misdiagnosis-and-inaccurate-medical-advice"></a>
</h4>
<p>In various studies and real-world applications, GPT-3 has been shown
to generate inaccurate medical advice when faced with OOD data. This can
be attributed to the fact that the training data, while extensive, does
not cover all possible medical scenarios and nuances, leading to
hallucinations or incorrect responses when encountering unfamiliar
input.</p>
<p>A <a href="https://hai.stanford.edu/news/generating-medical-errors-genai-and-erroneous-medical-references" class="external-link">study
published by researchers at Stanford</a> found that GPT-3, even when
using retrieval-augmented generation, provided unsupported medical
advice in about 30% of its statements. For example, it suggested the use
of a specific dosage for a defibrillator based on monophasic technology,
while the cited source only discussed biphasic technology, which
operates differently.</p>
</div>
<div class="section level4">
<h4 id="fake-medical-literature-references">Fake Medical Literature References<a class="anchor" aria-label="anchor" href="#fake-medical-literature-references"></a>
</h4>
<p>Another critical OOD issue is the generation of fake or non-existent
medical references by LLMs. When LLMs are prompted to provide citations
for their responses, they sometimes generate references that sound
plausible but do not actually exist. This can be particularly
problematic in academic and medical contexts where accurate sourcing is
crucial.</p>
<p>In <a href="https://hai.stanford.edu/news/generating-medical-errors-genai-and-erroneous-medical-references" class="external-link">evaluations
of GPT-3’s ability to generate medical literature references</a> , it
was found that a significant portion of the references were either
entirely fabricated or did not support the claims being made. This was
especially true for complex medical inquiries that the model had not
seen in its training data.</p>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="detecting-and-handling-ood-data">Detecting and Handling OOD Data<a class="anchor" aria-label="anchor" href="#detecting-and-handling-ood-data"></a>
</h1>
<p>Given the problems posed by OOD data, a reliable model should
identify such instances, and then:</p>
<ol style="list-style-type: decimal">
<li>Reject them during inference</li>
<li>Ideally, hand these OOD instances to a model trained on a more
similar distribution (an in-distribution).</li>
</ol>
<p>The second step is much more complicated/involved since it requires
matching OOD data to essentially an infinite number of possible classes.
For the current scope of this workshop, we will focus on just the first
step.</p>
<p>How can we determine whether a given instance is OOD or ID? Over the
past several years, there have been a wide assortment of new methods
developed to tackle this task. In this episode, we will cover a few of
the most common approaches and discuss advantages/disadvantages of
each.</p>
<div class="section level2">
<h2 id="threshold-based-methods">Threshold-based methods<a class="anchor" aria-label="anchor" href="#threshold-based-methods"></a>
</h2>
<p>Threshold-based methods are one of the simplest and most intuitive
approaches for detecting out-of-distribution (OOD) data. The central
idea is to define a threshold on a certain score or confidence measure,
beyond which the data point is considered out-of-distribution.
Typically, these scores are derived from the model’s output
probabilities or other statistical measures of uncertainty. There are
two general classes of threshold-based methods: output-based and
distance-based.</p>
<div class="section level3">
<h3 id="output-based-thresholds">Output-based thresholds<a class="anchor" aria-label="anchor" href="#output-based-thresholds"></a>
</h3>
<p>Output-based Out-of-Distribution (OOD) detection refers to methods
that determine whether a given input is out-of-distribution based on the
output of a trained model. These methods typically analyze the model’s
confidence scores, energy scores, or other output metrics to identify
data points that are unlikely to belong to the distribution the model
was trained on. The main approaches within output-based OOD detection
include:</p>
<ul>
<li>
<strong>Softmax scores</strong>: The softmax output of a neural
network represents the predicted probabilities for each class. A common
threshold-based method involves setting a confidence threshold, and if
the maximum softmax score of an instance falls below this threshold, it
is flagged as OOD.</li>
<li>
<strong>Energy</strong>: The energy-based method also uses the
network’s output but measures the uncertainty in a more nuanced way by
calculating an energy score. The energy score typically captures the
confidence more robustly, especially in high-dimensional spaces, and can
be considered a more general and reliable approach than just using
softmax probabilities.</li>
</ul>
</div>
<div class="section level3">
<h3 id="distance-based-thresholds">Distance-based thresholds<a class="anchor" aria-label="anchor" href="#distance-based-thresholds"></a>
</h3>
<p>Distance-based methods calculate the distance of an instance from the
distribution of training data features learned by the model. If the
distance is beyond a certain threshold, the instance is considered OOD.
Common distance-based approaches include:</p>
<ul>
<li>
<strong>Mahalanobis distance:</strong> This method calculates the
Mahalanobis distance of a data point from the mean of the training data
distribution. A high Mahalanobis distance indicates that the instance is
likely OOD.</li>
<li>
<strong>K-nearest neighbors (KNN):</strong> This method involves
computing the distance to the k-nearest neighbors in the training data.
If the average distance to these neighbors is high, the instance is
considered OOD.</li>
</ul>
<p>We will focus on output-based methods (softmax and energy) in this
episode and then do a deep dive into distance-based methods in the next
episode.</p>
</div>
</div>
</div>
<div class="section level1">
<h1 id="example-1-softmax-scores">Example 1: Softmax scores<a class="anchor" aria-label="anchor" href="#example-1-softmax-scores"></a>
</h1>
<p>Softmax-based out-of-distribution (OOD) detection methods are a
fundamental aspect of understanding how models differentiate between
in-distribution and OOD data. Even though energy-based methods are
becoming more popular, grasping softmax OOD detection methods provides
essential scaffolding for learning more advanced techniques.
Furthermore, softmax thresholding is still in use throughout ML
literature, and learning more about this method will help you better
assess results from others.</p>
<p>In this first example, we will train a simple logistic regression
model to classify images as T-shirts or pants. We will then evaluate how
our model reacts to data outside of these two classes (“semantic
shift”).</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># some settings I'm playing around with when designing this lesson</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>verbose <span class="op">=</span> <span class="va">False</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>alpha<span class="op">=</span><span class="fl">0.2</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>max_iter <span class="op">=</span> <span class="dv">10</span> <span class="co"># increase after testing phase</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>n_epochs <span class="op">=</span> <span class="dv">10</span> <span class="co"># increase after testing phase</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="prepare-the-id-train-and-test-and-ood-data">Prepare the ID (train and test) and OOD data<a class="anchor" aria-label="anchor" href="#prepare-the-id-train-and-test-and-ood-data"></a>
</h3>
<ul>
<li>ID = T-shirts/Blouses, Pants</li>
<li>OOD = any other class. For Illustrative purposes, we’ll focus on
images of sandals as the OOD class.</li>
</ul>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> accuracy_score</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="im">from</span> keras.datasets <span class="im">import</span> fashion_mnist</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="kw">def</span> prep_ID_OOD_datasests(ID_class_labels, OOD_class_labels):</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>    <span class="co"># Load Fashion MNIST dataset</span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>    (train_images, train_labels), (test_images, test_labels) <span class="op">=</span> fashion_mnist.load_data()</span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>    </span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>    <span class="co"># Prepare OOD data: Sandals = 5</span></span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a>    ood_filter <span class="op">=</span> np.isin(test_labels, OOD_class_labels)</span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a>    ood_data <span class="op">=</span> test_images[ood_filter]</span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a>    ood_labels <span class="op">=</span> test_labels[ood_filter]</span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'ood_data.shape=</span><span class="sc">{</span>ood_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a>    </span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a>    <span class="co"># Filter data for T-shirts (0) and Trousers (1) as in-distribution</span></span>
<span id="cb2-18"><a href="#cb2-18" tabindex="-1"></a>    train_filter <span class="op">=</span> np.isin(train_labels, ID_class_labels)</span>
<span id="cb2-19"><a href="#cb2-19" tabindex="-1"></a>    test_filter <span class="op">=</span> np.isin(test_labels, ID_class_labels)</span>
<span id="cb2-20"><a href="#cb2-20" tabindex="-1"></a>    </span>
<span id="cb2-21"><a href="#cb2-21" tabindex="-1"></a>    train_data <span class="op">=</span> train_images[train_filter]</span>
<span id="cb2-22"><a href="#cb2-22" tabindex="-1"></a>    train_labels <span class="op">=</span> train_labels[train_filter]</span>
<span id="cb2-23"><a href="#cb2-23" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'train_data.shape=</span><span class="sc">{</span>train_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb2-24"><a href="#cb2-24" tabindex="-1"></a>    </span>
<span id="cb2-25"><a href="#cb2-25" tabindex="-1"></a>    test_data <span class="op">=</span> test_images[test_filter]</span>
<span id="cb2-26"><a href="#cb2-26" tabindex="-1"></a>    test_labels <span class="op">=</span> test_labels[test_filter]</span>
<span id="cb2-27"><a href="#cb2-27" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'test_data.shape=</span><span class="sc">{</span>test_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb2-28"><a href="#cb2-28" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" tabindex="-1"></a>    <span class="cf">return</span> ood_data, train_data, test_data</span>
<span id="cb2-30"><a href="#cb2-30" tabindex="-1"></a></span>
<span id="cb2-31"><a href="#cb2-31" tabindex="-1"></a></span>
<span id="cb2-32"><a href="#cb2-32" tabindex="-1"></a><span class="kw">def</span> plot_data_sample(train_data, ood_data):</span>
<span id="cb2-33"><a href="#cb2-33" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-34"><a href="#cb2-34" tabindex="-1"></a><span class="co">    Plots a sample of in-distribution and OOD data.</span></span>
<span id="cb2-35"><a href="#cb2-35" tabindex="-1"></a></span>
<span id="cb2-36"><a href="#cb2-36" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb2-37"><a href="#cb2-37" tabindex="-1"></a><span class="co">    - train_data: np.array, array of in-distribution data images</span></span>
<span id="cb2-38"><a href="#cb2-38" tabindex="-1"></a><span class="co">    - ood_data: np.array, array of out-of-distribution data images</span></span>
<span id="cb2-39"><a href="#cb2-39" tabindex="-1"></a></span>
<span id="cb2-40"><a href="#cb2-40" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb2-41"><a href="#cb2-41" tabindex="-1"></a><span class="co">    - fig: matplotlib.figure.Figure, the figure object containing the plots</span></span>
<span id="cb2-42"><a href="#cb2-42" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-43"><a href="#cb2-43" tabindex="-1"></a>    fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb2-44"><a href="#cb2-44" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb2-45"><a href="#cb2-45" tabindex="-1"></a>        plt.subplot(<span class="dv">2</span>, <span class="dv">5</span>, i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-46"><a href="#cb2-46" tabindex="-1"></a>        plt.imshow(train_data[i], cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb2-47"><a href="#cb2-47" tabindex="-1"></a>        plt.title(<span class="st">"In-Dist"</span>)</span>
<span id="cb2-48"><a href="#cb2-48" tabindex="-1"></a>        plt.axis(<span class="st">'off'</span>)</span>
<span id="cb2-49"><a href="#cb2-49" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb2-50"><a href="#cb2-50" tabindex="-1"></a>        plt.subplot(<span class="dv">2</span>, <span class="dv">5</span>, i <span class="op">+</span> <span class="dv">6</span>)</span>
<span id="cb2-51"><a href="#cb2-51" tabindex="-1"></a>        plt.imshow(ood_data[i], cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb2-52"><a href="#cb2-52" tabindex="-1"></a>        plt.title(<span class="st">"OOD"</span>)</span>
<span id="cb2-53"><a href="#cb2-53" tabindex="-1"></a>        plt.axis(<span class="st">'off'</span>)</span>
<span id="cb2-54"><a href="#cb2-54" tabindex="-1"></a>    </span>
<span id="cb2-55"><a href="#cb2-55" tabindex="-1"></a>    <span class="cf">return</span> fig</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>ood_data, train_data, test_data <span class="op">=</span> prep_ID_OOD_datasests([<span class="dv">0</span>,<span class="dv">1</span>], [<span class="dv">5</span>])</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>fig <span class="op">=</span> plot_data_sample(train_data, ood_data)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>fig.savefig(<span class="st">'../images/OOD-detection_image-data-preview.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-detection_image-data-preview.png" alt="Preview of image dataset" class="figure mx-auto d-block"><div class="figcaption">Preview of image dataset</div>
</figure>
</div>
<div class="section level2">
<h2 id="visualizing-ood-and-id-data">Visualizing OOD and ID data<a class="anchor" aria-label="anchor" href="#visualizing-ood-and-id-data"></a>
</h2>
<div class="section level3">
<h3 id="pca">PCA<a class="anchor" aria-label="anchor" href="#pca"></a>
</h3>
<p>PCA visualization can provide insights into how well a model is
separating ID and OOD data. If the OOD data overlaps significantly with
ID data in the PCA space, it might indicate that the model could
struggle to correctly identify OOD samples.</p>
<p><strong>Focus on Linear Relationships</strong>: PCA is a linear
dimensionality reduction technique. It assumes that the directions of
maximum variance in the data can be captured by linear combinations of
the original features. This can be a limitation when the data has
complex, non-linear relationships, as PCA may not capture the true
structure of the data. However, if you’re using a linear model (as we
are here), PCA can be more appropriate for visualizing in-distribution
(ID) and out-of-distribution (OOD) data because both PCA and linear
models operate under linear assumptions. PCA will effectively capture
the main variance in the data as seen by the linear model, making it
easier to understand the decision boundaries and how OOD data deviates
from the ID data within those boundaries.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Flatten images for PCA and logistic regression</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>train_data_flat <span class="op">=</span> train_data.reshape((train_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>test_data_flat <span class="op">=</span> test_data.reshape((test_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>ood_data_flat <span class="op">=</span> ood_data.reshape((ood_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'train_data_flat.shape=</span><span class="sc">{</span>train_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'test_data_flat.shape=</span><span class="sc">{</span>test_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'ood_data_flat.shape=</span><span class="sc">{</span>ood_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># Perform PCA to visualize the first two principal components</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>pca <span class="op">=</span> PCA(n_components<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>train_data_pca <span class="op">=</span> pca.fit_transform(train_data_flat)</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>test_data_pca <span class="op">=</span> pca.transform(test_data_flat)</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>ood_data_pca <span class="op">=</span> pca.transform(ood_data_flat)</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co"># Plotting PCA components</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a>scatter1 <span class="op">=</span> plt.scatter(train_data_pca[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">0</span>], train_data_pca[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'blue'</span>, label<span class="op">=</span><span class="st">'T-shirt/top (ID)'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a>scatter2 <span class="op">=</span> plt.scatter(train_data_pca[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">0</span>], train_data_pca[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'red'</span>, label<span class="op">=</span><span class="st">'Pants (ID)'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a>scatter3 <span class="op">=</span> plt.scatter(ood_data_pca[:, <span class="dv">0</span>], ood_data_pca[:, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'green'</span>, label<span class="op">=</span><span class="st">'Sandals (OOD)'</span>, edgecolor<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a><span class="co"># Create a single legend for all classes</span></span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[scatter1, scatter2, scatter3], loc<span class="op">=</span><span class="st">"upper right"</span>)</span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a>plt.xlabel(<span class="st">'First Principal Component'</span>)</span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a>plt.ylabel(<span class="st">'Second Principal Component'</span>)</span>
<span id="cb5-19"><a href="#cb5-19" tabindex="-1"></a>plt.title(<span class="st">'PCA of In-Distribution and OOD Data'</span>)</span>
<span id="cb5-20"><a href="#cb5-20" tabindex="-1"></a>plt.savefig(<span class="st">'../images/OOD-detection_PCA-image-dataset.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb5-21"><a href="#cb5-21" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-detection_PCA-image-dataset.png" alt="PCA visualization" class="figure"> From this plot, we see that sandals are more
likely to be confused as T-shirts than pants. It also may be surprising
to see that these data clouds overlap so much given their semantic
differences. Why might this be?</p>
<ul>
<li>
<strong>Over-reliance on linear relationships</strong>: Part of this
has to do with the fact that we’re only looking at linear relationships
and treating each pixel as its own input feature, which is usually never
a great idea when working with image data. In our next example, we’ll
switch to the more modern approach of CNNs.</li>
<li>
<strong>Semantic gap != feature gap</strong>: Another factor of note
is that images that have a wide semantic gap may not necessarily
translate to a wide gap in terms of the data’s visual features (e.g.,
ankle boots and bags might both be small, have leather, and have
zippers). Part of an effective OOD detection scheme involves thinking
carefully about what sorts of data contanimations may be observed by the
model, and assessing how similar these contaminations may be to your
desired class labels. ## Train and evaluate model on ID data</li>
</ul>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># Train a logistic regression classifier</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>model <span class="op">=</span> LogisticRegression(max_iter<span class="op">=</span>max_iter, solver<span class="op">=</span><span class="st">'lbfgs'</span>, multi_class<span class="op">=</span><span class="st">'multinomial'</span>).fit(train_data_flat, train_labels)</span></code></pre>
</div>
<p>Before we worry about the impact of OOD data, let’s first verify that
we have a reasonably accurate model for the ID data.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># Evaluate the model on in-distribution data</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>in_dist_preds <span class="op">=</span> model.predict(test_data_flat)</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>in_dist_accuracy <span class="op">=</span> accuracy_score(test_labels, in_dist_preds)</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'In-Distribution Accuracy: </span><span class="sc">{</span>in_dist_accuracy<span class="sc">:.2f}</span><span class="ss">'</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> accuracy_score, confusion_matrix, ConfusionMatrixDisplay</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="co"># Generate and display confusion matrix</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>cm <span class="op">=</span> confusion_matrix(test_labels, in_dist_preds, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>cm, display_labels<span class="op">=</span>[<span class="st">'T-shirt/top'</span>, <span class="st">'Pants'</span>])</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>disp.plot(cmap<span class="op">=</span>plt.cm.Blues)</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>plt.savefig(<span class="st">'../images/OOD-detection_ID-confusion-matrix.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-detection_ID-confusion-matrix.png" alt="ID confusion matrix" class="figure mx-auto d-block"><div class="figcaption">ID confusion matrix</div>
</figure>
</div>
</div>
<div class="section level2">
<h2 id="how-does-our-model-view-ood-data">How does our model view OOD data?<a class="anchor" aria-label="anchor" href="#how-does-our-model-view-ood-data"></a>
</h2>
<p>A basic question we can start with is to ask, on average, how are OOD
samples classified? Are they more likely to be Tshirts or pants? For
this kind of question, we can calculate the probability scores for the
OOD data, and compare this to the ID data.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># Predict probabilities using the model on OOD data (Sandals)</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>ood_probs <span class="op">=</span> model.predict_proba(ood_data_flat)</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>avg_ood_prob <span class="op">=</span> np.mean(ood_probs, <span class="dv">0</span>)</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Avg. probability of sandal being T-shirt: </span><span class="sc">{</span>avg_ood_prob[<span class="dv">0</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Avg. probability of sandal being pants: </span><span class="sc">{</span>avg_ood_prob[<span class="dv">1</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>id_probs <span class="op">=</span> model.predict_proba(train_data_flat)</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>id_probs_shirts <span class="op">=</span> id_probs[train_labels<span class="op">==</span><span class="dv">0</span>,:]</span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a>id_probs_pants <span class="op">=</span> id_probs[train_labels<span class="op">==</span><span class="dv">1</span>,:]</span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a>avg_tshirt_prob <span class="op">=</span> np.mean(id_probs_shirts, <span class="dv">0</span>)</span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a>avg_pants_prob <span class="op">=</span> np.mean(id_probs_pants, <span class="dv">0</span>)</span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Avg. probability of T-shirt being T-shirt: </span><span class="sc">{</span>avg_tshirt_prob[<span class="dv">0</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Avg. probability of pants being pants: </span><span class="sc">{</span>avg_pants_prob[<span class="dv">1</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code></pre>
</div>
<p>Based on the difference in averages here, it looks like softmax may
provide at least a somewhat useful signal in separating ID and OOD data.
Let’s take a closer look by plotting histograms of all probability
scores across our classes of interest (ID-Tshirt, ID-Pants, and
OOD).</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co"># Creating the figure and subplots</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">4</span>), sharey<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>bins<span class="op">=</span><span class="dv">60</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="co"># Plotting the histogram of probabilities for OOD data (Sandals)</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>axes[<span class="dv">0</span>].hist(ood_probs[:, <span class="dv">0</span>], bins<span class="op">=</span>bins, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'T-shirt probability'</span>)</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>axes[<span class="dv">0</span>].set_xlabel(<span class="st">'Probability'</span>)</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>axes[<span class="dv">0</span>].set_ylabel(<span class="st">'Frequency'</span>)</span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'OOD Data (Sandals)'</span>)</span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>axes[<span class="dv">0</span>].legend()</span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a><span class="co"># Plotting the histogram of probabilities for ID data (T-shirt)</span></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>axes[<span class="dv">1</span>].hist(id_probs_shirts[:, <span class="dv">0</span>], bins<span class="op">=</span>bins, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'T-shirt probability'</span>, color<span class="op">=</span><span class="st">'orange'</span>)</span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a>axes[<span class="dv">1</span>].set_xlabel(<span class="st">'Probability'</span>)</span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'ID Data (T-shirt/top)'</span>)</span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a>axes[<span class="dv">1</span>].legend()</span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a><span class="co"># Plotting the histogram of probabilities for ID data (Pants)</span></span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a>axes[<span class="dv">2</span>].hist(id_probs_pants[:, <span class="dv">1</span>], bins<span class="op">=</span>bins, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Pants probability'</span>, color<span class="op">=</span><span class="st">'green'</span>)</span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a>axes[<span class="dv">2</span>].set_xlabel(<span class="st">'Probability'</span>)</span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a>axes[<span class="dv">2</span>].set_title(<span class="st">'ID Data (Pants)'</span>)</span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a>axes[<span class="dv">2</span>].legend()</span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a><span class="co"># Adjusting layout</span></span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a>plt.savefig(<span class="st">'../images/OOD-detection_histograms.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb10-26"><a href="#cb10-26" tabindex="-1"></a><span class="co"># Displaying the plot</span></span>
<span id="cb10-27"><a href="#cb10-27" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-detection_histograms.png" alt="Histograms of ID oand OOD data" class="figure"> Alternatively, for a better
comparison across all three classes, we can use a probability density
plot. This will allow for an easier comparison when the counts across
classes lie on vastly different sclaes (i.e., max of 35 vs max of
5000).</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> gaussian_kde</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="co"># Create figure</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="co"># Define bins</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">0.4</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a><span class="co"># Plot PDF for ID T-shirt (T-shirt probability)</span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>density_id_shirts <span class="op">=</span> gaussian_kde(id_probs_shirts[:, <span class="dv">0</span>])</span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>x_id_shirts <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1000</span>)</span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a>plt.plot(x_id_shirts, density_id_shirts(x_id_shirts), label<span class="op">=</span><span class="st">'ID T-shirt (T-shirt probability)'</span>, color<span class="op">=</span><span class="st">'orange'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a><span class="co"># Plot PDF for ID Pants (Pants probability)</span></span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a>density_id_pants <span class="op">=</span> gaussian_kde(id_probs_pants[:, <span class="dv">0</span>])</span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a>x_id_pants <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1000</span>)</span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a>plt.plot(x_id_pants, density_id_pants(x_id_pants), label<span class="op">=</span><span class="st">'ID Pants (T-shirt probability)'</span>, color<span class="op">=</span><span class="st">'green'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" tabindex="-1"></a><span class="co"># Plot PDF for OOD (T-shirt probability)</span></span>
<span id="cb11-20"><a href="#cb11-20" tabindex="-1"></a>density_ood <span class="op">=</span> gaussian_kde(ood_probs[:, <span class="dv">0</span>])</span>
<span id="cb11-21"><a href="#cb11-21" tabindex="-1"></a>x_ood <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1000</span>)</span>
<span id="cb11-22"><a href="#cb11-22" tabindex="-1"></a>plt.plot(x_ood, density_ood(x_ood), label<span class="op">=</span><span class="st">'OOD (T-shirt probability)'</span>, color<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb11-23"><a href="#cb11-23" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" tabindex="-1"></a><span class="co"># Adding labels and title</span></span>
<span id="cb11-25"><a href="#cb11-25" tabindex="-1"></a>plt.xlabel(<span class="st">'Probability'</span>)</span>
<span id="cb11-26"><a href="#cb11-26" tabindex="-1"></a>plt.ylabel(<span class="st">'Density'</span>)</span>
<span id="cb11-27"><a href="#cb11-27" tabindex="-1"></a>plt.title(<span class="st">'Probability Density Distributions for OOD and ID Data'</span>)</span>
<span id="cb11-28"><a href="#cb11-28" tabindex="-1"></a>plt.legend()</span>
<span id="cb11-29"><a href="#cb11-29" tabindex="-1"></a></span>
<span id="cb11-30"><a href="#cb11-30" tabindex="-1"></a>plt.savefig(<span class="st">'../images/OOD-detection_PSDs.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb11-31"><a href="#cb11-31" tabindex="-1"></a></span>
<span id="cb11-32"><a href="#cb11-32" tabindex="-1"></a><span class="co"># Displaying the plot</span></span>
<span id="cb11-33"><a href="#cb11-33" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-detection_PSDs.png" alt="Probability densities" class="figure"> Unfortunately, we observe a significant
amount of overlap between OOD data and high T-shirt probability.
Furthermore, the blue line doesn’t seem to decrease much as you move
from 0.9 to 1, suggesting that even a very high threshold is likely to
lead to OOD contamination (while also tossing out a significant portion
of ID data).</p>
<p>For pants, the problem is much less severe. It looks like a low
threshold (on this T-shirt probability scale) can separate nearly all
OOD samples from being pants.</p>
<div class="section level3">
<h3 id="setting-a-threshold">Setting a threshold<a class="anchor" aria-label="anchor" href="#setting-a-threshold"></a>
</h3>
<p>Let’s put our observations to the test and produce a confusion matrix
that includes ID-pants, ID-Tshirts, and OOD class labels. We’ll start
with a high threshold of 0.9 to see how that performs.</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="kw">def</span> softmax_thresh_classifications(probs, threshold):</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>    classifications <span class="op">=</span> np.where(probs[:, <span class="dv">1</span>] <span class="op">&gt;=</span> threshold, <span class="dv">1</span>,  <span class="co"># classified as pants</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>                               np.where(probs[:, <span class="dv">0</span>] <span class="op">&gt;=</span> threshold, <span class="dv">0</span>,  <span class="co"># classified as shirts</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>                                        <span class="op">-</span><span class="dv">1</span>))  <span class="co"># classified as OOD</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>    <span class="cf">return</span> classifications</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> precision_recall_fscore_support</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="co"># Assuming ood_probs, id_probs, and train_labels are defined</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="co"># Threshold values</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>upper_threshold <span class="op">=</span> <span class="fl">0.9</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="co"># Classifying OOD examples (sandals)</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a>ood_classifications <span class="op">=</span> softmax_thresh_classifications(ood_probs, upper_threshold)</span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="co"># Classifying ID examples (T-shirts and pants)</span></span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a>id_classifications <span class="op">=</span> softmax_thresh_classifications(id_probs, upper_threshold)</span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a><span class="co"># Combine OOD and ID classifications and true labels</span></span>
<span id="cb13-14"><a href="#cb13-14" tabindex="-1"></a>all_predictions <span class="op">=</span> np.concatenate([ood_classifications, id_classifications])</span>
<span id="cb13-15"><a href="#cb13-15" tabindex="-1"></a>all_true_labels <span class="op">=</span> np.concatenate([<span class="op">-</span><span class="dv">1</span> <span class="op">*</span> np.ones(ood_classifications.shape), train_labels])</span>
<span id="cb13-16"><a href="#cb13-16" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" tabindex="-1"></a><span class="co"># Confusion matrix</span></span>
<span id="cb13-18"><a href="#cb13-18" tabindex="-1"></a>cm <span class="op">=</span> confusion_matrix(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb13-19"><a href="#cb13-19" tabindex="-1"></a></span>
<span id="cb13-20"><a href="#cb13-20" tabindex="-1"></a><span class="co"># Plotting the confusion matrix</span></span>
<span id="cb13-21"><a href="#cb13-21" tabindex="-1"></a>disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>cm, display_labels<span class="op">=</span>[<span class="st">"Shirt"</span>, <span class="st">"Pants"</span>, <span class="st">"OOD"</span>])</span>
<span id="cb13-22"><a href="#cb13-22" tabindex="-1"></a>disp.plot(cmap<span class="op">=</span>plt.cm.Blues)</span>
<span id="cb13-23"><a href="#cb13-23" tabindex="-1"></a>plt.title(<span class="st">'Confusion Matrix for OOD and ID Classification'</span>)</span>
<span id="cb13-24"><a href="#cb13-24" tabindex="-1"></a></span>
<span id="cb13-25"><a href="#cb13-25" tabindex="-1"></a>plt.savefig(<span class="st">'../images/OOD-detection_ID-OOD-confusion-matrix1.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb13-26"><a href="#cb13-26" tabindex="-1"></a></span>
<span id="cb13-27"><a href="#cb13-27" tabindex="-1"></a>plt.show()</span>
<span id="cb13-28"><a href="#cb13-28" tabindex="-1"></a></span>
<span id="cb13-29"><a href="#cb13-29" tabindex="-1"></a><span class="co"># Looking at F1, precision, and recall</span></span>
<span id="cb13-30"><a href="#cb13-30" tabindex="-1"></a>precision, recall, f1, _ <span class="op">=</span> precision_recall_fscore_support(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>], average<span class="op">=</span><span class="st">'macro'</span>) <span class="co"># discuss macro vs micro .</span></span>
<span id="cb13-31"><a href="#cb13-31" tabindex="-1"></a></span>
<span id="cb13-32"><a href="#cb13-32" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"F1: </span><span class="sc">{</span>f1<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb13-33"><a href="#cb13-33" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Precision: </span><span class="sc">{</span>precision<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb13-34"><a href="#cb13-34" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Recall: </span><span class="sc">{</span>recall<span class="sc">}</span><span class="ss">"</span>)</span></code></pre>
</div>
<p><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-detection_ID-OOD-confusion-matrix1.png" alt="Probability densities" class="figure"> Even with a high threshold of 0.9, we end
up with nearly a couple hundred OOD samples classified as ID. In
addition, over 800 ID samples had to be tossed out due to
uncertainty.</p>
</div>
<div class="section level3">
<h3 id="quick-exercise">Quick exercise<a class="anchor" aria-label="anchor" href="#quick-exercise"></a>
</h3>
<p>What threhsold is required to ensure that no OOD samples are
incorrectly considered as IID? What percentage of ID samples are
mistaken as OOD at this threshold? Answer: 0.9999,
(3826+2414)/(3826+2414+2174+3586)=52%</p>
<p>With a very conservative threshold, we can make sure very few OOD
samples are incorrectly classified as ID. However, the flip side is that
conservative thresholds tend to incorrectly classify many ID samples as
being OOD. In this case, we incorrectly assume almost 20% of shirts are
OOD samples.</p>
</div>
</div>
<div class="section level2">
<h2 id="iterative-threshold-determination">Iterative Threshold Determination<a class="anchor" aria-label="anchor" href="#iterative-threshold-determination"></a>
</h2>
<p>In practice, selecting an appropriate threshold is an iterative
process that balances the trade-off between correctly identifying
in-distribution (ID) data and accurately flagging out-of-distribution
(OOD) data. Here’s how you can iteratively determine the threshold:</p>
<ul>
<li><p><strong>Define Evaluation Metrics</strong>: While confusion
matrices are an excellent tool when you’re ready to more closely examine
the data, we need a single metric that can summarize threshold
performance so we can easily compare across threshold. Common metrics
include accuracy, precision, recall, or the F1 score for both ID and OOD
detection.</p></li>
<li><p><strong>Evaluate Over a Range of Thresholds</strong>: Test
different threshold values and evaluate the performance on a validation
set containing both ID and OOD data.</p></li>
<li><p><strong>Select the Optimal Threshold</strong>: Choose the
threshold that provides the best balance according to your chosen
metrics.</p></li>
</ul>
<p>Use the below code to determine what threshold should be set to
ensure precision = 100%. What threshold is required for recall to be
100%? What threshold gives the highest F1 score?</p>
<div class="section level3">
<h3 id="callout-on-averaging-schemes">Callout on averaging schemes<a class="anchor" aria-label="anchor" href="#callout-on-averaging-schemes"></a>
</h3>
<p>F1 scores can be calculated per class, and then averaged in different
ways (macro, micro, or weighted) when dealing with multiclass or
multilabel classification problems. Here are the key types of averaging
methods:</p>
<ul>
<li><p>Macro-Averaging: Calculates the F1 score for each class
independently and then takes the average of these scores. This treats
all classes equally, regardless of their support (number of true
instances for each class).</p></li>
<li><p>Micro-Averaging: Aggregates the contributions of all classes to
compute the average F1 score. This is typically used for imbalanced
datasets as it gives more weight to classes with more
instances.</p></li>
<li><p>Weighted-Averaging: Calculates the F1 score for each class
independently and then takes the average, weighted by the number of true
instances for each class. This accounts for class imbalance by giving
more weight to classes with more instances.</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="callout-on-including-ood-data-in-f1-calculation">Callout on including OOD data in F1 calculation<a class="anchor" aria-label="anchor" href="#callout-on-including-ood-data-in-f1-calculation"></a>
</h3>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="co"># from sklearn.metrics import precision_recall_fscore_support, accuracy_score</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a><span class="kw">def</span> eval_softmax_thresholds(thresholds, ood_probs, id_probs):</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>    <span class="co"># Store evaluation metrics for each threshold</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>    precisions <span class="op">=</span> []</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a>    recalls <span class="op">=</span> []</span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>    f1_scores <span class="op">=</span> []</span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a>    </span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>    <span class="cf">for</span> threshold <span class="kw">in</span> thresholds:</span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a>        <span class="co"># Classifying OOD examples (sandals)</span></span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a>        ood_classifications <span class="op">=</span> softmax_thresh_classifications(ood_probs, threshold)</span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a>        </span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a>        <span class="co"># Classifying ID examples (T-shirts and pants)</span></span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a>        id_classifications <span class="op">=</span> softmax_thresh_classifications(id_probs, threshold)</span>
<span id="cb14-15"><a href="#cb14-15" tabindex="-1"></a>        </span>
<span id="cb14-16"><a href="#cb14-16" tabindex="-1"></a>        <span class="co"># Combine OOD and ID classifications and true labels</span></span>
<span id="cb14-17"><a href="#cb14-17" tabindex="-1"></a>        all_predictions <span class="op">=</span> np.concatenate([ood_classifications, id_classifications])</span>
<span id="cb14-18"><a href="#cb14-18" tabindex="-1"></a>        all_true_labels <span class="op">=</span> np.concatenate([<span class="op">-</span><span class="dv">1</span> <span class="op">*</span> np.ones(ood_classifications.shape), train_labels])</span>
<span id="cb14-19"><a href="#cb14-19" tabindex="-1"></a>        </span>
<span id="cb14-20"><a href="#cb14-20" tabindex="-1"></a>        <span class="co"># Evaluate metrics</span></span>
<span id="cb14-21"><a href="#cb14-21" tabindex="-1"></a>        precision, recall, f1, _ <span class="op">=</span> precision_recall_fscore_support(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>], average<span class="op">=</span><span class="st">'macro'</span>) <span class="co"># discuss macro vs micro .</span></span>
<span id="cb14-22"><a href="#cb14-22" tabindex="-1"></a>        precisions.append(precision)</span>
<span id="cb14-23"><a href="#cb14-23" tabindex="-1"></a>        recalls.append(recall)</span>
<span id="cb14-24"><a href="#cb14-24" tabindex="-1"></a>        f1_scores.append(f1)</span>
<span id="cb14-25"><a href="#cb14-25" tabindex="-1"></a>        </span>
<span id="cb14-26"><a href="#cb14-26" tabindex="-1"></a>    <span class="cf">return</span> precisions, recalls, f1_scores</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="co"># Define thresholds to evaluate</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>thresholds <span class="op">=</span> np.linspace(<span class="fl">.5</span>, <span class="dv">1</span>, <span class="dv">50</span>)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="co"># Evaluate on all thresholds</span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>precisions, recalls, f1_scores <span class="op">=</span> eval_softmax_thresholds(thresholds, ood_probs, id_probs)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="kw">def</span> plot_metrics_vs_thresholds(thresholds, f1_scores, precisions, recalls, OOD_signal):</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>    <span class="co"># Find the best thresholds for each metric</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>    best_f1_index <span class="op">=</span> np.argmax(f1_scores)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>    best_f1_threshold <span class="op">=</span> thresholds[best_f1_index]</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>    </span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a>    best_precision_index <span class="op">=</span> np.argmax(precisions)</span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a>    best_precision_threshold <span class="op">=</span> thresholds[best_precision_index]</span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a>    </span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a>    best_recall_index <span class="op">=</span> np.argmax(recalls)</span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a>    best_recall_threshold <span class="op">=</span> thresholds[best_recall_index]</span>
<span id="cb16-11"><a href="#cb16-11" tabindex="-1"></a>    </span>
<span id="cb16-12"><a href="#cb16-12" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best F1 threshold: </span><span class="sc">{</span>best_f1_threshold<span class="sc">}</span><span class="ss">, F1 Score: </span><span class="sc">{</span>f1_scores[best_f1_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-13"><a href="#cb16-13" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Precision threshold: </span><span class="sc">{</span>best_precision_threshold<span class="sc">}</span><span class="ss">, Precision: </span><span class="sc">{</span>precisions[best_precision_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-14"><a href="#cb16-14" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Recall threshold: </span><span class="sc">{</span>best_recall_threshold<span class="sc">}</span><span class="ss">, Recall: </span><span class="sc">{</span>recalls[best_recall_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-15"><a href="#cb16-15" tabindex="-1"></a></span>
<span id="cb16-16"><a href="#cb16-16" tabindex="-1"></a>    <span class="co"># Create a new figure</span></span>
<span id="cb16-17"><a href="#cb16-17" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb16-18"><a href="#cb16-18" tabindex="-1"></a></span>
<span id="cb16-19"><a href="#cb16-19" tabindex="-1"></a>    <span class="co"># Plot metrics as functions of the threshold</span></span>
<span id="cb16-20"><a href="#cb16-20" tabindex="-1"></a>    ax.plot(thresholds, precisions, label<span class="op">=</span><span class="st">'Precision'</span>, color<span class="op">=</span><span class="st">'g'</span>)</span>
<span id="cb16-21"><a href="#cb16-21" tabindex="-1"></a>    ax.plot(thresholds, recalls, label<span class="op">=</span><span class="st">'Recall'</span>, color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb16-22"><a href="#cb16-22" tabindex="-1"></a>    ax.plot(thresholds, f1_scores, label<span class="op">=</span><span class="st">'F1 Score'</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb16-23"><a href="#cb16-23" tabindex="-1"></a>    </span>
<span id="cb16-24"><a href="#cb16-24" tabindex="-1"></a>    <span class="co"># Add best threshold indicators</span></span>
<span id="cb16-25"><a href="#cb16-25" tabindex="-1"></a>    ax.axvline(x<span class="op">=</span>best_f1_threshold, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best F1 Threshold: </span><span class="sc">{</span>best_f1_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb16-26"><a href="#cb16-26" tabindex="-1"></a>    ax.axvline(x<span class="op">=</span>best_precision_threshold, color<span class="op">=</span><span class="st">'g'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best Precision Threshold: </span><span class="sc">{</span>best_precision_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb16-27"><a href="#cb16-27" tabindex="-1"></a>    ax.axvline(x<span class="op">=</span>best_recall_threshold, color<span class="op">=</span><span class="st">'b'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best Recall Threshold: </span><span class="sc">{</span>best_recall_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb16-28"><a href="#cb16-28" tabindex="-1"></a>    ax.set_xlabel(<span class="ss">f'</span><span class="sc">{</span>OOD_signal<span class="sc">}</span><span class="ss"> Threshold'</span>)</span>
<span id="cb16-29"><a href="#cb16-29" tabindex="-1"></a>    ax.set_ylabel(<span class="st">'Metric Value'</span>)</span>
<span id="cb16-30"><a href="#cb16-30" tabindex="-1"></a>    ax.set_title(<span class="st">'Evaluation Metrics as Functions of Threshold'</span>)</span>
<span id="cb16-31"><a href="#cb16-31" tabindex="-1"></a>    ax.legend()</span>
<span id="cb16-32"><a href="#cb16-32" tabindex="-1"></a></span>
<span id="cb16-33"><a href="#cb16-33" tabindex="-1"></a>    <span class="cf">return</span> fig, best_f1_threshold, best_precision_threshold, best_recall_threshold</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>fig, best_f1_threshold, best_precision_threshold, best_recall_threshold <span class="op">=</span> plot_metrics_vs_thresholds(thresholds, f1_scores, precisions, recalls, <span class="st">'Softmax'</span>)</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>fig.savefig(<span class="st">'../images/OOD-detection_metrics_vs_softmax-thresholds.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span></code></pre>
</div>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-detection_metrics_vs_softmax-thresholds.png" alt="OOD-detection_metrics_vs_softmax-thresholds" class="figure mx-auto d-block"><div class="figcaption">OOD-detection_metrics_vs_softmax-thresholds</div>
</figure><div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="co"># Threshold values</span></span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>upper_threshold <span class="op">=</span> best_f1_threshold</span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a><span class="co"># upper_threshold = best_precision_threshold</span></span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a><span class="co"># Classifying OOD examples (sandals)</span></span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a>ood_classifications <span class="op">=</span> softmax_thresh_classifications(ood_probs, upper_threshold)</span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a><span class="co"># Classifying ID examples (T-shirts and pants)</span></span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a>id_classifications <span class="op">=</span> softmax_thresh_classifications(id_probs, upper_threshold)</span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" tabindex="-1"></a><span class="co"># Combine OOD and ID classifications and true labels</span></span>
<span id="cb18-12"><a href="#cb18-12" tabindex="-1"></a>all_predictions <span class="op">=</span> np.concatenate([ood_classifications, id_classifications])</span>
<span id="cb18-13"><a href="#cb18-13" tabindex="-1"></a>all_true_labels <span class="op">=</span> np.concatenate([<span class="op">-</span><span class="dv">1</span> <span class="op">*</span> np.ones(ood_classifications.shape), train_labels])</span>
<span id="cb18-14"><a href="#cb18-14" tabindex="-1"></a></span>
<span id="cb18-15"><a href="#cb18-15" tabindex="-1"></a><span class="co"># Confusion matrix</span></span>
<span id="cb18-16"><a href="#cb18-16" tabindex="-1"></a>cm <span class="op">=</span> confusion_matrix(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb18-17"><a href="#cb18-17" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" tabindex="-1"></a><span class="co"># Plotting the confusion matrix</span></span>
<span id="cb18-19"><a href="#cb18-19" tabindex="-1"></a>disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>cm, display_labels<span class="op">=</span>[<span class="st">"Shirt"</span>, <span class="st">"Pants"</span>, <span class="st">"OOD"</span>])</span>
<span id="cb18-20"><a href="#cb18-20" tabindex="-1"></a>disp.plot(cmap<span class="op">=</span>plt.cm.Blues)</span>
<span id="cb18-21"><a href="#cb18-21" tabindex="-1"></a>plt.title(<span class="st">'Confusion Matrix for OOD and ID Classification'</span>)</span>
<span id="cb18-22"><a href="#cb18-22" tabindex="-1"></a>plt.savefig(<span class="st">'../images/OOD-detection_ID-OOD-confusion-matrix2.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb18-23"><a href="#cb18-23" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-detection_ID-OOD-confusion-matrix2.png" alt="Optimized threshold confusion matrix" class="figure mx-auto d-block"><div class="figcaption">Optimized threshold confusion matrix</div>
</figure>
</div>
</div>
</div>
<div class="section level1">
<h1 id="example-2-energy-based-ood-detection">Example 2: Energy-Based OOD Detection<a class="anchor" aria-label="anchor" href="#example-2-energy-based-ood-detection"></a>
</h1>
<p><strong>TODO</strong>: Provide background and intuiiton surrounding
energy-based measure. Some notes below:</p>
<p>Liu et al., Energy-based Out-of-distribution Detection, NeurIPS 2020;
<a href="https://arxiv.org/pdf/2010.03759" class="external-link uri">https://arxiv.org/pdf/2010.03759</a></p>
<ul>
<li><p>E(x, y) = energy value</p></li>
<li><p>if x and y are “compatitble”, lower energy</p></li>
<li>
<p>Energy can be turned into probability through Gibbs
distribution</p>
<ul>
<li>looks at integral over all possible y’s</li>
</ul>
</li>
<li><p>With energy scores, ID and OOD distributions become much more
separable</p></li>
<li><p>Another “output-based” method like softmax</p></li>
<li><p>I believe this measure is explicitly designed to work with neural
nets, but may (?) work with other models</p></li>
</ul>
<div class="section level2">
<h2 id="introducing-pytorch-ood">Introducing PyTorch OOD<a class="anchor" aria-label="anchor" href="#introducing-pytorch-ood"></a>
</h2>
<p>The PyTorch-OOD library provides methods for OOD detection and other
closely related fields, such as anomoly detection or novelty detection.
Visit the docs to learn more: <a href="https://pytorch-ood.readthedocs.io/en/latest/info.html" class="external-link">pytorch-ood.readthedocs.io/en/latest/info.html</a></p>
<p>This library will provide a streamlined way to calculate both energy
and softmax scores from a trained model. ### Setup example In this
example, we will train a CNN model on the FashionMNIST dataset. We will
then repeat a similar process as we did with softmax scores to evaluate
how well the energy metric can separate ID and OOD data.</p>
<p>We’ll start by fresh by loading our data again. This time, let’s
treat all remaining classes in the MNIST fashion dataset as OOD. This
should yield a more robust model that is more reliable when presented
with all kinds of data.</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>ood_data, train_data, test_data <span class="op">=</span> prep_ID_OOD_datasests([<span class="dv">0</span>,<span class="dv">1</span>], <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">2</span>,<span class="dv">10</span>))) <span class="co"># use remaining 8 classes in dataset as OOD</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>fig <span class="op">=</span> plot_data_sample(train_data, ood_data)</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a>fig.savefig(<span class="st">'../images/OOD-detection_image-data-preview.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
</div>
<div class="section level2">
<h2 id="visualizing-ood-and-id-data-1">Visualizing OOD and ID data<a class="anchor" aria-label="anchor" href="#visualizing-ood-and-id-data-1"></a>
</h2>
<div class="section level3">
<h3 id="umap-or-similar">UMAP (or similar)<a class="anchor" aria-label="anchor" href="#umap-or-similar"></a>
</h3>
<p>Recall in our previous example, we used PCA to visualize the ID and
OOD data distributions. This was appropriate given that we were
evaluating OOD/ID data in the context of a linear model. However, when
working with nonlinear models such as CNNs, it makes more sense to
investigate how the data is represented in a nonlinear space. Nonlinear
embedding methods, such as Uniform Manifold Approximation and Projection
(UMAP), are more suitable in such scenarios.</p>
<p>UMAP is a non-linear dimensionality reduction technique that
preserves both the global structure and the local neighborhood
relationships in the data. UMAP is often better at maintaining the
continuity of data points that lie on non-linear manifolds. It can
reveal nonlinear patterns and structures that PCA might miss, making it
a valuable tool for analyzing ID and OOD distributions.</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>plot_umap <span class="op">=</span> <span class="va">True</span> <span class="co"># leave off for now to save time testing downstream materials</span></span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a><span class="cf">if</span> plot_umap:</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a>    <span class="im">import</span> umap</span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>    <span class="co"># Flatten images for PCA and logistic regression</span></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a>    train_data_flat <span class="op">=</span> train_data.reshape((train_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a>    test_data_flat <span class="op">=</span> test_data.reshape((test_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a>    ood_data_flat <span class="op">=</span> ood_data.reshape((ood_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a>    </span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'train_data_flat.shape=</span><span class="sc">{</span>train_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'test_data_flat.shape=</span><span class="sc">{</span>test_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'ood_data_flat.shape=</span><span class="sc">{</span>ood_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a>    </span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a>    <span class="co"># Perform UMAP to visualize the data</span></span>
<span id="cb20-14"><a href="#cb20-14" tabindex="-1"></a>    umap_reducer <span class="op">=</span> umap.UMAP(n_components<span class="op">=</span><span class="dv">2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb20-15"><a href="#cb20-15" tabindex="-1"></a>    combined_data <span class="op">=</span> np.vstack([train_data_flat, ood_data_flat])</span>
<span id="cb20-16"><a href="#cb20-16" tabindex="-1"></a>    combined_labels <span class="op">=</span> np.hstack([train_labels, np.full(ood_data_flat.shape[<span class="dv">0</span>], <span class="dv">2</span>)])  <span class="co"># Use 2 for OOD class</span></span>
<span id="cb20-17"><a href="#cb20-17" tabindex="-1"></a>    </span>
<span id="cb20-18"><a href="#cb20-18" tabindex="-1"></a>    umap_results <span class="op">=</span> umap_reducer.fit_transform(combined_data)</span>
<span id="cb20-19"><a href="#cb20-19" tabindex="-1"></a>    </span>
<span id="cb20-20"><a href="#cb20-20" tabindex="-1"></a>    <span class="co"># Split the results back into in-distribution and OOD data</span></span>
<span id="cb20-21"><a href="#cb20-21" tabindex="-1"></a>    umap_in_dist <span class="op">=</span> umap_results[:<span class="bu">len</span>(train_data_flat)]</span>
<span id="cb20-22"><a href="#cb20-22" tabindex="-1"></a>    umap_ood <span class="op">=</span> umap_results[<span class="bu">len</span>(train_data_flat):]</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="cf">if</span> plot_umap:</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>    umap_alpha <span class="op">=</span> <span class="fl">.02</span></span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>    <span class="co"># Plotting UMAP components</span></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a>    </span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a>    <span class="co"># Plot in-distribution data</span></span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a>    scatter1 <span class="op">=</span> plt.scatter(umap_in_dist[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">0</span>], umap_in_dist[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'blue'</span>, label<span class="op">=</span><span class="st">'T-shirts (ID)'</span>, alpha<span class="op">=</span>umap_alpha)</span>
<span id="cb21-9"><a href="#cb21-9" tabindex="-1"></a>    scatter2 <span class="op">=</span> plt.scatter(umap_in_dist[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">0</span>], umap_in_dist[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'red'</span>, label<span class="op">=</span><span class="st">'Trousers (ID)'</span>, alpha<span class="op">=</span>umap_alpha)</span>
<span id="cb21-10"><a href="#cb21-10" tabindex="-1"></a>    </span>
<span id="cb21-11"><a href="#cb21-11" tabindex="-1"></a>    <span class="co"># Plot OOD data</span></span>
<span id="cb21-12"><a href="#cb21-12" tabindex="-1"></a>    scatter3 <span class="op">=</span> plt.scatter(umap_ood[:, <span class="dv">0</span>], umap_ood[:, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'green'</span>, label<span class="op">=</span><span class="st">'OOD'</span>, edgecolor<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb21-13"><a href="#cb21-13" tabindex="-1"></a>    </span>
<span id="cb21-14"><a href="#cb21-14" tabindex="-1"></a>    <span class="co"># Create a single legend for all classes</span></span>
<span id="cb21-15"><a href="#cb21-15" tabindex="-1"></a>    plt.legend(handles<span class="op">=</span>[scatter1, scatter2, scatter3], loc<span class="op">=</span><span class="st">"upper right"</span>)</span>
<span id="cb21-16"><a href="#cb21-16" tabindex="-1"></a>    plt.xlabel(<span class="st">'First UMAP Component'</span>)</span>
<span id="cb21-17"><a href="#cb21-17" tabindex="-1"></a>    plt.ylabel(<span class="st">'Second UMAP Component'</span>)</span>
<span id="cb21-18"><a href="#cb21-18" tabindex="-1"></a>    plt.title(<span class="st">'UMAP of In-Distribution and OOD Data'</span>)</span>
<span id="cb21-19"><a href="#cb21-19" tabindex="-1"></a>    plt.show()</span></code></pre>
</div>
</div>
</div>
<div class="section level2">
<h2 id="train-cnn">Train CNN<a class="anchor" aria-label="anchor" href="#train-cnn"></a>
</h2>
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim</span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a><span class="im">import</span> torchvision.transforms <span class="im">as</span> transforms</span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" tabindex="-1"></a><span class="co"># Convert to PyTorch tensors and normalize</span></span>
<span id="cb22-8"><a href="#cb22-8" tabindex="-1"></a>train_data_tensor <span class="op">=</span> torch.tensor(train_data, dtype<span class="op">=</span>torch.float32).unsqueeze(<span class="dv">1</span>) <span class="op">/</span> <span class="fl">255.0</span></span>
<span id="cb22-9"><a href="#cb22-9" tabindex="-1"></a>test_data_tensor <span class="op">=</span> torch.tensor(test_data, dtype<span class="op">=</span>torch.float32).unsqueeze(<span class="dv">1</span>) <span class="op">/</span> <span class="fl">255.0</span></span>
<span id="cb22-10"><a href="#cb22-10" tabindex="-1"></a>ood_data_tensor <span class="op">=</span> torch.tensor(ood_data, dtype<span class="op">=</span>torch.float32).unsqueeze(<span class="dv">1</span>) <span class="op">/</span> <span class="fl">255.0</span></span>
<span id="cb22-11"><a href="#cb22-11" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" tabindex="-1"></a>train_labels_tensor <span class="op">=</span> torch.tensor(train_labels, dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb22-13"><a href="#cb22-13" tabindex="-1"></a>test_labels_tensor <span class="op">=</span> torch.tensor(test_labels, dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb22-14"><a href="#cb22-14" tabindex="-1"></a></span>
<span id="cb22-15"><a href="#cb22-15" tabindex="-1"></a>train_dataset <span class="op">=</span> torch.utils.data.TensorDataset(train_data_tensor, train_labels_tensor)</span>
<span id="cb22-16"><a href="#cb22-16" tabindex="-1"></a>test_dataset <span class="op">=</span> torch.utils.data.TensorDataset(test_data_tensor, test_labels_tensor)</span>
<span id="cb22-17"><a href="#cb22-17" tabindex="-1"></a>ood_dataset <span class="op">=</span> torch.utils.data.TensorDataset(ood_data_tensor, torch.zeros(ood_data_tensor.shape[<span class="dv">0</span>], dtype<span class="op">=</span>torch.<span class="bu">long</span>))</span>
<span id="cb22-18"><a href="#cb22-18" tabindex="-1"></a></span>
<span id="cb22-19"><a href="#cb22-19" tabindex="-1"></a>train_loader <span class="op">=</span> torch.utils.data.DataLoader(train_dataset, batch_size<span class="op">=</span><span class="dv">64</span>, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb22-20"><a href="#cb22-20" tabindex="-1"></a>test_loader <span class="op">=</span> torch.utils.data.DataLoader(test_dataset, batch_size<span class="op">=</span><span class="dv">64</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb22-21"><a href="#cb22-21" tabindex="-1"></a>ood_loader <span class="op">=</span> torch.utils.data.DataLoader(ood_dataset, batch_size<span class="op">=</span><span class="dv">64</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb22-22"><a href="#cb22-22" tabindex="-1"></a></span>
<span id="cb22-23"><a href="#cb22-23" tabindex="-1"></a><span class="co"># Define a simple CNN model</span></span>
<span id="cb22-24"><a href="#cb22-24" tabindex="-1"></a><span class="kw">class</span> SimpleCNN(nn.Module):</span>
<span id="cb22-25"><a href="#cb22-25" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb22-26"><a href="#cb22-26" tabindex="-1"></a>        <span class="bu">super</span>(SimpleCNN, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb22-27"><a href="#cb22-27" tabindex="-1"></a>        <span class="va">self</span>.conv1 <span class="op">=</span> nn.Conv2d(<span class="dv">1</span>, <span class="dv">32</span>, kernel_size<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb22-28"><a href="#cb22-28" tabindex="-1"></a>        <span class="va">self</span>.conv2 <span class="op">=</span> nn.Conv2d(<span class="dv">32</span>, <span class="dv">64</span>, kernel_size<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb22-29"><a href="#cb22-29" tabindex="-1"></a>        <span class="va">self</span>.fc1 <span class="op">=</span> nn.Linear(<span class="dv">64</span><span class="op">*</span><span class="dv">5</span><span class="op">*</span><span class="dv">5</span>, <span class="dv">128</span>)  <span class="co"># Updated this line</span></span>
<span id="cb22-30"><a href="#cb22-30" tabindex="-1"></a>        <span class="va">self</span>.fc2 <span class="op">=</span> nn.Linear(<span class="dv">128</span>, <span class="dv">2</span>)</span>
<span id="cb22-31"><a href="#cb22-31" tabindex="-1"></a></span>
<span id="cb22-32"><a href="#cb22-32" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb22-33"><a href="#cb22-33" tabindex="-1"></a>        x <span class="op">=</span> F.relu(F.max_pool2d(<span class="va">self</span>.conv1(x), <span class="dv">2</span>))</span>
<span id="cb22-34"><a href="#cb22-34" tabindex="-1"></a>        x <span class="op">=</span> F.relu(F.max_pool2d(<span class="va">self</span>.conv2(x), <span class="dv">2</span>))</span>
<span id="cb22-35"><a href="#cb22-35" tabindex="-1"></a>        x <span class="op">=</span> x.view(<span class="op">-</span><span class="dv">1</span>, <span class="dv">64</span><span class="op">*</span><span class="dv">5</span><span class="op">*</span><span class="dv">5</span>)  <span class="co"># Updated this line</span></span>
<span id="cb22-36"><a href="#cb22-36" tabindex="-1"></a>        x <span class="op">=</span> F.relu(<span class="va">self</span>.fc1(x))</span>
<span id="cb22-37"><a href="#cb22-37" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.fc2(x)</span>
<span id="cb22-38"><a href="#cb22-38" tabindex="-1"></a>        <span class="cf">return</span> x</span>
<span id="cb22-39"><a href="#cb22-39" tabindex="-1"></a></span>
<span id="cb22-40"><a href="#cb22-40" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">'cuda'</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">'cpu'</span>)</span>
<span id="cb22-41"><a href="#cb22-41" tabindex="-1"></a>model <span class="op">=</span> SimpleCNN().to(device)</span>
<span id="cb22-42"><a href="#cb22-42" tabindex="-1"></a>criterion <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb22-43"><a href="#cb22-43" tabindex="-1"></a>optimizer <span class="op">=</span> optim.Adam(model.parameters(), lr<span class="op">=</span><span class="fl">0.001</span>)</span>
<span id="cb22-44"><a href="#cb22-44" tabindex="-1"></a></span>
<span id="cb22-45"><a href="#cb22-45" tabindex="-1"></a><span class="kw">def</span> train_model(model, train_loader, criterion, optimizer, epochs<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb22-46"><a href="#cb22-46" tabindex="-1"></a>    model.train()</span>
<span id="cb22-47"><a href="#cb22-47" tabindex="-1"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(epochs):</span>
<span id="cb22-48"><a href="#cb22-48" tabindex="-1"></a>        running_loss <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb22-49"><a href="#cb22-49" tabindex="-1"></a>        <span class="cf">for</span> inputs, labels <span class="kw">in</span> train_loader:</span>
<span id="cb22-50"><a href="#cb22-50" tabindex="-1"></a>            inputs, labels <span class="op">=</span> inputs.to(device), labels.to(device)</span>
<span id="cb22-51"><a href="#cb22-51" tabindex="-1"></a>            optimizer.zero_grad()</span>
<span id="cb22-52"><a href="#cb22-52" tabindex="-1"></a>            outputs <span class="op">=</span> model(inputs)</span>
<span id="cb22-53"><a href="#cb22-53" tabindex="-1"></a>            loss <span class="op">=</span> criterion(outputs, labels)</span>
<span id="cb22-54"><a href="#cb22-54" tabindex="-1"></a>            loss.backward()</span>
<span id="cb22-55"><a href="#cb22-55" tabindex="-1"></a>            optimizer.step()</span>
<span id="cb22-56"><a href="#cb22-56" tabindex="-1"></a>            running_loss <span class="op">+=</span> loss.item()</span>
<span id="cb22-57"><a href="#cb22-57" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f'Epoch </span><span class="sc">{</span>epoch<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">, Loss: </span><span class="sc">{</span>running_loss<span class="op">/</span><span class="bu">len</span>(train_loader)<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb22-58"><a href="#cb22-58" tabindex="-1"></a></span>
<span id="cb22-59"><a href="#cb22-59" tabindex="-1"></a>train_model(model, train_loader, criterion, optimizer)</span></code></pre>
</div>
<p>The warning message indicates that UMAP has overridden the n_jobs
parameter to 1 due to the random_state being set. This behavior ensures
reproducibility by using a single job. If you want to avoid the warning
and still use parallelism, you can remove the random_state parameter.
However, removing random_state will mean that the results might not be
reproducible.</p>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> confusion_matrix, ConfusionMatrixDisplay</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a><span class="co"># Function to plot confusion matrix</span></span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a><span class="kw">def</span> plot_confusion_matrix(labels, predictions, title):</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a>    cm <span class="op">=</span> confusion_matrix(labels, predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>    disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>cm, display_labels<span class="op">=</span>[<span class="st">"T-shirt/top"</span>, <span class="st">"Trouser"</span>])</span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a>    disp.plot(cmap<span class="op">=</span>plt.cm.Blues)</span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a>    plt.title(title)</span>
<span id="cb23-9"><a href="#cb23-9" tabindex="-1"></a>    plt.show()</span>
<span id="cb23-10"><a href="#cb23-10" tabindex="-1"></a></span>
<span id="cb23-11"><a href="#cb23-11" tabindex="-1"></a><span class="co"># Function to evaluate model on a dataset</span></span>
<span id="cb23-12"><a href="#cb23-12" tabindex="-1"></a><span class="kw">def</span> evaluate_model(model, dataloader, device):</span>
<span id="cb23-13"><a href="#cb23-13" tabindex="-1"></a>    model.<span class="bu">eval</span>()</span>
<span id="cb23-14"><a href="#cb23-14" tabindex="-1"></a>    all_labels <span class="op">=</span> []</span>
<span id="cb23-15"><a href="#cb23-15" tabindex="-1"></a>    all_predictions <span class="op">=</span> []</span>
<span id="cb23-16"><a href="#cb23-16" tabindex="-1"></a>    <span class="cf">with</span> torch.no_grad():</span>
<span id="cb23-17"><a href="#cb23-17" tabindex="-1"></a>        <span class="cf">for</span> inputs, labels <span class="kw">in</span> dataloader:</span>
<span id="cb23-18"><a href="#cb23-18" tabindex="-1"></a>            inputs, labels <span class="op">=</span> inputs.to(device), labels.to(device)</span>
<span id="cb23-19"><a href="#cb23-19" tabindex="-1"></a>            outputs <span class="op">=</span> model(inputs)</span>
<span id="cb23-20"><a href="#cb23-20" tabindex="-1"></a>            _, preds <span class="op">=</span> torch.<span class="bu">max</span>(outputs, <span class="dv">1</span>)</span>
<span id="cb23-21"><a href="#cb23-21" tabindex="-1"></a>            all_labels.extend(labels.cpu().numpy())</span>
<span id="cb23-22"><a href="#cb23-22" tabindex="-1"></a>            all_predictions.extend(preds.cpu().numpy())</span>
<span id="cb23-23"><a href="#cb23-23" tabindex="-1"></a>    <span class="cf">return</span> np.array(all_labels), np.array(all_predictions)</span>
<span id="cb23-24"><a href="#cb23-24" tabindex="-1"></a></span>
<span id="cb23-25"><a href="#cb23-25" tabindex="-1"></a><span class="co"># Evaluate on train data</span></span>
<span id="cb23-26"><a href="#cb23-26" tabindex="-1"></a>train_labels, train_predictions <span class="op">=</span> evaluate_model(model, train_loader, device)</span>
<span id="cb23-27"><a href="#cb23-27" tabindex="-1"></a>plot_confusion_matrix(train_labels, train_predictions, <span class="st">"Confusion Matrix for Train Data"</span>)</span>
<span id="cb23-28"><a href="#cb23-28" tabindex="-1"></a></span>
<span id="cb23-29"><a href="#cb23-29" tabindex="-1"></a><span class="co"># Evaluate on test data</span></span>
<span id="cb23-30"><a href="#cb23-30" tabindex="-1"></a>test_labels, test_predictions <span class="op">=</span> evaluate_model(model, test_loader, device)</span>
<span id="cb23-31"><a href="#cb23-31" tabindex="-1"></a>plot_confusion_matrix(test_labels, test_predictions, <span class="st">"Confusion Matrix for Test Data"</span>)</span>
<span id="cb23-32"><a href="#cb23-32" tabindex="-1"></a></span>
<span id="cb23-33"><a href="#cb23-33" tabindex="-1"></a><span class="co"># Evaluate on OOD data</span></span>
<span id="cb23-34"><a href="#cb23-34" tabindex="-1"></a>ood_labels, ood_predictions <span class="op">=</span> evaluate_model(model, ood_loader, device)</span>
<span id="cb23-35"><a href="#cb23-35" tabindex="-1"></a>plot_confusion_matrix(ood_labels, ood_predictions, <span class="st">"Confusion Matrix for Test Data"</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb24">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> gaussian_kde</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a><span class="im">from</span> pytorch_ood.detector <span class="im">import</span> EnergyBased</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> precision_recall_fscore_support, accuracy_score</span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a><span class="co"># Compute softmax scores</span></span>
<span id="cb24-6"><a href="#cb24-6" tabindex="-1"></a><span class="kw">def</span> get_softmax_scores(model, dataloader):</span>
<span id="cb24-7"><a href="#cb24-7" tabindex="-1"></a>    model.<span class="bu">eval</span>()</span>
<span id="cb24-8"><a href="#cb24-8" tabindex="-1"></a>    softmax_scores <span class="op">=</span> []</span>
<span id="cb24-9"><a href="#cb24-9" tabindex="-1"></a>    <span class="cf">with</span> torch.no_grad():</span>
<span id="cb24-10"><a href="#cb24-10" tabindex="-1"></a>        <span class="cf">for</span> inputs, _ <span class="kw">in</span> dataloader:</span>
<span id="cb24-11"><a href="#cb24-11" tabindex="-1"></a>            inputs <span class="op">=</span> inputs.to(device)</span>
<span id="cb24-12"><a href="#cb24-12" tabindex="-1"></a>            outputs <span class="op">=</span> model(inputs)</span>
<span id="cb24-13"><a href="#cb24-13" tabindex="-1"></a>            softmax <span class="op">=</span> torch.nn.functional.softmax(outputs, dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb24-14"><a href="#cb24-14" tabindex="-1"></a>            softmax_scores.extend(softmax.cpu().numpy())</span>
<span id="cb24-15"><a href="#cb24-15" tabindex="-1"></a>    <span class="cf">return</span> np.array(softmax_scores)</span>
<span id="cb24-16"><a href="#cb24-16" tabindex="-1"></a></span>
<span id="cb24-17"><a href="#cb24-17" tabindex="-1"></a>id_softmax_scores <span class="op">=</span> get_softmax_scores(model, test_loader)</span>
<span id="cb24-18"><a href="#cb24-18" tabindex="-1"></a>ood_softmax_scores <span class="op">=</span> get_softmax_scores(model, ood_loader)</span>
<span id="cb24-19"><a href="#cb24-19" tabindex="-1"></a></span>
<span id="cb24-20"><a href="#cb24-20" tabindex="-1"></a><span class="co"># Initialize the energy-based OOD detector</span></span>
<span id="cb24-21"><a href="#cb24-21" tabindex="-1"></a>energy_detector <span class="op">=</span> EnergyBased(model, t<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb24-22"><a href="#cb24-22" tabindex="-1"></a></span>
<span id="cb24-23"><a href="#cb24-23" tabindex="-1"></a><span class="co"># Compute energy scores</span></span>
<span id="cb24-24"><a href="#cb24-24" tabindex="-1"></a><span class="kw">def</span> get_energy_scores(detector, dataloader):</span>
<span id="cb24-25"><a href="#cb24-25" tabindex="-1"></a>    scores <span class="op">=</span> []</span>
<span id="cb24-26"><a href="#cb24-26" tabindex="-1"></a>    detector.model.<span class="bu">eval</span>()</span>
<span id="cb24-27"><a href="#cb24-27" tabindex="-1"></a>    <span class="cf">with</span> torch.no_grad():</span>
<span id="cb24-28"><a href="#cb24-28" tabindex="-1"></a>        <span class="cf">for</span> inputs, _ <span class="kw">in</span> dataloader:</span>
<span id="cb24-29"><a href="#cb24-29" tabindex="-1"></a>            inputs <span class="op">=</span> inputs.to(device)</span>
<span id="cb24-30"><a href="#cb24-30" tabindex="-1"></a>            score <span class="op">=</span> detector.predict(inputs)</span>
<span id="cb24-31"><a href="#cb24-31" tabindex="-1"></a>            scores.extend(score.cpu().numpy())</span>
<span id="cb24-32"><a href="#cb24-32" tabindex="-1"></a>    <span class="cf">return</span> np.array(scores)</span>
<span id="cb24-33"><a href="#cb24-33" tabindex="-1"></a></span>
<span id="cb24-34"><a href="#cb24-34" tabindex="-1"></a>id_energy_scores <span class="op">=</span> get_energy_scores(energy_detector, test_loader)</span>
<span id="cb24-35"><a href="#cb24-35" tabindex="-1"></a>ood_energy_scores <span class="op">=</span> get_energy_scores(energy_detector, ood_loader)</span>
<span id="cb24-36"><a href="#cb24-36" tabindex="-1"></a></span>
<span id="cb24-37"><a href="#cb24-37" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb24-38"><a href="#cb24-38" tabindex="-1"></a></span>
<span id="cb24-39"><a href="#cb24-39" tabindex="-1"></a></span>
<span id="cb24-40"><a href="#cb24-40" tabindex="-1"></a><span class="co"># Plot PSDs</span></span>
<span id="cb24-41"><a href="#cb24-41" tabindex="-1"></a></span>
<span id="cb24-42"><a href="#cb24-42" tabindex="-1"></a><span class="co"># Function to plot PSD</span></span>
<span id="cb24-43"><a href="#cb24-43" tabindex="-1"></a><span class="kw">def</span> plot_psd(id_scores, ood_scores, method_name):</span>
<span id="cb24-44"><a href="#cb24-44" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb24-45"><a href="#cb24-45" tabindex="-1"></a>    alpha <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="cb24-46"><a href="#cb24-46" tabindex="-1"></a></span>
<span id="cb24-47"><a href="#cb24-47" tabindex="-1"></a>    <span class="co"># Plot PSD for ID scores</span></span>
<span id="cb24-48"><a href="#cb24-48" tabindex="-1"></a>    id_density <span class="op">=</span> gaussian_kde(id_scores)</span>
<span id="cb24-49"><a href="#cb24-49" tabindex="-1"></a>    x_id <span class="op">=</span> np.linspace(id_scores.<span class="bu">min</span>(), id_scores.<span class="bu">max</span>(), <span class="dv">1000</span>)</span>
<span id="cb24-50"><a href="#cb24-50" tabindex="-1"></a>    plt.plot(x_id, id_density(x_id), label<span class="op">=</span><span class="ss">f'ID (</span><span class="sc">{</span>method_name<span class="sc">}</span><span class="ss">)'</span>, color<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb24-51"><a href="#cb24-51" tabindex="-1"></a></span>
<span id="cb24-52"><a href="#cb24-52" tabindex="-1"></a>    <span class="co"># Plot PSD for OOD scores</span></span>
<span id="cb24-53"><a href="#cb24-53" tabindex="-1"></a>    ood_density <span class="op">=</span> gaussian_kde(ood_scores)</span>
<span id="cb24-54"><a href="#cb24-54" tabindex="-1"></a>    x_ood <span class="op">=</span> np.linspace(ood_scores.<span class="bu">min</span>(), ood_scores.<span class="bu">max</span>(), <span class="dv">1000</span>)</span>
<span id="cb24-55"><a href="#cb24-55" tabindex="-1"></a>    plt.plot(x_ood, ood_density(x_ood), label<span class="op">=</span><span class="ss">f'OOD (</span><span class="sc">{</span>method_name<span class="sc">}</span><span class="ss">)'</span>, color<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb24-56"><a href="#cb24-56" tabindex="-1"></a></span>
<span id="cb24-57"><a href="#cb24-57" tabindex="-1"></a>    plt.xlabel(<span class="st">'Score'</span>)</span>
<span id="cb24-58"><a href="#cb24-58" tabindex="-1"></a>    plt.ylabel(<span class="st">'Density'</span>)</span>
<span id="cb24-59"><a href="#cb24-59" tabindex="-1"></a>    plt.title(<span class="ss">f'Probability Density Distributions for </span><span class="sc">{</span>method_name<span class="sc">}</span><span class="ss"> Scores'</span>)</span>
<span id="cb24-60"><a href="#cb24-60" tabindex="-1"></a>    plt.legend()</span>
<span id="cb24-61"><a href="#cb24-61" tabindex="-1"></a>    plt.show()</span>
<span id="cb24-62"><a href="#cb24-62" tabindex="-1"></a></span>
<span id="cb24-63"><a href="#cb24-63" tabindex="-1"></a><span class="co"># Plot PSD for softmax scores</span></span>
<span id="cb24-64"><a href="#cb24-64" tabindex="-1"></a>plot_psd(id_softmax_scores[:, <span class="dv">1</span>], ood_softmax_scores[:, <span class="dv">1</span>], <span class="st">'Softmax'</span>)</span>
<span id="cb24-65"><a href="#cb24-65" tabindex="-1"></a></span>
<span id="cb24-66"><a href="#cb24-66" tabindex="-1"></a><span class="co"># Plot PSD for energy scores</span></span>
<span id="cb24-67"><a href="#cb24-67" tabindex="-1"></a>plot_psd(id_energy_scores, ood_energy_scores, <span class="st">'Energy'</span>)</span>
<span id="cb24-68"><a href="#cb24-68" tabindex="-1"></a></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> precision_recall_fscore_support, accuracy_score, confusion_matrix, ConfusionMatrixDisplay</span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a><span class="co"># Define thresholds to evaluate</span></span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a>thresholds <span class="op">=</span> np.linspace(id_energy_scores.<span class="bu">min</span>(), id_energy_scores.<span class="bu">max</span>(), <span class="dv">50</span>)</span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" tabindex="-1"></a><span class="co"># Store evaluation metrics for each threshold</span></span>
<span id="cb25-9"><a href="#cb25-9" tabindex="-1"></a>accuracies <span class="op">=</span> []</span>
<span id="cb25-10"><a href="#cb25-10" tabindex="-1"></a>precisions <span class="op">=</span> []</span>
<span id="cb25-11"><a href="#cb25-11" tabindex="-1"></a>recalls <span class="op">=</span> []</span>
<span id="cb25-12"><a href="#cb25-12" tabindex="-1"></a>f1_scores <span class="op">=</span> []</span>
<span id="cb25-13"><a href="#cb25-13" tabindex="-1"></a></span>
<span id="cb25-14"><a href="#cb25-14" tabindex="-1"></a><span class="co"># True labels for OOD data (since they are not part of the original labels)</span></span>
<span id="cb25-15"><a href="#cb25-15" tabindex="-1"></a>ood_true_labels <span class="op">=</span> np.full(<span class="bu">len</span>(ood_energy_scores), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb25-16"><a href="#cb25-16" tabindex="-1"></a></span>
<span id="cb25-17"><a href="#cb25-17" tabindex="-1"></a><span class="co"># We need the test_labels to be aligned with the ID data</span></span>
<span id="cb25-18"><a href="#cb25-18" tabindex="-1"></a>id_true_labels <span class="op">=</span> test_labels[:<span class="bu">len</span>(id_energy_scores)]</span>
<span id="cb25-19"><a href="#cb25-19" tabindex="-1"></a></span>
<span id="cb25-20"><a href="#cb25-20" tabindex="-1"></a><span class="cf">for</span> threshold <span class="kw">in</span> thresholds:</span>
<span id="cb25-21"><a href="#cb25-21" tabindex="-1"></a>    <span class="co"># Classify OOD examples based on energy scores</span></span>
<span id="cb25-22"><a href="#cb25-22" tabindex="-1"></a>    ood_classifications <span class="op">=</span> np.where(ood_energy_scores <span class="op">&gt;=</span> threshold, <span class="op">-</span><span class="dv">1</span>,  <span class="co"># classified as OOD</span></span>
<span id="cb25-23"><a href="#cb25-23" tabindex="-1"></a>                                   np.where(ood_energy_scores <span class="op">&lt;</span> threshold, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>))  <span class="co"># classified as ID</span></span>
<span id="cb25-24"><a href="#cb25-24" tabindex="-1"></a></span>
<span id="cb25-25"><a href="#cb25-25" tabindex="-1"></a>    <span class="co"># Classify ID examples based on energy scores</span></span>
<span id="cb25-26"><a href="#cb25-26" tabindex="-1"></a>    id_classifications <span class="op">=</span> np.where(id_energy_scores <span class="op">&gt;=</span> threshold, <span class="op">-</span><span class="dv">1</span>,  <span class="co"># classified as OOD</span></span>
<span id="cb25-27"><a href="#cb25-27" tabindex="-1"></a>                                  np.where(id_energy_scores <span class="op">&lt;</span> threshold, id_true_labels, <span class="op">-</span><span class="dv">1</span>))  <span class="co"># classified as ID</span></span>
<span id="cb25-28"><a href="#cb25-28" tabindex="-1"></a></span>
<span id="cb25-29"><a href="#cb25-29" tabindex="-1"></a>    <span class="co"># Combine OOD and ID classifications and true labels</span></span>
<span id="cb25-30"><a href="#cb25-30" tabindex="-1"></a>    all_predictions <span class="op">=</span> np.concatenate([ood_classifications, id_classifications])</span>
<span id="cb25-31"><a href="#cb25-31" tabindex="-1"></a>    all_true_labels <span class="op">=</span> np.concatenate([ood_true_labels, id_true_labels])</span>
<span id="cb25-32"><a href="#cb25-32" tabindex="-1"></a></span>
<span id="cb25-33"><a href="#cb25-33" tabindex="-1"></a>    <span class="co"># Evaluate metrics</span></span>
<span id="cb25-34"><a href="#cb25-34" tabindex="-1"></a>    precision, recall, f1, _ <span class="op">=</span> precision_recall_fscore_support(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>], average<span class="op">=</span><span class="st">'macro'</span>)<span class="co">#, zero_division=0)</span></span>
<span id="cb25-35"><a href="#cb25-35" tabindex="-1"></a>    accuracy <span class="op">=</span> accuracy_score(all_true_labels, all_predictions)</span>
<span id="cb25-36"><a href="#cb25-36" tabindex="-1"></a></span>
<span id="cb25-37"><a href="#cb25-37" tabindex="-1"></a>    accuracies.append(accuracy)</span>
<span id="cb25-38"><a href="#cb25-38" tabindex="-1"></a>    precisions.append(precision)</span>
<span id="cb25-39"><a href="#cb25-39" tabindex="-1"></a>    recalls.append(recall)</span>
<span id="cb25-40"><a href="#cb25-40" tabindex="-1"></a>    f1_scores.append(f1)</span>
<span id="cb25-41"><a href="#cb25-41" tabindex="-1"></a></span>
<span id="cb25-42"><a href="#cb25-42" tabindex="-1"></a><span class="co"># Find the best thresholds for each metric</span></span>
<span id="cb25-43"><a href="#cb25-43" tabindex="-1"></a>best_f1_index <span class="op">=</span> np.argmax(f1_scores)</span>
<span id="cb25-44"><a href="#cb25-44" tabindex="-1"></a>best_f1_threshold <span class="op">=</span> thresholds[best_f1_index]</span>
<span id="cb25-45"><a href="#cb25-45" tabindex="-1"></a></span>
<span id="cb25-46"><a href="#cb25-46" tabindex="-1"></a>best_precision_index <span class="op">=</span> np.argmax(precisions)</span>
<span id="cb25-47"><a href="#cb25-47" tabindex="-1"></a>best_precision_threshold <span class="op">=</span> thresholds[best_precision_index]</span>
<span id="cb25-48"><a href="#cb25-48" tabindex="-1"></a></span>
<span id="cb25-49"><a href="#cb25-49" tabindex="-1"></a>best_recall_index <span class="op">=</span> np.argmax(recalls)</span>
<span id="cb25-50"><a href="#cb25-50" tabindex="-1"></a>best_recall_threshold <span class="op">=</span> thresholds[best_recall_index]</span>
<span id="cb25-51"><a href="#cb25-51" tabindex="-1"></a></span>
<span id="cb25-52"><a href="#cb25-52" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Best F1 threshold: </span><span class="sc">{</span>best_f1_threshold<span class="sc">}</span><span class="ss">, F1 Score: </span><span class="sc">{</span>f1_scores[best_f1_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-53"><a href="#cb25-53" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Best Precision threshold: </span><span class="sc">{</span>best_precision_threshold<span class="sc">}</span><span class="ss">, Precision: </span><span class="sc">{</span>precisions[best_precision_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-54"><a href="#cb25-54" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Best Recall threshold: </span><span class="sc">{</span>best_recall_threshold<span class="sc">}</span><span class="ss">, Recall: </span><span class="sc">{</span>recalls[best_recall_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-55"><a href="#cb25-55" tabindex="-1"></a></span>
<span id="cb25-56"><a href="#cb25-56" tabindex="-1"></a><span class="co"># Plot metrics as functions of the threshold</span></span>
<span id="cb25-57"><a href="#cb25-57" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb25-58"><a href="#cb25-58" tabindex="-1"></a>plt.plot(thresholds, precisions, label<span class="op">=</span><span class="st">'Precision'</span>, color<span class="op">=</span><span class="st">'g'</span>)</span>
<span id="cb25-59"><a href="#cb25-59" tabindex="-1"></a>plt.plot(thresholds, recalls, label<span class="op">=</span><span class="st">'Recall'</span>, color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb25-60"><a href="#cb25-60" tabindex="-1"></a>plt.plot(thresholds, f1_scores, label<span class="op">=</span><span class="st">'F1 Score'</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb25-61"><a href="#cb25-61" tabindex="-1"></a></span>
<span id="cb25-62"><a href="#cb25-62" tabindex="-1"></a><span class="co"># Add best threshold indicators</span></span>
<span id="cb25-63"><a href="#cb25-63" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>best_f1_threshold, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best F1 Threshold: </span><span class="sc">{</span>best_f1_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb25-64"><a href="#cb25-64" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>best_precision_threshold, color<span class="op">=</span><span class="st">'g'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best Precision Threshold: </span><span class="sc">{</span>best_precision_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb25-65"><a href="#cb25-65" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>best_recall_threshold, color<span class="op">=</span><span class="st">'b'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best Recall Threshold: </span><span class="sc">{</span>best_recall_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb25-66"><a href="#cb25-66" tabindex="-1"></a></span>
<span id="cb25-67"><a href="#cb25-67" tabindex="-1"></a>plt.xlabel(<span class="st">'Threshold'</span>)</span>
<span id="cb25-68"><a href="#cb25-68" tabindex="-1"></a>plt.ylabel(<span class="st">'Metric Value'</span>)</span>
<span id="cb25-69"><a href="#cb25-69" tabindex="-1"></a>plt.title(<span class="st">'Evaluation Metrics as Functions of Threshold (Energy-Based OOD Detection)'</span>)</span>
<span id="cb25-70"><a href="#cb25-70" tabindex="-1"></a>plt.legend()</span>
<span id="cb25-71"><a href="#cb25-71" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb26">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> precision_recall_fscore_support, accuracy_score, confusion_matrix, ConfusionMatrixDisplay</span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb26-6"><a href="#cb26-6" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb26-7"><a href="#cb26-7" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> precision_recall_fscore_support, accuracy_score</span>
<span id="cb26-8"><a href="#cb26-8" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" tabindex="-1"></a><span class="kw">def</span> evaluate_ood_detection(id_scores, ood_scores, id_true_labels, id_predictions, ood_predictions, score_type<span class="op">=</span><span class="st">'energy'</span>):</span>
<span id="cb26-10"><a href="#cb26-10" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb26-11"><a href="#cb26-11" tabindex="-1"></a><span class="co">    Evaluate OOD detection based on either energy scores or softmax scores.</span></span>
<span id="cb26-12"><a href="#cb26-12" tabindex="-1"></a></span>
<span id="cb26-13"><a href="#cb26-13" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb26-14"><a href="#cb26-14" tabindex="-1"></a><span class="co">    - id_scores: np.array, scores for in-distribution (ID) data</span></span>
<span id="cb26-15"><a href="#cb26-15" tabindex="-1"></a><span class="co">    - ood_scores: np.array, scores for out-of-distribution (OOD) data</span></span>
<span id="cb26-16"><a href="#cb26-16" tabindex="-1"></a><span class="co">    - id_true_labels: np.array, true labels for ID data</span></span>
<span id="cb26-17"><a href="#cb26-17" tabindex="-1"></a><span class="co">    - id_predictions: np.array, predicted labels for ID data</span></span>
<span id="cb26-18"><a href="#cb26-18" tabindex="-1"></a><span class="co">    - ood_predictions: np.array, predicted labels for OOD data</span></span>
<span id="cb26-19"><a href="#cb26-19" tabindex="-1"></a><span class="co">    - score_type: str, type of score used ('energy' or 'softmax')</span></span>
<span id="cb26-20"><a href="#cb26-20" tabindex="-1"></a></span>
<span id="cb26-21"><a href="#cb26-21" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb26-22"><a href="#cb26-22" tabindex="-1"></a><span class="co">    - Best thresholds for F1, Precision, and Recall</span></span>
<span id="cb26-23"><a href="#cb26-23" tabindex="-1"></a><span class="co">    - Plots of Precision, Recall, and F1 Score as functions of the threshold</span></span>
<span id="cb26-24"><a href="#cb26-24" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb26-25"><a href="#cb26-25" tabindex="-1"></a>    <span class="co"># Define thresholds to evaluate</span></span>
<span id="cb26-26"><a href="#cb26-26" tabindex="-1"></a>    <span class="cf">if</span> score_type <span class="op">==</span> <span class="st">'softmax'</span>:</span>
<span id="cb26-27"><a href="#cb26-27" tabindex="-1"></a>        thresholds <span class="op">=</span> np.linspace(<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="dv">200</span>)</span>
<span id="cb26-28"><a href="#cb26-28" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb26-29"><a href="#cb26-29" tabindex="-1"></a>        thresholds <span class="op">=</span> np.linspace(id_scores.<span class="bu">min</span>(), id_scores.<span class="bu">max</span>(), <span class="dv">50</span>)</span>
<span id="cb26-30"><a href="#cb26-30" tabindex="-1"></a></span>
<span id="cb26-31"><a href="#cb26-31" tabindex="-1"></a>    <span class="co"># Store evaluation metrics for each threshold</span></span>
<span id="cb26-32"><a href="#cb26-32" tabindex="-1"></a>    accuracies <span class="op">=</span> []</span>
<span id="cb26-33"><a href="#cb26-33" tabindex="-1"></a>    precisions <span class="op">=</span> []</span>
<span id="cb26-34"><a href="#cb26-34" tabindex="-1"></a>    recalls <span class="op">=</span> []</span>
<span id="cb26-35"><a href="#cb26-35" tabindex="-1"></a>    f1_scores <span class="op">=</span> []</span>
<span id="cb26-36"><a href="#cb26-36" tabindex="-1"></a></span>
<span id="cb26-37"><a href="#cb26-37" tabindex="-1"></a>    <span class="co"># True labels for OOD data (since they are not part of the original labels)</span></span>
<span id="cb26-38"><a href="#cb26-38" tabindex="-1"></a>    ood_true_labels <span class="op">=</span> np.full(<span class="bu">len</span>(ood_scores), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb26-39"><a href="#cb26-39" tabindex="-1"></a></span>
<span id="cb26-40"><a href="#cb26-40" tabindex="-1"></a>    <span class="cf">for</span> threshold <span class="kw">in</span> thresholds:</span>
<span id="cb26-41"><a href="#cb26-41" tabindex="-1"></a>        <span class="co"># Classify OOD examples based on scores</span></span>
<span id="cb26-42"><a href="#cb26-42" tabindex="-1"></a>        <span class="cf">if</span> score_type <span class="op">==</span> <span class="st">'energy'</span>:</span>
<span id="cb26-43"><a href="#cb26-43" tabindex="-1"></a>            ood_classifications <span class="op">=</span> np.where(ood_scores <span class="op">&gt;=</span> threshold, <span class="op">-</span><span class="dv">1</span>, ood_predictions)</span>
<span id="cb26-44"><a href="#cb26-44" tabindex="-1"></a>            id_classifications <span class="op">=</span> np.where(id_scores <span class="op">&gt;=</span> threshold, <span class="op">-</span><span class="dv">1</span>, id_predictions)</span>
<span id="cb26-45"><a href="#cb26-45" tabindex="-1"></a>        <span class="cf">elif</span> score_type <span class="op">==</span> <span class="st">'softmax'</span>:</span>
<span id="cb26-46"><a href="#cb26-46" tabindex="-1"></a>            ood_classifications <span class="op">=</span> np.where(ood_scores <span class="op">&lt;=</span> threshold, <span class="op">-</span><span class="dv">1</span>, ood_predictions)</span>
<span id="cb26-47"><a href="#cb26-47" tabindex="-1"></a>            id_classifications <span class="op">=</span> np.where(id_scores <span class="op">&lt;=</span> threshold, <span class="op">-</span><span class="dv">1</span>, id_predictions)</span>
<span id="cb26-48"><a href="#cb26-48" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb26-49"><a href="#cb26-49" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Invalid score_type. Use 'energy' or 'softmax'."</span>)</span>
<span id="cb26-50"><a href="#cb26-50" tabindex="-1"></a></span>
<span id="cb26-51"><a href="#cb26-51" tabindex="-1"></a>        <span class="co"># Combine OOD and ID classifications and true labels</span></span>
<span id="cb26-52"><a href="#cb26-52" tabindex="-1"></a>        all_predictions <span class="op">=</span> np.concatenate([ood_classifications, id_classifications])</span>
<span id="cb26-53"><a href="#cb26-53" tabindex="-1"></a>        all_true_labels <span class="op">=</span> np.concatenate([ood_true_labels, id_true_labels])</span>
<span id="cb26-54"><a href="#cb26-54" tabindex="-1"></a></span>
<span id="cb26-55"><a href="#cb26-55" tabindex="-1"></a>        <span class="co"># Evaluate metrics</span></span>
<span id="cb26-56"><a href="#cb26-56" tabindex="-1"></a>        precision, recall, f1, _ <span class="op">=</span> precision_recall_fscore_support(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>], average<span class="op">=</span><span class="st">'macro'</span>, zero_division<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb26-57"><a href="#cb26-57" tabindex="-1"></a>        accuracy <span class="op">=</span> accuracy_score(all_true_labels, all_predictions)</span>
<span id="cb26-58"><a href="#cb26-58" tabindex="-1"></a></span>
<span id="cb26-59"><a href="#cb26-59" tabindex="-1"></a>        accuracies.append(accuracy)</span>
<span id="cb26-60"><a href="#cb26-60" tabindex="-1"></a>        precisions.append(precision)</span>
<span id="cb26-61"><a href="#cb26-61" tabindex="-1"></a>        recalls.append(recall)</span>
<span id="cb26-62"><a href="#cb26-62" tabindex="-1"></a>        f1_scores.append(f1)</span>
<span id="cb26-63"><a href="#cb26-63" tabindex="-1"></a></span>
<span id="cb26-64"><a href="#cb26-64" tabindex="-1"></a>    <span class="co"># Find the best thresholds for each metric</span></span>
<span id="cb26-65"><a href="#cb26-65" tabindex="-1"></a>    best_f1_index <span class="op">=</span> np.argmax(f1_scores)</span>
<span id="cb26-66"><a href="#cb26-66" tabindex="-1"></a>    best_f1_threshold <span class="op">=</span> thresholds[best_f1_index]</span>
<span id="cb26-67"><a href="#cb26-67" tabindex="-1"></a></span>
<span id="cb26-68"><a href="#cb26-68" tabindex="-1"></a>    best_precision_index <span class="op">=</span> np.argmax(precisions)</span>
<span id="cb26-69"><a href="#cb26-69" tabindex="-1"></a>    best_precision_threshold <span class="op">=</span> thresholds[best_precision_index]</span>
<span id="cb26-70"><a href="#cb26-70" tabindex="-1"></a></span>
<span id="cb26-71"><a href="#cb26-71" tabindex="-1"></a>    best_recall_index <span class="op">=</span> np.argmax(recalls)</span>
<span id="cb26-72"><a href="#cb26-72" tabindex="-1"></a>    best_recall_threshold <span class="op">=</span> thresholds[best_recall_index]</span>
<span id="cb26-73"><a href="#cb26-73" tabindex="-1"></a></span>
<span id="cb26-74"><a href="#cb26-74" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best F1 threshold: </span><span class="sc">{</span>best_f1_threshold<span class="sc">}</span><span class="ss">, F1 Score: </span><span class="sc">{</span>f1_scores[best_f1_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-75"><a href="#cb26-75" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Precision threshold: </span><span class="sc">{</span>best_precision_threshold<span class="sc">}</span><span class="ss">, Precision: </span><span class="sc">{</span>precisions[best_precision_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-76"><a href="#cb26-76" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Recall threshold: </span><span class="sc">{</span>best_recall_threshold<span class="sc">}</span><span class="ss">, Recall: </span><span class="sc">{</span>recalls[best_recall_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-77"><a href="#cb26-77" tabindex="-1"></a></span>
<span id="cb26-78"><a href="#cb26-78" tabindex="-1"></a>    <span class="co"># Plot metrics as functions of the threshold</span></span>
<span id="cb26-79"><a href="#cb26-79" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb26-80"><a href="#cb26-80" tabindex="-1"></a>    plt.plot(thresholds, precisions, label<span class="op">=</span><span class="st">'Precision'</span>, color<span class="op">=</span><span class="st">'g'</span>)</span>
<span id="cb26-81"><a href="#cb26-81" tabindex="-1"></a>    plt.plot(thresholds, recalls, label<span class="op">=</span><span class="st">'Recall'</span>, color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb26-82"><a href="#cb26-82" tabindex="-1"></a>    plt.plot(thresholds, f1_scores, label<span class="op">=</span><span class="st">'F1 Score'</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb26-83"><a href="#cb26-83" tabindex="-1"></a></span>
<span id="cb26-84"><a href="#cb26-84" tabindex="-1"></a>    <span class="co"># Add best threshold indicators</span></span>
<span id="cb26-85"><a href="#cb26-85" tabindex="-1"></a>    plt.axvline(x<span class="op">=</span>best_f1_threshold, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best F1 Threshold: </span><span class="sc">{</span>best_f1_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb26-86"><a href="#cb26-86" tabindex="-1"></a>    plt.axvline(x<span class="op">=</span>best_precision_threshold, color<span class="op">=</span><span class="st">'g'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best Precision Threshold: </span><span class="sc">{</span>best_precision_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb26-87"><a href="#cb26-87" tabindex="-1"></a>    plt.axvline(x<span class="op">=</span>best_recall_threshold, color<span class="op">=</span><span class="st">'b'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best Recall Threshold: </span><span class="sc">{</span>best_recall_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb26-88"><a href="#cb26-88" tabindex="-1"></a></span>
<span id="cb26-89"><a href="#cb26-89" tabindex="-1"></a>    plt.xlabel(<span class="st">'Threshold'</span>)</span>
<span id="cb26-90"><a href="#cb26-90" tabindex="-1"></a>    plt.ylabel(<span class="st">'Metric Value'</span>)</span>
<span id="cb26-91"><a href="#cb26-91" tabindex="-1"></a>    plt.title(<span class="ss">f'Evaluation Metrics as Functions of Threshold (</span><span class="sc">{</span>score_type<span class="sc">.</span>capitalize()<span class="sc">}</span><span class="ss">-Based OOD Detection)'</span>)</span>
<span id="cb26-92"><a href="#cb26-92" tabindex="-1"></a>    plt.legend()</span>
<span id="cb26-93"><a href="#cb26-93" tabindex="-1"></a>    plt.show()</span>
<span id="cb26-94"><a href="#cb26-94" tabindex="-1"></a></span>
<span id="cb26-95"><a href="#cb26-95" tabindex="-1"></a>    <span class="co"># plot confusion matrix</span></span>
<span id="cb26-96"><a href="#cb26-96" tabindex="-1"></a></span>
<span id="cb26-97"><a href="#cb26-97" tabindex="-1"></a>    <span class="co"># Threshold value for the energy score</span></span>
<span id="cb26-98"><a href="#cb26-98" tabindex="-1"></a>    upper_threshold <span class="op">=</span> best_f1_threshold  <span class="co"># Using the best F1 threshold from the previous calculation</span></span>
<span id="cb26-99"><a href="#cb26-99" tabindex="-1"></a></span>
<span id="cb26-100"><a href="#cb26-100" tabindex="-1"></a>    <span class="co"># Classifying OOD examples based on energy scores</span></span>
<span id="cb26-101"><a href="#cb26-101" tabindex="-1"></a>    ood_classifications <span class="op">=</span> np.where(ood_energy_scores <span class="op">&gt;=</span> upper_threshold, <span class="op">-</span><span class="dv">1</span>,  <span class="co"># classified as OOD</span></span>
<span id="cb26-102"><a href="#cb26-102" tabindex="-1"></a>                                  np.where(ood_energy_scores <span class="op">&lt;</span> upper_threshold, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>))  <span class="co"># classified as ID</span></span>
<span id="cb26-103"><a href="#cb26-103" tabindex="-1"></a></span>
<span id="cb26-104"><a href="#cb26-104" tabindex="-1"></a>    <span class="co"># Classifying ID examples based on energy scores</span></span>
<span id="cb26-105"><a href="#cb26-105" tabindex="-1"></a>    id_classifications <span class="op">=</span> np.where(id_energy_scores <span class="op">&gt;=</span> upper_threshold, <span class="op">-</span><span class="dv">1</span>,  <span class="co"># classified as OOD</span></span>
<span id="cb26-106"><a href="#cb26-106" tabindex="-1"></a>                                  np.where(id_energy_scores <span class="op">&lt;</span> upper_threshold, id_true_labels, <span class="op">-</span><span class="dv">1</span>))  <span class="co"># classified as ID</span></span>
<span id="cb26-107"><a href="#cb26-107" tabindex="-1"></a></span>
<span id="cb26-108"><a href="#cb26-108" tabindex="-1"></a>    <span class="co"># Combine OOD and ID classifications and true labels</span></span>
<span id="cb26-109"><a href="#cb26-109" tabindex="-1"></a>    all_predictions <span class="op">=</span> np.concatenate([ood_classifications, id_classifications])</span>
<span id="cb26-110"><a href="#cb26-110" tabindex="-1"></a>    all_true_labels <span class="op">=</span> np.concatenate([ood_true_labels, id_true_labels])</span>
<span id="cb26-111"><a href="#cb26-111" tabindex="-1"></a></span>
<span id="cb26-112"><a href="#cb26-112" tabindex="-1"></a>    <span class="co"># Confusion matrix</span></span>
<span id="cb26-113"><a href="#cb26-113" tabindex="-1"></a>    cm <span class="op">=</span> confusion_matrix(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb26-114"><a href="#cb26-114" tabindex="-1"></a></span>
<span id="cb26-115"><a href="#cb26-115" tabindex="-1"></a>    <span class="co"># Plotting the confusion matrix</span></span>
<span id="cb26-116"><a href="#cb26-116" tabindex="-1"></a>    disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>cm, display_labels<span class="op">=</span>[<span class="st">"Shirt"</span>, <span class="st">"Pants"</span>, <span class="st">"OOD"</span>])</span>
<span id="cb26-117"><a href="#cb26-117" tabindex="-1"></a>    disp.plot(cmap<span class="op">=</span>plt.cm.Blues)</span>
<span id="cb26-118"><a href="#cb26-118" tabindex="-1"></a>    plt.title(<span class="st">'Confusion Matrix for OOD and ID Classification (Energy-Based)'</span>)</span>
<span id="cb26-119"><a href="#cb26-119" tabindex="-1"></a>    plt.show()</span>
<span id="cb26-120"><a href="#cb26-120" tabindex="-1"></a></span>
<span id="cb26-121"><a href="#cb26-121" tabindex="-1"></a></span>
<span id="cb26-122"><a href="#cb26-122" tabindex="-1"></a>    <span class="cf">return</span> best_f1_threshold, best_precision_threshold, best_recall_threshold</span>
<span id="cb26-123"><a href="#cb26-123" tabindex="-1"></a></span>
<span id="cb26-124"><a href="#cb26-124" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb26-125"><a href="#cb26-125" tabindex="-1"></a><span class="co"># Assuming id_energy_scores, ood_energy_scores, id_true_labels, and test_labels are already defined</span></span>
<span id="cb26-126"><a href="#cb26-126" tabindex="-1"></a>best_f1_threshold, best_precision_threshold, best_recall_threshold <span class="op">=</span> evaluate_ood_detection(id_energy_scores, ood_energy_scores, id_true_labels, test_labels, score_type<span class="op">=</span><span class="st">'energy'</span>)</span>
<span id="cb26-127"><a href="#cb26-127" tabindex="-1"></a>best_f1_threshold, best_precision_threshold, best_recall_threshold <span class="op">=</span> evaluate_ood_detection(id_softmax_scores[:,<span class="dv">0</span>], ood_softmax_scores[:,<span class="dv">0</span>], id_true_labels, test_labels, score_type<span class="op">=</span><span class="st">'softmax'</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb27">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>ood_softmax_scores[:,<span class="dv">0</span>].shape</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb28">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb29">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> confusion_matrix, ConfusionMatrixDisplay</span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a><span class="co"># Threshold value for the energy score</span></span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a>upper_threshold <span class="op">=</span> best_f1_threshold  <span class="co"># Using the best F1 threshold from the previous calculation</span></span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a><span class="co"># Classifying OOD examples based on energy scores</span></span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a>ood_classifications <span class="op">=</span> np.where(ood_energy_scores <span class="op">&gt;=</span> upper_threshold, <span class="op">-</span><span class="dv">1</span>,  <span class="co"># classified as OOD</span></span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a>                               np.where(ood_energy_scores <span class="op">&lt;</span> upper_threshold, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>))  <span class="co"># classified as ID</span></span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a></span>
<span id="cb29-12"><a href="#cb29-12" tabindex="-1"></a><span class="co"># Classifying ID examples based on energy scores</span></span>
<span id="cb29-13"><a href="#cb29-13" tabindex="-1"></a>id_classifications <span class="op">=</span> np.where(id_energy_scores <span class="op">&gt;=</span> upper_threshold, <span class="op">-</span><span class="dv">1</span>,  <span class="co"># classified as OOD</span></span>
<span id="cb29-14"><a href="#cb29-14" tabindex="-1"></a>                              np.where(id_energy_scores <span class="op">&lt;</span> upper_threshold, id_true_labels, <span class="op">-</span><span class="dv">1</span>))  <span class="co"># classified as ID</span></span>
<span id="cb29-15"><a href="#cb29-15" tabindex="-1"></a></span>
<span id="cb29-16"><a href="#cb29-16" tabindex="-1"></a><span class="co"># Combine OOD and ID classifications and true labels</span></span>
<span id="cb29-17"><a href="#cb29-17" tabindex="-1"></a>all_predictions <span class="op">=</span> np.concatenate([ood_classifications, id_classifications])</span>
<span id="cb29-18"><a href="#cb29-18" tabindex="-1"></a>all_true_labels <span class="op">=</span> np.concatenate([ood_true_labels, id_true_labels])</span>
<span id="cb29-19"><a href="#cb29-19" tabindex="-1"></a></span>
<span id="cb29-20"><a href="#cb29-20" tabindex="-1"></a><span class="co"># Confusion matrix</span></span>
<span id="cb29-21"><a href="#cb29-21" tabindex="-1"></a>cm <span class="op">=</span> confusion_matrix(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb29-22"><a href="#cb29-22" tabindex="-1"></a></span>
<span id="cb29-23"><a href="#cb29-23" tabindex="-1"></a><span class="co"># Plotting the confusion matrix</span></span>
<span id="cb29-24"><a href="#cb29-24" tabindex="-1"></a>disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>cm, display_labels<span class="op">=</span>[<span class="st">"Shirt"</span>, <span class="st">"Pants"</span>, <span class="st">"OOD"</span>])</span>
<span id="cb29-25"><a href="#cb29-25" tabindex="-1"></a>disp.plot(cmap<span class="op">=</span>plt.cm.Blues)</span>
<span id="cb29-26"><a href="#cb29-26" tabindex="-1"></a>plt.title(<span class="st">'Confusion Matrix for OOD and ID Classification (Energy-Based)'</span>)</span>
<span id="cb29-27"><a href="#cb29-27" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
</div>
</div>
<div class="section level1">
<h1 id="limitations-of-our-approach-thus-far">Limitations of our approach thus far<a class="anchor" aria-label="anchor" href="#limitations-of-our-approach-thus-far"></a>
</h1>
<ul>
<li>Focus on single OOD class: More reliable/accurate thresholds
can/should be obtained using a wider variety (more classes) and larger
sample of OOD data. This is part of the challenge of OOD detection which
is that space of OOD data is vast. <strong>Possible exercise</strong>:
Redo thresholding using all remaining classes in dataset.</li>
</ul>
<div class="section level2">
<h2 id="references-and-supplemental-resources">References and supplemental resources<a class="anchor" aria-label="anchor" href="#references-and-supplemental-resources"></a>
</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=hgLC9_9ZCJI" class="external-link uri">https://www.youtube.com/watch?v=hgLC9_9ZCJI</a></li>
<li>Generalized Out-of-Distribution Detection: A Survey: <a href="https://arxiv.org/abs/2110.11334" class="external-link uri">https://arxiv.org/abs/2110.11334</a>
</li>
</ul>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div></section><section id="aio-7b-OOD-detection-distance-based"><p>Content from <a href="7b-OOD-detection-distance-based.html">OOD detection: distance-based and contrastive learning</a></p>
<hr>
<p>Last updated on 2024-08-14 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/7b-OOD-detection-distance-based.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How do distance-based methods like Mahalanobis distance and KNN work
for OOD detection?</li>
<li>What is contrastive learning and how does it improve feature
representations?</li>
<li>How does contrastive learning enhance the effectiveness of
distance-based OOD detection methods?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Gain a thorough understanding of distance-based OOD detection
methods, including Mahalanobis distance and KNN.</li>
<li>Learn the principles of contrastive learning and its role in
improving feature representations.</li>
<li>Explore the synergy between contrastive learning and distance-based
OOD detection methods to enhance detection performance.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="example-3-distance-based-methods">Example 3: Distance-Based Methods<a class="anchor" aria-label="anchor" href="#example-3-distance-based-methods"></a>
</h1>
<p><em>Lee et al., A simple unified framework for detecting
out-of-distribution samples and adversarial attacks. NeurIPS
2018.</em></p>
<p>With softmax and energy-based methods, we focus on the models outputs
to determine a threshold that defines ID and OOD data. With
distance-based methods, we focus on the feature representations learned
by the model.</p>
<p>In the case of neural networks, a common approach is to use the
penultimate layer as a feature representation that can define an ID
clusters for each class. You can then use distance to the closesent
centroid as a proxy for OOD measure.</p>
<div class="section level2">
<h2 id="mahalanobis-distance-parametric">Mahalanobis distance (parametric)<a class="anchor" aria-label="anchor" href="#mahalanobis-distance-parametric"></a>
</h2>
<p>Model the feature space as a mixture of multivariate Gaussian
distribution, one for each class. use distance to the closest centroid
as proxy for OOD measure</p>
<div class="section level3">
<h3 id="limiations-of-parametric-approach">Limiations of parametric approach<a class="anchor" aria-label="anchor" href="#limiations-of-parametric-approach"></a>
</h3>
<ul>
<li>Strong distributional assumption (features may not necessarily be
Gassian-distributed)</li>
<li>Suboptimal embedding</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="nearest-neighbor-distance-non-parametric">Nearest Neighbor Distance (non-parametric)<a class="anchor" aria-label="anchor" href="#nearest-neighbor-distance-non-parametric"></a>
</h2>
<p><em>Sun et al., Out-of-distribution Detection with Deep Nearest
Neighbors, ICML 2022</em></p>
<ul>
<li>Sample considered OOD if it has a large KNN distrance w.r.t.
training data (and vice versa)</li>
<li>No distributional assumptions about underlying embedding space.
Stronger generality and flexibility than mahalanobis distancew</li>
</ul>
</div>
<div class="section level2">
<h2 id="cider">CIDER<a class="anchor" aria-label="anchor" href="#cider"></a>
</h2>
<p>This one might be out of scope…</p>
<p>Ming et al., How to Exploit Hyperspherical Embeddings for
Out-of-Distribution Detection # Contrastive Learning</p>
<ul>
<li>Explain the basic idea of contrastive learning: learning
representations by contrasting positive and negative pairs.</li>
<li>Highlight the role of contrastive learning in learning
discriminative features that can separate in-distribution (ID) from OOD
data more effectively.</li>
<li>Illustrate how contrastive learning improves the feature space,
making distance-based methods (like Mahalanobis and KNN) more
effective.</li>
<li>Provide examples or case studies where contrastive learning has been
applied to enhance OOD detection. # Example X: Comparing feature
representations with and without contrastive learning</li>
</ul>
</div>
<div class="section level2">
<h2 id="returning-to-umap">Returning to UMAP<a class="anchor" aria-label="anchor" href="#returning-to-umap"></a>
</h2>
<p>Notice how in our UMAP visualization, we say three distinct clusters
representing each class. However, our model still confidently rated many
sandals as being tshirts. The crux of this issue is that models do not
know what they don’t know. They simply draw classifcation boundaries
between the classes available to them during training.</p>
<p>One way to get around this problem is to train models to learn
discriminative features…</p>
</div>
<div class="section level2">
<h2 id="contrastive-learning">Contrastive learning<a class="anchor" aria-label="anchor" href="#contrastive-learning"></a>
</h2>
<p>In this experiment, we use both a traditional neural network and a
contrastive learning model to classify images from the Fashion MNIST
dataset, focusing on T-shirts (class 0) and Trousers (class 1).
Additionally, we evaluate the models on out-of-distribution (OOD) data,
specifically Sandals (class 5). To visualize the models’ learned
features, we extract features from specific layers of the neural
networks and reduce their dimensionality using UMAP.</p>
</div>
<div class="section level2">
<h2 id="overview-of-steps">Overview of steps<a class="anchor" aria-label="anchor" href="#overview-of-steps"></a>
</h2>
<div class="section level4">
<h4 id="train-model">1) Train model<a class="anchor" aria-label="anchor" href="#train-model"></a>
</h4>
<ul>
<li>With or without contrastive learning</li>
<li>Focusing on T-shirts (class 0) and Trousers (class 1)</li>
<li>Additionally, we evaluate the models on out-of-distribution (OOD)
data, specifically Sandals (class 5)</li>
</ul>
</div>
<div class="section level4">
<h4 id="feature-extraction">2) Feature Extraction:<a class="anchor" aria-label="anchor" href="#feature-extraction"></a>
</h4>
<ul>
<li>After training, we set the models to evaluation mode to prevent
updates to the model parameters.</li>
<li>For each subset of the data (training, validation, and OOD), we pass
the images through the entire network up to the first fully connected
layer.</li>
<li>The output of this layer, which captures high-level features and
abstractions, is then used as a 1D feature vector.</li>
<li>These feature vectors are detached from the computational graph and
converted to NumPy arrays for further processing.</li>
</ul>
</div>
<div class="section level4">
<h4 id="dimensionality-reduction-and-visualization">3) Dimensionality Reduction and Visualization:<a class="anchor" aria-label="anchor" href="#dimensionality-reduction-and-visualization"></a>
</h4>
<ul>
<li>We combine the feature vectors from the training, validation, and
OOD data into a single dataset.</li>
<li>UMAP (Uniform Manifold Approximation and Projection) is used to
reduce the dimensionality of the feature vectors from the
high-dimensional space to 2D, making it possible to visualize the
relationships between different data points.</li>
<li>The reduced features are then plotted, with different colors
representing the training data (T-shirts and Trousers), validation data
(T-shirts and Trousers), and OOD data (Sandals).</li>
</ul>
<p>By visualizing the features generated from different subsets of the
data, we can observe how well the models have learned to distinguish
between in-distribution classes (T-shirts and Trousers) and handle OOD
data (Sandals). This approach allows us to evaluate the robustness and
generalization capabilities of the models in dealing with data that may
not have been seen during training. ## Standard neural network w/out
contrastive learning</p>
</div>
<div class="section level3">
<h3 id="train-model-1">1) Train model<a class="anchor" aria-label="anchor" href="#train-model-1"></a>
</h3>
<p>We’ll first train our vanilla CNN w/out contrastive learning.</p>
<ul>
<li>Focusing on T-shirts (class 0) and Trousers (class 1)</li>
<li>Additionally, we evaluate the models on out-of-distribution (OOD)
data, specifically Sandals (class 5)</li>
</ul>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> accuracy_score</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="im">from</span> torchvision <span class="im">import</span> datasets, transforms</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> DataLoader, Subset, Dataset</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="co"># Check if GPU is available and set device</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Using device: </span><span class="sc">{</span>device<span class="sc">}</span><span class="ss">'</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Define a simple CNN model for classification</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="kw">class</span> ClassificationModel(nn.Module):</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>        <span class="bu">super</span>(ClassificationModel, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>        <span class="va">self</span>.conv1 <span class="op">=</span> nn.Conv2d(<span class="dv">1</span>, <span class="dv">32</span>, kernel_size<span class="op">=</span><span class="dv">3</span>, stride<span class="op">=</span><span class="dv">1</span>, padding<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>        <span class="va">self</span>.relu <span class="op">=</span> nn.ReLU()</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>        <span class="va">self</span>.flatten <span class="op">=</span> nn.Flatten()</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>        <span class="va">self</span>.fc1 <span class="op">=</span> nn.Linear(<span class="dv">32</span> <span class="op">*</span> <span class="dv">28</span> <span class="op">*</span> <span class="dv">28</span>, <span class="dv">128</span>)</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>        <span class="va">self</span>.fc2 <span class="op">=</span> nn.Linear(<span class="dv">128</span>, <span class="dv">2</span>)  <span class="co"># 2 classes for T-shirts and Trousers</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.conv1(x)</span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.relu(x)</span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.flatten(x)</span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.fc1(x)</span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.relu(x)</span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.fc2(x)</span>
<span id="cb2-18"><a href="#cb2-18" tabindex="-1"></a>        <span class="cf">return</span> x</span>
<span id="cb2-19"><a href="#cb2-19" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" tabindex="-1"></a><span class="co"># Load Fashion MNIST dataset and filter for T-shirts and Trousers</span></span>
<span id="cb2-21"><a href="#cb2-21" tabindex="-1"></a>transform <span class="op">=</span> transforms.Compose([transforms.ToTensor()])</span>
<span id="cb2-22"><a href="#cb2-22" tabindex="-1"></a>train_dataset <span class="op">=</span> datasets.FashionMNIST(root<span class="op">=</span><span class="st">'./data'</span>, train<span class="op">=</span><span class="va">True</span>, download<span class="op">=</span><span class="va">True</span>, transform<span class="op">=</span>transform)</span>
<span id="cb2-23"><a href="#cb2-23" tabindex="-1"></a>test_dataset <span class="op">=</span> datasets.FashionMNIST(root<span class="op">=</span><span class="st">'./data'</span>, train<span class="op">=</span><span class="va">False</span>, download<span class="op">=</span><span class="va">True</span>, transform<span class="op">=</span>transform)</span>
<span id="cb2-24"><a href="#cb2-24" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" tabindex="-1"></a>train_indices <span class="op">=</span> np.where((train_dataset.targets <span class="op">==</span> <span class="dv">0</span>) <span class="op">|</span> (train_dataset.targets <span class="op">==</span> <span class="dv">1</span>))[<span class="dv">0</span>]</span>
<span id="cb2-26"><a href="#cb2-26" tabindex="-1"></a>val_indices <span class="op">=</span> np.where((test_dataset.targets <span class="op">==</span> <span class="dv">0</span>) <span class="op">|</span> (test_dataset.targets <span class="op">==</span> <span class="dv">1</span>))[<span class="dv">0</span>]</span>
<span id="cb2-27"><a href="#cb2-27" tabindex="-1"></a>ood_indices <span class="op">=</span> np.where(test_dataset.targets <span class="op">==</span> <span class="dv">5</span>)[<span class="dv">0</span>]</span>
<span id="cb2-28"><a href="#cb2-28" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" tabindex="-1"></a><span class="co"># Use a subset of the data for quicker training</span></span>
<span id="cb2-30"><a href="#cb2-30" tabindex="-1"></a>train_subset <span class="op">=</span> Subset(train_dataset, np.random.choice(train_indices, size<span class="op">=</span><span class="dv">5000</span>, replace<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb2-31"><a href="#cb2-31" tabindex="-1"></a>val_subset <span class="op">=</span> Subset(test_dataset, np.random.choice(val_indices, size<span class="op">=</span><span class="dv">1000</span>, replace<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb2-32"><a href="#cb2-32" tabindex="-1"></a>ood_subset <span class="op">=</span> Subset(test_dataset, np.random.choice(ood_indices, size<span class="op">=</span><span class="dv">1000</span>, replace<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb2-33"><a href="#cb2-33" tabindex="-1"></a></span>
<span id="cb2-34"><a href="#cb2-34" tabindex="-1"></a>train_loader <span class="op">=</span> DataLoader(train_subset, batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-35"><a href="#cb2-35" tabindex="-1"></a>val_loader <span class="op">=</span> DataLoader(val_subset, batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-36"><a href="#cb2-36" tabindex="-1"></a>ood_loader <span class="op">=</span> DataLoader(ood_subset, batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-37"><a href="#cb2-37" tabindex="-1"></a></span>
<span id="cb2-38"><a href="#cb2-38" tabindex="-1"></a><span class="co"># Initialize the model and move it to the device</span></span>
<span id="cb2-39"><a href="#cb2-39" tabindex="-1"></a>classification_model <span class="op">=</span> ClassificationModel().to(device)</span>
<span id="cb2-40"><a href="#cb2-40" tabindex="-1"></a></span>
<span id="cb2-41"><a href="#cb2-41" tabindex="-1"></a><span class="co"># Loss function and optimizer</span></span>
<span id="cb2-42"><a href="#cb2-42" tabindex="-1"></a>criterion <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb2-43"><a href="#cb2-43" tabindex="-1"></a>optimizer <span class="op">=</span> optim.Adam(classification_model.parameters(), lr<span class="op">=</span><span class="fl">0.001</span>)</span>
<span id="cb2-44"><a href="#cb2-44" tabindex="-1"></a></span>
<span id="cb2-45"><a href="#cb2-45" tabindex="-1"></a><span class="co"># Training loop for standard neural network</span></span>
<span id="cb2-46"><a href="#cb2-46" tabindex="-1"></a>train_losses <span class="op">=</span> []</span>
<span id="cb2-47"><a href="#cb2-47" tabindex="-1"></a>val_losses <span class="op">=</span> []</span>
<span id="cb2-48"><a href="#cb2-48" tabindex="-1"></a></span>
<span id="cb2-49"><a href="#cb2-49" tabindex="-1"></a><span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(n_epochs):</span>
<span id="cb2-50"><a href="#cb2-50" tabindex="-1"></a>    total_train_loss <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-51"><a href="#cb2-51" tabindex="-1"></a>    classification_model.train()</span>
<span id="cb2-52"><a href="#cb2-52" tabindex="-1"></a>    <span class="cf">for</span> batch_images, batch_labels <span class="kw">in</span> train_loader:</span>
<span id="cb2-53"><a href="#cb2-53" tabindex="-1"></a>        batch_images, batch_labels <span class="op">=</span> batch_images.to(device), batch_labels.to(device)</span>
<span id="cb2-54"><a href="#cb2-54" tabindex="-1"></a></span>
<span id="cb2-55"><a href="#cb2-55" tabindex="-1"></a>        optimizer.zero_grad()</span>
<span id="cb2-56"><a href="#cb2-56" tabindex="-1"></a>        outputs <span class="op">=</span> classification_model(batch_images)</span>
<span id="cb2-57"><a href="#cb2-57" tabindex="-1"></a>        loss <span class="op">=</span> criterion(outputs, batch_labels)</span>
<span id="cb2-58"><a href="#cb2-58" tabindex="-1"></a></span>
<span id="cb2-59"><a href="#cb2-59" tabindex="-1"></a>        loss.backward()</span>
<span id="cb2-60"><a href="#cb2-60" tabindex="-1"></a>        optimizer.step()</span>
<span id="cb2-61"><a href="#cb2-61" tabindex="-1"></a></span>
<span id="cb2-62"><a href="#cb2-62" tabindex="-1"></a>        total_train_loss <span class="op">+=</span> loss.item()</span>
<span id="cb2-63"><a href="#cb2-63" tabindex="-1"></a></span>
<span id="cb2-64"><a href="#cb2-64" tabindex="-1"></a>    total_val_loss <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-65"><a href="#cb2-65" tabindex="-1"></a>    classification_model.<span class="bu">eval</span>()</span>
<span id="cb2-66"><a href="#cb2-66" tabindex="-1"></a>    <span class="cf">with</span> torch.no_grad():</span>
<span id="cb2-67"><a href="#cb2-67" tabindex="-1"></a>        <span class="cf">for</span> batch_images, batch_labels <span class="kw">in</span> val_loader:</span>
<span id="cb2-68"><a href="#cb2-68" tabindex="-1"></a>            batch_images, batch_labels <span class="op">=</span> batch_images.to(device), batch_labels.to(device)</span>
<span id="cb2-69"><a href="#cb2-69" tabindex="-1"></a>            outputs <span class="op">=</span> classification_model(batch_images)</span>
<span id="cb2-70"><a href="#cb2-70" tabindex="-1"></a>            loss <span class="op">=</span> criterion(outputs, batch_labels)</span>
<span id="cb2-71"><a href="#cb2-71" tabindex="-1"></a>            total_val_loss <span class="op">+=</span> loss.item()</span>
<span id="cb2-72"><a href="#cb2-72" tabindex="-1"></a></span>
<span id="cb2-73"><a href="#cb2-73" tabindex="-1"></a>    avg_train_loss <span class="op">=</span> total_train_loss <span class="op">/</span> <span class="bu">len</span>(train_loader)</span>
<span id="cb2-74"><a href="#cb2-74" tabindex="-1"></a>    avg_val_loss <span class="op">=</span> total_val_loss <span class="op">/</span> <span class="bu">len</span>(val_loader)</span>
<span id="cb2-75"><a href="#cb2-75" tabindex="-1"></a>    train_losses.append(avg_train_loss)</span>
<span id="cb2-76"><a href="#cb2-76" tabindex="-1"></a>    val_losses.append(avg_val_loss)</span>
<span id="cb2-77"><a href="#cb2-77" tabindex="-1"></a></span>
<span id="cb2-78"><a href="#cb2-78" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'Epoch </span><span class="sc">{</span>epoch <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">, Train Loss: </span><span class="sc">{</span>avg_train_loss<span class="sc">:.4f}</span><span class="ss">, Val Loss: </span><span class="sc">{</span>avg_val_loss<span class="sc">:.4f}</span><span class="ss">'</span>)</span>
<span id="cb2-79"><a href="#cb2-79" tabindex="-1"></a></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># Plot training and validation loss</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">1</span>, n_epochs <span class="op">+</span> <span class="dv">1</span>), train_losses, label<span class="op">=</span><span class="st">'Train Loss'</span>)</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">1</span>, n_epochs <span class="op">+</span> <span class="dv">1</span>), val_losses, label<span class="op">=</span><span class="st">'Validation Loss'</span>)</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>plt.xlabel(<span class="st">'Epoch'</span>)</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>plt.ylabel(<span class="st">'Loss'</span>)</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>plt.title(<span class="st">'Training and Validation Loss - Classification Model'</span>)</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>plt.legend()</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="extracting-learned-features">2) Extracting learned features<a class="anchor" aria-label="anchor" href="#extracting-learned-features"></a>
</h3>
<ul>
<li>After training, we set the models to evaluation mode to prevent
updates to the model parameters.</li>
<li>For each subset of the data (training, validation, and OOD), we pass
the images through the entire network up to the first fully connected
layer.</li>
<li>The output of this layer, which captures high-level features and
abstractions, is then used as a 1D feature vector.</li>
<li>These feature vectors are detached from the computational graph and
converted to NumPy arrays for further processing.</li>
</ul>
<div class="section level4">
<h4 id="why-later-layer-features-are-better">Why later layer features are better<a class="anchor" aria-label="anchor" href="#why-later-layer-features-are-better"></a>
</h4>
<p>In both the traditional neural network and the contrastive learning
model, we will extract features from the first fully connected layer
(fc1) before the final classification layer. Here’s why this layer is
particularly suitable for feature extraction:</p>
<ul>
<li><p><strong>Hierarchical feature representation</strong>: In neural
networks, the initial layers typically capture low-level features such
as edges, textures, and simple shapes (e.g., with CNNs). As you move
deeper into the network, the layers capture higher-level, more abstract
features that are more relevant for the final classification task. These
high-level features are combinations of the low-level features and are
typically more discriminative.</p></li>
<li><p><strong>Better separation of classes</strong>: Features from
later layers have been transformed through several layers of non-linear
activations and pooling operations, making them more suitable for
distinguishing between classes. These features are usually more compact
and have a better separation in the feature space, which helps in
visualization and understanding the model’s decision-making
process.</p></li>
</ul>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Extract features using the trained classification model</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>classification_model.<span class="bu">eval</span>()</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>train_features <span class="op">=</span> []</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>train_labels_list <span class="op">=</span> []</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="cf">for</span> batch_images, batch_labels <span class="kw">in</span> train_loader:</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>    batch_images <span class="op">=</span> batch_images.to(device)</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>    features <span class="op">=</span> classification_model.fc1(classification_model.flatten(classification_model.conv1(batch_images)))</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>    train_features.append(features.detach().cpu().numpy())</span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>    train_labels_list.append(batch_labels.numpy())</span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a>val_features <span class="op">=</span> []</span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a>val_labels_list <span class="op">=</span> []</span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a><span class="cf">for</span> batch_images, batch_labels <span class="kw">in</span> val_loader:</span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a>    batch_images <span class="op">=</span> batch_images.to(device)</span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a>    features <span class="op">=</span> classification_model.fc1(classification_model.flatten(classification_model.conv1(batch_images)))</span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a>    val_features.append(features.detach().cpu().numpy())</span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a>    val_labels_list.append(batch_labels.numpy())</span>
<span id="cb4-18"><a href="#cb4-18" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" tabindex="-1"></a>ood_features <span class="op">=</span> []</span>
<span id="cb4-20"><a href="#cb4-20" tabindex="-1"></a>ood_labels_list <span class="op">=</span> []</span>
<span id="cb4-21"><a href="#cb4-21" tabindex="-1"></a><span class="cf">for</span> batch_images, batch_labels <span class="kw">in</span> ood_loader:</span>
<span id="cb4-22"><a href="#cb4-22" tabindex="-1"></a>    batch_images <span class="op">=</span> batch_images.to(device)</span>
<span id="cb4-23"><a href="#cb4-23" tabindex="-1"></a>    features <span class="op">=</span> classification_model.fc1(classification_model.flatten(classification_model.conv1(batch_images)))</span>
<span id="cb4-24"><a href="#cb4-24" tabindex="-1"></a>    ood_features.append(features.detach().cpu().numpy())</span>
<span id="cb4-25"><a href="#cb4-25" tabindex="-1"></a>    ood_labels_list.append(batch_labels.numpy())</span></code></pre>
</div>
</div>
</div>
<div class="section level3">
<h3 id="dimensionality-reduction-and-visualization-1">3) Dimensionality Reduction and Visualization:<a class="anchor" aria-label="anchor" href="#dimensionality-reduction-and-visualization-1"></a>
</h3>
<ul>
<li>We combine the feature vectors from the training, validation, and
OOD data into a single dataset.</li>
<li>UMAP (Uniform Manifold Approximation and Projection) is used to
reduce the dimensionality of the feature vectors from the
high-dimensional space to 2D, making it possible to visualize the
relationships between different data points.</li>
<li>The reduced features are then plotted, with different colors
representing the training data (T-shirts and Trousers), validation data
(T-shirts and Trousers), and OOD data (Sandals).</li>
</ul>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>train_features <span class="op">=</span> np.concatenate(train_features)</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>train_labels <span class="op">=</span> np.concatenate(train_labels_list)</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>val_features <span class="op">=</span> np.concatenate(val_features)</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>val_labels <span class="op">=</span> np.concatenate(val_labels_list)</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>ood_features <span class="op">=</span> np.concatenate(ood_features)</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>ood_labels <span class="op">=</span> np.concatenate(ood_labels_list)</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co"># Perform UMAP to visualize the classification model features</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>combined_features <span class="op">=</span> np.vstack([train_features, val_features, ood_features])</span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>combined_labels <span class="op">=</span> np.hstack([train_labels, val_labels, np.full(<span class="bu">len</span>(ood_labels), <span class="dv">2</span>)])  <span class="co"># Use 2 for OOD class</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a>umap_reducer <span class="op">=</span> umap.UMAP(n_components<span class="op">=</span><span class="dv">2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a>umap_results <span class="op">=</span> umap_reducer.fit_transform(combined_features)</span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a><span class="co"># Split the results back into train, val, and OOD data</span></span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a>umap_train_features <span class="op">=</span> umap_results[:<span class="bu">len</span>(train_features)]</span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a>umap_val_features <span class="op">=</span> umap_results[<span class="bu">len</span>(train_features):<span class="bu">len</span>(train_features) <span class="op">+</span> <span class="bu">len</span>(val_features)]</span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a>umap_ood_features <span class="op">=</span> umap_results[<span class="bu">len</span>(train_features) <span class="op">+</span> <span class="bu">len</span>(val_features):]</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># Plotting UMAP components for classification model</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">.2</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co"># Plot train T-shirts</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>scatter1 <span class="op">=</span> plt.scatter(umap_train_features[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">0</span>], umap_train_features[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span>alpha, label<span class="op">=</span><span class="st">'Train T-shirts (ID)'</span>)</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co"># Plot train Trousers</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>scatter2 <span class="op">=</span> plt.scatter(umap_train_features[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">0</span>], umap_train_features[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span>alpha, label<span class="op">=</span><span class="st">'Train Trousers (ID)'</span>)</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a><span class="co"># Plot val T-shirts</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>scatter3 <span class="op">=</span> plt.scatter(umap_val_features[val_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">0</span>], umap_val_features[val_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span>alpha, marker<span class="op">=</span><span class="st">'x'</span>, label<span class="op">=</span><span class="st">'Val T-shirts (ID)'</span>)</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a><span class="co"># Plot val Trousers</span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>scatter4 <span class="op">=</span> plt.scatter(umap_val_features[val_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">0</span>], umap_val_features[val_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span>alpha, marker<span class="op">=</span><span class="st">'x'</span>, label<span class="op">=</span><span class="st">'Val Trousers (ID)'</span>)</span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a><span class="co"># Plot OOD Sandals</span></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>scatter5 <span class="op">=</span> plt.scatter(umap_ood_features[:, <span class="dv">0</span>], umap_ood_features[:, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'green'</span>, alpha<span class="op">=</span>alpha, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">'OOD Sandals'</span>)</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[scatter1, scatter2, scatter3, scatter4, scatter5])</span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a>plt.xlabel(<span class="st">'First UMAP Component'</span>)</span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a>plt.ylabel(<span class="st">'Second UMAP Component'</span>)</span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a>plt.title(<span class="st">'UMAP of Classification Model Features'</span>)</span>
<span id="cb6-18"><a href="#cb6-18" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
</div>
</div>
<div class="section level2">
<h2 id="neural-network-trained-with-contrastive-learning">Neural network trained with contrastive learning<a class="anchor" aria-label="anchor" href="#neural-network-trained-with-contrastive-learning"></a>
</h2>
<div class="section level3">
<h3 id="what-is-contrastive-learning">What is Contrastive Learning?<a class="anchor" aria-label="anchor" href="#what-is-contrastive-learning"></a>
</h3>
<p>Contrastive learning is a technique where the model learns to
distinguish between similar and dissimilar pairs of data. This can be
achieved through different types of learning: supervised, unsupervised,
and self-supervised.</p>
<ul>
<li><p>Supervised Contrastive Learning: Uses labeled data to create
pairs or groups of similar and dissimilar data points based on their
labels.</p></li>
<li><p>Unsupervised Contrastive Learning: Does not use any labels.
Instead, it relies on inherent patterns in the data to create pairs. For
example, random pairs of data points might be assumed to be dissimilar,
while augmented versions of the same data point might be assumed to be
similar.</p></li>
<li><p>Self-Supervised Contrastive Learning: A form of unsupervised
learning where the model generates its own supervisory signal from the
data. This typically involves data augmentation techniques where
positive pairs are created by augmenting the same image (e.g., cropping,
rotating), and negative pairs are formed from different images.</p></li>
</ul>
<p>In contrastive learning, the model learns to bring similar pairs
closer in the embedding space while pushing dissimilar pairs further
apart. This approach is particularly useful for tasks like image
retrieval, clustering, and representation learning.</p>
<p>Certainly! Let’s expand on how we are treating the T-shirt, Trouser,
and Sandals classes in the context of our supervised contrastive
learning framework.</p>
</div>
<div class="section level3">
<h3 id="key-concepts-in-our-code">Key Concepts in Our Code<a class="anchor" aria-label="anchor" href="#key-concepts-in-our-code"></a>
</h3>
</div>
<div class="section level3">
<h3 id="data-preparation">Data Preparation<a class="anchor" aria-label="anchor" href="#data-preparation"></a>
</h3>
<ul>
<li>
<strong>Dataset</strong>: We use the Fashion MNIST dataset, which
contains images of various clothing items, each labeled with a specific
class.</li>
<li>
<strong>Class Filtering</strong>: For this exercise, we are focusing
on three classes from the Fashion MNIST dataset:
<ul>
<li>
<strong>T-shirts</strong> (class label 0)</li>
<li>
<strong>Trousers</strong> (class label 1)</li>
<li>
<strong>Sandals</strong> (class label 5)</li>
</ul>
</li>
<li>
<strong>In-Distribution (ID) Data</strong>: We treat T-shirts and
Trousers as our primary classes for training. These are considered
“in-distribution” data.</li>
<li>
<strong>Out-of-Distribution (OOD) Data</strong>: Sandals are treated
as a different class for testing the robustness of our learned
embeddings, making them “out-of-distribution” data.</li>
</ul>
</div>
<div class="section level3">
<h3 id="pairs-creation">Pairs Creation<a class="anchor" aria-label="anchor" href="#pairs-creation"></a>
</h3>
<p>For each image in our training set: - <strong>Positive Pair</strong>:
We find another image of the same class (either T-shirt or Trouser).
These pairs are labeled as similar. - <strong>Negative Pair</strong>: We
randomly choose an image from a different class (T-shirt paired with
Trouser or vice versa). These pairs are labeled as dissimilar.</p>
<p>By creating these pairs, the model learns to produce embeddings where
similar images (same class) are close together, and dissimilar images
(different classes) are farther apart.</p>
</div>
<div class="section level3">
<h3 id="model-architecture">Model Architecture<a class="anchor" aria-label="anchor" href="#model-architecture"></a>
</h3>
<p>The model is a simple Convolutional Neural Network (CNN) designed to
output embeddings. It consists of: - Two convolutional layers to extract
features from the images. - Fully connected layers to map these features
to a 50-dimensional embedding space.</p>
</div>
<div class="section level3">
<h3 id="training-process">Training Process<a class="anchor" aria-label="anchor" href="#training-process"></a>
</h3>
<ul>
<li>
<strong>Forward Pass</strong>: The model processes pairs of images
and outputs their embeddings.</li>
<li>
<strong>Contrastive Loss</strong>: We use a contrastive loss
function to train the model. This loss encourages embeddings of similar
pairs to be close and embeddings of dissimilar pairs to be far apart.
Specifically, we:
<ul>
<li>Normalize the embeddings.</li>
<li>Calculate similarity scores.</li>
<li>Compute the contrastive loss, which penalizes similar pairs if they
are not close enough and dissimilar pairs if they are too close.</li>
</ul>
</li>
</ul>
</div>
<div class="section level3">
<h3 id="differences-from-standard-neural-network-training">Differences from Standard Neural Network Training<a class="anchor" aria-label="anchor" href="#differences-from-standard-neural-network-training"></a>
</h3>
<ul>
<li>
<strong>Data Pairing</strong>: In contrastive learning, we create
pairs of data points. Standard neural network training typically
involves individual data points with corresponding labels.</li>
<li>
<strong>Loss Function</strong>: We use a contrastive loss function
instead of the typical cross-entropy loss used in classification tasks.
The contrastive loss is designed to optimize the relative distances
between pairs of embeddings.</li>
<li>
<strong>Supervised Learning</strong>: Our approach uses labeled data
to form similar and dissimilar pairs, making it supervised contrastive
learning. This contrasts with self-supervised or unsupervised methods
where labels are not used.</li>
</ul>
</div>
<div class="section level3">
<h3 id="specific-type-of-contrastive-learning">Specific Type of Contrastive Learning<a class="anchor" aria-label="anchor" href="#specific-type-of-contrastive-learning"></a>
</h3>
<p>The specific contrastive learning technique we are using here is a
form of <strong>supervised contrastive learning</strong>. This involves
using labeled data to create similar and dissimilar pairs of images. The
model is trained to output embeddings where a contrastive loss function
is applied to these pairs. By doing so, the model learns to map images
into an embedding space where similar images are close together, and
dissimilar images are farther apart.</p>
<p>By training with this method, the model learns robust feature
representations that are useful for various downstream tasks, even with
limited labeled data. This is powerful because it allows leveraging
labeled data to improve the model’s performance and
generalizability.</p>
</div>
<div class="section level3">
<h3 id="application-of-the-framework">Application of the Framework<a class="anchor" aria-label="anchor" href="#application-of-the-framework"></a>
</h3>
<ol style="list-style-type: decimal">
<li>
<strong>Training with In-Distribution Data</strong>:
<ul>
<li>
<strong>T-shirts and Trousers</strong>: These classes are used to
train the model. Positive and negative pairs are created within this
subset to teach the model to distinguish between the two classes.</li>
</ul>
</li>
<li>
<strong>Testing with Out-of-Distribution Data</strong>:
<ul>
<li>
<strong>Sandals</strong>: This class is used to test the robustness
of the embeddings learned by the model. By introducing a completely
different class during testing, we can evaluate how well the model
generalizes to new, unseen data.</li>
</ul>
</li>
</ol>
<p>This framework demonstrates how supervised contrastive learning can
be effectively applied to learn discriminative embeddings that can
generalize well to both in-distribution and out-of-distribution
data.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> Dataset, DataLoader, Subset</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="im">from</span> torchvision <span class="im">import</span> datasets, transforms</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="im">import</span> umap</span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim</span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="kw">class</span> PairDataset(Dataset):</span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, images, labels):</span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a>        <span class="va">self</span>.images <span class="op">=</span> images</span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a>        <span class="va">self</span>.labels <span class="op">=</span> labels</span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__len__</span>(<span class="va">self</span>):</span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(<span class="va">self</span>.images)</span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__getitem__</span>(<span class="va">self</span>, idx):</span>
<span id="cb7-19"><a href="#cb7-19" tabindex="-1"></a>        img1 <span class="op">=</span> <span class="va">self</span>.images[idx]</span>
<span id="cb7-20"><a href="#cb7-20" tabindex="-1"></a>        label1 <span class="op">=</span> <span class="va">self</span>.labels[idx]</span>
<span id="cb7-21"><a href="#cb7-21" tabindex="-1"></a>        idx2 <span class="op">=</span> np.random.choice(np.where(<span class="va">self</span>.labels <span class="op">==</span> label1)[<span class="dv">0</span>])</span>
<span id="cb7-22"><a href="#cb7-22" tabindex="-1"></a>        img2 <span class="op">=</span> <span class="va">self</span>.images[idx2]</span>
<span id="cb7-23"><a href="#cb7-23" tabindex="-1"></a>        <span class="cf">return</span> img1, img2, label1</span>
<span id="cb7-24"><a href="#cb7-24" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" tabindex="-1"></a><span class="co"># Load Fashion MNIST dataset and filter for T-shirts and Trousers</span></span>
<span id="cb7-26"><a href="#cb7-26" tabindex="-1"></a>transform <span class="op">=</span> transforms.Compose([transforms.ToTensor()])</span>
<span id="cb7-27"><a href="#cb7-27" tabindex="-1"></a>train_dataset <span class="op">=</span> datasets.FashionMNIST(root<span class="op">=</span><span class="st">'./data'</span>, train<span class="op">=</span><span class="va">True</span>, download<span class="op">=</span><span class="va">True</span>, transform<span class="op">=</span>transform)</span>
<span id="cb7-28"><a href="#cb7-28" tabindex="-1"></a>test_dataset <span class="op">=</span> datasets.FashionMNIST(root<span class="op">=</span><span class="st">'./data'</span>, train<span class="op">=</span><span class="va">False</span>, download<span class="op">=</span><span class="va">True</span>, transform<span class="op">=</span>transform)</span>
<span id="cb7-29"><a href="#cb7-29" tabindex="-1"></a></span>
<span id="cb7-30"><a href="#cb7-30" tabindex="-1"></a>train_indices <span class="op">=</span> np.where((train_dataset.targets <span class="op">==</span> <span class="dv">0</span>) <span class="op">|</span> (train_dataset.targets <span class="op">==</span> <span class="dv">1</span>))[<span class="dv">0</span>]</span>
<span id="cb7-31"><a href="#cb7-31" tabindex="-1"></a>val_indices <span class="op">=</span> np.where((test_dataset.targets <span class="op">==</span> <span class="dv">0</span>) <span class="op">|</span> (test_dataset.targets <span class="op">==</span> <span class="dv">1</span>))[<span class="dv">0</span>]</span>
<span id="cb7-32"><a href="#cb7-32" tabindex="-1"></a>ood_indices <span class="op">=</span> np.where(test_dataset.targets <span class="op">==</span> <span class="dv">5</span>)[<span class="dv">0</span>]</span>
<span id="cb7-33"><a href="#cb7-33" tabindex="-1"></a></span>
<span id="cb7-34"><a href="#cb7-34" tabindex="-1"></a><span class="co"># Use a subset of the data for quicker training</span></span>
<span id="cb7-35"><a href="#cb7-35" tabindex="-1"></a>train_subset <span class="op">=</span> Subset(train_dataset, np.random.choice(train_indices, size<span class="op">=</span><span class="dv">5000</span>, replace<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb7-36"><a href="#cb7-36" tabindex="-1"></a>val_subset <span class="op">=</span> Subset(test_dataset, np.random.choice(val_indices, size<span class="op">=</span><span class="dv">1000</span>, replace<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb7-37"><a href="#cb7-37" tabindex="-1"></a>ood_subset <span class="op">=</span> Subset(test_dataset, np.random.choice(ood_indices, size<span class="op">=</span><span class="dv">1000</span>, replace<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb7-38"><a href="#cb7-38" tabindex="-1"></a></span>
<span id="cb7-39"><a href="#cb7-39" tabindex="-1"></a><span class="co"># Create DataLoaders for the subsets</span></span>
<span id="cb7-40"><a href="#cb7-40" tabindex="-1"></a>train_images <span class="op">=</span> np.array([train_dataset[i][<span class="dv">0</span>].numpy() <span class="cf">for</span> i <span class="kw">in</span> train_indices])</span>
<span id="cb7-41"><a href="#cb7-41" tabindex="-1"></a>train_labels <span class="op">=</span> np.array([train_dataset[i][<span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> train_indices])</span>
<span id="cb7-42"><a href="#cb7-42" tabindex="-1"></a>val_images <span class="op">=</span> np.array([test_dataset[i][<span class="dv">0</span>].numpy() <span class="cf">for</span> i <span class="kw">in</span> val_indices])</span>
<span id="cb7-43"><a href="#cb7-43" tabindex="-1"></a>val_labels <span class="op">=</span> np.array([test_dataset[i][<span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> val_indices])</span>
<span id="cb7-44"><a href="#cb7-44" tabindex="-1"></a>ood_images <span class="op">=</span> np.array([test_dataset[i][<span class="dv">0</span>].numpy() <span class="cf">for</span> i <span class="kw">in</span> ood_indices])</span>
<span id="cb7-45"><a href="#cb7-45" tabindex="-1"></a>ood_labels <span class="op">=</span> np.array([test_dataset[i][<span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> ood_indices])</span>
<span id="cb7-46"><a href="#cb7-46" tabindex="-1"></a></span>
<span id="cb7-47"><a href="#cb7-47" tabindex="-1"></a>train_loader <span class="op">=</span> DataLoader(PairDataset(train_images, train_labels), batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-48"><a href="#cb7-48" tabindex="-1"></a>val_loader <span class="op">=</span> DataLoader(PairDataset(val_images, val_labels), batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb7-49"><a href="#cb7-49" tabindex="-1"></a>ood_loader <span class="op">=</span> DataLoader(PairDataset(ood_images, ood_labels), batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb7-50"><a href="#cb7-50" tabindex="-1"></a></span>
<span id="cb7-51"><a href="#cb7-51" tabindex="-1"></a><span class="co"># Inspect the data loaders</span></span>
<span id="cb7-52"><a href="#cb7-52" tabindex="-1"></a><span class="cf">for</span> batch_images1, batch_images2, batch_labels <span class="kw">in</span> train_loader:</span>
<span id="cb7-53"><a href="#cb7-53" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"train_loader batch_images1 shape: </span><span class="sc">{</span>batch_images1<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-54"><a href="#cb7-54" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"train_loader batch_images2 shape: </span><span class="sc">{</span>batch_images2<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-55"><a href="#cb7-55" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"train_loader batch_labels shape: </span><span class="sc">{</span>batch_labels<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-56"><a href="#cb7-56" tabindex="-1"></a>    <span class="cf">break</span></span>
<span id="cb7-57"><a href="#cb7-57" tabindex="-1"></a></span>
<span id="cb7-58"><a href="#cb7-58" tabindex="-1"></a><span class="cf">for</span> batch_images1, batch_images2, batch_labels <span class="kw">in</span> val_loader:</span>
<span id="cb7-59"><a href="#cb7-59" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"val_loader batch_images1 shape: </span><span class="sc">{</span>batch_images1<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-60"><a href="#cb7-60" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"val_loader batch_images2 shape: </span><span class="sc">{</span>batch_images2<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-61"><a href="#cb7-61" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"val_loader batch_labels shape: </span><span class="sc">{</span>batch_labels<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-62"><a href="#cb7-62" tabindex="-1"></a>    <span class="cf">break</span></span>
<span id="cb7-63"><a href="#cb7-63" tabindex="-1"></a></span>
<span id="cb7-64"><a href="#cb7-64" tabindex="-1"></a><span class="cf">for</span> batch_images1, batch_images2, batch_labels <span class="kw">in</span> ood_loader:</span>
<span id="cb7-65"><a href="#cb7-65" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"ood_loader batch_images1 shape: </span><span class="sc">{</span>batch_images1<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-66"><a href="#cb7-66" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"ood_loader batch_images2 shape: </span><span class="sc">{</span>batch_images2<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-67"><a href="#cb7-67" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"ood_loader batch_labels shape: </span><span class="sc">{</span>batch_labels<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-68"><a href="#cb7-68" tabindex="-1"></a>    <span class="cf">break</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co"># Define a simple CNN model for contrastive learning</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="kw">class</span> ContrastiveModel(nn.Module):</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>        <span class="bu">super</span>(ContrastiveModel, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>        <span class="va">self</span>.conv1 <span class="op">=</span> nn.Conv2d(<span class="dv">1</span>, <span class="dv">32</span>, kernel_size<span class="op">=</span><span class="dv">3</span>, stride<span class="op">=</span><span class="dv">1</span>, padding<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>        <span class="va">self</span>.relu <span class="op">=</span> nn.ReLU()</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>        <span class="va">self</span>.flatten <span class="op">=</span> nn.Flatten()</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>        <span class="va">self</span>.fc1 <span class="op">=</span> nn.Linear(<span class="dv">32</span> <span class="op">*</span> <span class="dv">28</span> <span class="op">*</span> <span class="dv">28</span>, <span class="dv">128</span>)</span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>        <span class="va">self</span>.fc2 <span class="op">=</span> nn.Linear(<span class="dv">128</span>, <span class="dv">50</span>)  <span class="co"># Embedding size</span></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.conv1(x)</span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.relu(x)</span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.flatten(x)</span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.fc1(x)</span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.relu(x)</span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.fc2(x)</span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a>        <span class="cf">return</span> x</span>
<span id="cb8-19"><a href="#cb8-19" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" tabindex="-1"></a><span class="co"># Define contrastive loss function</span></span>
<span id="cb8-21"><a href="#cb8-21" tabindex="-1"></a><span class="kw">def</span> contrastive_loss(z_i, z_j, temperature<span class="op">=</span><span class="fl">0.5</span>):</span>
<span id="cb8-22"><a href="#cb8-22" tabindex="-1"></a>    z_i <span class="op">=</span> nn.functional.normalize(z_i, dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb8-23"><a href="#cb8-23" tabindex="-1"></a>    z_j <span class="op">=</span> nn.functional.normalize(z_j, dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb8-24"><a href="#cb8-24" tabindex="-1"></a>    batch_size <span class="op">=</span> z_i.size(<span class="dv">0</span>)</span>
<span id="cb8-25"><a href="#cb8-25" tabindex="-1"></a>    z <span class="op">=</span> torch.cat([z_i, z_j], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb8-26"><a href="#cb8-26" tabindex="-1"></a></span>
<span id="cb8-27"><a href="#cb8-27" tabindex="-1"></a>    sim <span class="op">=</span> torch.mm(z, z.t()) <span class="op">/</span> temperature</span>
<span id="cb8-28"><a href="#cb8-28" tabindex="-1"></a>    sim_i_j <span class="op">=</span> torch.diag(sim, batch_size)</span>
<span id="cb8-29"><a href="#cb8-29" tabindex="-1"></a>    sim_j_i <span class="op">=</span> torch.diag(sim, <span class="op">-</span>batch_size)</span>
<span id="cb8-30"><a href="#cb8-30" tabindex="-1"></a></span>
<span id="cb8-31"><a href="#cb8-31" tabindex="-1"></a>    positives <span class="op">=</span> torch.cat([sim_i_j, sim_j_i], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb8-32"><a href="#cb8-32" tabindex="-1"></a>    negatives_mask <span class="op">=</span> <span class="op">~</span>torch.eye(<span class="dv">2</span> <span class="op">*</span> batch_size, dtype<span class="op">=</span>torch.<span class="bu">bool</span>, device<span class="op">=</span>z.device)</span>
<span id="cb8-33"><a href="#cb8-33" tabindex="-1"></a>    negatives <span class="op">=</span> sim[negatives_mask].view(<span class="dv">2</span> <span class="op">*</span> batch_size, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb8-34"><a href="#cb8-34" tabindex="-1"></a></span>
<span id="cb8-35"><a href="#cb8-35" tabindex="-1"></a>    loss <span class="op">=</span> <span class="op">-</span>torch.mean(positives) <span class="op">+</span> torch.mean(negatives)</span>
<span id="cb8-36"><a href="#cb8-36" tabindex="-1"></a>    <span class="cf">return</span> loss</span>
<span id="cb8-37"><a href="#cb8-37" tabindex="-1"></a></span>
<span id="cb8-38"><a href="#cb8-38" tabindex="-1"></a><span class="co"># Training loop for contrastive learning</span></span>
<span id="cb8-39"><a href="#cb8-39" tabindex="-1"></a><span class="kw">def</span> train_contrastive_model(model, train_loader, optimizer, num_epochs<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb8-40"><a href="#cb8-40" tabindex="-1"></a>    model.train()</span>
<span id="cb8-41"><a href="#cb8-41" tabindex="-1"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(num_epochs):</span>
<span id="cb8-42"><a href="#cb8-42" tabindex="-1"></a>        total_loss <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-43"><a href="#cb8-43" tabindex="-1"></a>        <span class="cf">for</span> img1, img2, _ <span class="kw">in</span> train_loader:</span>
<span id="cb8-44"><a href="#cb8-44" tabindex="-1"></a>            img1, img2 <span class="op">=</span> img1.to(device), img2.to(device)</span>
<span id="cb8-45"><a href="#cb8-45" tabindex="-1"></a></span>
<span id="cb8-46"><a href="#cb8-46" tabindex="-1"></a>            optimizer.zero_grad()</span>
<span id="cb8-47"><a href="#cb8-47" tabindex="-1"></a></span>
<span id="cb8-48"><a href="#cb8-48" tabindex="-1"></a>            z_i <span class="op">=</span> model(img1)</span>
<span id="cb8-49"><a href="#cb8-49" tabindex="-1"></a>            z_j <span class="op">=</span> model(img2)</span>
<span id="cb8-50"><a href="#cb8-50" tabindex="-1"></a></span>
<span id="cb8-51"><a href="#cb8-51" tabindex="-1"></a>            loss <span class="op">=</span> contrastive_loss(z_i, z_j)</span>
<span id="cb8-52"><a href="#cb8-52" tabindex="-1"></a>            loss.backward()</span>
<span id="cb8-53"><a href="#cb8-53" tabindex="-1"></a>            optimizer.step()</span>
<span id="cb8-54"><a href="#cb8-54" tabindex="-1"></a></span>
<span id="cb8-55"><a href="#cb8-55" tabindex="-1"></a>            total_loss <span class="op">+=</span> loss.item()</span>
<span id="cb8-56"><a href="#cb8-56" tabindex="-1"></a></span>
<span id="cb8-57"><a href="#cb8-57" tabindex="-1"></a>        avg_loss <span class="op">=</span> total_loss <span class="op">/</span> <span class="bu">len</span>(train_loader)</span>
<span id="cb8-58"><a href="#cb8-58" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Epoch [</span><span class="sc">{</span>epoch <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>num_epochs<span class="sc">}</span><span class="ss">], Loss: </span><span class="sc">{</span>avg_loss<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb8-59"><a href="#cb8-59" tabindex="-1"></a></span>
<span id="cb8-60"><a href="#cb8-60" tabindex="-1"></a><span class="co"># Instantiate the model, optimizer, and start training</span></span>
<span id="cb8-61"><a href="#cb8-61" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">'cuda'</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">'cpu'</span>)</span>
<span id="cb8-62"><a href="#cb8-62" tabindex="-1"></a>contrastive_model <span class="op">=</span> ContrastiveModel().to(device)</span>
<span id="cb8-63"><a href="#cb8-63" tabindex="-1"></a>optimizer <span class="op">=</span> optim.Adam(contrastive_model.parameters(), lr<span class="op">=</span><span class="fl">0.001</span>)</span>
<span id="cb8-64"><a href="#cb8-64" tabindex="-1"></a></span>
<span id="cb8-65"><a href="#cb8-65" tabindex="-1"></a>train_contrastive_model(contrastive_model, train_loader, optimizer, num_epochs<span class="op">=</span>n_epochs)</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="extracting-learned-features-1">2) Extracting learned features<a class="anchor" aria-label="anchor" href="#extracting-learned-features-1"></a>
</h3>
<ul>
<li>After training, we set the models to evaluation mode to prevent
updates to the model parameters.</li>
<li>For each subset of the data (training, validation, and OOD), we pass
the images through the entire network up to the first fully connected
layer.</li>
<li>The output of this layer, which captures high-level features and
abstractions, is then used as a 1D feature vector.</li>
<li>These feature vectors are detached from the computational graph and
converted to NumPy arrays for further processing.</li>
</ul>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># Extract features using the trained contrastive model</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>contrastive_model.<span class="bu">eval</span>()</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>train_features <span class="op">=</span> []</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>train_labels_list <span class="op">=</span> []</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a><span class="cf">for</span> img1, _, label1 <span class="kw">in</span> train_loader:</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>    img1 <span class="op">=</span> img1.to(device)</span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>    features <span class="op">=</span> contrastive_model.fc1(contrastive_model.flatten(contrastive_model.conv1(img1)))</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>    train_features.append(features.detach().cpu().numpy())</span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a>    train_labels_list.append(label1.numpy())</span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a>val_features <span class="op">=</span> []</span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a>val_labels_list <span class="op">=</span> []</span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a><span class="cf">for</span> img1, _, label1 <span class="kw">in</span> val_loader:</span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a>    img1 <span class="op">=</span> img1.to(device)</span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a>    features <span class="op">=</span> contrastive_model.fc1(contrastive_model.flatten(contrastive_model.conv1(img1)))</span>
<span id="cb9-16"><a href="#cb9-16" tabindex="-1"></a>    val_features.append(features.detach().cpu().numpy())</span>
<span id="cb9-17"><a href="#cb9-17" tabindex="-1"></a>    val_labels_list.append(label1.numpy())</span>
<span id="cb9-18"><a href="#cb9-18" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" tabindex="-1"></a>ood_features <span class="op">=</span> []</span>
<span id="cb9-20"><a href="#cb9-20" tabindex="-1"></a>ood_labels_list <span class="op">=</span> []</span>
<span id="cb9-21"><a href="#cb9-21" tabindex="-1"></a><span class="cf">for</span> img1, _, label1 <span class="kw">in</span> ood_loader:</span>
<span id="cb9-22"><a href="#cb9-22" tabindex="-1"></a>    img1 <span class="op">=</span> img1.to(device)</span>
<span id="cb9-23"><a href="#cb9-23" tabindex="-1"></a>    features <span class="op">=</span> contrastive_model.fc1(contrastive_model.flatten(contrastive_model.conv1(img1)))</span>
<span id="cb9-24"><a href="#cb9-24" tabindex="-1"></a>    ood_features.append(features.detach().cpu().numpy())</span>
<span id="cb9-25"><a href="#cb9-25" tabindex="-1"></a>    ood_labels_list.append(label1.numpy())</span>
<span id="cb9-26"><a href="#cb9-26" tabindex="-1"></a></span>
<span id="cb9-27"><a href="#cb9-27" tabindex="-1"></a>train_features <span class="op">=</span> np.concatenate(train_features)</span>
<span id="cb9-28"><a href="#cb9-28" tabindex="-1"></a>train_labels <span class="op">=</span> np.concatenate(train_labels_list)</span>
<span id="cb9-29"><a href="#cb9-29" tabindex="-1"></a>val_features <span class="op">=</span> np.concatenate(val_features)</span>
<span id="cb9-30"><a href="#cb9-30" tabindex="-1"></a>val_labels <span class="op">=</span> np.concatenate(val_labels_list)</span>
<span id="cb9-31"><a href="#cb9-31" tabindex="-1"></a>ood_features <span class="op">=</span> np.concatenate(ood_features)</span>
<span id="cb9-32"><a href="#cb9-32" tabindex="-1"></a>ood_labels <span class="op">=</span> np.concatenate(ood_labels_list)</span>
<span id="cb9-33"><a href="#cb9-33" tabindex="-1"></a></span>
<span id="cb9-34"><a href="#cb9-34" tabindex="-1"></a><span class="co"># Diagnostic print statements</span></span>
<span id="cb9-35"><a href="#cb9-35" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"train_features shape: </span><span class="sc">{</span>train_features<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-36"><a href="#cb9-36" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"train_labels shape: </span><span class="sc">{</span>train_labels<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-37"><a href="#cb9-37" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"val_features shape: </span><span class="sc">{</span>val_features<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-38"><a href="#cb9-38" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"val_labels shape: </span><span class="sc">{</span>val_labels<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-39"><a href="#cb9-39" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"ood_features shape: </span><span class="sc">{</span>ood_features<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-40"><a href="#cb9-40" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"ood_labels shape: </span><span class="sc">{</span>ood_labels<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="dimensionality-reduction-and-visualization-2">3) Dimensionality Reduction and Visualization:<a class="anchor" aria-label="anchor" href="#dimensionality-reduction-and-visualization-2"></a>
</h3>
<ul>
<li>We combine the feature vectors from the training, validation, and
OOD data into a single dataset.</li>
<li>UMAP (Uniform Manifold Approximation and Projection) is used to
reduce the dimensionality of the feature vectors from the
high-dimensional space to 2D, making it possible to visualize the
relationships between different data points.</li>
<li>The reduced features are then plotted, with different colors
representing the training data (T-shirts and Trousers), validation data
(T-shirts and Trousers), and OOD data (Sandals).</li>
</ul>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co"># Ensure the labels array for OOD matches the feature array length</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>combined_features <span class="op">=</span> np.vstack([train_features, val_features, ood_features])</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>combined_labels <span class="op">=</span> np.hstack([train_labels, val_labels, np.full(<span class="bu">len</span>(ood_features), <span class="dv">2</span>)])  <span class="co"># Use 2 for OOD class</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>umap_reducer <span class="op">=</span> umap.UMAP(n_components<span class="op">=</span><span class="dv">2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>umap_results <span class="op">=</span> umap_reducer.fit_transform(combined_features)</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="co"># Split the results back into train, val, and OOD data</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>umap_train_features <span class="op">=</span> umap_results[:<span class="bu">len</span>(train_features)]</span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a>umap_val_features <span class="op">=</span> umap_results[<span class="bu">len</span>(train_features):<span class="bu">len</span>(train_features) <span class="op">+</span> <span class="bu">len</span>(val_features)]</span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a>umap_ood_features <span class="op">=</span> umap_results[<span class="bu">len</span>(train_features) <span class="op">+</span> <span class="bu">len</span>(val_features):]</span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a><span class="co"># Plotting UMAP components for contrastive learning model</span></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a><span class="co"># Plot train T-shirts</span></span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a>scatter1 <span class="op">=</span> plt.scatter(umap_train_features[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">0</span>], umap_train_features[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Train T-shirts (ID)'</span>)</span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a><span class="co"># Plot train Trousers</span></span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a>scatter2 <span class="op">=</span> plt.scatter(umap_train_features[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">0</span>], umap_train_features[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Train Trousers (ID)'</span>)</span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a><span class="co"># Plot val T-shirts</span></span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a>scatter3 <span class="op">=</span> plt.scatter(umap_val_features[val_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">0</span>], umap_val_features[val_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, marker<span class="op">=</span><span class="st">'x'</span>, label<span class="op">=</span><span class="st">'Val T-shirts (ID)'</span>)</span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a><span class="co"># Plot val Trousers</span></span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a>scatter4 <span class="op">=</span> plt.scatter(umap_val_features[val_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">0</span>], umap_val_features[val_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, marker<span class="op">=</span><span class="st">'x'</span>, label<span class="op">=</span><span class="st">'Val Trousers (ID)'</span>)</span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a><span class="co"># Plot OOD Sandals</span></span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a>scatter5 <span class="op">=</span> plt.scatter(umap_ood_features[:, <span class="dv">0</span>], umap_ood_features[:, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'green'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">'OOD Sandals'</span>)</span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[scatter1, scatter2, scatter3, scatter4, scatter5])</span>
<span id="cb10-26"><a href="#cb10-26" tabindex="-1"></a>plt.xlabel(<span class="st">'First UMAP Component'</span>)</span>
<span id="cb10-27"><a href="#cb10-27" tabindex="-1"></a>plt.ylabel(<span class="st">'Second UMAP Component'</span>)</span>
<span id="cb10-28"><a href="#cb10-28" tabindex="-1"></a>plt.title(<span class="st">'UMAP of Contrastive Model Features'</span>)</span>
<span id="cb10-29"><a href="#cb10-29" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="limitations-of-threshold-based-ood-detection-methods">Limitations of Threshold-Based OOD Detection Methods<a class="anchor" aria-label="anchor" href="#limitations-of-threshold-based-ood-detection-methods"></a>
</h1>
<p>Threshold-based out-of-distribution (OOD) detection methods are
widely used due to their simplicity and intuitive nature. However, they
come with several significant limitations that need to be
considered:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Dependence on OOD Data Choice</strong>:
<ul>
<li>
<strong>Variety and Representation</strong>: The effectiveness of
threshold-based methods heavily relies on the variety and
representativeness of the OOD data used during threshold selection. If
the chosen OOD samples do not adequately cover the possible range of OOD
scenarios, the threshold may not generalize well to unseen OOD
data.</li>
<li>
<strong>Threshold Determination</strong>: To determine a robust
threshold, it is essential to include a diverse set of OOD samples. This
helps in setting a threshold that can effectively distinguish between
in-distribution and out-of-distribution data across various scenarios.
Without a comprehensive OOD dataset, the threshold might either be too
conservative, causing many ID samples to be misclassified as OOD, or too
lenient, failing to detect OOD samples accurately.</li>
</ul>
</li>
<li>
<strong>Impact of High Thresholds</strong>:
<ul>
<li>
<strong>False OOD Classification</strong>: High thresholds can lead
to a significant number of ID samples being incorrectly classified as
OOD. This false OOD classification results in the loss of potentially
valuable data, reducing the efficiency and performance of the
model.</li>
<li>
<strong>Data Efficiency</strong>: In applications where retaining as
much ID data as possible is crucial, high thresholds can be particularly
detrimental. It’s important to strike a balance between detecting OOD
samples and retaining ID samples to ensure the model’s overall
performance and data efficiency.</li>
</ul>
</li>
<li>
<strong>Sensitivity to Model Confidence</strong>:
<ul>
<li>
<strong>Model Calibration</strong>: Threshold-based methods rely on
the model’s confidence scores, which can be misleading if the model is
poorly calibrated. Overconfident predictions for ID samples or
underconfident predictions for OOD samples can result in suboptimal
threshold settings.</li>
<li>
<strong>Confidence Variability</strong>: The variability in
confidence scores across different models and architectures can make it
challenging to set a universal threshold. Each model might require
different threshold settings, complicating the deployment and
maintenance of threshold-based OOD detection systems.</li>
</ul>
</li>
<li>
<strong>Lack of Discriminative Features</strong>:
<ul>
<li>
<strong>Boundary-Based Detection</strong>: Threshold-based methods
focus on class boundaries rather than learning discriminative features
that can effectively separate ID and OOD samples. This approach can be
less robust, particularly in complex or high-dimensional data spaces
where class boundaries might be less clear.</li>
<li>
<strong>Feature Learning</strong>: By relying solely on confidence
scores, these methods miss the opportunity to learn and leverage
features that are inherently more discriminative. This limitation
highlights the need for advanced techniques like contrastive learning,
which focuses on learning features that distinguish between ID and OOD
samples more effectively.</li>
</ul>
</li>
</ol>
<div class="section level3">
<h3 id="conclusion">Conclusion<a class="anchor" aria-label="anchor" href="#conclusion"></a>
</h3>
<p>While threshold-based OOD detection methods offer a straightforward
approach, their limitations underscore the importance of considering
additional OOD samples for robust threshold determination and the
potential pitfalls of high thresholds. Transitioning to methods that
learn discriminative features rather than relying solely on class
boundaries can address these limitations, paving the way for more
effective OOD detection. This sets the stage for discussing contrastive
learning, which provides a powerful framework for learning such
discriminative features.</p>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div></section><section id="aio-7c-OOD-detection-algo-design"><p>Content from <a href="7c-OOD-detection-algo-design.html">OOD detection: training-time regularization</a></p>
<hr>
<p>Last updated on 2024-08-14 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/7c-OOD-detection-algo-design.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are the key considerations when designing algorithms for OOD
detection?</li>
<li>How can OOD detection be incorporated into the loss functions of
models?</li>
<li>What are the challenges and best practices for training models with
OOD detection capabilities?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand the critical design considerations for creating effective
OOD detection algorithms.</li>
<li>Learn how to integrate OOD detection into the loss functions of
machine learning models.</li>
<li>Identify the challenges in training models with OOD detection and
explore best practices to overcome these challenges.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="training-time-regularization-for-ood-detection">Training-time regularization for OOD detection<a class="anchor" aria-label="anchor" href="#training-time-regularization-for-ood-detection"></a>
</h1>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div></section><section id="aio-8-releasing-a-model"><p>Content from <a href="8-releasing-a-model.html">Documenting and releasing a model</a></p>
<hr>
<p>Last updated on 2024-07-16 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/8-releasing-a-model.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Why is model sharing important in the context of reproducibility and
responsible use?</li>
<li>What are the challenges, risks, and ethical considerations related
to sharing models?</li>
<li>How can model-sharing best practices be applied using tools like
model cards and the Hugging Face platform?</li>
<li>What is distribution shift and what are its implications in machine
learning models?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand the importance of model sharing and best practices to
ensure reproducibility and responsible use of models.</li>
<li>Understand the challenges, risks, and ethical concerns associated
with model sharing.</li>
<li>Apply model-sharing best practices through using model cards and the
Hugging Face platform.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Model cards are the standard technique for communicating information
about how machine learning systems were trained and how they should and
should not be used.</li>
<li>Models can be shared and reused via the Hugging Face platform.</li>
</ul>
</div>
</div>
</div>
<div id="why-should-we-share-trained-models" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="why-should-we-share-trained-models" class="callout-inner">
<h3 class="callout-title">Why should we share trained models?</h3>
<div class="callout-content">
<p>Discuss in small groups and report out: <em>Why do you believe it is
or isn’t important to share ML models? How has model-sharing contributed
to your experiences or projects?</em></p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<ul>
<li>
<strong>Accelerating research</strong>: Sharing models allows
researchers and practitioners to build upon existing work, accelerating
the pace of innovation in the field.</li>
<li>
<strong>Knowledge exchange</strong>: Model sharing promotes
knowledge exchange and collaboration within the machine learning
community, fostering a culture of open science.</li>
<li>
<strong>Reproducibility</strong>: Sharing models, along with
associated code and data, enhances reproducibility, enabling others to
validate and verify the results reported in research papers.</li>
<li>
<strong>Benchmarking</strong>: Shared models serve as benchmarks for
comparing new models and algorithms, facilitating the evaluation and
improvement of state-of-the-art techniques.</li>
<li>
<strong>Education / Accessibility to state-of-the-art
architectures</strong>: Shared models provide valuable resources for
educational purposes, allowing students and learners to explore and
experiment with advanced machine learning techniques.</li>
<li>
<strong>Repurpose (transfer learning and finetuning)</strong>: Some
models (i.e., foundation models) can be repurposed for a wide variety of
tasks. This is especially useful when working with limited data. Data
scarcity</li>
<li>
<strong>Resource efficiency</strong>: Instead of training a model
from the ground up, practitioners can use existing models as a starting
point, saving time, computational resources, and energy.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="challenges-and-risks-of-model-sharing" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="challenges-and-risks-of-model-sharing" class="callout-inner">
<h3 class="callout-title">Challenges and risks of model sharing</h3>
<div class="callout-content">
<p>Discuss in small groups and report out: <em>What are some potential
challenges, risks, or ethical concerns associated with model sharing and
reproducing ML workflows?</em></p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<ul>
<li>
<strong>Privacy concerns</strong>: Sharing models that were trained
on sensitive or private data raises privacy concerns. The potential
disclosure of personal information through the model poses a risk to
individuals and can lead to unintended consequences.</li>
<li>
<strong>Informed consent</strong>: If models involve user data,
ensuring informed consent is crucial. Sharing models trained on
user-generated content without clear consent may violate privacy norms
and regulations.</li>
<li>
<strong>Data bias and fairness</strong>: Models trained on biased
datasets may perpetuate or exacerbate existing biases. Reproducing
workflows without addressing bias in the data may result in unfair
outcomes, particularly in applications like hiring or criminal
justice.</li>
<li>
<strong>Intellectual property</strong>: Models may be developed
within organizations with proprietary data and methodologies. Sharing
such models without proper consent or authorization may lead to
intellectual property disputes and legal consequences.</li>
<li>
<strong>Model robustness and generalization</strong>: Reproduced
models may not generalize well to new datasets or real-world scenarios.
Failure to account for the limitations of the original model can result
in reduced performance and reliability in diverse settings.</li>
<li>
<strong>Lack of reproducibility</strong>: Incomplete documentation,
missing details, or changes in dependencies over time can hinder the
reproducibility of ML workflows. This lack of reproducibility can impede
scientific progress and validation of research findings.</li>
<li>
<strong>Unintended use and misuse</strong>: Shared models may be
used in unintended ways, leading to ethical concerns. Developers should
consider the potential consequences of misuse, particularly in
applications with societal impact, such as healthcare or law
enforcement.</li>
<li>
<strong>Responsible AI considerations</strong>: Ethical
considerations, such as fairness, accountability, and transparency,
should be addressed during model sharing. Failing to consider these
aspects can result in models that inadvertently discriminate or lack
interpretability. Models used for decision-making, especially in
critical areas like healthcare or finance, should be ethically deployed.
Transparent documentation and disclosure of how decisions are made are
essential for responsible AI adoption.</li>
</ul>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="saving-model-locally">Saving model locally<a class="anchor" aria-label="anchor" href="#saving-model-locally"></a>
</h2>
<hr class="half-width">
<p>Let’s review the simplest method for sharing a model first — saving
the model locally. When working with PyTorch, it’s important to know how
to save and load models efficiently. This process ensures that you can
pause your work, share your models, or deploy them for inference without
having to retrain them from scratch each time.</p>
<div class="section level3">
<h3 id="define-model">Define model<a class="anchor" aria-label="anchor" href="#define-model"></a>
</h3>
<p>As an example, we’ll configure a simple perceptron (single hidden
layer) in PyTorch. We’ll define a bare bones class for this just so we
can initialize the model.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Dict, Any</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="kw">class</span> MyModel(nn.Module):</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, config: Dict[<span class="bu">str</span>, <span class="bu">int</span>]):</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>        <span class="co"># Parameter is a trainable tensor initialized with random values</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>        <span class="va">self</span>.param <span class="op">=</span> nn.Parameter(torch.rand(config[<span class="st">"num_channels"</span>], config[<span class="st">"hidden_size"</span>]))</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>        <span class="co"># Linear layer (fully connected layer) for the output</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>        <span class="va">self</span>.linear <span class="op">=</span> nn.Linear(config[<span class="st">"hidden_size"</span>], config[<span class="st">"num_classes"</span>])</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>        <span class="co"># Store the configuration</span></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>        <span class="va">self</span>.config <span class="op">=</span> config</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x: torch.Tensor) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>        <span class="co"># Forward pass: Add the input to the param tensor, then pass through the linear layer</span></span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.linear(x <span class="op">+</span> <span class="va">self</span>.param)</span></code></pre>
</div>
<p>Initialize model by calling the class with configuration
settings.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Create model instance with specific configuration</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>config <span class="op">=</span> {<span class="st">"num_channels"</span>: <span class="dv">3</span>, <span class="st">"hidden_size"</span>: <span class="dv">32</span>, <span class="st">"num_classes"</span>: <span class="dv">10</span>}</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>model <span class="op">=</span> MyModel(config<span class="op">=</span>config)</span></code></pre>
</div>
<p>We can then write a function to save out the model. We’ll need both
the model weights and the model’s configuration (hyperparameter
settings). We’ll saving the configurations as a json since a key/value
format is convenient here.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="im">import</span> json</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="co"># Function to save model and config locally</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="kw">def</span> save_model(model: nn.Module, model_path: <span class="bu">str</span>, config_path: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>    <span class="co"># Save model state dict (weights and biases) as a .pth file</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>    torch.save(model.state_dict(), model_path) <span class="co">#</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>    <span class="co"># Save config</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(config_path, <span class="st">'w'</span>) <span class="im">as</span> f:</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>        json.dump(model.config, f)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Save the model and config locally</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>save_model(model, <span class="st">"my_awesome_model.pth"</span>, <span class="st">"my_awesome_model_config.json"</span>)</span></code></pre>
</div>
<p>To load the model back in, we can write another function</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># Function to load model and config locally</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="kw">def</span> load_model(model_class: Any, model_path: <span class="bu">str</span>, config_path: <span class="bu">str</span>) <span class="op">-&gt;</span> nn.Module:</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>    <span class="co"># Load config</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(config_path, <span class="st">'r'</span>) <span class="im">as</span> f:</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>        config <span class="op">=</span> json.load(f)</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>    <span class="co"># Create model instance with config</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>    model <span class="op">=</span> model_class(config<span class="op">=</span>config)</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>    <span class="co"># Load model state dict</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>    model.load_state_dict(torch.load(model_path))</span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>    <span class="cf">return</span> model</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># Load the model and config locally</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>loaded_model <span class="op">=</span> load_model(MyModel, <span class="st">"my_awesome_model.pth"</span>, <span class="st">"my_awesome_model_config.json"</span>)</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co"># Verify the loaded model</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="bu">print</span>(loaded_model)</span></code></pre>
</div>
</div>
</section><section><h2 class="section-heading" id="saving-a-model-to-hugging-face">Saving a model to Hugging Face<a class="anchor" aria-label="anchor" href="#saving-a-model-to-hugging-face"></a>
</h2>
<hr class="half-width">
<p>To share your model with a wider audience, we recommend uploading
your model to Hugging Face. Hugging Face is a very popular machine
learning (ML) platform and community that helps users build, deploy,
share, and train machine learning models. It has quickly become the
go-to option for sharing models with the public.</p>
<div class="section level3">
<h3 id="create-a-hugging-face-account-and-access-token">Create a Hugging Face account and access Token<a class="anchor" aria-label="anchor" href="#create-a-hugging-face-account-and-access-token"></a>
</h3>
<p>If you haven’t completed these steps from the setup, make sure to do
this now.</p>
<p><strong>Create account</strong>: To create an account on Hugging
Face, visit: <a href="https://huggingface.co/join" class="external-link">huggingface.co/join</a>. Enter an
email address and password, and follow the instructions provided via
Hugging Face (you may need to verify your email address) to complete the
process.</p>
<p><strong>Setup access token</strong>: Once you have your account
created, you’ll need to generate an access token so that you can
upload/share models to your Hugging Face account during the workshop. To
generate a token, visit the <a href="https://huggingface.co/settings/tokens" class="external-link">Access Tokens setting
page</a> after logging in.</p>
</div>
<div class="section level3">
<h3 id="login-to-hugging-face-account">Login to Hugging Face account<a class="anchor" aria-label="anchor" href="#login-to-hugging-face-account"></a>
</h3>
<p>To login, you will need to retrieve your access token from the <a href="https://huggingface.co/settings/tokens" class="external-link">Access Tokens setting
page</a></p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="op">!</span>huggingface<span class="op">-</span>cli login</span></code></pre>
</div>
<p>You might get a message saying you cannot authenticate through
git-credential as no helper is defined on your machine. TODO: What does
this warning mean?</p>
<p>Once logged in, we will need to edit our model class defnition to
include Hugging Face’s “push_to_hub” attribe. To enable the push_to_hub
functionality, you’ll need to include the PyTorchModelHubMixin “mixin
class” provided by the huggingface_hub library. A mixin class is a type
of class used in object-oriented programming to “mix in” additional
properties and methods into a class. The PyTorchModelHubMixin class adds
methods to your PyTorch model to enable easy saving and loading from the
Hugging Face Model Hub.</p>
<p>Here’s how you can adjust the code to incorporate both saving/loading
locally and pushing the model to the Hugging Face Hub.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="im">from</span> huggingface_hub <span class="im">import</span> PyTorchModelHubMixin <span class="co"># NEW</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="kw">class</span> MyModel(nn.Module, PyTorchModelHubMixin): <span class="co"># PyTorchModelHubMixin is new</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, config: Dict[<span class="bu">str</span>, Any]):</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>        <span class="co"># Initialize layers and parameters</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>        <span class="va">self</span>.param <span class="op">=</span> nn.Parameter(torch.rand(config[<span class="st">"num_channels"</span>], config[<span class="st">"hidden_size"</span>]))</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>        <span class="va">self</span>.linear <span class="op">=</span> nn.Linear(config[<span class="st">"hidden_size"</span>], config[<span class="st">"num_classes"</span>])</span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>        <span class="va">self</span>.config <span class="op">=</span> config</span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x: torch.Tensor) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.linear(x <span class="op">+</span> <span class="va">self</span>.param)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># Create model instance with specific configuration</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>config <span class="op">=</span> {<span class="st">"num_channels"</span>: <span class="dv">3</span>, <span class="st">"hidden_size"</span>: <span class="dv">32</span>, <span class="st">"num_classes"</span>: <span class="dv">10</span>}</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>model <span class="op">=</span> MyModel(config<span class="op">=</span>config)</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="bu">print</span>(model)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co"># push to the hub</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>model.push_to_hub(<span class="st">"my-awesome-model"</span>, config<span class="op">=</span>config)</span></code></pre>
</div>
<p><strong>Verifying</strong>: To check your work, head back over to
your Hugging Face and click your profile icon in the top-right of the
website. Click “Profile” from there to view all of your uploaded models.
Alternatively, you can search for your username (or model name) from the
<a href="https://huggingface.co/models" class="external-link">Model Hub</a>.</p>
<div class="section level4">
<h4 id="loading-the-model-from-hugging-face">Loading the model from Hugging Face<a class="anchor" aria-label="anchor" href="#loading-the-model-from-hugging-face"></a>
</h4>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="co"># reload</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>model <span class="op">=</span> MyModel.from_pretrained(<span class="st">"your-username/my-awesome-model"</span>)</span></code></pre>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="uploading-transformer-models-to-hugging-face">Uploading transformer models to Hugging Face<a class="anchor" aria-label="anchor" href="#uploading-transformer-models-to-hugging-face"></a>
</h2>
<hr class="half-width">
<p>Key Differences * <strong>Saving and Loading the Tokenizer</strong>:
Transformer models require a tokenizer that needs to be saved and loaded
with the model. This is not necessary for custom PyTorch models that
typically do not require a separate tokenizer. * <strong>Using
Pre-trained Classes</strong>: Transformer models use classes like
AutoModelForSequenceClassification and AutoTokenizer from the
transformers library, which are pre-built and designed for specific
tasks (e.g., sequence classification). * <strong>Methods for Saving and
Loading</strong>: The transformers library provides save_pretrained and
from_pretrained methods for both models and tokenizers, which handle the
serialization and deserialization processes seamlessly.</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> AutoModelForSequenceClassification, AutoTokenizer</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="co"># Load a pre-trained model and tokenizer</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>model_name <span class="op">=</span> <span class="st">"bert-base-uncased"</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>model <span class="op">=</span> AutoModelForSequenceClassification.from_pretrained(model_name, num_labels<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(model_name)</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a><span class="co"># Save the model and tokenizer locally</span></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>model.save_pretrained(<span class="st">"my_transformer_model"</span>)</span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>tokenizer.save_pretrained(<span class="st">"my_transformer_model"</span>)</span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a><span class="co"># Load the model and tokenizer from the saved directory</span></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a>loaded_model <span class="op">=</span> AutoModelForSequenceClassification.from_pretrained(<span class="st">"my_transformer_model"</span>)</span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a>loaded_tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(<span class="st">"my_transformer_model"</span>)</span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a><span class="co"># Verify the loaded model and tokenizer</span></span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a><span class="bu">print</span>(loaded_model)</span>
<span id="cb12-18"><a href="#cb12-18" tabindex="-1"></a><span class="bu">print</span>(loaded_tokenizer)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="co"># Push the model and tokenizer to Hugging Face Hub</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>model.push_to_hub(<span class="st">"my-awesome-transformer-model"</span>)</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>tokenizer.push_to_hub(<span class="st">"my-awesome-transformer-model"</span>)</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a><span class="co"># Load the model and tokenizer from the Hugging Face Hub</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>hub_model <span class="op">=</span> AutoModelForSequenceClassification.from_pretrained(<span class="st">"user-name/my-awesome-transformer-model"</span>)</span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a>hub_tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(<span class="st">"user-name/my-awesome-transformer-model"</span>)</span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a><span class="co"># Verify the model and tokenizer loaded from the hub</span></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="bu">print</span>(hub_model)</span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a><span class="bu">print</span>(hub_tokenizer)</span></code></pre>
</div>
<div id="what-pieces-must-be-well-documented-to-ensure-reproducible-and-responsible-model-sharing" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="what-pieces-must-be-well-documented-to-ensure-reproducible-and-responsible-model-sharing" class="callout-inner">
<h3 class="callout-title">What pieces must be well-documented to ensure reproducible and responsible model sharing?</h3>
<div class="callout-content">
<p>Discuss in small groups and report out: <em>Why do you believe it is
or isn’t important to share ML models? How has model-sharing contributed
to your experiences or projects?</em></p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" data-bs-parent="#accordionSolution3" aria-labelledby="headingSolution3">
<div class="accordion-body">
<ul>
<li>Environment setup</li>
<li>Training data
<ul>
<li>How the data was collected</li>
<li>Who owns the data: data license and usage terms</li>
<li>Basic descriptive statistics: number of samples, features, classes,
etc.</li>
<li>Note any class imbalance or general bias issues</li>
<li>Description of data distribution to help prevent out-of-distribution
failures.</li>
</ul>
</li>
<li>Preprocessing steps.
<ul>
<li>Data splitting</li>
<li>Standardization method</li>
<li>Feature selection</li>
<li>Outlier detection and other filters</li>
</ul>
</li>
<li>Model architecture, hyperparameters and, training procedure (e.g.,
dropout or early stopping)</li>
<li>Model weights</li>
<li>Evaluation metrics. Results and performance. The more tasks/datasets
you can evaluate on, the better.</li>
<li>Ethical considerations: Include investigations of bias/fairness when
applicable (i.e., if your model involves human data or affects
decision-making involving humans)</li>
<li>Contact info</li>
<li>Acknowledgments</li>
<li>Examples and demos (highly recommended)</li>
</ul>
</div>
</div>
</div>
</div>
<div id="document-your-model" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="document-your-model" class="callout-inner">
<h3 class="callout-title">Document your model</h3>
<div class="callout-content">
<p>TODO</p>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" data-bs-parent="#accordionSolution4" aria-labelledby="headingSolution4">
<div class="accordion-body">
<p>TODO</p>
</div>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section>
</div>
    </main>
</div>
<!-- END  : inst/pkgdown/templates/content-extra.html -->

      </div>
<!--/div.row-->
      		<footer class="row footer mx-md-3"><hr>
<div class="col-md-6">
        <p>This lesson is subject to the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a></p>
        <p>

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/README.md" class="external-link">Edit on GitHub</a>

	
        | <a href="https://github.com/carpentries-incubator/fair-explainable-ml/blob/main/CONTRIBUTING.md" class="external-link">Contributing</a>
        | <a href="https://github.com/carpentries-incubator/fair-explainable-ml/" class="external-link">Source</a></p>
				<p><a href="https://github.com/carpentries-incubator/fair-explainable-ml/blob/main/CITATION" class="external-link">Cite</a> | <a href="mailto:apmeyer4@wisc.edu">Contact</a> | <a href="https://carpentries.org/about/" class="external-link">About</a></p>
			</div>
			<div class="col-md-6">

        <p>Materials licensed under <a href="LICENSE.html">CC-BY 4.0</a> by the authors</p>

        <p>Template licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/" class="external-link">CC-BY 4.0</a> by <a href="https://carpentries.org/" class="external-link">The Carpentries</a></p>
        <p>Built with <a href="https://github.com/carpentries/sandpaper/tree/0.16.6" class="external-link">sandpaper (0.16.6)</a>, <a href="https://github.com/carpentries/pegboard/tree/0.7.6" class="external-link">pegboard (0.7.6)</a>, and <a href="https://github.com/carpentries/varnish/tree/1.0.4" class="external-link">varnish (1.0.4)</a></p>
			</div>
		</footer>
</div> <!-- / div.container -->
	<div id="to-top">
		<a href="#top">
      <i class="search-icon" data-feather="arrow-up" role="img" aria-label="Back To Top"></i><br><!-- <span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top --><span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top
		</a>
	</div>
  <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "TrainingMaterial",
  "@id": "https://carpentries-incubator.github.io/fair-explainable-ml/instructor/aio.html",
  "inLanguage": "en",
  "dct:conformsTo": "https://bioschemas.org/profiles/TrainingMaterial/1.0-RELEASE",
  "description": "A Carpentries Lesson teaching foundational data and coding skills to researchers worldwide",
  "keywords": "fairness, explainability, fair machine learning, interpretable machine learning, xai, lesson, The Carpentries",
  "name": "All in One View",
  "creativeWorkStatus": "active",
  "url": "https://carpentries-incubator.github.io/fair-explainable-ml/instructor/aio.html",
  "identifier": "https://carpentries-incubator.github.io/fair-explainable-ml/instructor/aio.html",
  "dateCreated": "2023-12-05",
  "dateModified": "2024-08-27",
  "datePublished": "2024-08-27"
}

  </script><script>
		feather.replace();
	</script>
</body>
</html><!-- END:   inst/pkgdown/templates/layout.html-->

