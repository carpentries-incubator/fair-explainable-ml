<!DOCTYPE html>
<!-- START: inst/pkgdown/templates/layout.html --><!-- Generated by pkgdown: do not edit by hand --><html lang="en" data-bs-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Trustworthy AI: Explainability, Bias, Fairness, and Safety: All in One View</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="../assets/themetoggle.js"></script><link rel="stylesheet" type="text/css" href="../assets/styles.css">
<script src="../assets/scripts.js" type="text/javascript"></script><!-- mathjax --><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      config: ["MMLorHTML.js"],
      jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [['\\(', '\\)']],
        displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
        processEscapes: true
      }
    });
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><!-- Responsive Favicon for The Carpentries --><link rel="apple-touch-icon" sizes="180x180" href="../favicons/incubator/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicons/incubator/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../favicons/incubator/favicon-16x16.png">
<link rel="manifest" href="../favicons/incubator/site.webmanifest">
<link rel="mask-icon" href="../favicons/incubator/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="white">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="black">
</head>
<body>
    <header id="top" class="navbar navbar-expand-md top-nav incubator"><svg xmlns="http://www.w3.org/2000/svg" class="d-none"><symbol id="check2" viewbox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path></symbol><symbol id="circle-half" viewbox="0 0 16 16"><path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path></symbol><symbol id="moon-stars-fill" viewbox="0 0 16 16"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path><path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"></path></symbol><symbol id="sun-fill" viewbox="0 0 16 16"><path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></symbol></svg><a class="visually-hidden-focusable skip-link" href="#main-content">Skip to main content</a>
  <div class="container-fluid top-nav-container">
    <div class="col-md-8">
      <div class="large-logo">
        <img id="incubator-logo" alt="Carpentries Incubator" src="../assets/images/incubator-logo.svg"><span class="badge text-bg-danger">
          <abbr title="This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.">
            <a href="https://cdh.carpentries.org/the-lesson-life-cycle.html#early-development-pre-alpha-through-alpha" class="external-link alert-link">
              <i aria-hidden="true" class="icon" data-feather="alert-octagon" style="border-radius: 5px"></i>
              Pre-Alpha
            </a>
            <span class="visually-hidden">This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.</span>
          </abbr>
        </span>

      </div>
    </div>
    <div class="selector-container">
      <div id="theme-selector">
        <li class="nav-item dropdown" id="theme-button-list">
          <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
            <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="bd-theme-text">
<li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                Light
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                Dark
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                Auto
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
          </ul>
</li>
      </div>

      <div class="dropdown" id="instructor-dropdown">
        <button class="btn btn-secondary dropdown-toggle bordered-button" type="button" id="dropdownMenu1" data-bs-toggle="dropdown" aria-expanded="false">
          <i aria-hidden="true" class="icon" data-feather="eye"></i> Instructor View <i data-feather="chevron-down"></i>
        </button>
        <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
<li><button class="dropdown-item" type="button" onclick="window.location.href='../aio.html';">Learner View</button></li>
        </ul>
</div>
    </div>
  </div>
  <hr></header><nav class="navbar navbar-expand-xl bottom-nav incubator" aria-label="Main Navigation"><div class="container-fluid nav-container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle Navigation">
      <span class="navbar-toggler-icon"></span>
      <span class="menu-title">Menu</span>
    </button>
    <div class="nav-logo">
      <img class="small-logo" alt="Carpentries Incubator" src="../assets/images/incubator-logo-sm.svg">
</div>
    <div class="lesson-title-md">
      Trustworthy AI: Explainability, Bias, Fairness, and Safety
    </div>
    <div class="search-icon-sm">
      <!-- TODO: do not show until we have search
        <i role="img" aria-label="Search the All In One page" data-feather="search"></i>
      -->
    </div>
    <div class="desktop-nav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
<li class="nav-item">
          <span class="lesson-title">
            Trustworthy AI: Explainability, Bias, Fairness, and Safety
          </span>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/key-points.html">Key Points</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/instructor-notes.html">Instructor Notes</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/images.html">Extract All Images</a>
        </li>
        <li class="nav-item dropdown">
          <button class="nav-link dropdown-toggle" id="navbarDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            More <i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
<hr>
<li><a class="dropdown-item" href="reference.html">Reference</a></li>
          </ul>
</li>
      </ul>
</div>
    <!--
    <form class="d-flex col-md-2 search-form">
      <fieldset disabled>
      <input class="form-control me-2 searchbox" type="search" placeholder="" aria-label="">
        <button class="btn btn-outline-success tablet-search-button"  type="submit">
          <i class="search-icon" data-feather="search" role="img" aria-label="Search the All In One page"></i>
        </button>
      </fieldset>
    </form>
    -->
    <a id="search-button" class="btn btn-primary" href="../instructor/aio.html" role="button" aria-label="Search the All In One page">Search the All In One page</a>
  </div>
<!--/div.container-fluid -->
</nav><div class="col-md-12 mobile-title">
  Trustworthy AI: Explainability, Bias, Fairness, and Safety
</div>

<aside class="col-md-12 lesson-progress"><div style="width: %" class="percentage">
    %
  </div>
  <div class="progress incubator">
    <div class="progress-bar incubator" role="progressbar" style="width: %" aria-valuenow="" aria-label="Lesson Progress" aria-valuemin="0" aria-valuemax="100">
    </div>
  </div>
</aside><div class="container">
      <div class="row">
        <!-- START: inst/pkgdown/templates/navbar.html -->
<div id="sidebar-col" class="col-lg-4">
  <div id="sidebar" class="sidebar">
      <nav aria-labelledby="flush-headingEleven"><button role="button" aria-label="close menu" alt="close menu" aria-expanded="true" aria-controls="sidebar" class="collapse-toggle" data-collapse="Collapse " data-episodes="Episodes ">
          <i class="search-icon" data-feather="x" role="img"></i>
        </button>
        <div class="sidebar-inner">
          <div class="row mobile-row" id="theme-row-mobile">
            <div class="col" id="theme-selector">
              <li class="nav-item dropdown" id="theme-button-list">
                <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
                  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><span class="d-lg-none ms-1" id="bd-theme-text">Toggle Theme</span>
                </button>
                <ul class="dropdown-menu dropdown-menu-right" aria-labelledby="bd-theme-text">
<li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                      Light
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                      Dark
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                      <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                      Auto
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                </ul>
</li>
            </div>
          </div>
          <div class="row mobile-row">
            <div class="col">
              <div class="sidenav-view-selector">
                <div class="accordion accordion-flush" id="accordionFlush9">
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingNine">
                      <button class="accordion-button collapsed" id="instructor" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <i id="eye" aria-hidden="true" class="icon" data-feather="eye"></i> Instructor View
                      </button>
                    </h2>
                    <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlush2">
                      <div class="accordion-body">
                        <a href="../aio.html">Learner View</a>
                      </div>
                    </div>
                  </div>
<!--/div.accordion-item-->
                </div>
<!--/div.accordion-flush-->
              </div>
<!--div.sidenav-view-selector -->
            </div>
<!--/div.col -->

            <hr>
</div>
<!--/div.mobile-row -->

          <div class="accordion accordion-flush" id="accordionFlush11">
            <div class="accordion-item">

              <button id="chapters" class="accordion-button show" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                <h2 class="accordion-header chapters" id="flush-headingEleven">
                  EPISODES
                </h2>
              </button>
              <div id="flush-collapseEleven" class="accordion-collapse show collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlush11">

                <div class="accordion-body">
                  <div class="accordion accordion-flush" id="accordionFlush1">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading1">
        <a href="index.html">Summary and Schedule</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush2">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading2">
        <a href="0-introduction.html">1. Overview</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush3">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading3">
        <a href="1-preparing-to-train.html">2. Preparing to train a model</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush4">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading4">
        <a href="2-model-eval-and-fairness.html">3. Model evaluation and fairness</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush5">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading5">
        <a href="3-model-fairness-deep-dive.html">4. Model fairness: hands-on</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush6">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading6">
        <a href="4-explainability-vs-interpretability.html">5. Interpretablility versus explainability</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush7">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading7">
        <a href="5a-explainable-AI-method-overview.html">6. Explainability methods overview</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush8">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading8">
        <a href="5c-probes.html">7. Explainability methods: Linear Probes</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush9">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading9">
        <a href="5d-gradcam.html">8. Explainability methods: GradCAM</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush10">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading10">
        <a href="6-uncertainty-overview.html">9. Estimating model uncertainty</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush11">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading11">
        <a href="7a-OOD-detection-overview.html">10. OOD detection: overview</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush12">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading12">
        <a href="7b-OOD-detection-softmax.html">11. OOD detection: softmax</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush13">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading13">
        <a href="7c-OOD-detection-energy.html">12. OOD detection: energy</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush14">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading14">
        <a href="7d-OOD-detection-distance.html">13. OOD detection: distance-based</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush15">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading15">
        <a href="8-releasing-a-model.html">14. Documenting and releasing a model</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

                </div>
              </div>
            </div>

            <hr class="half-width">
<div class="accordion accordion-flush lesson-resources" id="accordionFlush12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingTwelve">
                  <button class="accordion-button collapsed" id="lesson-resources" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                    RESOURCES
                  </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlush12">
                  <div class="accordion-body">
                    <ul>
<li>
                        <a href="../instructor/key-points.html">Key Points</a>
                      </li>
                      <li>
                        <a href="../instructor/instructor-notes.html">Instructor Notes</a>
                      </li>
                      <li>
                        <a href="../instructor/images.html">Extract All Images</a>
                      </li>
                      <hr>
<li><a class="dropdown-item" href="reference.html">Reference</a></li>
                    </ul>
</div>
                </div>
              </div>
            </div>
            <hr class="half-width lesson-resources">
<a href="../instructor/aio.html">See all in one page</a>


            <hr class="d-none d-sm-block d-md-none">
<div class="d-grid gap-1">

            </div>
          </div>
<!-- /div.accordion -->
        </div>
<!-- /div.sidebar-inner -->
      </nav>
</div>
<!-- /div.sidebar -->
  </div>
<!-- /div.sidebar-col -->
<!-- END:   inst/pkgdown/templates/navbar.html-->

        <!-- START: inst/pkgdown/templates/content-extra.html -->
  <div class="col-xl-8 col-lg-12 primary-content">
    <main id="main-content" class="main-content"><div class="container lesson-content">
        
        
<section id="aio-0-introduction"><p>Content from <a href="0-introduction.html">Overview</a></p>
<hr>
<p>Last updated on 2024-10-17 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/0-introduction.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 31 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What do we mean by “Trustworthy AI”?</li>
<li>How is this workshop structured, and what content does it
cover?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Define trustworthy AI and its various components.</li>
<li>Be prepared to dive into the rest of the workshop.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="what-is-trustworthy-ai">What is trustworthy AI?<a class="anchor" aria-label="anchor" href="#what-is-trustworthy-ai"></a>
</h2>
<hr class="half-width">
<div id="discussion1" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Discussion</h3>
<div class="callout-content">
<p>Take a moment to brainstorm what keywords/concepts come to mind when
we mention “Trustworthy AI”. Share your thoughts with the class.</p>
</div>
</div>
</div>
<p>Artificial intelligence (AI) and machine learning (ML) are being used
widely to improve upon human capabilities (either in
speed/convenience/cost or accuracy) in a variety of domains: medicine,
social media, news, marketing, policing, and more. It is important that
the decisions made by AI/ML models uphold values that we, as a society,
care about.</p>
<p>Trustworthy AI is a large and growing sub-field of AI that aims to
ensure that AI models are trained and deployed in ways that are ethical
and responsible.</p>
</section><section><h2 class="section-heading" id="the-ai-bill-of-rights">The AI Bill of Rights<a class="anchor" aria-label="anchor" href="#the-ai-bill-of-rights"></a>
</h2>
<hr class="half-width">
<p>In October 2022, the Biden administration released a <a href="https://www.whitehouse.gov/ostp/ai-bill-of-rights/" class="external-link">Blueprint for
an AI Bill of Rights</a>, a non-binding document that outlines how
automated systems and AI should behave in order to protect Americans’
rights.</p>
<p>The blueprint is centered around five principles:</p>
<ul>
<li>Safe and Effective Systems – AI systems should work as expected, and
should not cause harm</li>
<li>Algorithmic Discrimination Protections – AI systems should not
discriminate or produce inequitable outcomes</li>
<li>Data Privacy – data collection should be limited to what is
necessary for the system functionality, and you should have control over
how and if your data is used</li>
<li>Notice and Explanation – it should be transparent when an AI system
is being used, and there should be an explanation of how particular
decisions are reached</li>
<li>Human Alternatives, Consideration, and Fallback – you should be able
to opt out of engaging with AI systems, and a human should be available
to remedy any issues</li>
</ul></section><section><h2 class="section-heading" id="this-workshop">This workshop<a class="anchor" aria-label="anchor" href="#this-workshop"></a>
</h2>
<hr class="half-width">
<p>This workshop centers around four principles that are important to
trustworthy AI: <em>scientific validity</em>, <em>fairness</em>,
<em>transparency</em>, and <em>accountability</em>. We summarize each
principle here.</p>
<div class="section level3">
<h3 id="scientific-validity">Scientific validity<a class="anchor" aria-label="anchor" href="#scientific-validity"></a>
</h3>
<p>In order to be trustworthy, a model and its predictions need to be
founded on good science. A model is not going to perform well if is not
trained on the correct data, if it fits the underlying data poorly, or
if it cannot recognize its own limitations. Scientific validity is
closely linked to the AI Bill of Rights principle of “safe and effective
systems”.</p>
<p>In this workshop, we cover the following topics relating to
scientific validity:</p>
<ul>
<li>Defining the problem (Preparing to Train a Model episode)</li>
<li>Training and evaluating a model, especially selecting an accuracy
metric, avoiding over/underfitting, and preventing data leakage (Model
Evaluation and Fairness episode)</li>
<li>Estimating model uncertainty (Estimating Model Uncertainty
episode)</li>
<li>Out-of-distribution detection (OOD Detection episodes)</li>
</ul>
</div>
<div class="section level3">
<h3 id="fairness">Fairness<a class="anchor" aria-label="anchor" href="#fairness"></a>
</h3>
<p>As stated in the AI Bill of Rights, AI systems should not be
discriminatory or produce inequitable outcomes. In the Model Evaluation
and Fairness episode we discuss various definitions of fairness in the
context of AI, and overview how model developers try to make their
models more fair.</p>
</div>
<div class="section level3">
<h3 id="transparency">Transparency<a class="anchor" aria-label="anchor" href="#transparency"></a>
</h3>
<p>Transparency – i.e., insight into <em>how</em> a model makes its
decisions – is important for trustworthy AI, as we want models that make
the right decisions <em>for the right reasons</em>. Transparency can be
achieved via <em>explanations</em> or by using inherently
<em>interpretable</em> models. We discuss transparency in the follow
episodes:</p>
<ul>
<li>Interpretability vs Explainability</li>
<li>Explainability Methods Overview</li>
<li>Explainability Methods: Deep Dive, Linear Probe, and GradCAM
episodes</li>
</ul>
</div>
<div class="section level3">
<h3 id="accountability">Accountability<a class="anchor" aria-label="anchor" href="#accountability"></a>
</h3>
<p>Accountability is important for trustworthy AI because, inevitably,
models will make mistakes or cause harm. Accountability is multi-faceted
and largely non-technical, which is not to say unimportant, but just
that it falls partially out of scope of this technical workshop.</p>
<p>We discuss two facets of accountability, model documentation and
model sharing, in the Documenting and Releasing a Model episode.</p>
<p>For those who are interested, we recommend these papers to learn more
about different aspects of AI accountability:</p>
<ol style="list-style-type: decimal">
<li>
<a href="https://arxiv.org/pdf/1711.01134" class="external-link">Accountability of AI
Under the Law: The Role of Explanation</a> by Finale Doshi-Velez and
colleagues. This paper discusses how explanations can be used in a legal
context to determine accountability for harms caused by AI.</li>
<li>
<a href="https://dl.acm.org/doi/abs/10.1145/3351095.3372873" class="external-link">Closing
the AI accountability gap: defining an end-to-end framework for internal
algorithmic auditing</a> by Deborah Raji and colleagues proposes a
framework for auditing algorithms. A key contribution of this paper is
defining an auditing procedure over the whole model development and
implementation pipeline, rather than narrowly focusing on the modeling
stages.</li>
<li>
<a href="https://ieeexplore.ieee.org/abstract/document/10516659" class="external-link">AI
auditing: The Broken Bus on the Road to AI Accountability</a> by Abeba
Birhane and colleagues challenges previous work on AI accountability,
arguing that most existing AI auditing systems are not effective. They
propose necessary traits for effective AI audits, based on a review of
existing practices.</li>
</ol>
</div>
<div class="section level3">
<h3 id="topics-we-do-not-cover">Topics we do not cover<a class="anchor" aria-label="anchor" href="#topics-we-do-not-cover"></a>
</h3>
<p>Trustworthy AI is a large, and growing, area of study. As of
September 24, 2024, <strong>there are about 18,000 articles on Google
Scholar that mention Trustworthy AI and were published in the first 9
months of 2024</strong>.</p>
<p>There are different Trustworthy AI methods for different types of
models – e.g., decisions trees or linear models that are commonly used
with tabular data, neural networks that are used with image data, or
large multi-modal foundation models. In this workshop, we focus
primarily on neural networks for the specific techniques we show in the
technical implementations. That being said, much of the conceptual
content is relevant to any model type.</p>
<p>Many of the topics we do not cover are sub-topics of the broad
categories – e.g., fairness, explainability, or OOD detection – of the
workshop and are important for specific use cases, but less relevant for
a general audience. But, there are a few major areas of research that we
don’t have time to touch on. We summarize a few of them here:</p>
<div class="section level4">
<h4 id="data-privacy">Data Privacy<a class="anchor" aria-label="anchor" href="#data-privacy"></a>
</h4>
<p>In the US’s Blueprint for an AI Bill of Rights, one principle is data
privacy, meaning that people should be aware how their data is being
used, companies should not collect more data than they need, and people
should be able to consent and/or opt out of data collection and
usage.</p>
<p>A lack of data privacy poses several risks: first, whenever data is
collected, it can be subject to data breaches. This risk is unavoidable,
but collecting only the data that is truly necessary mitigates this
risk, as does implementing safeguards to how data is stored and and
accessed. Second, when data is used to train ML models, that data can
sometimes be identifying by attackers. For instance, large language
models like ChatGPT are known to release private data that was part of
the training corpus when prompted in clever ways (see this <a href="https://not-just-memorization.github.io/extracting-training-data-from-chatgpt.html" class="external-link">blog
post</a> for more information).<br>
Membership inference attacks, where an attacker determines whether a
particular individual’s data was in the training corpus, are another
vulnerability. These attacks may reveal things about a person directly
(e.g., if the training dataset consisted of only people with a
particular medical condition), or can be used to setup downstream
attacks to gain more information.</p>
<p>There are several areas of active research relating to data
privacy.</p>
<ul>
<li>
<a href="https://link.springer.com/chapter/10.1007/978-3-540-79228-4_1" class="external-link">Differential
privacy</a> is a statistical technique that protects the privacy of
individual data points. Models can be trained using differential privacy
to provably prevent future attacks, but this currently comes at a high
cost to accuracy.</li>
<li>
<a href="https://ieeexplore.ieee.org/abstract/document/9599369" class="external-link">Federated
learning</a> trains models using decentralized data from a variety of
sources. Since the data is not shared centrally, there is less risk of
data breaches or unauthorized data usage.</li>
</ul>
</div>
<div class="section level4">
<h4 id="generative-ai-risks">Generative AI risks<a class="anchor" aria-label="anchor" href="#generative-ai-risks"></a>
</h4>
<p>We touch on fairness issues with generative AI in the Model
Evaluation and Fairness episode. But generative AI poses other risks,
too, many of which are just starting to be researched and understood
given how new widely-available generative AI is. We discuss one such
risk, disinformation, briefly here:</p>
<ul>
<li>Disinformation: A major risk of generative AI is the creation of
misleading or fake and malicious content, often known as <a href="https://timreview.ca/article/1282" class="external-link">deep fakes</a>. Deep fakes pose
risks to individuals (e.g., creating content that harms an individual’s
reputation) and society (e.g., fake news articles or pictures that look
real).</li>
</ul>
<div id="accordionInstructor1" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor1" aria-expanded="false" aria-controls="collapseInstructor1">
  <h3 class="accordion-header" id="headingInstructor1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Instructor Note </h3>
</button>
<div id="collapseInstructor1" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor1" aria-labelledby="headingInstructor1">
<div class="accordion-body">
<p>Inline instructor notes can help inform instructors of timing
challenges associated with the lessons. They appear in the “Instructor
View”</p>
</div>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div>
</section></section><section id="aio-1-preparing-to-train"><p>Content from <a href="1-preparing-to-train.html">Preparing to train a model</a></p>
<hr>
<p>Last updated on 2024-10-17 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/1-preparing-to-train.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>For what prediction tasks is machine learning an appropriate
tool?</li>
<li>How can inappropriate target variable choice lead to suboptimal
outcomes in a machine learning pipeline?</li>
<li>What forms of “bias” can occur in machine learning, and where do
these biases come from?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Judge what tasks are appropriate for machine learning</li>
<li>Understand why the choice of prediction task / target variable is
important.</li>
<li>Describe how bias can appear in training data and algorithms.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="choosing-appropriate-tasks">Choosing appropriate tasks<a class="anchor" aria-label="anchor" href="#choosing-appropriate-tasks"></a>
</h2>
<hr class="half-width">
<p>Machine learning is a rapidly advancing, powerful technology that is
helping to drive innovation. Before embarking on a machine learning
project, we need to consider the task carefully. Many machine learning
efforts are not solving problems that need to be solved. Or, the problem
may be valid, but the machine learning approach makes incorrect
assumptions and fails to solve the problem effectively. Worse, many
applications of machine learning are not for the public good.</p>
<p>We will start by considering the <a href="https://www.nih.gov/health-information/nih-clinical-research-trials-you/guiding-principles-ethical-research" class="external-link">NIH
Guiding Principles for Ethical Research</a>, which provide a useful set
of considerations for any project.</p>
<div id="discussion1" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Take a look at the <a href="https://www.nih.gov/health-information/nih-clinical-research-trials-you/guiding-principles-ethical-research" class="external-link">NIH
Guiding Principles for Ethical Research</a>.</p>
<p>What are the main principles?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<p>A summary of the principles is listed below:</p>
<ul>
<li>Social and clinical value: Does the social or clinical value of
developing and implementing the model outweigh the risk and burden of
the people involved?</li>
<li>Scientific validity: Once created, will the model provide valid,
meaningful outputs?</li>
<li>Fair subject selection: Are the people who contribute and benefit
from the model selected fairly, and not through vulnerability,
privilege, or other unrelated factors?</li>
<li>Favorable risk-benefit ratio: Do the potential benefits of of
developing and implementing the model outweigh the risks?</li>
<li>Independent review: Has the project been reviewed by someone
independent of the project, and has an Institutional Review Board (IRB)
been approached where appropriate?</li>
<li>Informed consent: Are participants whose data contributes to
development and implementation of the model, as well as downstream
recipients of the model, kept informed?</li>
<li>Respect for potential and enrolled subjects: Is the privacy of
participants respected and are steps taken to continuously monitor the
effect of the model on downstream participants?</li>
</ul>
</div>
</div>
</div>
</div>
<p>AI tasks are often most controversial when they involve human
subjects, and especially visual representations of people. We’ll discuss
two case studies that use people’s faces as a prediction tool, and
discuss whether these uses of AI are appropriate.</p>
<div class="section level3">
<h3 id="case-study-1-physiognomy">Case study 1: Physiognomy<a class="anchor" aria-label="anchor" href="#case-study-1-physiognomy"></a>
</h3>
<p>In 2019, Nature Medicine <a href="https://www.nature.com/articles/s41591-018-0279-0.epdf" class="external-link">published
a paper</a> that describes a model that can identify genetic disorders
from a photograph of a patient’s face. The abstract of the paper is
copied below:</p>
<blockquote>
<p>Syndromic genetic conditions, in aggregate, affect 8% of the
population. Many syndromes have recognizable facial features that are
highly informative to clinical geneticists. Recent studies show that
facial analysis technologies measured up to the capabilities of expert
clinicians in syndrome identification. However, these technologies
identified only a few disease phenotypes, limiting their role in
clinical settings, where hundreds of diagnoses must be considered. Here
we present a facial image analysis framework, DeepGestalt, using
computer vision and deep-learning algorithms, that quantifies
similarities to hundreds of syndromes.</p>
<p>DeepGestalt outperformed clinicians in three initial experiments, two
with the goal of distinguishing subjects with a target syndrome from
other syndromes, and one of separating different genetic sub-types in
Noonan syndrome. On the final experiment reflecting a real clinical
setting problem, DeepGestalt achieved 91% top-10 accuracy in identifying
the correct syndrome on 502 different images. The model was trained on a
dataset of over 17,000 images representing more than 200 syndromes,
curated through a community-driven phenotyping platform. DeepGestalt
potentially adds considerable value to phenotypic evaluations in
clinical genetics, genetic testing, research and precision medicine.</p>
</blockquote>
<ul>
<li>What is the proposed value of the algorithm?</li>
<li>What are the potential risks?</li>
<li>Are you supportive of this kind of research?</li>
<li>What safeguards, if any, would you want to be used when developing
and using this algorithm?</li>
</ul>
<div id="accordionInstructor1" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor1" aria-expanded="false" aria-controls="collapseInstructor1">
  <h3 class="accordion-header" id="headingInstructor1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Discussion points </h3>
</button>
<div id="collapseInstructor1" class="accordion-collapse collapse" aria-labelledby="headingInstructor1" data-bs-parent="#accordionInstructor1">
<div class="accordion-body">
<ul>
<li>The algorithm could help doctors figure out what rare disease a
patient has.</li>
<li>First, if the algorithm is used in the wrong hands, it could be used
to discriminate against people with diseases. Second, if the algorithm
is not accurate (false positive or false negative), trusting its results
could lead to improper medical care.</li>
<li>Safeguards could include: requiring extensive testing to ensure that
the algorithm maintains similar accuracy across racial and gender
groups, making sure the algorithm is only accessible to medical
professionals, and requiring follow-up testing to confirm the
algorithm’s diagnosis.</li>
</ul>
</div>
</div>
</div>
</div>
<p>Media reports about this paper were largely positive, e.g., <a href="https://www.genengnews.com/insights/a-i-gets-in-the-face-of-rare-genetic-diseases/" class="external-link">reporting
that clinicians are excited about the new technology</a>.</p>
</div>
<div class="section level3">
<h3 id="case-study-2">Case study 2:<a class="anchor" aria-label="anchor" href="#case-study-2"></a>
</h3>
<p>There is a long history of physiognomy, the “science” of trying to
read someone’s character from their face. With the advent of machine
learning, this discredited area of research has made a comeback. There
have been numerous studies attempting to guess characteristics such as
trustworthness, criminality, and political and sexual orientation.</p>
<p>In 2018, for example, researchers suggested that neural networks
could be used to detect sexual orientation from facial images. The
abstract is copied below:</p>
<blockquote>
<p>We show that faces contain much more information about sexual
orientation than can be perceived and interpreted by the human brain. We
used deep neural networks to extract features from 35,326 facial images.
These features were entered into a logistic regression aimed at
classifying sexual orientation. Given a single facial image, a
classifier could correctly distinguish between gay and heterosexual men
in 81% of cases, and in 74% of cases for women. Human judges achieved
much lower accuracy: 61% for men and 54% for women. The accuracy of the
algorithm increased to 91% and 83%, respectively, given five facial
images per person.</p>
<p>Facial features employed by the classifier included both fixed (e.g.,
nose shape) and transient facial features (e.g., grooming style).
Consistent with the prenatal hormone theory of sexual orientation, gay
men and women tended to have gender-atypical facial morphology,
expression, and grooming styles. Prediction models aimed at gender alone
allowed for detecting gay males with 57% accuracy and gay females with
58% accuracy. Those findings advance our understanding of the origins of
sexual orientation and the limits of human perception. Additionally,
given that companies and governments are increasingly using computer
vision algorithms to detect people’s intimate traits, our findings
expose a threat to the privacy and safety of gay men and women.</p>
</blockquote>
<div id="discussion2" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Discussion</h3>
<div class="callout-content">
<p>Discuss the following questions.</p>
<ul>
<li>What is the proposed value of the algorithm?</li>
<li>What are the potential risks?</li>
<li>Are you supportive of this kind of research?</li>
<li>What distinguishes this use of AI from the use of AI described in
Case Study 1?</li>
</ul>
</div>
</div>
</div>
<div id="accordionInstructor2" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor2" aria-expanded="false" aria-controls="collapseInstructor2">
  <h3 class="accordion-header" id="headingInstructor2">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Discussion points </h3>
</button>
<div id="collapseInstructor2" class="accordion-collapse collapse" aria-labelledby="headingInstructor2" data-bs-parent="#accordionInstructor2">
<div class="accordion-body">
<ul>
<li>The algorithm proposes detecting an individual’s sexual orientation
from images of their face. It is unclear why this is something that
needs to be algorithmically detected by any entity.</li>
<li>If the algorithm is used by anti-LGBTQ entities, it could be used to
harass members of the LGBTQ community (as well as non-LGBTQ people who
are flagged as LGBTQ by the algorithm). If the algorithm is accurate, it
could be used to “out” individuals who are gay but do not want to
publicly share that information.</li>
<li>The first case study aims to detect disease. The implication of this
research – at least, as suggested by the linked article – is that it can
help doctors with diagnosis and give individuals affected by the disease
access to treatment. Conversely, if there is a medical reason for
knowing someone’s sexual orientation, it is not necessary to use AI –
the doctor can just ask the patient.</li>
</ul>
</div>
</div>
</div>
</div>
<p>Media reports of this algorithm were largely negative, with a <a href="https://www.scientificamerican.com/blog/observations/can-we-read-a-persons-character-from-facial-images/" class="external-link">Scientific
American article</a> highlighting the connections to physiognomy and
raising concern over government use of these algorithms:</p>
<blockquote>
<p>This is precisely the kind of “scientific” claim that can motivate
repressive governments to apply AI algorithms to images of their
citizens. And what is it to stop them from “reading” intelligence,
political orientation and criminal inclinations from these images?</p>
</blockquote>
</div>
</section><section><h2 class="section-heading" id="choosing-the-outcome-variable">Choosing the outcome variable<a class="anchor" aria-label="anchor" href="#choosing-the-outcome-variable"></a>
</h2>
<hr class="half-width">
<p>Sometimes, choosing the outcome variable is easy: for instance, when
building a model to predict how warm it will be out tomorrow, the
temperature can be the outcome variable because it’s measurable (i.e.,
you know what temperature it was yesterday and today) and your
predictions won’t cause a feedback loop (e.g., given a set of past
weather data, the weather next Monday won’t change based on what your
model predicts tomorrow’s temperature to be).</p>
<p>By contrast, sometimes it’s not possible to measure the target
prediction subject directly, and sometimes predictions can cause
feedback loops.</p>
<div class="section level3">
<h3 id="case-study-proxy-variables">Case Study: Proxy variables<a class="anchor" aria-label="anchor" href="#case-study-proxy-variables"></a>
</h3>
<p>Consider the scenario described in the challenge below.</p>
<div id="discussion3" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Suppose that you work for a hospital and are asked to build a model
to predict which patients are high-risk and need extra care to prevent
negative health outcomes.</p>
<p>Discuss the following with a partner or small group: 1. What is the
goal target variable? 2. What are challenges in measuring the target
variable in the training data (i.e., former patients)? 3. Are there
other variables that are easier to measure, but can approximate the
target variable, that could serve as proxies? 3. How do social
inequities interplay with the value of the target variable versus the
value of the proxies?</p>
</div>
</div>
</div>
<div id="accordionInstructor3" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor3" aria-expanded="false" aria-controls="collapseInstructor3">
  <h3 class="accordion-header" id="headingInstructor3">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Discussion points </h3>
</button>
<div id="collapseInstructor3" class="accordion-collapse collapse" aria-labelledby="headingInstructor3" data-bs-parent="#accordionInstructor3">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>The goal target variable is healthcare need.</li>
<li>Patients’ healthcare needs are unknown unless they have seen a
doctor. Patients who have less access to medical care may have
under-documented needs. There might also be differences between doctors
or hospital systems in how health conditions are documented.</li>
<li>In the US, there are standard ways that healthcare <em>billing</em>
information needs to be documented (this information may be more
standardized than medical conditions). There may be more complete data
from acute medical emergencies (i.e., emergency room visits) than there
is for chronic conditions.</li>
<li>In the US, healthcare access is often tied to employment, which
means that wealthier people (who in the US, also tend to be white) have
more access to healthcare.</li>
</ol>
</div>
</div>
</div>
</div>
<p>The “challenge” scenario is not hypothetical: A well-known <a href="https://escholarship.org/content/qt6h92v832/qt6h92v832.pdf" class="external-link">study
by Obermeyer et al.</a> analyzed an algorithm that hospitals used to
assign patients risk scores for various conditions. The algorithm had
access to various patient data, such as demographics (e.g., age and
sex), the number of chronic conditions, insurance type, diagnoses, and
medical costs. The algorithm did not have access to the patient’s race.
The patient risk score determined the level of care the patient should
receive, with higher-risk patients receiving additional care.</p>
<p>Ideally, the target variable would be health needs, but this can be
challenging to measure: how do you compare the severity of two different
conditions? Do you count chronic and acute conditions equally? In the
system described by Obermeyer et al., the hospital decided to use
<strong>health-care costs</strong> as a proxy for health needs, perhaps
reasoning that this data is at least standardized across patients and
doctors.</p>
<p>However, Obermeyer et al. reveal that the algorithm is biased against
Black patients. That is, if there are two individuals – one white and
one Black – with equal health, the algorithm tends to assign a higher
risk score to the white patient, thus giving them access to higher care
quality. The authors blame the choice of proxy variable for the racial
disparities.</p>
<p>The authors go on to describe how, due to how health-care access is
structured in the US, richer patients have more healthcare expenses,
even if they are equally (un)healthy to a lower-income patient. The
richer patients are also more likely to be white.</p>
<p>Consider the following:</p>
<ul>
<li>How could the algorithm developers have caught this problem
earlier?</li>
<li>Is this a technical mistake or a process-based mistake? Why?</li>
</ul>
<div id="accordionInstructor4" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor4" aria-expanded="false" aria-controls="collapseInstructor4">
  <h3 class="accordion-header" id="headingInstructor4">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Discussion points </h3>
</button>
<div id="collapseInstructor4" class="accordion-collapse collapse" aria-labelledby="headingInstructor4" data-bs-parent="#accordionInstructor4">
<div class="accordion-body">
<ul>
<li>The algorithm developers could have tested specifically checked for
racial bias in their solution.</li>
<li>Discussion about the choice of target variable, including
implementing models with different targets and comparing the results,
could have exposed the bias.</li>
<li>Possibly a more diverse development team – e.g., including
individuals who have firsthand experience with struggling to access
healthcare – would have spotted the issue.</li>
<li>Note that it’s easier to see the mistake in hindsight than in the
moment.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="case-study-feedback-loop">Case study: Feedback loop<a class="anchor" aria-label="anchor" href="#case-study-feedback-loop"></a>
</h3>
<p>Consider social media, like Instagram or TikTok’s “for you page” or
Facebook or Twitter’s newsfeed. The algorithms that determine what to
show are complex (and proprietary!) but a large part of the algorithms’
objective is engagement: the number of clicks, views, or re-posts. For
instance, this focus on engagement can create an “echo chamber” where
individual users solely see content that aligns with their political
ideology, thereby maximizing the positive engagement with each post. But
the impact of social media feedback loops spreads beyond politics: <a href="https://arxiv.org/pdf/2305.11316" class="external-link">researchers have explored</a>
how similar feedback loops exist for mental health conditions such as
eating disorders. If someone finds themselves in this area of social
media, it’s likely because they have, or have risk factors for, an
eating disorder, and seeing pro-eating disorder content can drive
engagement, but ultimately be very bad for mental health.</p>
<p>Consider the following questions:</p>
<ul>
<li>Why do social media companies optimize for engagement?</li>
<li>What would be an alternative optimization target? How would the
outcomes differ, both for users and for the companies’ profits?</li>
</ul>
<div id="accordionInstructor5" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor5" aria-expanded="false" aria-controls="collapseInstructor5">
  <h3 class="accordion-header" id="headingInstructor5">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Discussion points </h3>
</button>
<div id="collapseInstructor5" class="accordion-collapse collapse" aria-labelledby="headingInstructor5" data-bs-parent="#accordionInstructor5">
<div class="accordion-body">
<ul>
<li>Social media companies optimize for engagement to maximize profits:
if users keep using the service, they can sell more ads and bring in
more revenue.</li>
<li>It’s hard to come up with an alternate optimization target that
could be easily operationalized. Alternate goals could be <em>social
connection</em>, <em>learning</em>, <em>broadening one’s worldview</em>,
or even <em>entertainment</em>. But how would any of these goals be
measured?</li>
</ul>
</div>
</div>
</div>
</div>
<p><strong>Recap - Choosing the right outcome variable</strong>:
Sometimes, choosing the outcome variable is straightforward, like
predicting tomorrow’s temperature. Other times, it gets tricky,
especially when we can’t directly measure what we want to predict. It’s
important to choose the right outcome variable because this decision
plays a crucial role in ensuring our models are trustworthy, “fair”
(more on this later), and unbiased. A poor choice can lead to biased
results and unintended consequences, making it harder for our models to
be effective and reliable.</p>
</div>
</section><section><h2 class="section-heading" id="understanding-bias">Understanding bias<a class="anchor" aria-label="anchor" href="#understanding-bias"></a>
</h2>
<hr class="half-width">
<p>Now that we’ve covered the importance of the outcome variable, let’s
talk about bias. Bias can show up in various ways during the modeling
process, impacting our results and fairness. If we don’t consider bias
from the beginning, we risk creating models that don’t work well for
everyone or that reinforce existing inequalities.</p>
<p>So, what exactly do we mean by bias? The term is a little overloaded
and can refer to different things depending on context. However, there
are two general types/definitions of bias:</p>
<ul>
<li>(Statistical) bias: This refers to the tendency of an algorithm to
produce one solution over another, even when other options may be just
as good or better. Statistical bias can arise from several sources
(discussed below), including how data is collected and processed.</li>
<li>(Social) bias: outcomes are unfair to one or more social groups.
Social bias can be the result of statistical bias (i.e., an algorithm
giving preferential treatment to one social group over others), but can
also occur outside of a machine learning context.</li>
</ul>
<div class="section level3">
<h3 id="sources-of-statistical-bias">Sources of statistical bias<a class="anchor" aria-label="anchor" href="#sources-of-statistical-bias"></a>
</h3>
<div class="section level4">
<h4 id="algorithmic-bias">Algorithmic bias<a class="anchor" aria-label="anchor" href="#algorithmic-bias"></a>
</h4>
<p>Algorithmic bias is the tendency of an algorithm to favor one
solution over another. Algorithmic bias is not always bad, and may
sometimes be encoded for by algorithm developers. For instance, linear
regression with L0-regularization displays algorithmic bias towards
sparse classifiers (i.e., classifiers where most weights are 0). This
bias may be desirable in settings where human interpretability is
important.</p>
<p>But algorithmic bias can also occur unintentionally: for instance, if
there is data bias (described below), this may lead algorithm developers
to select an algorithm that is ill-suited to underrepresented groups.
Then, even if the data bias is rectified, sticking with the original
algorithm choice may not fix biased outcomes.</p>
</div>
<div class="section level4">
<h4 id="data-bias">Data bias:<a class="anchor" aria-label="anchor" href="#data-bias"></a>
</h4>
<p>Data bias is when the available training data is not accurate or
representative of the target population. Data bias is extremely common
(it’s often hard to collect perfectly-representative, and
perfectly-accurate data), and care arise in multiple ways:</p>
<ul>
<li>Measurement error - if a tool is not well calibrated, measurements
taken by that tool won’t be accurate. Likewise, human biases can lead to
measurement error, for instance, if people systematically over-report
their height on dating apps, or if doctors do not believe patient’s
self-reports of their pain levels.</li>
<li>Response bias - for instance, when conducting a survey about
customer satisfaction, customers who had very positive or very negative
experiences may be more likely to respond.</li>
<li>Representation bias - the data is not well representative of the
whole population. For instance, doing clinical trials primarily on white
men means that women and other races are not well represented in
data.</li>
</ul>
<p>Through the rest of this lesson, if we use the term “bias” without
any additional context, we will be referring to social bias that stems
from statistical bias.</p>
<div id="case-study" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="case-study" class="callout-inner">
<h3 class="callout-title">Case Study</h3>
<div class="callout-content">
<p>With a partner or small group, choose one of the three case study
options. Read or watch individually, then discuss as a group how bias
manifested in the training data, and what strategies could correct for
it.</p>
<p>After the discussion, share with the whole workshop what you
discussed.</p>
<ol style="list-style-type: decimal">
<li><a href="https://www.technologyreview.com/2019/02/13/137444/predictive-policing-algorithms-ai-crime-dirty-data/" class="external-link">Predictive
policing</a></li>
<li>
<a href="http://gendershades.org/" class="external-link">Facial recognition</a> (video, 5
min.)</li>
<li><a href="https://www.aclu.org/news/womens-rights/why-amazons-automated-hiring-tool-discriminated-against" class="external-link">Amazon
hiring tool</a></li>
</ol>
</div>
</div>
</div>
<div id="accordionInstructor6" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor6" aria-expanded="false" aria-controls="collapseInstructor6">
  <h3 class="accordion-header" id="headingInstructor6">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Discussion points </h3>
</button>
<div id="collapseInstructor6" class="accordion-collapse collapse" aria-labelledby="headingInstructor6" data-bs-parent="#accordionInstructor6">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>Policing data does not provide a complete picture of crime: it only
contains data about crimes that are reported. Some neighborhoods (in the
US, usually poor neighborhoods with predominantly Black and Brown
residents) are over-policed relative to other neighborhoods. As a
result, data will suggest that the over-policed neighborhoods have more
crime, and then will send more officers to patrol those areas, resulting
in a feedback loop. Using techniques to clean and balance the data could
help, but the article’s authors also point towards using non-technical
solutions, such as algorithmic accountability and oversight
frameworks.</li>
<li>Commercially-available facial recognition systems have much higher
accuracies on white men than on darker-skinned women. This discrepancy
is attributed to imbalances in the training data. This problem could
have been avoided if development teams were more diverse: e.g., if
someone thought to evaluate the model on darker-skinned people during
the development process. Then, collecting more data from
underrepresented groups could improve accuracy on those
individuals.</li>
<li>Amazon tried to automate the resume-screening part of its hiring
process, relying on data (e.g., resumes) from existing employees.
However, the AI learned to discriminate against women because Amazon’s
existing technical staff skewed heavily male. This could have been
avoided in a couple ways: first, if Amazon did not have an existing
gender skew, the data would have been cleaner. Second, given the gender
skew in Amazon’s employees, model developers could have built in
safeguards, e.g., mechanisms to satisfy some notion of fairness, such as
deciding to interview an equal proportion of male and female job
applicants.</li>
</ol>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Some tasks are not appropriate for machine learning due to ethical
concerns.</li>
<li>Machine learning tasks should have a valid prediction target that
maps clearly to the real-world goal.</li>
<li>Training data can be biased due to societal inequities, errors in
the data collection process, and lack of attention to careful sampling
practices.</li>
<li>“Bias” also refers to statistical bias, and certain algorithms can
be biased towards some solutions.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div>
</section></section><section id="aio-2-model-eval-and-fairness"><p>Content from <a href="2-model-eval-and-fairness.html">Model evaluation and fairness</a></p>
<hr>
<p>Last updated on 2024-10-15 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/2-model-eval-and-fairness.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What metrics do we use to evaluate models?</li>
<li>What are some common pitfalls in model evaluation?</li>
<li>How do we define fairness and bias in machine learning
outcomes?</li>
<li>What types of bias and unfairness can occur in generative AI?</li>
<li>What techniques exist to improve the fairness of ML models?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Reason about model performance through standard evaluation
metrics.</li>
<li>Recall how underfitting, overfitting, and data leakage impact model
performance.</li>
<li>Understand and distinguish between various notions of fairness in
machine learning.</li>
<li>Understand general approaches for improving the fairness of ML
models.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="accuracy-metrics">Accuracy metrics<a class="anchor" aria-label="anchor" href="#accuracy-metrics"></a>
</h2>
<hr class="half-width">
<p>Stakeholders often want to know the accuracy of a machine learning
model – what percent of predictions are correct? Accuracy can be
decomposed into further metrics: e.g., in a binary prediction setting,
recall (the fraction of positive samples that are classified correctly)
and precision (the fraction of samples classified as positive that
actually are positive) are commonly-used metrics.</p>
<p>Suppose we have a model that performs binary classification (+, -) on
a test dataset of 1000 samples (let <span class="math inline">\(n\)</span>=1000). A <em>confusion matrix</em>
defines how many predictions we make in each of four quadrants: true
positive with positive prediction (++), true positive with negative
prediction (+-), true negative with positive prediction (-+), and true
negative with negative prediction (–).</p>
<table class="table">
<thead><tr class="header">
<th></th>
<th>True +</th>
<th>True -</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Predicted +</td>
<td>300</td>
<td>80</td>
</tr>
<tr class="even">
<td>Predicted -</td>
<td>25</td>
<td>595</td>
</tr>
</tbody>
</table>
<p>So, for instance, 80 samples have a true class of + but get predicted
as members of -.</p>
<p>We can compute the following metrics:</p>
<ul>
<li>Accuracy: What fraction of predictions are correct?
<ul>
<li>(300 + 595) / 100 = 0.895</li>
<li>Accuracy is 89.5%</li>
</ul>
</li>
<li>Precision: What fraction of predicted positives are true positives?
<ul>
<li>300 / (300 + 80) = 0.789</li>
<li>Precision is 78.9%</li>
</ul>
</li>
<li>Recall: What fraction of true positives are classified as positive?
<ul>
<li>300 / (300 + 25) = 0.923</li>
<li>Recall is 92.3%</li>
</ul>
</li>
</ul>
<div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>We’ve discussed binary classification but for other types of tasks
there are different metrics. For example,</p>
<ul>
<li>Multi-class problems often use <a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.top_k_accuracy_score.html" class="external-link">Top-K
accuracy</a>, a metric of how often the true response appears in their
top-K guesses.</li>
<li>Regression tasks often use the <a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" class="external-link">Area
Under the ROC curve (AUC ROC)</a> as a measure of how well the
classifier performs at different thresholds.</li>
</ul>
</div>
</div>
</div>
<div id="what-accuracy-metric-to-use" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="what-accuracy-metric-to-use" class="callout-inner">
<h3 class="callout-title">What accuracy metric to use?</h3>
<div class="callout-content">
<p>Different accuracy metrics may be more relevant in different
situations. Discuss with a partner or small groups whether precision,
recall, or some combination of the two is most relevant in the following
prediction tasks:</p>
<ol style="list-style-type: decimal">
<li>Deciding what patients are high risk for a disease and who should
get additional low-cost screening.</li>
<li>Deciding what patients are high risk for a disease and should start
taking medication to lower the disease risk. The medication is expensive
and can have unpleasant side effects.</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li><p>It is best if all patients who need the screening get it, and
there is little downside for doing screenings unnecessarily because the
screening costs are low. Thus, a high recall score is optimal.</p></li>
<li><p>Given the costs and side effects of the medicine, we do not want
patients not at risk for the disease to take the medication. So, a high
precision score is ideal.</p></li>
</ol>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="model-evaluation-pitfalls">Model evaluation pitfalls<a class="anchor" aria-label="anchor" href="#model-evaluation-pitfalls"></a>
</h2>
<hr class="half-width">
<div class="section level3">
<h3 id="overfitting-and-underfitting">Overfitting and underfitting<a class="anchor" aria-label="anchor" href="#overfitting-and-underfitting"></a>
</h3>
<p><strong>Overfitting</strong> is characterized by worse performance on
the test set than on the train set and can be fixed by switching to a
simpler model architecture or by adding regularization.</p>
<p><strong>Underfitting</strong> is characterized by poor performance on
both the training and test datasets. It can be fixed by collecting more
training data, switching to a more complex model architecture, or
improving feature quality.</p>
<figure><img src="https://kharshit.github.io/img/overfitting.png" alt="graphs of overfitting and underfitting" class="figure mx-auto d-block"><div class="figcaption">Example of overfitting/underfitting</div>
</figure><p>If you need a refresher on how to detect overfitting and underfitting
in your models, <a href="https://towardsdatascience.com/learning-curve-to-identify-overfitting-underfitting-problems-133177f38df5" class="external-link">this
article</a> is a good resource.</p>
</div>
<div class="section level3">
<h3 id="data-leakage">Data Leakage<a class="anchor" aria-label="anchor" href="#data-leakage"></a>
</h3>
<p>Data leakage occurs when the model has access to the test data during
training and results in overconfidence in the model’s performance.</p>
<p><a href="https://www.sciencedirect.com/science/article/pii/S2666389923001599" class="external-link">Recent
work</a> by Sayash Kapoor and Arvind Narayanan shows that data leakage
is incredibly widespread in papers that use ML across several scientific
fields. They define 8 common ways that data leakage occurs,
including:</p>
<ol style="list-style-type: decimal">
<li>No test set: there is no hold-out test-set, rather, the model is
evaluated on a subset of the training data. This is the “obvious,”
canonical example of data leakage.</li>
<li>Preprocessing on whole dataset: when preprocessing occurs on the
train + test sets, rather than just the train set, the model learns
information about the test set that it should not have access to until
later. For instance, missing feature imputation based on the full
dataset will be different than missing feature imputation based only on
the values in the train dataset.</li>
<li>Illegitimate features: sometimes, there are features that are
proxies for the outcome variable. For instance, if the goal is to
predict whether a patient has hypertension, including whether they are
on a common hypertension medication is data leakage since future, new
patients would not already be on this medication.</li>
<li>Temporal leakage: if the model predicts a future outcome, the train
set should contain information from the future. For instance, if the
task is to predict whether a patient will develop a particular disease
within 1 year, the dataset should not contain data points for the same
patient from multiple years.</li>
</ol>
</div>
</section><section><h2 class="section-heading" id="measuring-fairness">Measuring fairness<a class="anchor" aria-label="anchor" href="#measuring-fairness"></a>
</h2>
<hr class="half-width">
<p>What does it mean for a machine learning model to be fair or
unbiased? There is no single definition of fairness, and we can talk
about fairness at several levels (ranging from training data, to model
internals, to how a model is deployed in practice). Similarly, bias is
often used as a catch-all term for any behavior that we think is unfair.
Even though there is no tidy definition of unfairness or bias, we can
use aggregate model outputs to gain an overall understanding of how
models behave with respect to different demographic groups – an approach
called group fairness.</p>
<p>In general, if there are no differences between groups in the real
world (e.g., if we lived in a utopia with no racial or gender gaps),
achieving fairness is easy. But, in practice, in many social settings
where prediction tools are used, there are differences between groups,
e.g., due to historical and current discrimination.</p>
<p>For instance, in a loan prediction setting in the United States, the
average white applicant may be better positioned to repay a loan than
the average Black applicant due to differences in generational wealth,
education opportunities, and other factors stemming from anti-Black
racism. Suppose that a bank uses a machine learning model to decide who
gets a loan. Suppose that 50% of white applicants are granted a loan,
with a precision of 90% and a recall of 70% – in other words, 90% of
white people granted loans end up repaying them, and 70% of all people
who would have repaid the loan, if given the opportunity, get the loan.
Consider the following scenarios:</p>
<ul>
<li>(Demographic parity) We give loans to 50% of Black applicants in a
way that maximizes overall accuracy</li>
<li>(Equalized odds) We give loans to X% of Black applicants, where X is
chosen to maximize accuracy subject to keeping precision equal to
90%.</li>
<li>(Group level calibration) We give loans to X% of Black applicants,
where X is chosen to maximize accuracy while keeping recall equal to
70%.</li>
</ul>
<p>There are <em>many</em> notions of statistical group fairness, but
most boil down to one of the three above options: demographic parity,
equalized odds, and group-level calibration. All three are forms of
<em>distributional</em> (or <em>outcome</em>) fairness. Another
dimension, though, is <em>procedural</em> fairness: whether decisions
are made in a just way, regardless of final outcomes. Procedural
fairness contains many facets, but one way to operationalize it is to
consider individual fairness (also called counterfactual fairness),
which was suggested in 2012 by <a href="https://dl.acm.org/doi/abs/10.1145/2090236.2090255" class="external-link">Dwork et
al.</a> as a way to ensure that “similar individuals [are treated]
similarly”. For instance, if two individuals differ only on their race
or gender, they should receive the same outcome from an algorithm that
decides whether to approve a loan application.</p>
<p>In practice, it’s hard to use individual fairness because defining a
complete set of rules about when two individuals are sufficiently
“similar” is challenging.</p>
<div id="matching-fairness-terminology-with-definitions" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="matching-fairness-terminology-with-definitions" class="callout-inner">
<h3 class="callout-title">Matching fairness terminology with definitions</h3>
<div class="callout-content">
<p>Match the following types of formal fairness with their definitions.
(A) Individual fairness, (B) Equalized odds, (C) Demographic parity, and
(D) Group-level calibration</p>
<ol style="list-style-type: decimal">
<li>The model is equally accurate across all demographic groups.</li>
<li>Different demographic groups have the same true positive rates and
false positive rates.</li>
<li>Similar people are treated similarly.</li>
<li>People from different demographic groups receive each outcome at the
same rate.</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<p>A - 3, B - 2, C - 4, D - 1</p>
</div>
</div>
</div>
</div>
<p>But some types of unfairness cannot be directly measured by
group-level statistical data. In particular, generative AI opens up new
opportunities for bias and unfairness. Bias can occur through
representational harms (e.g., creating content that over-represents one
population subgroup at the expense of another), or through stereotypes
(e.g., creating content that reinforces real-world stereotypes about a
group of people). We’ll discuss some specific examples of bias in
generative models next.</p>
</section><section><h2 class="section-heading" id="fairness-in-generative-ai">Fairness in generative AI<a class="anchor" aria-label="anchor" href="#fairness-in-generative-ai"></a>
</h2>
<hr class="half-width">
<p>Generative models learn from statistical patterns in real-world data.
These statistical patterns reflect instances of bias in real-world data
- what data is available on the internet, what stereotypes does it
reinforce, and what forms of representation are missing?</p>
<div class="section level3">
<h3 id="natural-language">Natural language<a class="anchor" aria-label="anchor" href="#natural-language"></a>
</h3>
<p>One set of social stereotypes that large AI models can learn is
gender based. For instance, certain occupations are associated with men,
and others with women. For instance, in the U.S., doctors are
historically and stereotypically usually men.</p>
<p>In 2016, Caliskan et al. <a href="https://www.fatml.org/schedule/2016/presentation/semantics-derived-automatically-language-corpora" class="external-link">showed
that machine translation systems exhibit gender bias</a>, for instance,
by reverting to stereotypical gendered pronouns in ambiguous
translations, like in Turkish – a language without gendered pronouns –
to English.</p>
<p>In response, Google <a href="https://blog.research.google/2018/12/providing-gender-specific-translations.html" class="external-link">tweaked
their translator algorithms</a> to identify and correct for gender
stereotypes in Turkish and several other widely-spoken languages. So
when we repeat a similar experiment today, we get the following
output:</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e4-turkish-nlp-stereotypes.png" alt='Screenshot of Google Translate output. The English sentence "The doctor is on her lunch break" is translated to Turkish, and then the Turkish output is translated back to English as either "The doctor is on his lunch break" or "The doctor is on his lunch break".' class="figure mx-auto d-block"><div class="figcaption">Turkish Google Translate example (screenshot
from 1/9/2024)</div>
</figure><p>But for other, less widely-spoken languages, the original problem
persists:</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e4-norwegian-nlp-stereotypes.png" alt='Screenshot of Google Translate output. The English sentence "The doctor is on her lunch break" is translated to Norwegian, and then the Norwegian output is translated back to English as "The doctor is on his lunch break".' class="figure mx-auto d-block"><div class="figcaption">Norwegian Google Translate example (screenshot
from 1/9/2024)</div>
</figure><p>We’re not trying to slander Google Translate here – the translation,
without additional context, is ambiguous. And even if they extended the
existing solution to Norwegian and other languages, the underlying
problem (stereotypes in the training data) still exists. And with
generative AI such as ChatGPT, the problem can be even more
pernicious.</p>
<div id="red-teaming-large-language-models" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="red-teaming-large-language-models" class="callout-inner">
<h3 class="callout-title">Red-teaming large language models</h3>
<div class="callout-content">
<p>In cybersecurity, “red-teaming” is when well-intentioned people think
like a hacker in order to make a system safer. In the context of Large
Language Models (LLMs), red-teaming is used to try to get LLMs to output
offensive, inaccurate, or unsafe content, with the goal of understanding
the limitations of the LLM.</p>
<p>Try out red-teaming with ChatGPT or another LLM. Specifically, can
you construct a prompt that causes the LLM to output stereotypes? Here
are some example prompts, but feel free to get creative!</p>
<ul>
<li><p>“Tell me a story about a doctor” (or other profession with
gender)</p></li>
<li><p>If you speak a language other than English, how does are
ambiguous gendered pronouns handled? For instance, try the prompt
“Translate ‘The doctor is here’ to Spanish”. Is a masculine or feminine
pronoun used for the doctor in Spanish?</p></li>
</ul>
<p>If you use LLMs in your research, consider whether any of these
issues are likely to be present for your use cases. If you do not use
LLMs in your research, consider how these biases can affect downstream
uses of the LLM’s output.</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" data-bs-parent="#accordionSolution3" aria-labelledby="headingSolution3">
<div class="accordion-body">
<p>Most publicly-available LLM providers set up guardrails to avoid
propagating biases present in their training data. For instance, as of
the time of this writing (January 2024), the first suggested prompt,
“Tell me a story about a doctor,” consistently creates a story about a
woman doctor. Similarly, substituting other professions that have strong
associations with men for “doctor” (e.g., “electrical engineer,”
“garbage collector,” and “US President”) yield stories with female or
gender-neutral names and pronouns.</p>
</div>
</div>
</div>
</div>
<div id="discussing-other-fairness-issues" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="discussing-other-fairness-issues" class="callout-inner">
<h3 class="callout-title">Discussing other fairness issues</h3>
<div class="callout-content">
<p>If you use LLMs in your research, consider whether any of these
issues are likely to be present for your use cases. Share your thoughts
in small groups with other workshop participants.</p>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="image-generation">Image generation<a class="anchor" aria-label="anchor" href="#image-generation"></a>
</h3>
<p>The same problems that language modeling face also affect image
generation. Consider, for instance, Melon et al. <a href="https://arxiv.org/pdf/2003.03808.pdf" class="external-link">developed an algorithm
called Pulse</a> that can convert blurry images to higher resolution.
But, biases were quickly unearthed and <a href="https://twitter.com/Chicken3gg/status/1274314622447820801?s=20&amp;t=_oORPJBJRaBW_J0zresFJQ" class="external-link">shared
via social media</a>.</p>
<div id="discussion5" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Who is shown in this blurred picture? <img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e4-obama.png" alt="blurry image of Barack Obama" class="figure"></p>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" data-bs-parent="#accordionSolution4" aria-labelledby="headingSolution4">
<div class="accordion-body">
<p>While the picture is of Barack Obama, the upsampled image shows a
white face. <img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e4-obama-upsampled.png" alt="Unblurred version of the pixelated picture of Obama. Instead of showing Obama, it shows a white man." class="figure"></p>
<p>You can <a href="https://colab.research.google.com/github/tg-bomze/Face-Depixelizer/blob/master/Face_Depixelizer_Eng.ipynb#scrollTo=fU0aGtD4Nl4W" class="external-link">try
the model here</a>.</p>
</div>
</div>
</div>
</div>
<p>Menon and colleagues subsequently updated their paper to discuss this
issue of bias. They assert that the problems inherent in the PULSE model
are largely a result of the <a href="https://arxiv.org/abs/1812.04948" class="external-link">underlying StyleGAN model</a>,
which they had used in their work.</p>
<blockquote>
<p>Overall, it seems that sampling from StyleGAN yields white faces much
more frequently than faces of people of color … This bias extends to any
downstream application of StyleGAN, including the implementation of
PULSE using StyleGAN.</p>
<p>…</p>
<p>Results indicate a racial bias among the generated pictures, with
close to three-fourths (72.6%) of the pictures representing White
people. Asian (13.8%) and Black (10.1%) are considerably less frequent,
while Indians represent only a minor fraction of the pictures
(3.4%).</p>
</blockquote>
<p>These remarks get at a central issue: biases in any building block of
a system (data, base models, etc.) get propagated forwards. In
generative AI, such as text-to-image systems, this can result in
representational harms, <a href="https://arxiv.org/pdf/2211.03759.pdf" class="external-link">as documented by Bianchi et
al.</a> Fixing these issues of bias is still an active area of research.
One important step is to be careful in data collection, and try to get a
balanced dataset that does not contain harmful stereotypes. But large
language models use massive training datasets, so it is not possible to
manually verify data quality. Instead, researchers use heuristic
approaches to improve data quality, and then rely on various techniques
to improve models’ fairness, which we discuss next.</p>
</div>
</section><section><h2 class="section-heading" id="improving-fairness-of-models">Improving fairness of models<a class="anchor" aria-label="anchor" href="#improving-fairness-of-models"></a>
</h2>
<hr class="half-width">
<p>Model developers frequently try to improve the fairness of there
model by intervening at one of three stages: pre-processing,
in-processing, or post-processing. We’ll cover techniques within each of
these paradigms in turn.</p>
<p>We start, though, by discussing why removing the sensitive
attribute(s) is not sufficient. Consider the task of deciding which loan
applicants are funded. Suppose we are concerned with racial bias in the
model outputs. If we remove race from the set of attributes available to
the model, the model cannot make <em>overly</em> racist decisions.
However, it could instead make decisions based on zip code, which in the
US is a very good proxy for race.</p>
<p>Can we simply remove all proxy variables? We could likely remove zip
code, if we cannot identify a causal relationship between where someone
lives and whether they will be able to repay a loan. But what about an
attribute like educational achievement? Someone with a college degree
(compared with someone with, say, less than a high school degree) has
better employment opportunities and therefore might reasonably be
expected to be more likely to be able to repay a loan. However,
educational attainment is still a proxy for race in the United States
due to historical (and ongoing) discrimination.</p>
<p><strong>Pre-processing</strong> generally modifies the dataset used
for learning. Techniques in this category include:</p>
<ul>
<li><p>Oversampling/undersampling: instead of training a machine
learning model on all of the data, <em>undersample</em> the majority
class by removing some of the majority class samples from the dataset in
order to have a more balanced dataset. Alternatively,
<em>oversample</em> the minority class by duplicating samples belonging
to this group.</p></li>
<li><p>Data augmentation: the number of samples from minority groups may
be increased by generating synthetic data with a generative adversarial
network (GAN). We won’t cover this method in this workshop (using a GAN
can be more computationally expensive than other techniques). If you’re
interested, you can learn more about this method from the paper <a href="https://link.springer.com/chapter/10.1007/978-3-030-58542-6_23" class="external-link">Inclusive
GAN: Improving Data and Minority Coverage in Generative
Models</a>.</p></li>
<li><p>Changing feature representations: various techniques have been
proposed to increase fairness by removing unfairness from the data
directly. To do so, the data is converted into an alternate
representation so that differences between demographic groups are
minimized, yet enough information is maintained in order to be able to
learn a model that performs well. An advantage of this method is that it
is model-agnostic, however, a challenge is it reduces the
interpretability of interpretable models and makes post-hoc
explainability less meaningful for black-box models.</p></li>
</ul>
<div id="pros-and-cons-of-preprocessing-options" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="pros-and-cons-of-preprocessing-options" class="callout-inner">
<h3 class="callout-title">Pros and cons of preprocessing options</h3>
<div class="callout-content">
<p>Discuss what you think the pros and cons of the different
pre-processing options are. What techniques might work better in
different settings?</p>
</div>
</div>
</div>
<div id="accordionSolution5" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution5" aria-expanded="false" aria-controls="collapseSolution5">
  <h4 class="accordion-header" id="headingSolution5"> Show me the solution </h4>
</button>
<div id="collapseSolution5" class="accordion-collapse collapse" data-bs-parent="#accordionSolution5" aria-labelledby="headingSolution5">
<div class="accordion-body">
<p>A downside of oversampling is that it may violate statistical
assumptions about independence of samples. A downside of undersampling
is that the total amount of data is reduced, potentially resulting in
models that perform less well overall.</p>
<p>A downside of using GANs to generate additional data is that this
process may be expensive and require higher levels of ML expertise.</p>
<p>A challenge with all techniques is that if there is not sufficient
data from minority groups, it may be hard to achieve good performance on
the groups without simply collecting more or higher-quality data.</p>
</div>
</div>
</div>
</div>
<p><strong>In-processing</strong> modifies the learning algorithm. Some
specific in-processing techniques include:</p>
<ul>
<li><p>Reweighting samples: many machine learning models allow for
reweighting individual samples, i.e., indicating that misclassifying
certain, rarer, samples should be penalized more severely in the loss
function. In the code example, we show how to reweight samples using
AIF360’s <a href="https://aif360.readthedocs.io/en/latest/modules/generated/aif360.algorithms.preprocessing.Reweighing.html" class="external-link">Reweighting</a>
function.</p></li>
<li><p>Incorporating fairness into the loss function: reweighting
explicitly instructs the loss function to penalize the misclassification
of certain samples more harshly. However, another option is to add a
term to the loss function corresponding to the fairness metric of
interest.</p></li>
</ul>
<p><strong>Post-processing</strong> modifies an existing model to
increase its fairness. Techniques in this category often compute a
custom <em>threshold</em> for each demographic group in order to satisfy
a specific notion of group fairness. For instance, if a machine learning
model for a binary prediction task uses 0.5 as a cutoff (e.g., raw
scores less than 0.5 get a prediction of 0 and others get a prediction
of 1), fair post-processing techniques may select different thresholds,
e.g., 0.4 or 0.6 for different demographic groups.</p>
<p>In the next episode, we explore two different bias mitigations
strategies implemented in the <a href="https://aif360.readthedocs.io/en/stable/" class="external-link">AIF360 Fairness
Toolkit</a>. <!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 --></p>
</section></section><section id="aio-3-model-fairness-deep-dive"><p>Content from <a href="3-model-fairness-deep-dive.html">Model fairness: hands-on</a></p>
<hr>
<p>Last updated on 2024-12-02 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/3-model-fairness-deep-dive.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How can we use AI Fairness 360 – a common toolkit – for measuring
and improving model fairness?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Describe and implement two different ways of modifying the machine
learning modeling process to improve the fairness of a model.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<hr>
<p>In this episode, we will explore, hands-on, how to measure and
improve fairness of ML models.</p>
<p>This notebook is adapted from AIF360’s <a href="https://github.com/Trusted-AI/AIF360/blob/master/examples/tutorial_medical_expenditure.ipynb" class="external-link">Medical
Expenditure Tutorial</a>.</p>
<p>The tutorial uses data from the <a href="https://meps.ahrq.gov/mepsweb/" class="external-link">Medical Expenditure Panel
Survey</a>. We include a short description of the data below. For more
details, especially on the preprocessing, please see the AIF360
tutorial.</p>
<p>To begin, we’ll import some generally-useful packages.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># import numpy</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="co"># import Markdown for nice display</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Markdown, display</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="co"># import matplotlib</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="co"># import defaultdict (we'll use this instead of dict because it allows us to initialize a dictionary with a default value)</span></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span></code></pre>
</div>
<section><h2 class="section-heading" id="scenario-and-data">Scenario and data<a class="anchor" aria-label="anchor" href="#scenario-and-data"></a>
</h2>
<hr class="half-width">
<p>The goal is to develop a healthcare utilization scoring model – i.e.,
to predict which patients will have the highest utilization of
healthcare resources.</p>
<p>The original dataset contains information about various types of
medical visits; the AIF360 preprocessing created a single output feature
‘UTILIZATION’ that combines utilization across all visit types. Then,
this feature is binarized based on whether utilization is high, defined
as &gt;= 10 visits. Around 17% of the dataset has high utilization.</p>
<p>The sensitive feature (that we will base fairness scores on) is
defined as race. Other predictors include demographics, health
assessment data, past diagnoses, and physical/mental limitations.</p>
<p>The data is divided into years (we follow the lead of AIF360’s
tutorial and use 2015), and further divided into Panels. We use Panel 19
(the first half of 2015).</p>
<div class="section level3">
<h3 id="loading-the-data">Loading the data<a class="anchor" aria-label="anchor" href="#loading-the-data"></a>
</h3>
<p>Before starting, make sure you have downloaded the data as described
in the <a href="https://carpentries-incubator.github.io/fair-explainable-ml/#download-and-move-the-data-needed" class="external-link">setup
instructions</a>.</p>
<p>First, we need to import the dataset from the AI Fairness 360
library. Then, we can load in the data and create the
train/validation/test splits. The rest of the code in the following
blocks sets up information about the privileged and unprivileged groups.
(Recall, we focus on race as the sensitive feature.)</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="im">from</span> aif360.datasets <span class="im">import</span> MEPSDataset19 <span class="co"># import the dataset</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># assign train, validation, and test data. </span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="co"># Split the data into 50% train, 30% val, and 20% test</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>(dataset_orig_panel19_train,</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a> dataset_orig_panel19_val,</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a> dataset_orig_panel19_test) <span class="op">=</span> MEPSDataset19().split([<span class="fl">0.5</span>, <span class="fl">0.8</span>], shuffle<span class="op">=</span><span class="va">True</span>, seed<span class="op">=</span><span class="dv">1</span>) </span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>sens_ind <span class="op">=</span> <span class="dv">0</span> <span class="co"># sensitive attribute index is 0</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>sens_attr <span class="op">=</span> dataset_orig_panel19_train.protected_attribute_names[sens_ind] <span class="co"># sensitive attribute name</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="co"># find the attribute values that correspond to the privileged and unprivileged groups</span></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a>unprivileged_groups <span class="op">=</span> [{sens_attr: v} <span class="cf">for</span> v <span class="kw">in</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>                       dataset_orig_panel19_train.unprivileged_protected_attributes[sens_ind]]</span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a>privileged_groups <span class="op">=</span> [{sens_attr: v} <span class="cf">for</span> v <span class="kw">in</span></span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a>                     dataset_orig_panel19_train.privileged_protected_attributes[sens_ind]]</span></code></pre>
</div>
<p>Check object type.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="bu">type</span>(dataset_orig_panel19_train)</span></code></pre>
</div>
<p>Preview data.</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>dataset_orig_panel19_train.convert_to_dataframe()[<span class="dv">0</span>].head()</span></code></pre>
</div>
<p>Show details about the data.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="kw">def</span> describe(train:MEPSDataset19<span class="op">=</span><span class="va">None</span>, val:MEPSDataset19<span class="op">=</span><span class="va">None</span>, test:MEPSDataset19<span class="op">=</span><span class="va">None</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co">        Print information about the test dataset (and train and validation dataset, if </span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co">        provided). Prints the dataset shape, favorable and unfavorable labels, </span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="co">        protected attribute names, and feature names.</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>    <span class="cf">if</span> train <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>        display(Markdown(<span class="st">"#### Training Dataset shape"</span>))</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>        <span class="bu">print</span>(train.features.shape) <span class="co"># print the shape of the training dataset - should be (7915, 138)</span></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>    <span class="cf">if</span> val <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>        display(Markdown(<span class="st">"#### Validation Dataset shape"</span>))</span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>        <span class="bu">print</span>(val.features.shape)</span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Test Dataset shape"</span>))</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>    <span class="bu">print</span>(test.features.shape)</span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Favorable and unfavorable labels"</span>))</span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a>    <span class="bu">print</span>(test.favorable_label, test.unfavorable_label) <span class="co"># print favorable and unfavorable labels. Should be 1, 0</span></span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Protected attribute names"</span>))</span>
<span id="cb6-18"><a href="#cb6-18" tabindex="-1"></a>    <span class="bu">print</span>(test.protected_attribute_names) <span class="co"># print protected attribute name, "RACE"</span></span>
<span id="cb6-19"><a href="#cb6-19" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Privileged and unprivileged protected attribute values"</span>))</span>
<span id="cb6-20"><a href="#cb6-20" tabindex="-1"></a>    <span class="bu">print</span>(test.privileged_protected_attributes, </span>
<span id="cb6-21"><a href="#cb6-21" tabindex="-1"></a>          test.unprivileged_protected_attributes) <span class="co"># print protected attribute values. Should be [1, 0]</span></span>
<span id="cb6-22"><a href="#cb6-22" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Dataset feature names</span><span class="ch">\n</span><span class="st"> See [MEPS documentation](https://meps.ahrq.gov/data_stats/download_data/pufs/h181/h181doc.pdf) for details on the various features"</span>))</span>
<span id="cb6-23"><a href="#cb6-23" tabindex="-1"></a>    <span class="bu">print</span>(test.feature_names) <span class="co"># print feature names</span></span>
<span id="cb6-24"><a href="#cb6-24" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" tabindex="-1"></a>describe(dataset_orig_panel19_train, dataset_orig_panel19_val, dataset_orig_panel19_test) <span class="co"># call our function "describe"</span></span></code></pre>
</div>
<p>Next, we will look at whether the dataset contains bias; i.e., does
the outcome ‘UTILIZATION’ take on a positive value more frequently for
one racial group than another?</p>
<p>To check for biases, we will use the BinaryLabelDatasetMetric class
from the AI Fairness 360 toolkit. This class creates an object that –
given a dataset and user-defined sets of “privileged” and “unprivileged”
groups – can compute various fairness scores. We will call the function
MetricTextExplainer (also in AI Fairness 360) on the
BinaryLabelDatasetMetric object to compute the disparate impact. The
disparate impact score will be between 0 and 1, where 1 indicates <em>no
bias</em> and 0 indicates extreme bias. In other words, we want a score
that is close to 1, because this indicates that different demographic
groups have similar outcomes under the model. A commonly used threshold
for an “acceptable” disparate impact score is 0.8, because under U.S.
law in various domains (e.g., employment and housing), the disparate
impact between racial groups can be no larger than 80%.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># import MetricTextExplainer to be able to print descriptions of metrics</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="im">from</span> aif360.explainers <span class="im">import</span> MetricTextExplainer </span></code></pre>
</div>
<p>Some initial import error may occur since we’re using the CPU-only
version of torch. If you run the import statement twice it should
correct itself. We’ve coded this as a try/except statement below.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co"># import BinaryLabelDatasetMetric (class of metrics) </span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>    <span class="im">from</span> aif360.metrics <span class="im">import</span> BinaryLabelDatasetMetric</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="cf">except</span> <span class="pp">OSError</span> <span class="im">as</span> e:</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"First import failed: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">. Retrying..."</span>)</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>    <span class="im">from</span> aif360.metrics <span class="im">import</span> BinaryLabelDatasetMetric</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Import successful!"</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>metric_orig_panel19_train <span class="op">=</span> BinaryLabelDatasetMetric(</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>        dataset_orig_panel19_train, <span class="co"># train data</span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>        unprivileged_groups<span class="op">=</span>unprivileged_groups, <span class="co"># pass in names of unprivileged and privileged groups</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>        privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>explainer_orig_panel19_train <span class="op">=</span> MetricTextExplainer(metric_orig_panel19_train) <span class="co"># create a MetricTextExplainer object</span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="bu">print</span>(explainer_orig_panel19_train.disparate_impact()) <span class="co"># print disparate impact</span></span></code></pre>
</div>
<p>We see that the disparate impact is about 0.48, which means the
privileged group has the favorable outcome at about 2x the rate as the
unprivileged group does.</p>
<p>(In this case, the “favorable” outcome is label=1, i.e., high
utilization) ## Train a model</p>
<p>We will train a logistic regression classifier. To do so, we have to
import various functions from sklearn: a scaler, the logistic regression
class, and make_pipeline.</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> make_pipeline <span class="co"># allows to stack modeling steps</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> Pipeline <span class="co"># allow us to reference the Pipeline object type</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>dataset <span class="op">=</span> dataset_orig_panel19_train <span class="co"># use the train dataset</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>model <span class="op">=</span> make_pipeline(StandardScaler(), <span class="co"># scale the data to have mean 0 and variance 1</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>                      LogisticRegression(solver<span class="op">=</span><span class="st">'liblinear'</span>, </span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>                                         random_state<span class="op">=</span><span class="dv">1</span>) <span class="co"># logistic regression model</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>                    )</span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>fit_params <span class="op">=</span> {<span class="st">'logisticregression__sample_weight'</span>: dataset.instance_weights} <span class="co"># use the instance weights to fit the model</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a>lr_orig_panel19 <span class="op">=</span> model.fit(dataset.features, dataset.labels.ravel(), <span class="op">**</span>fit_params) <span class="co"># fit the model</span></span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="validate-the-model">Validate the model<a class="anchor" aria-label="anchor" href="#validate-the-model"></a>
</h3>
<p>We want to validate the model – that is, check that it has good
accuracy and fairness when evaluated on the <em>validation</em> dataset.
(By contrast, during training, we only optimize for accuracy and
fairness on the training dataset.)</p>
<p>Recall that a logistic regression model can output probabilities
(i.e., <code>model.predict(dataset).scores</code>) and we can determine
our own threshold for predicting class 0 or 1. One goal of the
validation process is to select the <em>threshold</em> for the model,
i.e., the value <em>v</em> so that if the model’s output is greater than
<em>v</em>, we will predict the label 1.</p>
<p>The following function, <code>test</code>, computes performance on
the logistic regression model based on a variety of thresholds, as
indicated by <code>thresh_arr</code>, an array of threshold values. The
threshold values we test are determined through the function
<code>np.linspace</code>. We will continue to focus on disparate impact,
but all other metrics are described in the <a href="https://aif360.readthedocs.io/en/stable/modules/generated/aif360.metrics.ClassificationMetric.html#aif360.metrics.ClassificationMetric" class="external-link">AIF360
documentation</a>.</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="co"># Import the ClassificationMetric class to be able to compute metrics for the model</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="im">from</span> aif360.metrics <span class="im">import</span> ClassificationMetric</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="kw">def</span> test(dataset: MEPSDataset19, model:Pipeline, thresh_arr: np.ndarray) <span class="op">-&gt;</span> <span class="bu">dict</span>: </span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>    <span class="co">''' </span></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="co">        Given a dataset, model, and list of potential cutoff thresholds, compute various metrics</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="co">        for the model. Returns a dictionary of the metrics, including balanced accuracy, average odds</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a><span class="co">        difference, disparate impact, statistical parity difference, equal opportunity difference, and</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a><span class="co">        theil index.</span></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a>        <span class="co"># sklearn classifier</span></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a>        y_val_pred_prob <span class="op">=</span> model.predict_proba(dataset.features) <span class="co"># get the predicted probabilities</span></span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">AttributeError</span> <span class="im">as</span> e:</span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a>        <span class="bu">print</span>(e)</span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a>        <span class="co"># aif360 inprocessing algorithm</span></span>
<span id="cb13-14"><a href="#cb13-14" tabindex="-1"></a>        y_val_pred_prob <span class="op">=</span> model.predict(dataset).scores <span class="co"># get the predicted scores</span></span>
<span id="cb13-15"><a href="#cb13-15" tabindex="-1"></a>        pos_ind <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-16"><a href="#cb13-16" tabindex="-1"></a>        </span>
<span id="cb13-17"><a href="#cb13-17" tabindex="-1"></a>    pos_ind <span class="op">=</span> np.where(model.classes_ <span class="op">==</span> dataset.favorable_label)[<span class="dv">0</span>][<span class="dv">0</span>] <span class="co"># get the index corresponding to the positive class</span></span>
<span id="cb13-18"><a href="#cb13-18" tabindex="-1"></a>    metric_arrs <span class="op">=</span> defaultdict(<span class="bu">list</span>) <span class="co"># create a dictionary to store the metrics</span></span>
<span id="cb13-19"><a href="#cb13-19" tabindex="-1"></a>    </span>
<span id="cb13-20"><a href="#cb13-20" tabindex="-1"></a>    <span class="co"># repeat the following for each potential cutoff threshold</span></span>
<span id="cb13-21"><a href="#cb13-21" tabindex="-1"></a>    <span class="cf">for</span> thresh <span class="kw">in</span> thresh_arr:</span>
<span id="cb13-22"><a href="#cb13-22" tabindex="-1"></a>        y_val_pred <span class="op">=</span> (y_val_pred_prob[:, pos_ind] <span class="op">&gt;</span> thresh).astype(np.float64) <span class="co"># get the predicted labels</span></span>
<span id="cb13-23"><a href="#cb13-23" tabindex="-1"></a></span>
<span id="cb13-24"><a href="#cb13-24" tabindex="-1"></a>        dataset_pred <span class="op">=</span> dataset.copy() <span class="co"># create a copy of the dataset</span></span>
<span id="cb13-25"><a href="#cb13-25" tabindex="-1"></a>        dataset_pred.labels <span class="op">=</span> y_val_pred <span class="co"># assign the predicted labels to the new dataset</span></span>
<span id="cb13-26"><a href="#cb13-26" tabindex="-1"></a>        metric <span class="op">=</span> ClassificationMetric( <span class="co"># create a ClassificationMetric object</span></span>
<span id="cb13-27"><a href="#cb13-27" tabindex="-1"></a>                dataset, dataset_pred,</span>
<span id="cb13-28"><a href="#cb13-28" tabindex="-1"></a>                unprivileged_groups<span class="op">=</span>unprivileged_groups,</span>
<span id="cb13-29"><a href="#cb13-29" tabindex="-1"></a>                privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb13-30"><a href="#cb13-30" tabindex="-1"></a></span>
<span id="cb13-31"><a href="#cb13-31" tabindex="-1"></a>        <span class="co"># various metrics - can look up what they are on your own</span></span>
<span id="cb13-32"><a href="#cb13-32" tabindex="-1"></a>        metric_arrs[<span class="st">'bal_acc'</span>].append((metric.true_positive_rate()</span>
<span id="cb13-33"><a href="#cb13-33" tabindex="-1"></a>                                     <span class="op">+</span> metric.true_negative_rate()) <span class="op">/</span> <span class="dv">2</span>) <span class="co"># balanced accuracy</span></span>
<span id="cb13-34"><a href="#cb13-34" tabindex="-1"></a>        metric_arrs[<span class="st">'avg_odds_diff'</span>].append(metric.average_odds_difference()) <span class="co"># average odds difference</span></span>
<span id="cb13-35"><a href="#cb13-35" tabindex="-1"></a>        metric_arrs[<span class="st">'disp_imp'</span>].append(metric.disparate_impact()) <span class="co"># disparate impact</span></span>
<span id="cb13-36"><a href="#cb13-36" tabindex="-1"></a>        metric_arrs[<span class="st">'stat_par_diff'</span>].append(metric.statistical_parity_difference()) <span class="co"># statistical parity difference</span></span>
<span id="cb13-37"><a href="#cb13-37" tabindex="-1"></a>        metric_arrs[<span class="st">'eq_opp_diff'</span>].append(metric.equal_opportunity_difference()) <span class="co"># equal opportunity difference</span></span>
<span id="cb13-38"><a href="#cb13-38" tabindex="-1"></a>        metric_arrs[<span class="st">'theil_ind'</span>].append(metric.theil_index()) <span class="co"># theil index</span></span>
<span id="cb13-39"><a href="#cb13-39" tabindex="-1"></a>    </span>
<span id="cb13-40"><a href="#cb13-40" tabindex="-1"></a>    <span class="cf">return</span> metric_arrs</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>thresh_arr <span class="op">=</span> np.linspace(<span class="fl">0.01</span>, <span class="fl">0.5</span>, <span class="dv">50</span>) <span class="co"># create an array of 50 potential cutoff thresholds ranging from 0.01 to 0.5</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>val_metrics <span class="op">=</span> test(dataset<span class="op">=</span>dataset_orig_panel19_val, </span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>                   model<span class="op">=</span>lr_orig_panel19,</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>                   thresh_arr<span class="op">=</span>thresh_arr) <span class="co"># call our function "test" with the validation data and lr model</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>lr_orig_best_ind <span class="op">=</span> np.argmax(val_metrics[<span class="st">'bal_acc'</span>]) <span class="co"># get the index of the best balanced accuracy</span></span></code></pre>
</div>
<p>We will plot <code>val_metrics</code>. The x-axis will be the
threshold we use to output the label 1 (i.e., if the raw score is larger
than the threshold, we output 1).</p>
<p>The y-axis will show both balanced accuracy (in blue) and disparate
impact (in red).</p>
<p>Note that we plot 1 - Disparate Impact, so now a score of 0 indicates
no bias.</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="kw">def</span> plot(x:np.ndarray, x_name:<span class="bu">str</span>, y_left:np.ndarray, y_left_name:<span class="bu">str</span>, y_right:np.ndarray, y_right_name:<span class="bu">str</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a><span class="co">        Create a matplotlib plot with two y-axes and a single x-axis. </span></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>    fig, ax1 <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">7</span>)) <span class="co"># create a figure and axis</span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>    ax1.plot(x, y_left) <span class="co"># plot the left y-axis data</span></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>    ax1.set_xlabel(x_name, fontsize<span class="op">=</span><span class="dv">16</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>) <span class="co"># set the x-axis label</span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a>    ax1.set_ylabel(y_left_name, color<span class="op">=</span><span class="st">'b'</span>, fontsize<span class="op">=</span><span class="dv">16</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)  <span class="co"># set the left y-axis label</span></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a>    ax1.xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">14</span>) <span class="co"># set the x-axis tick label size</span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a>    ax1.yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">14</span>) <span class="co"># set the left y-axis tick label size</span></span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a>    ax1.set_ylim(<span class="fl">0.5</span>, <span class="fl">0.8</span>) <span class="co"># set the left y-axis limits</span></span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a>    ax2 <span class="op">=</span> ax1.twinx() <span class="co"># create a second y-axis that shares the same x-axis</span></span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a>    ax2.plot(x, y_right, color<span class="op">=</span><span class="st">'r'</span>) <span class="co"># plot the right y-axis data</span></span>
<span id="cb15-15"><a href="#cb15-15" tabindex="-1"></a>    ax2.set_ylabel(y_right_name, color<span class="op">=</span><span class="st">'r'</span>, fontsize<span class="op">=</span><span class="dv">16</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>) <span class="co"># set the right y-axis label</span></span>
<span id="cb15-16"><a href="#cb15-16" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'DI'</span> <span class="kw">in</span> y_right_name: </span>
<span id="cb15-17"><a href="#cb15-17" tabindex="-1"></a>        ax2.set_ylim(<span class="fl">0.</span>, <span class="fl">0.7</span>) <span class="co"># set the right y-axis limits  if we're plotting disparate impact</span></span>
<span id="cb15-18"><a href="#cb15-18" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb15-19"><a href="#cb15-19" tabindex="-1"></a>        ax2.set_ylim(<span class="op">-</span><span class="fl">0.25</span>, <span class="fl">0.1</span>)  <span class="co"># set the right y-axis limits if we're plotting 1-DI</span></span>
<span id="cb15-20"><a href="#cb15-20" tabindex="-1"></a></span>
<span id="cb15-21"><a href="#cb15-21" tabindex="-1"></a>    best_ind <span class="op">=</span> np.argmax(y_left) <span class="co"># get the index of the best balanced accuracy</span></span>
<span id="cb15-22"><a href="#cb15-22" tabindex="-1"></a>    ax2.axvline(np.array(x)[best_ind], color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">':'</span>) <span class="co"># add a vertical line at the best balanced accuracy</span></span>
<span id="cb15-23"><a href="#cb15-23" tabindex="-1"></a>    ax2.yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">14</span>) <span class="co"># set the right y-axis tick label size</span></span>
<span id="cb15-24"><a href="#cb15-24" tabindex="-1"></a>    ax2.grid(<span class="va">True</span>) <span class="co"># add a grid</span></span>
<span id="cb15-25"><a href="#cb15-25" tabindex="-1"></a>disp_imp <span class="op">=</span> np.array(val_metrics[<span class="st">'disp_imp'</span>]) <span class="co"># disparate impact (DI)</span></span>
<span id="cb15-26"><a href="#cb15-26" tabindex="-1"></a>disp_imp_err <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> disp_imp <span class="co"># calculate 1 - DI</span></span>
<span id="cb15-27"><a href="#cb15-27" tabindex="-1"></a>plot(thresh_arr, <span class="st">'Classification Thresholds'</span>,</span>
<span id="cb15-28"><a href="#cb15-28" tabindex="-1"></a>     val_metrics[<span class="st">'bal_acc'</span>], <span class="st">'Balanced Accuracy'</span>,</span>
<span id="cb15-29"><a href="#cb15-29" tabindex="-1"></a>     disp_imp_err, <span class="st">'1 - DI'</span>) <span class="co"># Plot balanced accuracy and 1-DI against the classification thresholds</span></span></code></pre>
</div>
<div id="interpreting-the-plot" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="interpreting-the-plot" class="callout-inner">
<h3 class="callout-title">Interpreting the plot</h3>
<div class="callout-content">
<p>Answer the following questions:</p>
<ol style="list-style-type: decimal">
<li><p>When the classification threshold is 0.1, what is the
(approximate) accuracy and 1-DI score? What about when the
classification threshold is 0.5?</p></li>
<li><p>If you were developing the model, what classification threshold
would you choose based on this graph? Why?</p></li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li><p>Using a threshold of 0.1, the accuracy is about 0.72 and the 1-DI
score is about 0.54. Using a threshold of 0.5, the accuracy is about
0.69 and the 1-DI score is about 0.61.</p></li>
<li><p>The optimal accuracy occurs with a threshold of 0.19 (indicated
by the dotted vertical line). However, the disparate impact is worse at
this threshold (0.61) than at smaller thresholds. Choosing a slightly
smaller threshold, e.g., around 0.11, yields accuracy that is a bit
worse (about 0.73 vs 0.76) and is slightly fairer. However, there’s no
"good" outcome here: whenever the accuracy is near-optimal, the 1-DI
score is high. If you were the model developer, you might want to
consider interventions to improve the accuracy/fairness tradeoff, some
of which we discuss below.</p></li>
</ol>
</div>
</div>
</div>
</div>
<p>If you like, you can plot other metrics, e.g., average odds
difference.</p>
<p>In the next cell, we write a function to print out a variety of other
metrics. Instead of considering disparate impact directly, we will
consider 1 - disparate impact. Recall that a disparate impact of 0 is
very bad, and 1 is perfect – thus, considering 1 - disparate impact
means that 0 is perfect and 1 is very bad, similar to the other metrics
we consider. <strong>I.e., all of these metrics have a value of 0 if
they are perfectly fair</strong>.</p>
<p>We print the value of several metrics here for illustrative purposes
(i.e., to see that multiple metrics are not able to be optimized
simultaneously). In practice, when evaluating a model it is typical ot
choose a single fairness metric to use based on the details of the
situation. You can learn more details about the various metrics in the
<a href="https://aif360.readthedocs.io/en/stable/modules/generated/aif360.metrics.ClassificationMetric.html#aif360.metrics.ClassificationMetric" class="external-link">AIF360
documentation</a>.</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="kw">def</span> describe_metrics(metrics: <span class="bu">dict</span>, thresh_arr: np.ndarray) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a><span class="co">        Given a dictionary of metrics and a list of potential cutoff thresholds, print the best</span></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a><span class="co">        threshold (based on 'bal_acc' balanced accuracy dictionary entry) and the corresponding</span></span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a><span class="co">        values of other metrics at the selected threshold.</span></span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a>    best_ind <span class="op">=</span> np.argmax(metrics[<span class="st">'bal_acc'</span>]) <span class="co"># get the index of the best balanced accuracy</span></span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Threshold corresponding to Best balanced accuracy: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(thresh_arr[best_ind]))</span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Best balanced accuracy: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'bal_acc'</span>][best_ind]))</span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a>    disp_imp_at_best_ind <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> metrics[<span class="st">'disp_imp'</span>][best_ind] <span class="co"># calculate 1 - DI at the best index</span></span>
<span id="cb16-11"><a href="#cb16-11" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Corresponding 1-DI value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(disp_imp_at_best_ind))</span>
<span id="cb16-12"><a href="#cb16-12" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Corresponding average odds difference value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'avg_odds_diff'</span>][best_ind]))</span>
<span id="cb16-13"><a href="#cb16-13" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Corresponding statistical parity difference value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'stat_par_diff'</span>][best_ind]))</span>
<span id="cb16-14"><a href="#cb16-14" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Corresponding equal opportunity difference value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'eq_opp_diff'</span>][best_ind]))</span>
<span id="cb16-15"><a href="#cb16-15" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Corresponding Theil index value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'theil_ind'</span>][best_ind]))</span>
<span id="cb16-16"><a href="#cb16-16" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" tabindex="-1"></a>describe_metrics(val_metrics, thresh_arr) <span class="co"># call the function</span></span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="test-the-model">Test the model<a class="anchor" aria-label="anchor" href="#test-the-model"></a>
</h3>
<p>Now that we have used the validation data to select the best
threshold, we will evaluate the test the model on the test data.</p>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>lr_metrics <span class="op">=</span> test(dataset<span class="op">=</span>dataset_orig_panel19_test,</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>                       model<span class="op">=</span>lr_orig_panel19,</span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>                       thresh_arr<span class="op">=</span>[thresh_arr[lr_orig_best_ind]]) <span class="co"># call our function "test" with the test data and lr model</span></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a>describe_metrics(lr_metrics, [thresh_arr[lr_orig_best_ind]]) <span class="co"># print the metrics for the test data</span></span></code></pre>
</div>
</div>
</section><section><h2 class="section-heading" id="mitigate-bias-with-in-processing">Mitigate bias with in-processing<a class="anchor" aria-label="anchor" href="#mitigate-bias-with-in-processing"></a>
</h2>
<hr class="half-width">
<p>We will use reweighting as an in-processing step to try to increase
fairness. AIF360 has a function that performs reweighting that we will
use. If you’re interested, you can look at details about how it works in
<a href="https://aif360.readthedocs.io/en/latest/modules/generated/aif360.algorithms.preprocessing.Reweighing.html" class="external-link">the
documentation</a>.</p>
<p>If you look at the documentation, you will see that AIF360 classifies
reweighting as a preprocessing, not an in-processing intervention.
Technically, AIF360’s implementation modifies the dataset, not the
learning algorithm so it is pre-processing. But, it is functionally
equivalent to modifying the learning algorithm’s loss function, so we
follow the convention of the fair ML field and call it
in-processing.</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="im">from</span> aif360.algorithms.preprocessing <span class="im">import</span> Reweighing</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="co"># Reweighting is a AIF360 class to reweight the data </span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>RW <span class="op">=</span> Reweighing(unprivileged_groups<span class="op">=</span>unprivileged_groups,</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a>                privileged_groups<span class="op">=</span>privileged_groups) <span class="co"># create a Reweighing object with the unprivileged and privileged groups</span></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a>dataset_transf_panel19_train <span class="op">=</span> RW.fit_transform(dataset_orig_panel19_train) <span class="co"># reweight the training data</span></span></code></pre>
</div>
<p>We’ll also define metrics for the reweighted data and print out the
disparate impact of the dataset.</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>metric_transf_panel19_train <span class="op">=</span> BinaryLabelDatasetMetric(</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>        dataset_transf_panel19_train, <span class="co"># use train data</span></span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a>        unprivileged_groups<span class="op">=</span>unprivileged_groups, <span class="co"># pass in unprivileged and privileged groups</span></span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>        privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a>explainer_transf_panel19_train <span class="op">=</span> MetricTextExplainer(metric_transf_panel19_train) <span class="co"># create a MetricTextExplainer object</span></span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a><span class="bu">print</span>(explainer_transf_panel19_train.disparate_impact()) <span class="co"># print disparate impact</span></span></code></pre>
</div>
<p>Then, we’ll train a model, validate it, and evaluate of the test
data.</p>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="co"># train</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>dataset <span class="op">=</span> dataset_transf_panel19_train  <span class="co"># use the reweighted training data</span></span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>model <span class="op">=</span> make_pipeline(StandardScaler(),</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>                      LogisticRegression(solver<span class="op">=</span><span class="st">'liblinear'</span>, random_state<span class="op">=</span><span class="dv">1</span>)) <span class="co"># model pipeline</span></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>fit_params <span class="op">=</span> {<span class="st">'logisticregression__sample_weight'</span>: dataset.instance_weights}</span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a>lr_transf_panel19 <span class="op">=</span> model.fit(dataset.features, dataset.labels.ravel(), <span class="op">**</span>fit_params) <span class="co"># fit the model</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="co"># validate</span></span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>thresh_arr <span class="op">=</span> np.linspace(<span class="fl">0.01</span>, <span class="fl">0.5</span>, <span class="dv">50</span>) <span class="co"># check 50 thresholds between 0.01 and 0.5</span></span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a>val_metrics <span class="op">=</span> test(dataset<span class="op">=</span>dataset_orig_panel19_val,</span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a>                   model<span class="op">=</span>lr_transf_panel19,</span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a>                   thresh_arr<span class="op">=</span>thresh_arr) <span class="co"># call our function "test" with the validation data and lr model</span></span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a>lr_transf_best_ind <span class="op">=</span> np.argmax(val_metrics[<span class="st">'bal_acc'</span>]) <span class="co"># get the index of the best balanced accuracy</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="co"># plot validation results</span></span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>disp_imp <span class="op">=</span> np.array(val_metrics[<span class="st">'disp_imp'</span>]) <span class="co"># get the disparate impact values</span></span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>disp_imp_err <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> np.minimum(disp_imp, <span class="dv">1</span><span class="op">/</span>disp_imp) <span class="co"># calculate 1 - min(DI, 1/DI)</span></span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>plot(thresh_arr, <span class="co"># use the classification thresholds as the x-axis</span></span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a>     <span class="st">'Classification Thresholds'</span>, </span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>     val_metrics[<span class="st">'bal_acc'</span>],  <span class="co"># plot accuracy on the first y-axis</span></span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a>     <span class="st">'Balanced Accuracy'</span>, </span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a>     disp_imp_err, <span class="co"># plot 1 - min(DI, 1/DI) on the second y-axis</span></span>
<span id="cb23-9"><a href="#cb23-9" tabindex="-1"></a>     <span class="st">'1 - min(DI, 1/DI)'</span></span>
<span id="cb23-10"><a href="#cb23-10" tabindex="-1"></a>     )</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb24">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>describe_metrics(val_metrics, thresh_arr) <span class="co"># describe validation results</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="test">Test<a class="anchor" aria-label="anchor" href="#test"></a>
</h3>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>lr_transf_metrics <span class="op">=</span> test(dataset<span class="op">=</span>dataset_orig_panel19_test,</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>                         model<span class="op">=</span>lr_transf_panel19,</span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a>                         thresh_arr<span class="op">=</span>[thresh_arr[lr_transf_best_ind]]) <span class="co"># call our function "test" with the test data and lr model</span></span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a>describe_metrics(lr_transf_metrics, [thresh_arr[lr_transf_best_ind]]) <span class="co"># describe test results</span></span></code></pre>
</div>
<p>We see that the disparate impact score on the test data is better
after reweighting than it was originally.</p>
<p>How do the other fairness metrics compare?</p>
</div>
</section><section><h2 class="section-heading" id="mitigate-bias-with-preprocessing">Mitigate bias with preprocessing<a class="anchor" aria-label="anchor" href="#mitigate-bias-with-preprocessing"></a>
</h2>
<hr class="half-width">
<p>We will use a method, <a href="https://fairlearn.org/main/api_reference/generated/fairlearn.postprocessing.ThresholdOptimizer.html#fairlearn.postprocessing.ThresholdOptimizer" class="external-link">ThresholdOptimizer</a>,
that is implemented in the library <a href="https://fairlearn.org/" class="external-link">Fairlearn</a>. ThresholdOptimizer finds
custom thresholds for each demographic group so as to achieve parity in
the desired group fairness metric.</p>
<p>We will focus on demographic parity, but feel free to try other
metrics if you’re curious on how it does.</p>
<p>The first step is creating the ThresholdOptimizer object. We pass in
the demographic parity constraint, and indicate that we would like to
optimize the balanced accuracy score (other options include accuracy,
and true or false positive rate – see <a href="https://fairlearn.org/main/api_reference/generated/fairlearn.postprocessing.ThresholdOptimizer.html#fairlearn.postprocessing.ThresholdOptimizer" class="external-link">the
documentation</a> for more details).</p>
<div class="codewrapper sourceCode" id="cb26">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="im">from</span> fairlearn.postprocessing <span class="im">import</span> ThresholdOptimizer <span class="co"># import ThresholdOptimizer</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb27">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="co"># create a ThresholdOptimizer object</span></span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>to <span class="op">=</span> ThresholdOptimizer(estimator<span class="op">=</span>model, </span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a>                        constraints<span class="op">=</span><span class="st">"demographic_parity"</span>, <span class="co"># set the constraint to demographic parity</span></span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a>                        objective<span class="op">=</span><span class="st">"balanced_accuracy_score"</span>, <span class="co"># optimize for balanced accuracy</span></span>
<span id="cb27-5"><a href="#cb27-5" tabindex="-1"></a>                        prefit<span class="op">=</span><span class="va">True</span>) </span></code></pre>
</div>
<p>Next, we fit the ThresholdOptimizer object to the validation
data.</p>
<div class="codewrapper sourceCode" id="cb28">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>to.fit(dataset_orig_panel19_val.features, dataset_orig_panel19_val.labels, </span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>       sensitive_features<span class="op">=</span>dataset_orig_panel19_val.protected_attributes[:,<span class="dv">0</span>]) <span class="co"># fit the ThresholdOptimizer object</span></span></code></pre>
</div>
<p>Then, we’ll create a helper function, <code>mini_test</code> to allow
us to call the <code>describe_metrics</code> function even though we are
no longer evaluating our method as a variety of thresholds.</p>
<p>After that, we call the ThresholdOptimizer’s predict function on the
validation and test data, and then compute metrics and print the
results.</p>
<div class="codewrapper sourceCode" id="cb29">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="kw">def</span> mini_test(dataset:MEPSDataset19, preds:np.ndarray) <span class="op">-&gt;</span> <span class="bu">dict</span>:</span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a><span class="co">        Given a dataset and predictions, compute various metrics for the model. Returns a dictionary of the metrics,</span></span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a><span class="co">        including balanced accuracy, average odds difference, disparate impact, statistical parity difference, equal</span></span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a><span class="co">        opportunity difference, and theil index.</span></span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a>    metric_arrs <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a>    dataset_pred <span class="op">=</span> dataset.copy()</span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a>    dataset_pred.labels <span class="op">=</span> preds</span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a>    metric <span class="op">=</span> ClassificationMetric(</span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a>            dataset, dataset_pred,</span>
<span id="cb29-12"><a href="#cb29-12" tabindex="-1"></a>            unprivileged_groups<span class="op">=</span>unprivileged_groups,</span>
<span id="cb29-13"><a href="#cb29-13" tabindex="-1"></a>            privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb29-14"><a href="#cb29-14" tabindex="-1"></a></span>
<span id="cb29-15"><a href="#cb29-15" tabindex="-1"></a>    <span class="co"># various metrics - can look up what they are on your own</span></span>
<span id="cb29-16"><a href="#cb29-16" tabindex="-1"></a>    metric_arrs[<span class="st">'bal_acc'</span>].append((metric.true_positive_rate()</span>
<span id="cb29-17"><a href="#cb29-17" tabindex="-1"></a>                                    <span class="op">+</span> metric.true_negative_rate()) <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb29-18"><a href="#cb29-18" tabindex="-1"></a>    metric_arrs[<span class="st">'avg_odds_diff'</span>].append(metric.average_odds_difference())</span>
<span id="cb29-19"><a href="#cb29-19" tabindex="-1"></a>    metric_arrs[<span class="st">'disp_imp'</span>].append(metric.disparate_impact())</span>
<span id="cb29-20"><a href="#cb29-20" tabindex="-1"></a>    metric_arrs[<span class="st">'stat_par_diff'</span>].append(metric.statistical_parity_difference())</span>
<span id="cb29-21"><a href="#cb29-21" tabindex="-1"></a>    metric_arrs[<span class="st">'eq_opp_diff'</span>].append(metric.equal_opportunity_difference())</span>
<span id="cb29-22"><a href="#cb29-22" tabindex="-1"></a>    metric_arrs[<span class="st">'theil_ind'</span>].append(metric.theil_index())</span>
<span id="cb29-23"><a href="#cb29-23" tabindex="-1"></a>    </span>
<span id="cb29-24"><a href="#cb29-24" tabindex="-1"></a>    <span class="cf">return</span> metric_arrs</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb30">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="co"># get predictions for validation dataset using the ThresholdOptimizer</span></span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>to_val_preds <span class="op">=</span> to.predict(dataset_orig_panel19_val.features, </span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a>                          sensitive_features<span class="op">=</span>dataset_orig_panel19_val.protected_attributes[:,<span class="dv">0</span>])</span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" tabindex="-1"></a><span class="co"># get predictions for test dataset using the ThresholdOptimizer</span></span>
<span id="cb30-6"><a href="#cb30-6" tabindex="-1"></a>to_test_preds <span class="op">=</span> to.predict(dataset_orig_panel19_test.features, </span>
<span id="cb30-7"><a href="#cb30-7" tabindex="-1"></a>                           sensitive_features<span class="op">=</span>dataset_orig_panel19_test.protected_attributes[:,<span class="dv">0</span>])</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb31">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a>to_val_metrics <span class="op">=</span> mini_test(dataset_orig_panel19_val, to_val_preds) <span class="co"># compute metrics for the validation set</span></span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>to_test_metrics <span class="op">=</span> mini_test(dataset_orig_panel19_test, to_test_preds) <span class="co"># compute metrics for the test set</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb32">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Remember, `Threshold corresponding to Best balanced accuracy` is just a placeholder here."</span>)</span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a>describe_metrics(to_val_metrics, [<span class="dv">0</span>]) <span class="co"># check accuracy (ignore other metrics for now)</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb33">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Remember, `Threshold corresponding to Best balanced accuracy` is just a placeholder here."</span>)</span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a>describe_metrics(to_test_metrics, [<span class="dv">0</span>]) <span class="co"># check accuracy (ignore other metrics for now)</span></span></code></pre>
</div>
<p>Scroll up and see how these results compare with the original
classifier and with the in-processing technique.</p>
<p>A major difference is that the accuracy is lower, now. In practice,
it might be better to use an algorithm that allows a custom tradeoff
between the accuracy sacrifice and increased levels of fairness.</p>
<p>We can also see what threshold is being used for each demographic
group by examining the
<code>interpolated_thresholder_.interpretation_dict</code> property of
the ThresholdOptimzer.</p>
<div class="codewrapper sourceCode" id="cb34">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>threshold_rules_by_group <span class="op">=</span> to.interpolated_thresholder_.interpolation_dict <span class="co"># get the threshold rules by group</span></span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a>threshold_rules_by_group <span class="co"># print the threshold rules by group</span></span></code></pre>
</div>
<p>Recall that a value of 1 in the Race column corresponds to White
people, while a value of 0 corresponds to non-White people.</p>
<p>Due to the inherent randomness of the ThresholdOptimizer, you might
get slightly different results than your neighbors. When we ran the
previous cell, the output was</p>
<p><code>{0.0: {'p0': 0.9287205987170348,   'operation0': [&gt;0.5],   'p1': 0.07127940128296517,   'operation1': [&gt;-inf]},  1.0: {'p0': 0.002549618320610717,   'operation0': [&gt;inf],   'p1': 0.9974503816793893,   'operation1': [&gt;0.5]}}</code></p>
<p>This tells us that for non-White individuals:</p>
<ul>
<li><p>If the score is above 0.5, predict 1.</p></li>
<li><p>Otherwise, predict 1 with probability 0.071</p></li>
</ul>
<p>And for White individuals:</p>
<ul>
<li>If the score is above 0.5, predict 1 with probability 0.997</li>
</ul>
<div id="discuss" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="discuss" class="callout-inner">
<h3 class="callout-title">Discuss</h3>
<div class="callout-content">
<p>What are the pros and cons of improving the model fairness by
introducing randomization?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<p><strong>Pros:</strong> Randomization can be effective at increasing
fairness.</p>
<p><strong>Cons:</strong> There is less predictability and
explainability in model outcomes. Even though model outputs are fair in
aggregate according to a defined group fairness metric, decisions may
feel unfair on an individual basis because similar individual (or even
the same individual, at different times) are treated unequally.
Randomization may not be appropriate in settings (e.g., medical
diagnosis) where accuracy is paramount.</p>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>It’s important to consider many dimensions of model performance: a
single accuracy score is not sufficient.</li>
<li>There is no single definition of “fair machine learning”: different
notions of fairness are appropriate in different contexts.</li>
<li>Representational harms and stereotypes can be perpetuated by
generative AI.</li>
<li>The fairness of a model can be improved by using techniques like
data reweighting and model postprocessing.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-4-explainability-vs-interpretability"><p>Content from <a href="4-explainability-vs-interpretability.html">Interpretablility versus explainability</a></p>
<hr>
<p>Last updated on 2024-11-29 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/4-explainability-vs-interpretability.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 2 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are model interpretability and model explainability? Why are
they important?</li>
<li>How do you choose between interpretable models and explainable
models in different contexts?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand and distinguish between explainable machine learning
models and interpretable machine learning models.</li>
<li>Make informed model selection choices based on the goals of your
model.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h3>
<p>In this lesson, we will explore the concepts of interpretability and
explainability in machine learning models. For applied scientists,
choosing the right model for your research data is critical. Whether
you’re working with patient data, environmental factors, or financial
information, understanding how a model arrives at its predictions can
significantly impact your work.</p>
<div class="section level4">
<h4 id="interpretability">Interpretability<a class="anchor" aria-label="anchor" href="#interpretability"></a>
</h4>
<p>In the context of machine learning, interpretability is the degree to
which a human can understand the cause of a decision made by a model,
crucial for verifying correctness and ensuring compliance.</p>
<p><strong>“Interpretable” models</strong>: Generally refers to models
that are “inherently” understandable, such as…</p>
<ul>
<li>Linear regression: Examining the coefficients along with confidence
intervals (CIs) helps understand the strength and direction of the
relationship between features and predictions.</li>
<li>Decision trees: Visualizing decision trees allows users to see the
rules that lead to specific predictions, clarifying how features
interact in the decision-making process.</li>
<li>Rule-based classifiers. These models provide clear insights into how
input features influence predictions, making it easier for users to
verify and trust the outcomes.</li>
</ul>
<p>However, as we scale up these models (e.g., high-dimensional
regression models or random forests), it is important to note that the
complexity can increase significantly, potentially making these models
less interpretable than their simpler counterparts.</p>
</div>
<div class="section level4">
<h4 id="explainability">Explainability<a class="anchor" aria-label="anchor" href="#explainability"></a>
</h4>
<p>In the context of machine learning, explainability is the extent to
which the internal mechanics of a machine learning model can be
articulated in human terms, important for transparency and building
trust.</p>
<p><strong>Explainable models</strong>: Typical refers to more complex
models, such as neural networks or ensemble methods, that may be
considered “black boxes” without the use of specialized
<em>explainability methods</em>.</p>
<p><strong>Explainability methods preview:</strong> Various
explainability methods exist to help clarify how complex models work.
For instance…</p>
<ul>
<li>
<strong>LIME (Local Interpretable Model-agnostic
Explanations)</strong> provides insights into individual predictions by
approximating the model locally with a simpler, interpretable
model.</li>
<li>
<strong>SHAP (SHapley Additive exPlanations)</strong> assigns each
feature an importance value for a particular prediction, helping
understand the contribution of each feature.</li>
<li>
<strong>Saliency Maps</strong> visually highlight which parts of an
input (e.g., in images) are most influential for a model’s
prediction.</li>
</ul>
<p>These techniques, which we’ll talk more about in a later episode,
bridge the gap between complex models and user understanding, enhancing
transparency while still leveraging powerful algorithms.</p>
</div>
</div>
<div class="section level3">
<h3 id="accuracy-vs--complexity">Accuracy vs. Complexity<a class="anchor" aria-label="anchor" href="#accuracy-vs--complexity"></a>
</h3>
<p>The traditional idea that simple models (e.g., regression, decision
trees) are inherently interpretable and complex models (neural nets) are
truly black-box is increasingly inadequate. Modern interpretable models,
such as high-dimensional regression or tree-based methods with hundreds
of variables, can be as difficult to understand as neural networks. This
leads to a more fluid spectrum of complexity versus accuracy.</p>
<p>The accuracy vs. complexity plot from the AAAI tutorial helps to
visualize the continuous relationship between model complexity,
accuracy, and interpretability. It showcases that the trade-off is not
always straightforward, and some models can achieve a balance between
interpretability and strong performance.</p>
<p>This evolving landscape demonstrates that the old clusters of
“interpretable” versus “black-box” models break down. Instead, we must
evaluate models across the dimensions of complexity and accuracy.</p>
<p>Understanding the trade-off between model complexity and accuracy is
crucial for effective model selection. As model complexity increases,
accuracy typically improves. However, more complicated models become
more difficult to interpret and explain.</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/accuracy_vs_complexity.png" alt="Accuracy vs. Complexity Plot" class="figure mx-auto d-block"><div class="figcaption">Accuracy vs. Complexity Plot</div>
</figure><p><strong>Discussion of the Plot:</strong></p>
<ul>
<li>
<strong>X-Axis:</strong> Represents model complexity, ranging from
simple models (like linear regression) to complex models (like deep
neural networks).</li>
<li>
<strong>Y-Axis:</strong> Represents accuracy, demonstrating how well
each model performs on a given task.</li>
</ul>
<p>This plot illustrates that while simpler models offer clarity and
ease of understanding, they may not effectively capture complex
relationships in the data. Conversely, while complex models can achieve
higher accuracy, they may sacrifice interpretability, which can hinder
trust in their predictions.</p>
</div>
<div class="section level3">
<h3 id="exploring-model-choices">Exploring Model Choices<a class="anchor" aria-label="anchor" href="#exploring-model-choices"></a>
</h3>
<p>We will analyze a few real-world scenarios and discuss the trade-offs
between “<em>interpretable models</em>” (e.g., regression, decision
trees, etc.) and “<em>explainable models</em>” (e.g., neural nets).</p>
<p>For each scenario, you’ll consider key factors like accuracy,
complexity, and transparency, and answer discussion questions to
evaluate the strengths and limitations of each approach.</p>
<p>Here are some of the questions you’ll reflect on during the
exercises:</p>
<ul>
<li>What are the advantages of using interpretable models versus
explainable (black box) models in the given context?</li>
<li>What are the potential drawbacks of each approach?</li>
<li>How might the specific goals of the task influence your choice of
model?</li>
<li>Are there situations where high accuracy justifies the use of less
interpretable models?</li>
</ul>
<p>As you work through these exercises, keep in mind the broader
implications of these decisions, especially in fields like healthcare,
where model transparency can directly impact trust and outcomes.</p>
<div id="exercise-1-model-selection-for-predicting-covid-19-progression-a-study-by-giotta-et-al." class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="exercise-1-model-selection-for-predicting-covid-19-progression-a-study-by-giotta-et-al." class="callout-inner">
<h3 class="callout-title">Exercise 1: Model Selection for Predicting
COVID-19 Progression, a study by <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9602523/" class="external-link">Giotta et
al.</a>
</h3>
<div class="callout-content">
<p><strong>Scenario:</strong><br>
In the early days of the COVID-19 pandemic, healthcare professionals
faced unprecedented challenges in predicting which patients were at
higher risk of severe outcomes. Accurate predictions of death or the
need for intensive care could guide resource allocation and improve
patient care. A study explored the use of various biomarkers to build
predictive models, highlighting the importance of both accuracy and
transparency in such high-stakes settings.</p>
<p><strong>Objective:</strong><br>
Predict severe outcomes (death or transfer to intensive care) in
COVID-19 patients using biomarkers.</p>
<p><strong>Dataset features:</strong><br>
The dataset includes biomarkers from three categories:<br>
- <strong>Hematological markers:</strong> White blood cell count,
neutrophils, lymphocytes, platelets, hemoglobin, etc.<br>
- <strong>Biochemical markers:</strong> Albumin, bilirubin, creatinine,
cardiac troponin, LDH, etc.<br>
- <strong>Inflammatory markers:</strong> CRP, serum ferritin,
interleukins, TNFα, etc.</p>
<p>These features are critical for understanding disease progression and
predicting outcomes.</p>
<div class="section level3">
<h3 id="discussion-questions">Discussion questions<a class="anchor" aria-label="anchor" href="#discussion-questions"></a>
</h3>
<div class="section level4">
<h4 id="compare-the-advantages">Compare the advantages<a class="anchor" aria-label="anchor" href="#compare-the-advantages"></a>
</h4>
<ul>
<li>What are the advantages of using interpretable models such as
decision trees in predicting COVID-19 outcomes?</li>
<li>What are the advantages of using black box models such as neural
networks in this scenario?</li>
</ul>
</div>
<div class="section level4">
<h4 id="assess-the-drawbacks">Assess the drawbacks<a class="anchor" aria-label="anchor" href="#assess-the-drawbacks"></a>
</h4>
<ul>
<li>What are the potential drawbacks of using interpretable models like
decision trees?</li>
<li>What are the potential drawbacks of using black box models in
healthcare settings?</li>
</ul>
</div>
<div class="section level4">
<h4 id="decision-making-criteria">Decision-making criteria<a class="anchor" aria-label="anchor" href="#decision-making-criteria"></a>
</h4>
<ul>
<li>In what situations might you prioritize an interpretable model over
a black box model, and why?</li>
<li>Are there scenarios where the higher accuracy of black box models
justifies their use despite their lack of transparency?</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<div class="section level4">
<h4 id="compare-the-advantages-1">Compare the advantages<a class="anchor" aria-label="anchor" href="#compare-the-advantages-1"></a>
</h4>
<ul>
<li>
<strong>Interpretable models:</strong> Allow healthcare
professionals to understand and trust the model’s decisions, providing
clear insights into which biomarkers contribute most to predicting bad
outcomes. This transparency is crucial in critical fields such as
healthcare, where understanding the decision-making process can inform
treatment plans and improve patient outcomes.</li>
<li>
<strong>Black box models:</strong> Often provide higher predictive
accuracy, which can be crucial for identifying patterns in complex
datasets. They can capture non-linear relationships and interactions
that simpler models might miss.</li>
</ul>
</div>
<div class="section level4">
<h4 id="assess-the-drawbacks-1">Assess the drawbacks<a class="anchor" aria-label="anchor" href="#assess-the-drawbacks-1"></a>
</h4>
<ul>
<li>
<strong>Interpretable models:</strong> May not capture complex
relationships in the data as effectively as black box models,
potentially leading to lower predictive accuracy in some cases.</li>
<li>
<strong>Black box models:</strong> Can be difficult to interpret,
which hinders trust and adoption by medical professionals. Without
understanding the model’s reasoning, it becomes challenging to validate
its correctness, ensure regulatory compliance, and effectively debug or
refine the model.</li>
</ul>
</div>
<div class="section level4">
<h4 id="decision-making-criteria-1">Decision-making criteria<a class="anchor" aria-label="anchor" href="#decision-making-criteria-1"></a>
</h4>
<ul>
<li>
<strong>Interpretable models:</strong> When transparency, trust, and
regulatory compliance are critical, such as in healthcare settings where
understanding and validating decisions is essential.</li>
<li>
<strong>Black box models:</strong> When the need for high predictive
accuracy outweighs the need for transparency, and when supplementary
methods for interpreting the model’s output can be employed.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="exercise-2-covid-19-diagnosis-using-chest-x-rays-a-study-by-ucar-and-korkmaz" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="exercise-2-covid-19-diagnosis-using-chest-x-rays-a-study-by-ucar-and-korkmaz" class="callout-inner">
<h3 class="callout-title">Exercise 2: COVID-19 Diagnosis Using Chest
X-Rays, a study by <a href="https://www.sciencedirect.com/science/article/pii/S0306987720307702" class="external-link">Ucar
and Korkmaz</a>
</h3>
<div class="callout-content">
<p><strong>Objective:</strong> Diagnose COVID-19 through chest
X-rays.</p>
<p><strong>Motivation:</strong></p>
<p>The COVID-19 pandemic has had an unprecedented impact on global
health, affecting millions of people worldwide. One of the critical
challenges in managing this pandemic is the rapid and accurate diagnosis
of infected individuals. Traditional methods, such as the Reverse
Transcription Polymerase Chain Reaction (RT-PCR) test, although widely
used, have several drawbacks. These tests are time-consuming, require
specialized equipment and personnel, and often suffer from low detection
rates, necessitating multiple tests to confirm a diagnosis.</p>
<p>In this context, radiological imaging, particularly chest X-rays, has
emerged as a valuable tool for COVID-19 diagnosis. Early studies have
shown that COVID-19 causes specific abnormalities in chest X-rays, such
as ground-glass opacities, which can be used as indicators of the
disease. However, interpreting these images requires expertise and time,
both of which are in short supply during a pandemic.</p>
<p>To address these challenges, researchers have turned to machine
learning techniques…</p>
<p><strong>Dataset Specification:</strong> <a href="https://ars.els-cdn.com/content/image/1-s2.0-S0306987720307702-gr5.jpg" class="external-link">Chest
X-ray images</a></p>
<p><strong>Real-World Impact:</strong></p>
<p>The COVID-19 pandemic highlighted the urgent need for rapid and
accurate diagnostic tools. Traditional methods like RT-PCR tests, while
effective, are often time-consuming and have variable detection rates.
Using chest X-rays for diagnosis offers a quicker and more accessible
alternative. By analyzing chest X-rays, healthcare providers can swiftly
identify COVID-19 cases, enabling timely treatment and isolation
measures. Developing a machine learning method that can quickly and
accurately analyze chest X-rays can significantly enhance the speed and
efficiency of the healthcare response, especially in areas with limited
access to RT-PCR testing.</p>
<p><strong>Discussion Questions:</strong></p>
<ol style="list-style-type: decimal">
<li>
<strong>Compare the Advantages:</strong>
<ul>
<li>What are the advantages of using deep neural networks in diagnosing
COVID-19 from chest X-rays?</li>
<li>What are the advantages of traditional methods, such as genomic data
analysis, for COVID-19 diagnosis?</li>
</ul>
</li>
<li>
<strong>Assess the Drawbacks:</strong>
<ul>
<li>What are the potential drawbacks of using deep neural networks for
COVID-19 diagnosis from chest X-rays?</li>
<li>How do these drawbacks compare to those of traditional methods?</li>
</ul>
</li>
<li>
<strong>Decision-Making Criteria:</strong>
<ul>
<li>In what situations might you prioritize using deep neural networks
over traditional methods, and why?</li>
<li>Are there scenarios where the rapid availability of X-ray results
justifies the use of deep neural networks despite potential
drawbacks?</li>
</ul>
</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>
<strong>Compare the Advantages:</strong>
<ul>
<li>
<strong>Deep Neural Networks:</strong> Provide high accuracy (e.g.,
98%) in diagnosing COVID-19 from chest X-rays, offering a quick and
non-invasive diagnostic tool. They can handle large amounts of image
data and identify complex patterns that might be missed by human
eyes.</li>
<li>
<strong>Traditional Methods:</strong> Provide detailed and specific
diagnostic information by analyzing genomic data and biomarkers, which
can be crucial for understanding the virus’s behavior and patient
response.</li>
</ul>
</li>
<li>
<strong>Assess the Drawbacks:</strong>
<ul>
<li>
<strong>Deep Neural Networks:</strong> Require large labeled
datasets for training, which may not always be available. The models can
be seen as “black boxes”, making it challenging to interpret their
decisions without additional explainability methods.</li>
<li>
<strong>Traditional Methods:</strong> Time-consuming and may have
lower detection accuracy. They often require specialized equipment and
personnel, leading to delays in diagnosis.</li>
</ul>
</li>
<li>
<strong>Decision-Making Criteria:</strong>
<ul>
<li>
<strong>Prioritizing Deep Neural Networks:</strong> When rapid
diagnosis is critical, and chest X-rays are readily available. Useful in
large-scale screening scenarios where speed is more critical than the
detailed understanding provided by genomic data.</li>
<li>
<strong>Using Traditional Methods:</strong> When detailed and
specific information about the virus is needed for treatment planning,
and when the availability of genomic data and biomarkers is not a
bottleneck.</li>
</ul>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>
<strong>Model Explainability vs. Model Interpretability:</strong>
<ul>
<li>
<strong>Interpretability:</strong> The degree to which a human can
understand the cause of a decision made by a model, crucial for
verifying correctness and ensuring compliance.</li>
<li>
<strong>Explainability:</strong> The extent to which the internal
mechanics of a machine learning model can be articulated in human terms,
important for transparency and building trust.</li>
</ul>
</li>
<li>
<strong>Choosing Between Explainable and Interpretable
Models:</strong>
<ul>
<li>
<strong>When Transparency is Critical:</strong> Use interpretable
models when understanding how decisions are made is essential.</li>
<li>
<strong>When Performance is a Priority:</strong> Use explainable
models when accuracy is more important, leveraging techniques like LIME
and SHAP to clarify complex models.</li>
</ul>
</li>
<li>
<strong>Accuracy vs. Complexity:</strong>
<ul>
<li>The relationship between model complexity and accuracy is not always
linear. Increasing complexity can improve accuracy up to a point but may
lead to overfitting, highlighting the gray area in model selection. This
is illustrated by the accuracy vs. complexity plot, which shows
different models on these axes.</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div></section><section id="aio-5a-explainable-AI-method-overview"><p>Content from <a href="5a-explainable-AI-method-overview.html">Explainability methods overview</a></p>
<hr>
<p>Last updated on 2024-12-17 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/5a-explainable-AI-method-overview.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are the major categories of explainability methods, and how do
they differ?</li>
<li>How do you determine which explainability method to use for a
specific use case?</li>
<li>What are the trade-offs between black-box and white-box approaches
to explainability?</li>
<li>How do post-hoc explanation methods compare to inherently
interpretable models in terms of utility and reliability?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand the key differences between black-box and white-box
explanation methods.</li>
<li>Explore the trade-offs between post-hoc explainability and inherent
interpretability in models.</li>
<li>Identify and categorize different explainability techniques based on
their scope, model access, and approach.</li>
<li>Learn when to apply specific explainability techniques for various
machine learning tasks.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="fantastic-explainability-methods-and-where-to-use-them">Fantastic Explainability Methods and Where to Use Them<a class="anchor" aria-label="anchor" href="#fantastic-explainability-methods-and-where-to-use-them"></a>
</h2>
<hr class="half-width">
<p>We will now take a bird’s-eye view of explainability methods that are
widely applied on complex models like neural networks. We will get a
sense of when to use which kind of method, and what the tradeoffs
between these methods are.</p>
</section><section><h2 class="section-heading" id="three-axes-of-use-cases-for-understanding-model-behavior">Three axes of use cases for understanding model behavior<a class="anchor" aria-label="anchor" href="#three-axes-of-use-cases-for-understanding-model-behavior"></a>
</h2>
<hr class="half-width">
<p>When deciding which explainability method to use, it is helpful to
define your setting along three axes. This helps in understanding the
context in which the model is being used, and the kind of insights you
are looking to gain from the model.</p>
<div class="section level3">
<h3 id="inherently-interpretable-vs-post-hoc-explainable">Inherently Interpretable vs Post Hoc Explainable<a class="anchor" aria-label="anchor" href="#inherently-interpretable-vs-post-hoc-explainable"></a>
</h3>
<p>Understanding the tradeoff between interpretability and complexity is
crucial in machine learning. Simple models like decision trees, random
forests, and linear regression offer transparency and ease of
understanding, making them ideal for explaining predictions to
stakeholders. In contrast, neural networks, while powerful, lack
interpretability due to their complexity. Post hoc explainable
techniques can be applied to neural networks to provide explanations for
predictions, but it’s essential to recognize that using such methods
involves a tradeoff between model complexity and interpretability.</p>
<p>Striking the right balance between these factors is key to selecting
the most suitable model for a given task, considering both its
predictive performance and the need for interpretability.</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-interpretability-vs-complexity.png" alt="_Credits: AAAI 2021 Tutorial on Explaining Machine Learning Predictions: State of the Art, Challenges, Opportunities._" class="figure mx-auto d-block"><div class="figcaption">The tradeoff between Interpretability and
Complexity</div>
</figure>
</div>
<div class="section level3">
<h3 id="local-vs-global-explanations">Local vs Global Explanations<a class="anchor" aria-label="anchor" href="#local-vs-global-explanations"></a>
</h3>
<p>Local explanations focus on describing model behavior within a
specific neighborhood, providing insights into individual predictions.
Conversely, global explanations aim to elucidate overall model behavior,
offering a broader perspective. While global explanations may be more
comprehensive, they run the risk of being overly complex.</p>
<p>Both types of explanations are valuable for uncovering biases and
ensuring that the model makes predictions for the right reasons. The
tradeoff between local and global explanations has a long history in
statistics, with methods like linear regression (global) and kernel
smoothing (local) illustrating the importance of considering both
perspectives in statistical analysis.</p>
<div class="section level4">
<h4 id="local-example-understanding-single-prediciton-using-shap">Local example: Understanding single prediciton using SHAP<a class="anchor" aria-label="anchor" href="#local-example-understanding-single-prediciton-using-shap"></a>
</h4>
<p>SHAP (SHapley Additive exPlanations) is a feature attribution method
that provides insights into how individual features contribute to a
specific prediction for an <em>individual instance</em>. Its popularity
stems from its strong theoretical foundation and flexibility, making it
applicable across a wide range of machine learning models, including
tree-based models, linear regressions, and neural networks. SHAP is
particularly relevant for deep learning models, where traditional
feature importance methods struggle to handle complex feature
interactions and non-linearities.</p>
<p><strong>Examples</strong></p>
<ul>
<li>Explaining why a specific patient was predicted to have a high risk
of developing a disease.</li>
<li>Identifying the key features driving the predicted price of a single
house in a real estate model.</li>
<li>Understanding why a fraud detection model flagged a particular
transaction as suspicious</li>
</ul>
<p><strong>How it works</strong>: SHAP values start with a model that’s
been fitted to all features and training data. We then perturb the
instance by including or excluding features, where excluding a feature
means replacing its value with a baseline value (i.e., its average value
or a value sampled from the dataset). For each subset of features, SHAP
computes the model’s prediction and measures the marginal contribution
of each feature to the outcome. To ensure fairness and consistency, SHAP
averages these contributions across all possible feature orderings. The
result is a set of SHAP values that explain how much each feature pushed
the prediction higher or lower relative to the baseline model output.
These local explanations provide clear, human-readable insights into why
the model made a particular prediction. However, for high-dimensional
datasets, the combinatorial nature of feature perturbations can lead to
longer compute times, making approximations like Kernel SHAP more
practical.</p>
</div>
<div class="section level4">
<h4 id="global-example-aggregated-insights-with-shap">Global example: Aggregated insights with SHAP<a class="anchor" aria-label="anchor" href="#global-example-aggregated-insights-with-shap"></a>
</h4>
<p>SHAP (SHapley Additive exPlanations) can also provide global insights
by aggregating feature attributions across multiple instances, offering
a comprehensive understanding of a model’s behavior. Its ability to rank
feature importance and reveal trends makes it invaluable for uncovering
dataset-wide patterns and detecting potential biases. This global
perspective is particularly useful for complex models where direct
interpretation of weights or architecture is not feasible.</p>
<p><strong>Examples</strong></p>
<ul>
<li>Understanding which features are the most influential across a
dataset (e.g., income level being the most significant factor in loan
approvals).</li>
<li>Detecting global trends or biases in a predictive model, such as
gender-based discrepancies in hiring recommendations.</li>
<li>Identifying the key drivers behind a model’s success in predicting
customer churn rates.</li>
</ul>
<p><strong>How it works</strong>: SHAP values are first computed for
individual predictions by analyzing the contributions of features to
specific outputs. These local attributions are then aggregated across
all instances in the dataset to compute a global measure of feature
importance. For example, averaging the absolute SHAP values for each
feature reveals its overall impact on the model’s predictions. This
process allows practitioners to identify which features consistently
drive predictions and uncover dataset-level insights. By connecting
local explanations to a broader view, SHAP provides a unified approach
to understanding both individual predictions and global model
behavior.</p>
<p>However, for large datasets or highly complex models, aggregating
SHAP values can be computationally expensive. Optimized implementations,
such as Tree SHAP for tree-based models, help mitigate this challenge by
efficiently calculating global feature attributions.</p>
</div>
</div>
<div class="section level3">
<h3 id="black-box-vs-white-box-approaches">Black box vs White Box Approaches<a class="anchor" aria-label="anchor" href="#black-box-vs-white-box-approaches"></a>
</h3>
<p>Techniques that require access to model internals (e.g., model
architecture and model weights) are called “white box” while techniques
that only need query access to the model are called “black box”. Even
without access to the model weights, black box or top down approaches
can shed a lot of light on model behavior. For example, by simply
evaluating the model on certain kinds of data, high level biases or
trends in the model’s decision making process can be unearthed.</p>
<p>White box approaches use the weights and activations of the model to
understand its behavior. These classes or methods are more complex and
diverse, and we will discuss them in more detail later in this episode.
Some large models are closed-source due to commercial or safety
concerns; for example, users can’t get access to the weights of GPT-4.
This limits the use of white box explanations for such models.</p>
</div>
</section><section><h2 class="section-heading" id="classes-of-explainability-methods-for-understanding-model-behavior">Classes of Explainability Methods for Understanding Model
Behavior<a class="anchor" aria-label="anchor" href="#classes-of-explainability-methods-for-understanding-model-behavior"></a>
</h2>
<hr class="half-width">
<div class="section level3">
<h3 id="diagnostic-testing">Diagnostic Testing<a class="anchor" aria-label="anchor" href="#diagnostic-testing"></a>
</h3>
<p>This is the simplest approach towards explaining model behavior. This
involves applying a series of unit tests to the model, where each test
is a sample input where you know what the correct output should be. By
identifying test examples that break the heuristics the model relies on
(called counterfactuals), you can gain insights into the high-level
behavior of the model.</p>
<p><strong>Example Methods:</strong> <a href="https://arxiv.org/abs/1902.01007" class="external-link">Counterfactuals</a>, <a href="https://arxiv.org/abs/2005.04118" class="external-link">Unit tests</a></p>
<p><strong>Pros and Cons:</strong> These methods allow for gaining
insights into the high-level behavior of the model without the needing
access to model weights. This is especially useful with recent powerful
closed-source models like GPT-4. One challenge with this approach is
that it is hard to identify in advance what heuristics a model may
depend on.</p>
</div>
<div class="section level3">
<h3 id="baking-interpretability-into-models">Baking interpretability into models<a class="anchor" aria-label="anchor" href="#baking-interpretability-into-models"></a>
</h3>
<p>Some recent research has focused on tweaking highly complex models
like neural networks, towards making them more interpretable inherently.
One such example with language models involves training the model to
generate rationales for its prediction, in addition to its original
prediction. This approach has gained some traction, and there are even
<a href="https://arxiv.org/abs/1911.03429" class="external-link">public benchmarks</a> for
evaluating the quality of these generated rationales.</p>
<p><strong>Example methods:</strong> <a href="https://arxiv.org/abs/2004.14546" class="external-link">Rationales with WT5</a>, <a href="https://arxiv.org/abs/1606.04155" class="external-link">Older approaches for
rationales</a></p>
<p><strong>Pros and cons:</strong> These models hope to achieve the best
of both worlds: complex models that are also inherently interpretable.
However, research in this direction is still new, and there are no
established and reliable approaches for real world applications just
yet.</p>
</div>
<div class="section level3">
<h3 id="identifying-decision-rules-of-the-model">Identifying Decision Rules of the Model:<a class="anchor" aria-label="anchor" href="#identifying-decision-rules-of-the-model"></a>
</h3>
<p>In this class of methods, we try find a set of rules that generally
explain the decision making process of the model. Loosely, these rules
would be of the form “if a specific condition is met, then the model
will predict a certain class”.</p>
<p><strong>Example methods:</strong> <a href="https://aaai.org/papers/11491-anchors-high-precision-model-agnostic-explanations/" class="external-link">Anchors</a>,
<a href="https://arxiv.org/abs/1908.07125" class="external-link">Universal Adversarial
Triggers</a></p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-anchors-example.png" alt='Table caption: "Generated anchors for Tabular datasets". Table shows the following rules: for the adult dataset, predict less than 50K if no capital gain or loss and never married. Predict over 50K if country is US, married, and work hours over 45. For RCDV dataset, predict not rearrested if person has no priors, no prison violations, and crime not against property. Predict re-arrested if person is male, black, has 1-5 priors, is not married, and the crime not against property. For the Lending dataset, predict bad loan if FICO score is less than 650. Predict good loan if FICO score is between 650 and 700 and loan amount is between 5400 and 10000.' class="figure mx-auto d-block"><div class="figcaption">Example use of anchors (table from <a href="https://aaai.org/papers/11491-anchors-high-precision-model-agnostic-explanations/" class="external-link">Ribeiro
et al.</a>)</div>
</figure><p><strong>Pros and cons:</strong> Some global rules help find “bugs” in
the model, or identify high level biases. But finding such broad
coverage rules is challenging. Furthermore, these rules only showcase
the model’s weaknesses, but give next to no insight as to why these
weaknesses exist.</p>
</div>
<div class="section level3">
<h3 id="visualizing-model-weights-or-representations">Visualizing model weights or representations<a class="anchor" aria-label="anchor" href="#visualizing-model-weights-or-representations"></a>
</h3>
<p>Just like how a picture tells a thousand words, visualizations can
help encapsulate complex model behavior in a simple image.
Visualizations are commonly used in explaining neural networks, where
the weights or data representations of the model are directly
visualized. Many such approaches involve reducing the high-dimensional
weights or representations to a 2D or 3D space, using techniques like
PCA, tSNE, or UMAP. Alternatively, these visualizations can retain their
high dimensional representation, but use color or size to identify which
dimensions or neurons are more important.</p>
<p><strong>Example methods:</strong> <a href="https://arxiv.org/abs/1612.08220" class="external-link">Visualizing attention
heatmaps</a>, Weight visualizations, Model activation visualizations</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-visualization-heatmap.png" alt="Image shows a grid with 3 rows and 50 columns. Each cell is colored on a scale of -1.5 (white) to 0.9 (dark blue). Darker colors are concentrated in the first row in seemingly-random columns." class="figure mx-auto d-block"><div class="figcaption">Example usage of visualizing attention heatmaps
for part-of-speech (POS) identification task using word2vec-encoded
vectors. Each cell is a unit in a neural network (each row is a layer
and each column is a dimension). Darker colors indicates that a unit is
more importance for predictive accuracy (table from <a href="https://arxiv.org/pdf/1612.08220" class="external-link">Li et al.</a>.)</div>
</figure><p><strong>Pros and cons:</strong> Gleaning model behaviour from
visualizations is very intuitive and user-friendly, and visualizations
sometimes have interactive interfaces. However, visualizations can be
misleading, especially when high-dimensional vectors are reduced to 2D,
leading to a loss of information (crowding issue).</p>
<p>An iconic debate exemplifying the validity of visualizations has
centered around attention heatmaps. Research has shown them to be <a href="https://arxiv.org/abs/1902.10186" class="external-link">unreliable</a>, and then <a href="https://arxiv.org/abs/1908.04626" class="external-link">reliable again</a>. (Check out
the titles of these papers!) Thus, visualization can only be used as an
additional step in an analysis, and not as a standalone method.</p>
</div>
<div class="section level3">
<h3 id="understanding-the-impact-of-training-examples">Understanding the impact of training examples<a class="anchor" aria-label="anchor" href="#understanding-the-impact-of-training-examples"></a>
</h3>
<p>These techniques unearth which training data instances caused the
model to generate a specific prediction for a given sample. At a high
level, these techniques mathematically identify what training samples
that – if removed from the training process – are most influential for
causing a particular prediction.</p>
<p><strong>Example methods:</strong> <a href="https://arxiv.org/abs/1703.04730" class="external-link">Influence functions</a>, <a href="https://arxiv.org/abs/1811.09720" class="external-link">Representer point
selection</a></p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-influence.png" alt="Two images. On the left, several antelope are standing in the background on a grassy field. On the right, several zebra graze in a field in the background, while there is one antelope in the foreground and other antelope in the background." class="figure mx-auto d-block"><div class="figcaption">Example usage of representer point selection.
The image on the left is a test image that is misclassified as a deer
(the true label is antelope). The image on the right is the most
influential training point. We see that this image is labeled “zebra,”
but contains both zebras and antelopes. (example adapted from <a href="https://arxiv.org/pdf/1811.09720" class="external-link">Yeh et al.</a>.)</div>
</figure><p><strong>Pros and cons:</strong> The insights from these approaches
are actionable - by identifying the data responsible for a prediction,
it can help correct labels or annotation artifacts in that data.
Unfortunately, these methods scale poorly with the size of the model and
training data, quickly becoming computationally expensive. Furthermore,
even knowing which datapoints had a high influence on a prediction, we
don’t know what it was about that datapoint that caused the
influence.</p>
</div>
<div class="section level3">
<h3 id="understanding-the-impact-of-a-single-example">Understanding the impact of a single example:<a class="anchor" aria-label="anchor" href="#understanding-the-impact-of-a-single-example"></a>
</h3>
<p>For a single input, what parts of the input were most important in
generating the model’s prediction? These methods study the signal sent
by various features to the model, and observe how the model reacts to
changes in these features.</p>
<p><strong>Example methods:</strong> <a href="https://arxiv.org/abs/1312.6034" class="external-link">Saliency Maps</a>, <a href="https://arxiv.org/abs/1602.04938" class="external-link">LIME</a>/<a href="https://arxiv.org/abs/1705.07874" class="external-link">SHAP</a>, Perturbations (<a href="https://arxiv.org/abs/1804.07781" class="external-link">Input reduction</a>, <a href="https://arxiv.org/abs/1712.06751" class="external-link">Adversarial
Perturbations</a>)</p>
<p>These methods can be further subdivided into two categories:
gradient-based methods that rely on white-box model access to directly
see the impact of changing a single input, and perturbation-based
methods that manually perturb an input and re-query the model to see how
the prediction changes.</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-smoothgrad.png" alt='Two rows images (5 images per row). Leftmost column shows two different pictures, each containing a cat and a dog. Remaining columns show the saliency maps using different techniques (VanillaGrad, InteGrad, GuidedBackProp, and SmoothGrad). Each saliency map has red dots (indicated regions that are influential for predicting "dog") and blue dots (influential for predicting "cat"). All methods except GuidedBackProp have good overlap between the respective dots and where the animals appear in the image. SmoothGrad has the most precise mapping.' class="figure mx-auto d-block"><div class="figcaption">Example saliency maps. The right 4 columns show
the result of different saliency method techniques, where red dots
indicate regions that are influential for predicting “dog” and blue dots
indicate regions that are influential for predicting “cat”. The image
creators argue that their method, SmoothGrad, is most effective at
mapping model behavior to images. (Image taken from <a href="https://arxiv.org/pdf/1706.03825" class="external-link">Smilkov et al.</a>)</div>
</figure><p><strong>Pros and cons:</strong> These methods are fast to compute,
and flexible in their use across models. However, the insights gained
from these methods are not actionable - knowing which part of the input
caused the prediction does not highlight why that part caused it. On
finding issues in the prediction process, it is also hard to pick up on
if there is an underlying issue in the model, or just the specific
inputs tested on. Relatedly, these methods can be unstable, and can even
be <a href="https://proceedings.neurips.cc/paper_files/paper/2019/hash/7fea637fd6d02b8f0adf6f7dc36aed93-Abstract.html" class="external-link">fooled
by adversarial examples</a>.</p>
</div>
<div class="section level3">
<h3 id="probing-internal-representations">Probing internal representations<a class="anchor" aria-label="anchor" href="#probing-internal-representations"></a>
</h3>
<p>As the name suggests, this class of methods aims to probe the
internals of a model, to discover what kind of information or knowledge
is stored inside the model. Probes are often administered to a specific
component of the model, like a set of neurons or layers within a neural
network.</p>
<p><strong>Example methods:</strong> <a href="https://direct.mit.edu/coli/article/48/1/207/107571/Probing-Classifiers-Promises-Shortcomings-and" class="external-link">Probing
classifiers</a>, <a href="https://proceedings.neurips.cc/paper/2020/hash/92650b2e92217715fe312e6fa7b90d82-Abstract.html" class="external-link">Causal
tracing</a></p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-probe.png" alt='The phrase "The nurse examined the farmer for injuries because PRONOUN" is shown twice, once with PRONOUN=she and once with PRONOUN=he. Each word is annotated with the importance of three different attention heads. The distribution of which heads are important with each pronoun differs for all words, but especially for nurse and farmer.' class="figure mx-auto d-block"><div class="figcaption">Example probe output. The image shows the result
from probing three attention heads. We see that gender stereotypes are
encoded into the model because the heads that are important for nurse
and farmer change depending on the final pronoun. Specifically, Head
5-10 attends to the stereotypical gender assignment while Head 4-6
attends to the anti-stereotypical gender assignment. (Image taken from
<a href="https://proceedings.neurips.cc/paper/2020/hash/92650b2e92217715fe312e6fa7b90d82-Abstract.html" class="external-link">Vig
et al.</a>)</div>
</figure><p><strong>Pros and cons:</strong> Probes have shown that it is possible
to find highly interpretable components in a complex model, e.g., MLP
layers in transformers have been shown to store factual knowledge in a
structured manner. However, there is no systematic way of finding
interpretable components, and many components may remain elusive to
humans to understand. Furthermore, the model components that have been
shown to contain certain knowledge may not actually play a role in the
model’s prediction.</p>
<div id="is-that-all" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="is-that-all" class="callout-inner">
<h3 class="callout-title">Is that all?</h3>
<div class="callout-content">
<p>Nope! We’ve discussed a few of the common explanation techniques, but
many others exist. In particular, specialized model architectures often
need their own explanation algorithms. For instance, <a href="https://ieeexplore.ieee.org/abstract/document/9875989?casa_token=BiFHRXv7_9gAAAAA:wPV-PXOpCLFg2g1qYgEQ7QF_LKZs32cOXEJBvwjK3z43sXeaGfvQ9e1QePW03MTLq4lrUsh4Jw" class="external-link">Yuan
et al.</a> give an overview of different explanation techniques for
graph neural networks (GNNs).</p>
</div>
</div>
</div>
<div id="classifying-explanation-techniques" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="classifying-explanation-techniques" class="callout-inner">
<h3 class="callout-title">Classifying explanation techniques</h3>
<div class="callout-content">
<p>For each of the explanation techniques described above, discuss the
following with a partner:</p>
<ul>
<li>Does it require black-box or white-box model access?</li>
<li>Are the explanations it provides global or local?</li>
<li>Is the technique post-hoc or does it rely on inherent
interpretability of the model?</li>
</ul>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<table class="table">
<colgroup>
<col width="54%">
<col width="21%">
<col width="10%">
<col width="13%">
</colgroup>
<thead><tr class="header">
<th>Approach</th>
<th>Post Hoc or Inherently Interpretable?</th>
<th>Local or Global?</th>
<th>White Box or Black Box?</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><a href="#diagnostic-testing">Diagnostic Testing</a></td>
<td>Post Hoc</td>
<td>Global</td>
<td>Black Box</td>
</tr>
<tr class="even">
<td><a href="#baking-interpretability-into-models">Baking
interpretability into models</a></td>
<td>Inherently Interpretable</td>
<td>Local</td>
<td>White Box</td>
</tr>
<tr class="odd">
<td><a href="#identifying-decision-rules-of-the-model">Identifying
Decision Rules of the Model</a></td>
<td>Post Hoc</td>
<td>Both</td>
<td>White Box</td>
</tr>
<tr class="even">
<td><a href="#visualizing-model-weights-or-representations">Visualizing
model weights or representations</a></td>
<td>Post Hoc</td>
<td>Global</td>
<td>White Box</td>
</tr>
<tr class="odd">
<td><a href="#understanding-the-impact-of-training-examples">Understanding the
impact of training examples</a></td>
<td>Post Hoc</td>
<td>Local</td>
<td>White Box</td>
</tr>
<tr class="even">
<td><a href="#understanding-the-impact-of-a-single-example">Understanding the
impact of a single example</a></td>
<td>Post Hoc</td>
<td>Local</td>
<td>Both</td>
</tr>
<tr class="odd">
<td><a href="#probing-internal-representations">Probing internal
representations of a model</a></td>
<td>Post Hoc</td>
<td>Global/Local</td>
<td>White Box</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<p>What explanation should you use when? There is no simple answer, as
it depends upon your goals (i.e., why you need an explanation), who the
audience is, the model architecture, and the availability of model
internals (e.g., there is no white-box access to ChatGPT unless you work
for Open AI!). The next exercise asks you to consider different
scenarios and discuss what explanation techniques are appropriate.</p>
<div id="discussion2" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Think about the following scenarios and suggest which explainability
method would be most appropriate to use, and what information could be
gained from that method. Furthermore, think about the limitations of
your findings.</p>
<p><em>Note:</em> These are open-ended questions, and there is no
correct answer. Feel free to break into discussion groups to discuss the
scenarios.</p>
<p><strong>Scenario 1</strong>: Suppose that you are an ML engineer
working at a tech company. A fast-food chain company consults with you
about sentimental analysis based on feedback they collected on Yelp and
their survey. You use an open sourced LLM such as Llama-2 and finetune
it on the review text data. The fast-food company asks to provide
explanations for the model: Is there any outlier review? How does each
review in the data affect the finetuned model? Which part of the
language in the review indicates that a customer likes or dislikes the
food? Can you score the food quality according to the reviews? Does the
review show a trend over time? What item is gaining popularity or losing
popularity? Q: Can you suggest a few explainability methods that may be
useful for answering these questions?</p>
<p><strong>Scenario 2</strong>: Suppose that you are a radiologist who
analyzes medical images of patients with the help of machine learning
models. You use black-box models (e.g., CNNs, Vision Transformers) to
complement human expertise and get useful information before making
high-stake decisions. Which areas of a medical image most likely
explains the output of a black-box? Can we visualize and understand what
features are captured by the intermediate components of the black-box
models? How do we know if there is a distribution shift? How can we tell
if an image is an out-of-distribution example? Q: Can you suggest a few
explainability methods that may be useful for answering these
questions?</p>
<p><strong>Scenario 3</strong>: Suppose that you work on genomics and
you just collected samples of single-cell data into a table: each row
records gene expression levels, and each column represents a single
cell. You are interested in scientific hypotheses about evolution of
cells. You believe that only a few genes are playing a role in your
study. What exploratory data analysis techniques would you use to
examine the dataset? How do you check whether there are potential
outliers, irregularities in the dataset? You believe that only a few
genes are playing a role in your study. What can you do to find the set
of most explanatory genes? How do you know if there is clustering, and
if there is a trajectory of changes in the cells? Q: Can you explain the
decisions you make for each method you use?</p>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<p>There are many available explanation techniques and they differ along
three dimensions: model access (white-box or black-box), explanation
scope (global or local), and approach (inherently interpretable or
post-hoc). There’s often no objectively-right answer of which
explanation technique to use in a given situation, as the different
methods have different tradeoffs.</p>
<div class="section level3">
<h3 id="references-and-further-reading">References and Further Reading<a class="anchor" aria-label="anchor" href="#references-and-further-reading"></a>
</h3>
<p>This lesson provides a gentle overview into the world of
explainability methods. If you’d like to know more, here are some
resources to get you started:</p>
<ul>
<li>Tutorials on Explainability:
<ul>
<li><a href="https://github.com/Eric-Wallace/interpretability-tutorial-emnlp2020/blob/master/tutorial_slides.pdf" class="external-link">Wallace,
E., Gardner, M., &amp; Singh, S. (2020, November). Interpreting
predictions of NLP models. In Proceedings of the 2020 Conference on
Empirical Methods in Natural Language Processing: Tutorial Abstracts
(pp. 20-23).</a></li>
<li><a href="https://explainml-tutorial.github.io/aaai21" class="external-link">Lakkaraju, H.,
Adebayo, J., &amp; Singh, S. (2020). Explaining machine learning
predictions: State-of-the-art, challenges, and opportunities. NeurIPS
Tutorial.</a></li>
<li><a href="https://sebastiangehrmann.github.io/assets/files/acl_2020_interpretability_tutorial.pdf" class="external-link">Belinkov,
Y., Gehrmann, S., &amp; Pavlick, E. (2020, July). Interpretability and
analysis in neural NLP. In Proceedings of the 58th annual meeting of the
association for computational linguistics: tutorial abstracts
(pp. 1-5).</a></li>
</ul>
</li>
<li>Research papers:
<ul>
<li><a href="https://arxiv.org/abs/2308.00189" class="external-link">Holtzman, A., West, P.,
&amp; Zettlemoyer, L. (2023). Generative Models as a Complex Systems
Science: How can we make sense of large language model behavior?. arXiv
preprint arXiv:2308.00189.</a></li>
</ul>
</li>
</ul>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-5c-probes"><p>Content from <a href="5c-probes.html">Explainability methods: Linear Probes</a></p>
<hr>
<p>Last updated on 2024-12-16 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/5c-probes.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How can probing classifiers help us understand what a model has
learned?<br>
</li>
<li>What are the limitations of probing classifiers, and how can they be
addressed?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand the concept of probing classifiers and how they assess
the representations learned by models.<br>
</li>
<li>Gain familiarity with the PyTorch and HuggingFace libraries, for
using and evaluating language models.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="what-part-of-my-model-causes-this-prediction">What part of my model causes this prediction?<a class="anchor" aria-label="anchor" href="#what-part-of-my-model-causes-this-prediction"></a>
</h2>
<hr class="half-width">
<p>When a model makes a correct prediction on a task it has been trained
on (known as a ‘downstream task’), <strong><a href="https://direct.mit.edu/coli/article/48/1/207/107571/Probing-Classifiers-Promises-Shortcomings-and" class="external-link">Probing
classifiers</a></strong> can be used to identify if the model actually
contains the relevant information or knowledge required to make that
prediction, or if it is just making a lucky guess. Furthermore, probes
can be used to identify the specific components of the model that
contain this relevant information, providing crucial insights for
developing better models over time.</p>
<div class="section level4">
<h4 id="method-and-examples">Method and Examples<a class="anchor" aria-label="anchor" href="#method-and-examples"></a>
</h4>
<p>A neural network takes its input as a series of vectors, or
representations, and transforms them through a series of layers to
produce an output. The job of the main body of the neural network is to
develop representations that are as useful for the downstream task as
possible, so that the final few layers of the network can make a good
prediction.</p>
<p>This essentially means that a good quality representation is one that
<em>already</em> contains all the information required to make a good
prediction. In other words, the features or representations from the
model are easily separable by a simple classifier. And that classifier
is what we call a ‘probe’. A probe is a simple model that uses the
representations of the model as input, and tries to learn the downstream
task from them. The probe itself is designed to be too easy to learn the
task on its own. This means, that the only way the probe get perform
well on this task is if the representations it is given are already good
enough to make the prediction.</p>
<p>These representations can be taken from any part of the model.
Generally, using representations from the last layer of a neural network
help identify if the model even contains the information to make
predictions for the downstream task. However, this can be extended
further: probing the representations from different layers of the model
can help identify where in the model the information is stored, and how
it is transformed through the model.</p>
<p>Probes have been frequently used in the domain of NLP, where they
have been used to check if language models contain certain kinds of
linguistic information. These probes can be designed with varying levels
of complexity. For example, simple probes have shown language models to
contain information about simple syntactical features like <a href="https://aclanthology.org/D15-1246.pdf" class="external-link">Part of Speech tags</a>,
and more complex probes have shown models to contain entire <a href="https://aclanthology.org/N19-1419.pdf" class="external-link">Parse trees</a> of
sentences.</p>
</div>
<div class="section level4">
<h4 id="limitations-and-extensions">Limitations and Extensions<a class="anchor" aria-label="anchor" href="#limitations-and-extensions"></a>
</h4>
<p>One large challenge in using probes is identifying the correct
architectural design of the probe. Too simple, and it may not be able to
learn the downstream task at all. Too complex, and it may be able to
learn the task even if the model does not contain the information
required to make the prediction.</p>
<p>Another large limitation is that even if a probe is able to learn the
downstream task, it does not mean that the model is actually using the
information contained in the representations to make the prediction. So
essentially, a probe can only tell us if a part of the model
<em>can</em> make the prediction, not if it <em>does</em> make the
prediction.</p>
<p>A new approach known as <strong><a href="https://proceedings.neurips.cc/paper/2020/hash/92650b2e92217715fe312e6fa7b90d82-Abstract.html" class="external-link">Causal
Tracing</a></strong> addresses this limitation. The objective of this
approach is similar to probes: attempting to understand which part of a
model contains information relevant to a downstream task. The approach
involves iterating through all parts of the model being examined
(e.g. all layers of a model), and disrupting the information flow
through that part of the model. (This could be as easy as adding some
kind of noise on top of the weights of that model component). If the
model performance on the downstream task suddenly drops on disrupting a
specific model component, we know for sure that that component not only
contains the information required to make the prediction, but that the
model is actually using that information to make the prediction.</p>
</div>
</section><section><h2 class="section-heading" id="implementing-your-own-probe">Implementing your own Probe<a class="anchor" aria-label="anchor" href="#implementing-your-own-probe"></a>
</h2>
<hr class="half-width">
<p>Let’s start by importing the necessary libraries.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">import</span> logging</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Tuple</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="im">from</span> sklearn.manifold <span class="im">import</span> TSNE</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="im">from</span> datasets <span class="im">import</span> load_dataset, Dataset</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> AutoModel, AutoTokenizer, AutoConfig</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>logging.basicConfig(level<span class="op">=</span>logging.INFO)</span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>os.environ[<span class="st">'TOKENIZERS_PARALLELISM'</span>] <span class="op">=</span> <span class="st">'false'</span>  <span class="co"># This is needed to avoid a warning from huggingface</span></span></code></pre>
</div>
<p>Now, let’s set the random seed to ensure reproducibility. Setting
random seeds is like setting a starting point for your machine learning
adventure. It ensures that every time you train your model, it starts
from the same place, using the same random numbers, making your results
consistent and comparable.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Set random seeds for reproducibility - pick any number of your choice to set the seed. We use 42, since that is the answer to everything, after all.</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>torch.manual_seed(<span class="dv">42</span>)</span></code></pre>
</div>
<div class="section level5">
<h5 id="loading-the-dataset">Loading the Dataset<a class="anchor" aria-label="anchor" href="#loading-the-dataset"></a>
</h5>
<p>Let’s load our data: the IMDB Movie Review dataset. The dataset
contains text reviews and their corresponding sentiment labels (positive
or negative). The label 1 corresponds to a positive review, and 0
corresponds to a negative review.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="kw">def</span> load_imdb_dataset(keep_samples: <span class="bu">int</span> <span class="op">=</span> <span class="dv">100</span>) <span class="op">-&gt;</span> Tuple[Dataset, Dataset, Dataset]:</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="co">    Load the IMDB dataset from huggingface.</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="co">    The dataset contains text reviews and their corresponding sentiment labels (positive or negative).</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="co">    The label 1 corresponds to a positive review, and 0 corresponds to a negative review.</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="co">    :param keep_samples: Number of samples to keep, for faster training.</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a><span class="co">    :return: train, dev, test datasets. Each can be treated as a dictionary with keys 'text' and 'label'.</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>    dataset <span class="op">=</span> load_dataset(<span class="st">'imdb'</span>)</span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a>    <span class="co"># Keep only a subset of the data for faster training</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>    train_dataset <span class="op">=</span> Dataset.from_dict(dataset[<span class="st">'train'</span>].shuffle(seed<span class="op">=</span><span class="dv">42</span>)[:keep_samples])</span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a>    dev_dataset <span class="op">=</span> Dataset.from_dict(dataset[<span class="st">'test'</span>].shuffle(seed<span class="op">=</span><span class="dv">42</span>)[:keep_samples])</span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a>    test_dataset <span class="op">=</span> Dataset.from_dict(dataset[<span class="st">'test'</span>].shuffle(seed<span class="op">=</span><span class="dv">42</span>)[keep_samples:<span class="dv">2</span><span class="op">*</span>keep_samples])</span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a>    <span class="co"># train_dataset[0] will return {'text': ...., 'label': 0}</span></span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a>    logging.info(<span class="ss">f'Loaded IMDB dataset: </span><span class="sc">{</span><span class="bu">len</span>(train_dataset)<span class="sc">}</span><span class="ss"> training samples, </span><span class="sc">{</span><span class="bu">len</span>(dev_dataset)<span class="sc">}</span><span class="ss"> dev samples, </span><span class="sc">{</span><span class="bu">len</span>(test_dataset)<span class="sc">}</span><span class="ss"> test samples.'</span>)</span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a>    <span class="cf">return</span> train_dataset, dev_dataset, test_dataset</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>train_dataset, dev_dataset, test_dataset <span class="op">=</span> load_imdb_dataset(keep_samples<span class="op">=</span><span class="dv">50</span>)</span></code></pre>
</div>
</div>
<div class="section level5">
<h5 id="loading-the-model">Loading the Model<a class="anchor" aria-label="anchor" href="#loading-the-model"></a>
</h5>
<p>We will load a model from huggingface, and use this model to get the
embeddings for the probe. We use distilBERT for this example, but feel
free to explore other models from huggingface after the exercise.</p>
<p>BERT is a transformer-based model, and is known to perform well on a
variety of NLP tasks. The model is pre-trained on a large corpus of
text, and can be fine-tuned for specific tasks. distilBERT is a
lightweight version of the model, created through a process known as <a href="https://en.wikipedia.org/wiki/Knowledge_distillation#:~:text=In%20machine%20learning%2C%20knowledge%20distillation,might%20not%20be%20fully%20utilized." class="external-link">distillation</a></p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="kw">def</span> load_model(model_name: <span class="bu">str</span>) <span class="op">-&gt;</span> Tuple[AutoModel, AutoTokenizer]:</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="co">    Load a model from huggingface.</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="co">    :param model_name: Check huggingface for acceptable model names.</span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="co">    :return: Model and tokenizer.</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>    tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(model_name)</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>    config <span class="op">=</span> AutoConfig.from_pretrained(model_name)</span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>    model <span class="op">=</span> AutoModel.from_pretrained(model_name, config<span class="op">=</span>config)</span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>    model.config.max_position_embeddings <span class="op">=</span> <span class="dv">128</span>  <span class="co"># Reducing from default 512 to 128 for computational efficiency</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a>    logging.info(<span class="ss">f'Loaded model and tokenizer: </span><span class="sc">{</span>model_name<span class="sc">}</span><span class="ss"> with </span><span class="sc">{</span>model<span class="sc">.</span>config<span class="sc">.</span>num_hidden_layers<span class="sc">}</span><span class="ss"> layers, '</span></span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a>                 <span class="ss">f'hidden size </span><span class="sc">{</span>model<span class="sc">.</span>config<span class="sc">.</span>hidden_size<span class="sc">}</span><span class="ss"> and sequence length </span><span class="sc">{</span>model<span class="sc">.</span>config<span class="sc">.</span>max_position_embeddings<span class="sc">}</span><span class="ss">.'</span>)</span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a>    <span class="cf">return</span> model, tokenizer</span></code></pre>
</div>
<p>To play around with other models, find a list of models and their
model_ids at: <a href="https://huggingface.co/models" class="external-link uri">https://huggingface.co/models</a></p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>model, tokenizer <span class="op">=</span> load_model(<span class="st">'distilbert-base-uncased'</span>) <span class="co">#'bert-base-uncased' has 12 layers and may take a while to process. We'll investigate distilbert instead.</span></span></code></pre>
</div>
<p>Let’s see what the model’s architecture looks like. How many layers
does it have?</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="bu">print</span>(model)</span></code></pre>
</div>
<p>Let’s see if your answer matches the actual number of layers in the
model.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>num_layers <span class="op">=</span> model.config.num_hidden_layers</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'The model has </span><span class="sc">{</span>num_layers<span class="sc">}</span><span class="ss"> layers.'</span>)</span></code></pre>
</div>
</div>
<div class="section level5">
<h5 id="setting-up-the-probe">Setting up the Probe<a class="anchor" aria-label="anchor" href="#setting-up-the-probe"></a>
</h5>
<p>Before we define the probing classifier or probe, let’s set up some
utility functions the probe will use. The probe will be trained from
hidden representations from a specific layer of the BERT model. The
<code>get_embeddings_from_model</code> function will retrieve the
intermediate layer representations (also known as embeddings) from a
user defined layer number.</p>
<p>The <code>visualize_embeddings</code> method can be used to see what
these high dimensional hidden embeddings would look like when converted
into a 2D view. The visualization is not intended to be informative in
itself, and is only an additional tool used to get a sense of what the
inputs to the probing classifier may look like.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="kw">def</span> get_embeddings_from_model(model: AutoModel, tokenizer: AutoTokenizer, layer_num: <span class="bu">int</span>, data: <span class="bu">list</span>[<span class="bu">str</span>], batch_size : <span class="bu">int</span>) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="co">    Get the embeddings from a model.</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="co">    :param model: The model to use. This is needed to get the embeddings.</span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a><span class="co">    :param tokenizer: The tokenizer to use. This is needed to convert the data to input IDs.</span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="co">    :param layer_num: The layer to get embeddings from. 0 is the input embeddings, and the last layer is the output embeddings.</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="co">    :param data: The data to get embeddings for. A list of strings.</span></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="co">    :return: The embeddings. Shape is N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a>    logging.info(<span class="ss">f'Getting embeddings from layer </span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss"> for </span><span class="sc">{</span><span class="bu">len</span>(data)<span class="sc">}</span><span class="ss"> samples...'</span>)</span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a>    <span class="co"># Batch the data for computational efficiency</span></span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a>    batch_num <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(data), batch_size):</span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a>        batch <span class="op">=</span> data[i:i<span class="op">+</span>batch_size]</span>
<span id="cb9-16"><a href="#cb9-16" tabindex="-1"></a>        logging.debug(<span class="ss">f'Getting embeddings for batch </span><span class="sc">{</span>batch_num<span class="sc">}</span><span class="ss">...'</span>)</span>
<span id="cb9-17"><a href="#cb9-17" tabindex="-1"></a>        batch_num <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb9-18"><a href="#cb9-18" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" tabindex="-1"></a>        <span class="co"># Tokenize the batch of data</span></span>
<span id="cb9-20"><a href="#cb9-20" tabindex="-1"></a>        inputs <span class="op">=</span> tokenizer(batch, return_tensors<span class="op">=</span><span class="st">'pt'</span>, padding<span class="op">=</span><span class="va">True</span>, truncation<span class="op">=</span><span class="va">True</span>, max_length<span class="op">=</span><span class="dv">256</span>)</span>
<span id="cb9-21"><a href="#cb9-21" tabindex="-1"></a></span>
<span id="cb9-22"><a href="#cb9-22" tabindex="-1"></a>        <span class="co"># Get the embeddings from the model</span></span>
<span id="cb9-23"><a href="#cb9-23" tabindex="-1"></a>        outputs <span class="op">=</span> model(<span class="op">**</span>inputs, output_hidden_states<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-24"><a href="#cb9-24" tabindex="-1"></a></span>
<span id="cb9-25"><a href="#cb9-25" tabindex="-1"></a>        <span class="co"># Get the embeddings for the specific the layer</span></span>
<span id="cb9-26"><a href="#cb9-26" tabindex="-1"></a>        embeddings <span class="op">=</span> outputs.hidden_states[layer_num]</span>
<span id="cb9-27"><a href="#cb9-27" tabindex="-1"></a>        logging.debug(<span class="ss">f'Extracted hidden states of shape </span><span class="sc">{</span>embeddings<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb9-28"><a href="#cb9-28" tabindex="-1"></a></span>
<span id="cb9-29"><a href="#cb9-29" tabindex="-1"></a>        <span class="co"># Concatenate the embeddings from each batch</span></span>
<span id="cb9-30"><a href="#cb9-30" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb9-31"><a href="#cb9-31" tabindex="-1"></a>            all_embeddings <span class="op">=</span> embeddings</span>
<span id="cb9-32"><a href="#cb9-32" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-33"><a href="#cb9-33" tabindex="-1"></a>            all_embeddings <span class="op">=</span> torch.cat([all_embeddings, embeddings], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb9-34"><a href="#cb9-34" tabindex="-1"></a></span>
<span id="cb9-35"><a href="#cb9-35" tabindex="-1"></a>    logging.info(<span class="ss">f'Got embeddings for </span><span class="sc">{</span><span class="bu">len</span>(data)<span class="sc">}</span><span class="ss"> samples from layer </span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss">. Shape: </span><span class="sc">{</span>all_embeddings<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb9-36"><a href="#cb9-36" tabindex="-1"></a>    <span class="cf">return</span> all_embeddings</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="kw">def</span> visualize_embeddings(embeddings: torch.Tensor, labels: <span class="bu">list</span>, layer_num: <span class="bu">int</span>, visualization_method: <span class="bu">str</span> <span class="op">=</span> <span class="st">'t-SNE'</span>, save_plot: <span class="bu">bool</span> <span class="op">=</span> <span class="va">False</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a><span class="co">    Visualize the embeddings using t-SNE.</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="co">    :param embeddings: The embeddings to visualize. Shape is N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="co">    :param labels: The labels for the embeddings. A list of integers.</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="co">    :return: None</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>    <span class="co"># Since we are working with sentiment analysis, which is sentence based task, we can use sentence embeddings.</span></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a>    <span class="co"># The sentence embeddings are simply the mean of the token embeddings of that sentence.</span></span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a>    sentence_embeddings <span class="op">=</span> torch.mean(embeddings, dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># N, D</span></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a>    <span class="co"># Convert to numpy</span></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a>    sentence_embeddings <span class="op">=</span> sentence_embeddings.detach().numpy()</span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a>    labels <span class="op">=</span> np.array(labels)</span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a>    <span class="cf">assert</span> visualization_method <span class="kw">in</span> [<span class="st">'t-SNE'</span>, <span class="st">'PCA'</span>], <span class="st">"visualization_method must be one of 't-SNE' or 'PCA'"</span></span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a>    <span class="co"># Visualize the embeddings</span></span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a>    <span class="cf">if</span> visualization_method <span class="op">==</span> <span class="st">'t-SNE'</span>:</span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a>        tsne <span class="op">=</span> TSNE(n_components<span class="op">=</span><span class="dv">2</span>, random_state<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a>        embeddings_2d <span class="op">=</span> tsne.fit_transform(sentence_embeddings)</span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a>        xlabel <span class="op">=</span> <span class="st">'t-SNE dimension 1'</span></span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a>        ylabel <span class="op">=</span> <span class="st">'t-SNE dimension 2'</span></span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a>    <span class="cf">if</span> visualization_method <span class="op">==</span> <span class="st">'PCA'</span>:</span>
<span id="cb10-26"><a href="#cb10-26" tabindex="-1"></a>        pca <span class="op">=</span> PCA(n_components<span class="op">=</span><span class="dv">2</span>, random_state<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb10-27"><a href="#cb10-27" tabindex="-1"></a>        embeddings_2d <span class="op">=</span> pca.fit_transform(sentence_embeddings)</span>
<span id="cb10-28"><a href="#cb10-28" tabindex="-1"></a>        xlabel <span class="op">=</span> <span class="st">'First Principal Component'</span></span>
<span id="cb10-29"><a href="#cb10-29" tabindex="-1"></a>        ylabel <span class="op">=</span> <span class="st">'Second Principal Component'</span></span>
<span id="cb10-30"><a href="#cb10-30" tabindex="-1"></a></span>
<span id="cb10-31"><a href="#cb10-31" tabindex="-1"></a>    negative_points <span class="op">=</span> embeddings_2d[labels <span class="op">==</span> <span class="dv">0</span>]</span>
<span id="cb10-32"><a href="#cb10-32" tabindex="-1"></a>    positive_points <span class="op">=</span> embeddings_2d[labels <span class="op">==</span> <span class="dv">1</span>]</span>
<span id="cb10-33"><a href="#cb10-33" tabindex="-1"></a></span>
<span id="cb10-34"><a href="#cb10-34" tabindex="-1"></a>    <span class="co"># Plot the embeddings. We want to colour the datapoints by label.</span></span>
<span id="cb10-35"><a href="#cb10-35" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb10-36"><a href="#cb10-36" tabindex="-1"></a>    ax.scatter(negative_points[:, <span class="dv">0</span>], negative_points[:, <span class="dv">1</span>], label<span class="op">=</span><span class="st">'Negative'</span>, color<span class="op">=</span><span class="st">'red'</span>, marker<span class="op">=</span><span class="st">'o'</span>, s<span class="op">=</span><span class="dv">10</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb10-37"><a href="#cb10-37" tabindex="-1"></a>    ax.scatter(positive_points[:, <span class="dv">0</span>], positive_points[:, <span class="dv">1</span>], label<span class="op">=</span><span class="st">'Positive'</span>, color<span class="op">=</span><span class="st">'blue'</span>, marker<span class="op">=</span><span class="st">'o'</span>, s<span class="op">=</span><span class="dv">10</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb10-38"><a href="#cb10-38" tabindex="-1"></a>    plt.xlabel(xlabel)</span>
<span id="cb10-39"><a href="#cb10-39" tabindex="-1"></a>    plt.ylabel(ylabel)</span>
<span id="cb10-40"><a href="#cb10-40" tabindex="-1"></a>    plt.title(<span class="ss">f'</span><span class="sc">{</span>visualization_method<span class="sc">}</span><span class="ss"> of Sentence Embeddings - Layer</span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb10-41"><a href="#cb10-41" tabindex="-1"></a>    plt.legend()</span>
<span id="cb10-42"><a href="#cb10-42" tabindex="-1"></a></span>
<span id="cb10-43"><a href="#cb10-43" tabindex="-1"></a>    <span class="co"># Save the plot if needed, then display it</span></span>
<span id="cb10-44"><a href="#cb10-44" tabindex="-1"></a>    <span class="cf">if</span> save_plot:</span>
<span id="cb10-45"><a href="#cb10-45" tabindex="-1"></a>        plt.savefig(<span class="ss">f'</span><span class="sc">{</span>visualization_method<span class="sc">}</span><span class="ss">_layer_</span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss">.png'</span>)</span>
<span id="cb10-46"><a href="#cb10-46" tabindex="-1"></a>    plt.show()</span>
<span id="cb10-47"><a href="#cb10-47" tabindex="-1"></a></span>
<span id="cb10-48"><a href="#cb10-48" tabindex="-1"></a>    logging.info(<span class="ss">f'Visualized embeddings using </span><span class="sc">{</span>visualization_method<span class="sc">}</span><span class="ss">.'</span>)</span></code></pre>
</div>
<p>Now, it’s finally time to define our probe! We set this up as a
class, where the probe itself is an object of this class. The class also
contains methods used to train and evaluate the probe.</p>
<p>Read through this code block in a bit more detail - from this whole
exercise, this part provides you with the most useful takeaways on ways
to define and train neural networks!</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="kw">class</span> Probe():</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, hidden_dim: <span class="bu">int</span> <span class="op">=</span> <span class="dv">768</span>, class_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">2</span>)  <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="co">        Initialize the probe.</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a><span class="co">        :param hidden_dim: The dimensionality of the hidden layer of the probe.</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="co">        :param num_layers: The number of layers in the probe.</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a><span class="co">        :return: None</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>        <span class="co"># The probe is a simple linear classifier, with a hidden layer and an output layer.</span></span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>        <span class="co"># The input to the probe is the embeddings from the model, and the output is the predicted class.</span></span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a>        <span class="co"># Exercise: Try playing around with the hidden_dim and num_layers to see how it affects the probe's performance.</span></span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a>        <span class="co"># But watch out: if a complex probe performs well on the task, we don't know if the performance</span></span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a>        <span class="co"># is because of the model embeddings, or the probe itself learning the task!</span></span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a>        <span class="va">self</span>.probe <span class="op">=</span> torch.nn.Sequential(</span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a>            torch.nn.Linear(hidden_dim, hidden_dim),</span>
<span id="cb11-19"><a href="#cb11-19" tabindex="-1"></a>            torch.nn.ReLU(),</span>
<span id="cb11-20"><a href="#cb11-20" tabindex="-1"></a>            torch.nn.Linear(hidden_dim, class_size),</span>
<span id="cb11-21"><a href="#cb11-21" tabindex="-1"></a></span>
<span id="cb11-22"><a href="#cb11-22" tabindex="-1"></a>            <span class="co"># Add more layers here if needed</span></span>
<span id="cb11-23"><a href="#cb11-23" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" tabindex="-1"></a>            <span class="co"># Sigmoid is used to convert the hidden states into a probability distribution over the classes</span></span>
<span id="cb11-25"><a href="#cb11-25" tabindex="-1"></a>            torch.nn.Sigmoid()</span>
<span id="cb11-26"><a href="#cb11-26" tabindex="-1"></a>        )</span>
<span id="cb11-27"><a href="#cb11-27" tabindex="-1"></a></span>
<span id="cb11-28"><a href="#cb11-28" tabindex="-1"></a></span>
<span id="cb11-29"><a href="#cb11-29" tabindex="-1"></a>    <span class="kw">def</span> train(<span class="va">self</span>, data_embeddings: torch.Tensor, labels: torch.Tensor, num_epochs: <span class="bu">int</span> <span class="op">=</span> <span class="dv">10</span>,</span>
<span id="cb11-30"><a href="#cb11-30" tabindex="-1"></a>              learning_rate: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.001</span>, batch_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">32</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb11-31"><a href="#cb11-31" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb11-32"><a href="#cb11-32" tabindex="-1"></a><span class="co">        Train the probe on the embeddings of data from the model.</span></span>
<span id="cb11-33"><a href="#cb11-33" tabindex="-1"></a><span class="co">        :param data_embeddings: A tensor of shape N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb11-34"><a href="#cb11-34" tabindex="-1"></a><span class="co">        :param labels: A tensor of shape N, where N is the number of samples. Each element is the label for the corresponding sample.</span></span>
<span id="cb11-35"><a href="#cb11-35" tabindex="-1"></a><span class="co">        :param num_epochs: The number of epochs to train the probe for. An epoch is one pass through the entire dataset.</span></span>
<span id="cb11-36"><a href="#cb11-36" tabindex="-1"></a><span class="co">        :param learning_rate: How fast the probe learns. A hyperparameter.</span></span>
<span id="cb11-37"><a href="#cb11-37" tabindex="-1"></a><span class="co">        :param batch_size: Used to batch the data for computational efficiency. A hyperparameter.</span></span>
<span id="cb11-38"><a href="#cb11-38" tabindex="-1"></a><span class="co">        :return:</span></span>
<span id="cb11-39"><a href="#cb11-39" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb11-40"><a href="#cb11-40" tabindex="-1"></a></span>
<span id="cb11-41"><a href="#cb11-41" tabindex="-1"></a>        <span class="co"># Setup the loss function (training objective) for the training process.</span></span>
<span id="cb11-42"><a href="#cb11-42" tabindex="-1"></a>        <span class="co"># The cross-entropy loss is used for multi-class classification, and represents the negative log likelihood of the true class.</span></span>
<span id="cb11-43"><a href="#cb11-43" tabindex="-1"></a>        criterion <span class="op">=</span> torch.nn.CrossEntropyLoss()</span>
<span id="cb11-44"><a href="#cb11-44" tabindex="-1"></a></span>
<span id="cb11-45"><a href="#cb11-45" tabindex="-1"></a>        <span class="co"># Setup the optimization algorithm to update the probe's parameters during training.</span></span>
<span id="cb11-46"><a href="#cb11-46" tabindex="-1"></a>        <span class="co"># The Adam optimizer is an extension to stochastic gradient descent, and is a popular choice.</span></span>
<span id="cb11-47"><a href="#cb11-47" tabindex="-1"></a>        optimizer <span class="op">=</span> torch.optim.Adam(<span class="va">self</span>.probe.parameters(), lr<span class="op">=</span>learning_rate)</span>
<span id="cb11-48"><a href="#cb11-48" tabindex="-1"></a></span>
<span id="cb11-49"><a href="#cb11-49" tabindex="-1"></a>        <span class="co"># Train the probe</span></span>
<span id="cb11-50"><a href="#cb11-50" tabindex="-1"></a>        logging.info(<span class="st">'Training the probe...'</span>)</span>
<span id="cb11-51"><a href="#cb11-51" tabindex="-1"></a>        <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(num_epochs):  <span class="co"># Pass over the data num_epochs times</span></span>
<span id="cb11-52"><a href="#cb11-52" tabindex="-1"></a></span>
<span id="cb11-53"><a href="#cb11-53" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(data_embeddings), batch_size):</span>
<span id="cb11-54"><a href="#cb11-54" tabindex="-1"></a></span>
<span id="cb11-55"><a href="#cb11-55" tabindex="-1"></a>                <span class="co"># Iterate through one batch of data at a time</span></span>
<span id="cb11-56"><a href="#cb11-56" tabindex="-1"></a>                batch_embeddings <span class="op">=</span> data_embeddings[i:i<span class="op">+</span>batch_size].detach()</span>
<span id="cb11-57"><a href="#cb11-57" tabindex="-1"></a>                batch_labels <span class="op">=</span> labels[i:i<span class="op">+</span>batch_size]</span>
<span id="cb11-58"><a href="#cb11-58" tabindex="-1"></a></span>
<span id="cb11-59"><a href="#cb11-59" tabindex="-1"></a>                <span class="co"># Convert to sentence embeddings, since we are performing a sentence classification task</span></span>
<span id="cb11-60"><a href="#cb11-60" tabindex="-1"></a>                batch_embeddings <span class="op">=</span> torch.mean(batch_embeddings, dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># N, D</span></span>
<span id="cb11-61"><a href="#cb11-61" tabindex="-1"></a></span>
<span id="cb11-62"><a href="#cb11-62" tabindex="-1"></a>                <span class="co"># Get the probe's predictions, given the embeddings from the model</span></span>
<span id="cb11-63"><a href="#cb11-63" tabindex="-1"></a>                outputs <span class="op">=</span> <span class="va">self</span>.probe(batch_embeddings)</span>
<span id="cb11-64"><a href="#cb11-64" tabindex="-1"></a></span>
<span id="cb11-65"><a href="#cb11-65" tabindex="-1"></a>                <span class="co"># Calculate the loss of the predictions, against the true labels</span></span>
<span id="cb11-66"><a href="#cb11-66" tabindex="-1"></a>                loss <span class="op">=</span> criterion(outputs, batch_labels)</span>
<span id="cb11-67"><a href="#cb11-67" tabindex="-1"></a></span>
<span id="cb11-68"><a href="#cb11-68" tabindex="-1"></a>                <span class="co"># Backward pass - update the probe's parameters</span></span>
<span id="cb11-69"><a href="#cb11-69" tabindex="-1"></a>                optimizer.zero_grad()</span>
<span id="cb11-70"><a href="#cb11-70" tabindex="-1"></a>                loss.backward()</span>
<span id="cb11-71"><a href="#cb11-71" tabindex="-1"></a>                optimizer.step()</span>
<span id="cb11-72"><a href="#cb11-72" tabindex="-1"></a></span>
<span id="cb11-73"><a href="#cb11-73" tabindex="-1"></a>        logging.info(<span class="st">'Done.'</span>)</span>
<span id="cb11-74"><a href="#cb11-74" tabindex="-1"></a></span>
<span id="cb11-75"><a href="#cb11-75" tabindex="-1"></a></span>
<span id="cb11-76"><a href="#cb11-76" tabindex="-1"></a>    <span class="kw">def</span> predict(<span class="va">self</span>, data_embeddings: torch.Tensor, batch_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">32</span>) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb11-77"><a href="#cb11-77" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb11-78"><a href="#cb11-78" tabindex="-1"></a><span class="co">        Get the probe's predictions on the embeddings from the model, for unseen data.</span></span>
<span id="cb11-79"><a href="#cb11-79" tabindex="-1"></a><span class="co">        :param data_embeddings: A tensor of shape N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb11-80"><a href="#cb11-80" tabindex="-1"></a><span class="co">        :param batch_size: Used to batch the data for computational efficiency.</span></span>
<span id="cb11-81"><a href="#cb11-81" tabindex="-1"></a><span class="co">        :return: A tensor of shape N, where N is the number of samples. Each element is the predicted class for the corresponding sample.</span></span>
<span id="cb11-82"><a href="#cb11-82" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb11-83"><a href="#cb11-83" tabindex="-1"></a></span>
<span id="cb11-84"><a href="#cb11-84" tabindex="-1"></a>        <span class="co"># Iterate through batches</span></span>
<span id="cb11-85"><a href="#cb11-85" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(data_embeddings), batch_size):</span>
<span id="cb11-86"><a href="#cb11-86" tabindex="-1"></a></span>
<span id="cb11-87"><a href="#cb11-87" tabindex="-1"></a>            <span class="co"># Iterate through one batch of data at a time</span></span>
<span id="cb11-88"><a href="#cb11-88" tabindex="-1"></a>            batch_embeddings <span class="op">=</span> data_embeddings[i:i<span class="op">+</span>batch_size]</span>
<span id="cb11-89"><a href="#cb11-89" tabindex="-1"></a></span>
<span id="cb11-90"><a href="#cb11-90" tabindex="-1"></a>            <span class="co"># Convert to sentence embeddings, since we are performing a sentence classification task</span></span>
<span id="cb11-91"><a href="#cb11-91" tabindex="-1"></a>            batch_embeddings <span class="op">=</span> torch.mean(batch_embeddings, dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># N, D</span></span>
<span id="cb11-92"><a href="#cb11-92" tabindex="-1"></a></span>
<span id="cb11-93"><a href="#cb11-93" tabindex="-1"></a>            <span class="co"># Get the probe's predictions</span></span>
<span id="cb11-94"><a href="#cb11-94" tabindex="-1"></a>            outputs <span class="op">=</span> <span class="va">self</span>.probe(batch_embeddings)</span>
<span id="cb11-95"><a href="#cb11-95" tabindex="-1"></a></span>
<span id="cb11-96"><a href="#cb11-96" tabindex="-1"></a>            <span class="co"># Get the predicted class for each sample</span></span>
<span id="cb11-97"><a href="#cb11-97" tabindex="-1"></a>            _, predicted <span class="op">=</span> torch.<span class="bu">max</span>(outputs, <span class="dv">1</span>)</span>
<span id="cb11-98"><a href="#cb11-98" tabindex="-1"></a></span>
<span id="cb11-99"><a href="#cb11-99" tabindex="-1"></a>            <span class="co"># Concatenate the predictions from each batch</span></span>
<span id="cb11-100"><a href="#cb11-100" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb11-101"><a href="#cb11-101" tabindex="-1"></a>                all_predicted <span class="op">=</span> predicted</span>
<span id="cb11-102"><a href="#cb11-102" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb11-103"><a href="#cb11-103" tabindex="-1"></a>                all_predicted <span class="op">=</span> torch.cat([all_predicted, predicted], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb11-104"><a href="#cb11-104" tabindex="-1"></a></span>
<span id="cb11-105"><a href="#cb11-105" tabindex="-1"></a>        <span class="cf">return</span> all_predicted</span>
<span id="cb11-106"><a href="#cb11-106" tabindex="-1"></a></span>
<span id="cb11-107"><a href="#cb11-107" tabindex="-1"></a></span>
<span id="cb11-108"><a href="#cb11-108" tabindex="-1"></a>    <span class="kw">def</span> evaluate(<span class="va">self</span>, data_embeddings: torch.tensor, labels: torch.tensor, batch_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">32</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb11-109"><a href="#cb11-109" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb11-110"><a href="#cb11-110" tabindex="-1"></a><span class="co">        Evaluate the probe's performance by testing it on unseen data.</span></span>
<span id="cb11-111"><a href="#cb11-111" tabindex="-1"></a><span class="co">        :param data_embeddings: A tensor of shape N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb11-112"><a href="#cb11-112" tabindex="-1"></a><span class="co">        :param labels: A tensor of shape N, where N is the number of samples. Each element is the label for the corresponding sample.</span></span>
<span id="cb11-113"><a href="#cb11-113" tabindex="-1"></a><span class="co">        :return: The accuracy of the probe on the unseen data.</span></span>
<span id="cb11-114"><a href="#cb11-114" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb11-115"><a href="#cb11-115" tabindex="-1"></a></span>
<span id="cb11-116"><a href="#cb11-116" tabindex="-1"></a>        <span class="co"># Iterate through batches</span></span>
<span id="cb11-117"><a href="#cb11-117" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(data_embeddings), batch_size):</span>
<span id="cb11-118"><a href="#cb11-118" tabindex="-1"></a></span>
<span id="cb11-119"><a href="#cb11-119" tabindex="-1"></a>            <span class="co"># Iterate through one batch of data at a time</span></span>
<span id="cb11-120"><a href="#cb11-120" tabindex="-1"></a>            batch_embeddings <span class="op">=</span> data_embeddings[i:i<span class="op">+</span>batch_size]</span>
<span id="cb11-121"><a href="#cb11-121" tabindex="-1"></a>            batch_labels <span class="op">=</span> labels[i:i<span class="op">+</span>batch_size]</span>
<span id="cb11-122"><a href="#cb11-122" tabindex="-1"></a></span>
<span id="cb11-123"><a href="#cb11-123" tabindex="-1"></a>            <span class="co"># Convert to sentence embeddings, since we are performing a sentence classification task</span></span>
<span id="cb11-124"><a href="#cb11-124" tabindex="-1"></a>            batch_embeddings <span class="op">=</span> torch.mean(batch_embeddings, dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># N, D</span></span>
<span id="cb11-125"><a href="#cb11-125" tabindex="-1"></a></span>
<span id="cb11-126"><a href="#cb11-126" tabindex="-1"></a>            <span class="co"># Get the probe's predictions</span></span>
<span id="cb11-127"><a href="#cb11-127" tabindex="-1"></a>            <span class="cf">with</span> torch.no_grad():</span>
<span id="cb11-128"><a href="#cb11-128" tabindex="-1"></a>                outputs <span class="op">=</span> <span class="va">self</span>.probe(batch_embeddings)</span>
<span id="cb11-129"><a href="#cb11-129" tabindex="-1"></a></span>
<span id="cb11-130"><a href="#cb11-130" tabindex="-1"></a>            <span class="co"># Get the predicted class for each sample</span></span>
<span id="cb11-131"><a href="#cb11-131" tabindex="-1"></a>            _, predicted <span class="op">=</span> torch.<span class="bu">max</span>(outputs, dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb11-132"><a href="#cb11-132" tabindex="-1"></a></span>
<span id="cb11-133"><a href="#cb11-133" tabindex="-1"></a>            <span class="co"># Concatenate the predictions from each batch</span></span>
<span id="cb11-134"><a href="#cb11-134" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb11-135"><a href="#cb11-135" tabindex="-1"></a>                all_predicted <span class="op">=</span> predicted</span>
<span id="cb11-136"><a href="#cb11-136" tabindex="-1"></a>                all_labels <span class="op">=</span> batch_labels</span>
<span id="cb11-137"><a href="#cb11-137" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb11-138"><a href="#cb11-138" tabindex="-1"></a>                all_predicted <span class="op">=</span> torch.cat([all_predicted, predicted], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb11-139"><a href="#cb11-139" tabindex="-1"></a>                all_labels <span class="op">=</span> torch.cat([all_labels, batch_labels], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb11-140"><a href="#cb11-140" tabindex="-1"></a></span>
<span id="cb11-141"><a href="#cb11-141" tabindex="-1"></a>        <span class="co"># Calculate the accuracy of the probe</span></span>
<span id="cb11-142"><a href="#cb11-142" tabindex="-1"></a>        correct <span class="op">=</span> (all_predicted <span class="op">==</span> all_labels).<span class="bu">sum</span>().item()</span>
<span id="cb11-143"><a href="#cb11-143" tabindex="-1"></a>        accuracy <span class="op">=</span> correct <span class="op">/</span> all_labels.shape[<span class="dv">0</span>]</span>
<span id="cb11-144"><a href="#cb11-144" tabindex="-1"></a>        logging.info(<span class="ss">f'Probe accuracy: </span><span class="sc">{</span>accuracy<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb11-145"><a href="#cb11-145" tabindex="-1"></a></span>
<span id="cb11-146"><a href="#cb11-146" tabindex="-1"></a>        <span class="cf">return</span> accuracy</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="co"># Initialize the probing classifier (or probe)</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>probe <span class="op">=</span> Probe()</span></code></pre>
</div>
</div>
<div class="section level5">
<h5 id="analysing-the-model-using-probes">Analysing the model using Probes<a class="anchor" aria-label="anchor" href="#analysing-the-model-using-probes"></a>
</h5>
<p>Time to start evaluating the model using our probing tool! Let’s see
which layer has most information about sentiment analysis on IMDB. For
this, we will train the probe on embeddings from each layer of the
model, and see which layer performs the best on the dev set.</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>layer_wise_accuracies <span class="op">=</span> []</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>best_probe, best_layer, best_accuracy <span class="op">=</span> <span class="va">None</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">32</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a><span class="cf">for</span> layer_num <span class="kw">in</span> <span class="bu">range</span>(num_layers):</span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>    logging.info(<span class="ss">f'Evaluating representations of layer </span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss">:</span><span class="ch">\n</span><span class="ss">'</span>)</span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a>    train_embeddings <span class="op">=</span> get_embeddings_from_model(model, tokenizer, layer_num<span class="op">=</span>layer_num, data<span class="op">=</span>train_dataset[<span class="st">'text'</span>], batch_size<span class="op">=</span>batch_size)</span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a>    dev_embeddings <span class="op">=</span> get_embeddings_from_model(model, tokenizer, layer_num<span class="op">=</span>layer_num, data<span class="op">=</span>dev_dataset[<span class="st">'text'</span>], batch_size<span class="op">=</span>batch_size)</span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a>    train_labels, dev_labels <span class="op">=</span> torch.tensor(train_dataset[<span class="st">'label'</span>],  dtype<span class="op">=</span>torch.<span class="bu">long</span>), torch.tensor(dev_dataset[<span class="st">'label'</span>],  dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a>    <span class="co"># Now, let's train the probe on the embeddings from the model.</span></span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a>    <span class="co"># Feel free to play around with the training hyperparameters, and see what works best for your probe.</span></span>
<span id="cb13-14"><a href="#cb13-14" tabindex="-1"></a>    probe <span class="op">=</span> Probe()</span>
<span id="cb13-15"><a href="#cb13-15" tabindex="-1"></a>    probe.train(data_embeddings<span class="op">=</span>train_embeddings, labels<span class="op">=</span>train_labels,</span>
<span id="cb13-16"><a href="#cb13-16" tabindex="-1"></a>                num_epochs<span class="op">=</span><span class="dv">5</span>, learning_rate<span class="op">=</span><span class="fl">0.001</span>, batch_size<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb13-17"><a href="#cb13-17" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" tabindex="-1"></a>    <span class="co"># Let's see how well our probe does on a held out dev set</span></span>
<span id="cb13-19"><a href="#cb13-19" tabindex="-1"></a>    accuracy <span class="op">=</span> probe.evaluate(data_embeddings<span class="op">=</span>dev_embeddings, labels<span class="op">=</span>dev_labels)</span>
<span id="cb13-20"><a href="#cb13-20" tabindex="-1"></a>    layer_wise_accuracies.append(accuracy)</span>
<span id="cb13-21"><a href="#cb13-21" tabindex="-1"></a></span>
<span id="cb13-22"><a href="#cb13-22" tabindex="-1"></a>    <span class="co"># Keep track of the best probe</span></span>
<span id="cb13-23"><a href="#cb13-23" tabindex="-1"></a>    <span class="cf">if</span> accuracy <span class="op">&gt;</span> best_accuracy:</span>
<span id="cb13-24"><a href="#cb13-24" tabindex="-1"></a>        best_probe, best_layer, best_accuracy <span class="op">=</span> probe, layer_num, accuracy</span>
<span id="cb13-25"><a href="#cb13-25" tabindex="-1"></a></span>
<span id="cb13-26"><a href="#cb13-26" tabindex="-1"></a>logging.info(<span class="ss">f'DONE.</span><span class="ch">\n</span><span class="ss"> Best accuracy of </span><span class="sc">{</span>best_accuracy<span class="op">*</span><span class="dv">100</span><span class="sc">}</span><span class="ss">% from layer </span><span class="sc">{</span>best_layer<span class="sc">}</span><span class="ss">.'</span>)</span></code></pre>
</div>
<p>Seeing a list of accuracies can be hard to interpret. Let’s plot the
layer-wise accuracies to see which layer is best.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>plt.plot(layer_wise_accuracies)</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>plt.xlabel(<span class="st">'Layer'</span>)</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>plt.ylabel(<span class="st">'Accuracy'</span>)</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>plt.title(<span class="st">'Probe Accuracy by Layer'</span>)</span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>plt.grid(alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p>Which layer has the best accuracy? What does this tell us about the
model?</p>
<p>Is the last layer of every model the most informative? Not
necessarily! With larger models, many semantic tasks are encoded in the
intermediate layers, while the last layers focus more on next token
prediction.</p>
</div>
<div class="section level5">
<h5 id="visualizing-embeddings">Visualizing Embeddings<a class="anchor" aria-label="anchor" href="#visualizing-embeddings"></a>
</h5>
<p>We’ve seen that the last layer of the model is most informative for
the sentiment analysis task. Can we “see” what embedding structure the
probe saw to say that the last layer’s embeddings were most
separable?</p>
<p>Let’s use the <code>visualize_embeddings</code> method from before.
We’ll also use two different kinds of visualization strategies: - PCA: A
linear method using SVD to highlight the largest variances in the data.
- t-SNE: A non-linear method that emphasizes local patterns and
clusters.</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>layer_num <span class="op">=</span> ...</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>embeddings<span class="op">=</span>get_embeddings_from_model(model, tokenizer, layer_num<span class="op">=</span>layer_num, data<span class="op">=</span>train_dataset[<span class="st">'text'</span>], batch_size<span class="op">=</span>batch_size)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>labels<span class="op">=</span>torch.tensor(train_dataset[<span class="st">'label'</span>],  dtype<span class="op">=</span>torch.<span class="bu">long</span>).numpy().tolist()</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>visualize_embeddings(embeddings<span class="op">=</span>embeddings, labels<span class="op">=</span>labels, layer_num<span class="op">=</span>layer_num, visualization_method<span class="op">=</span><span class="st">'t-SNE'</span>)</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>visualize_embeddings(embeddings<span class="op">=</span>embeddings, labels<span class="op">=</span>labels, layer_num<span class="op">=</span>layer_num, visualization_method<span class="op">=</span><span class="st">'PCA'</span>)</span></code></pre>
</div>
<p>Not very informative, was it? Because these embeddings exist in such
high dimentions, it is not always possible to extract useful structure
in them to simple 2D spaces. For this reason, visualizations are better
treated as additional sources of information, rather than primary
ones.</p>
</div>
<div class="section level4">
<h4 id="testing-the-best-layer-on-ood-data">Testing the best layer on OOD data<a class="anchor" aria-label="anchor" href="#testing-the-best-layer-on-ood-data"></a>
</h4>
<p>Let’s go ahead and stress test our probe’s finding. Is the best layer
able to predict sentiment for sentences outside the IMDB dataset?</p>
<p>For answering this question, you are the test set! Try to think of
challenging sequences for which the model may not be able to predict
sentiment.</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>best_layer <span class="op">=</span> ...</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>test_sequences <span class="op">=</span> [<span class="st">'Your sentence here'</span>, <span class="st">'Here is another sentence'</span>]</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>embeddings <span class="op">=</span> get_embeddings_from_model(model<span class="op">=</span>model, tokenizer<span class="op">=</span>tokenizer, layer_num<span class="op">=</span>best_layer, data<span class="op">=</span>test_sequences, batch_size<span class="op">=</span>batch_size)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>preds <span class="op">=</span> probe.predict(data_embeddings<span class="op">=</span>embeddings)</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>predictions <span class="op">=</span> [<span class="st">'Positive'</span> <span class="cf">if</span> pred <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="st">'Negative'</span> <span class="cf">for</span> pred <span class="kw">in</span> preds]</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Predictions for test sequences: </span><span class="sc">{</span>predictions<span class="sc">}</span><span class="ss">'</span>)</span></code></pre>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-5d-gradcam"><p>Content from <a href="5d-gradcam.html">Explainability methods: GradCAM</a></p>
<hr>
<p>Last updated on 2024-12-17 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/5d-gradcam.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How can we identify which parts of an input contribute most to a
model’s prediction?<br>
</li>
<li>What insights can saliency maps, GradCAM, and similar techniques
provide about model behavior?<br>
</li>
<li>What are the strengths and limitations of gradient-based
explainability methods?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Explain how saliency maps and GradCAM work and their applications in
understanding model predictions.<br>
</li>
<li>Introduce GradCAM as a method to visualize the important features
used by a model.<br>
</li>
<li>Gain familiarity with the PyTorch and GradCam libraries for vision
models.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="what-part-of-my-input-causes-this-prediction">What part of my input causes this prediction?<a class="anchor" aria-label="anchor" href="#what-part-of-my-input-causes-this-prediction"></a>
</h2>
<hr class="half-width">
<p>When a model makes a prediction, we often want to know which parts of
the input were most important in generating that prediction. This helps
confirm if the model is making its predictions for the right reasons.
Sometimes, models use features totally unrelated to the task for their
prediction - these are known as ‘spurious correlations’. For example, a
model might predict that a picture contains a dog because it was taken
in a park, and not because there is actually a dog in the picture.</p>
<p><strong><a href="https://arxiv.org/abs/1312.6034" class="external-link">Saliency
Maps</a></strong> are among the most simple and popular methods used
towards this end. We will be working with a more sophisticated version
of this method, known as <strong><a href="https://arxiv.org/abs/1610.02391" class="external-link">GradCAM</a></strong>.</p>
<div class="section level4">
<h4 id="method-and-examples">Method and Examples<a class="anchor" aria-label="anchor" href="#method-and-examples"></a>
</h4>
<p>A saliency map is a kind of visualization - it is a heatmap across
the input that shows which parts of the input are most important in
generating the model’s prediction. They can be calculated using the
gradients of a neural network, or by perturbing the input to any ML
model and observing how the model reacts to these perturbations. The key
intuition is that if a small change in a part of the input causes a
large change in the model’s prediction, then that part of the input is
important for the prediction. Gradients are useful in this because they
provide a signal towards how much the model’s prediction would change if
the input was changed slightly.</p>
<p>For example, in an image classification task, a saliency map can be
used to highlight the parts of the image that the model is focusing on
to make its prediction. In a text classification task, a saliency map
can be used to highlight the words or phrases that are most important
for the model’s prediction.</p>
<p>GradCAM is an extension of this idea, which uses the gradients of the
final layer of a convolutional neural network to generate a heatmap that
highlights the important regions of an image. This heatmap can be
overlaid on the original image to visualize which parts of the image are
most important for the model’s prediction.</p>
<p>Other variants of this method include <a href="https://arxiv.org/abs/1703.01365" class="external-link">Integrated Gradients</a>, <a href="https://arxiv.org/pdf/1806.03000" class="external-link">SmoothGrad</a>, and others,
which are designed to provide more robust and reliable explanations for
model predictions. However, GradCAM is a good starting point for
understanding how saliency maps work, and is a popularly used
approach.</p>
<p>Alternative approaches, which may not directly generate heatmaps,
include <a href="https://arxiv.org/abs/1602.04938" class="external-link">LIME</a> and <a href="https://arxiv.org/abs/1705.07874" class="external-link">SHAP</a>, which are also popular
and recommended for further reading.</p>
</div>
<div class="section level4">
<h4 id="limitations-and-extensions">Limitations and Extensions<a class="anchor" aria-label="anchor" href="#limitations-and-extensions"></a>
</h4>
<p>Gradient based saliency methods like GradCam are fast to compute,
requiring only a handful of backpropagation steps on the model to
generate the heatmap. The method is also model-agnostic, meaning it can
be applied to any model that can be trained using gradient descent.
Additionally, the results obtained from these methods are intuitive and
easy to understand, making them useful for explaining model predictions
to non-experts.</p>
<p>However, their use is limited to models that can be trained using
gradient descent, and have white-box access. It is also difficult to
apply these methods to tasks beyond classification, making their
application limited with many recent generative models (think LLMs).</p>
<p>Another limitation is that the insights gained from these methods are
not actionable - knowing which part of the input caused the prediction
does not highlight why that part caused it. On finding issues in the
prediction process, it is also hard to pick up on if there is an
underlying issue in the model, or just the specific inputs tested
on.</p>
</div>
</section><section><h2 class="section-heading" id="implementing-gradcam">Implementing GradCAM<a class="anchor" aria-label="anchor" href="#implementing-gradcam"></a>
</h2>
<hr class="half-width">
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>device <span class="op">=</span> <span class="st">'cpu'</span> <span class="co"># we're using the CPU only version of this workshop </span></span></code></pre>
</div>
<div class="section level5">
<h5 id="load-model">Load Model<a class="anchor" aria-label="anchor" href="#load-model"></a>
</h5>
<p>We’ll load the ResNet-50 model from torchvision. This model is
pre-trained on the ImageNet dataset, which contains 1.2 million images
across 1000 classes. ResNet-50 is popular model that is a type of
convolutional neural network. You can learn more about it here: <a href="https://pytorch.org/hub/pytorch_vision_resnet/" class="external-link uri">https://pytorch.org/hub/pytorch_vision_resnet/</a></p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="im">from</span> torchvision.models <span class="im">import</span> resnet50</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>model <span class="op">=</span> resnet50(pretrained<span class="op">=</span><span class="va">True</span>).to(device).<span class="bu">eval</span>() <span class="co"># set to evaluation/inference mode (rather than training)</span></span></code></pre>
</div>
</div>
<div class="section level5">
<h5 id="load-test-image">Load Test Image<a class="anchor" aria-label="anchor" href="#load-test-image"></a>
</h5>
<p>Let’s first take a look at the image, which we source from the
GradCAM package</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># Packages to download images</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="im">import</span> requests</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/jacobgil/pytorch-grad-cam/master/examples/both.png"</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>Image.<span class="bu">open</span>(requests.get(url, stream<span class="op">=</span><span class="va">True</span>).raw)</span></code></pre>
</div>
<p>Cute, isn’t it? Do you prefer dogs or cats?</p>
<p>We will need to convert the image into a tensor to feed it into the
model. Let’s create a function to do this for us.</p>
<p><strong>ML reminder:</strong> A tensor is a mathematical object that
can be thought of as a generalization of scalars, vectors, and matrices.
Tensors have a rank (or order), which determines their
dimensionality:</p>
<ul>
<li>Rank 0: Scalar (a single number, e.g., 5)</li>
<li>Rank 1: Vector (a 1-dimensional array, e.g., [1, 2, 3])</li>
<li>Rank 2: Matrix (a 2-dimensional array, e.g., [[1, 2], [3, 4]])</li>
<li>Rank ≥ 3: Higher-dimensional tensors (e.g., a 3D tensor for images,
a 4D tensor for batch processing, etc.)</li>
</ul>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="im">from</span> pytorch_grad_cam.utils.image <span class="im">import</span> preprocess_image</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="kw">def</span> load_image(url):</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>    rgb_img <span class="op">=</span> np.array(Image.<span class="bu">open</span>(requests.get(url, stream<span class="op">=</span><span class="va">True</span>).raw))</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>    rgb_img <span class="op">=</span> np.float32(rgb_img) <span class="op">/</span> <span class="dv">255</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>    input_tensor <span class="op">=</span> preprocess_image(rgb_img).to(device)</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>    <span class="cf">return</span> input_tensor, rgb_img</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>input_tensor, rgb_image <span class="op">=</span> load_image(url)</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="grad-cam-time">Grad-CAM Time!<a class="anchor" aria-label="anchor" href="#grad-cam-time"></a>
</h3>
<p>Let’s start by selecting which layers of the model we want to use to
generate the CAM. For that, we will need to inspect the model
architecture. We can do that by simply printing the model object.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="bu">print</span>(model)</span></code></pre>
</div>
<p>Here we want to interpret what the model as a whole is doing (not
what a specific layer is doing). That means that we want to use the
embeddings of the last layer before the final classification layer. This
is the layer that contains the information about the image encoded by
the model as a whole.</p>
<p>Looking at the model, we can see that the last layer before the final
classification layer is <code>layer4</code>.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>target_layers <span class="op">=</span> [model.layer4]</span></code></pre>
</div>
<p>We also want to pick a label for the CAM - this is the class we want
to visualize the activation for. Essentially, we want to see what the
model is looking at when it is predicting a certain class.</p>
<p>Since ResNet was trained on the ImageNet dataset with 1000 classes,
let’s get an indexed list of those classes. We can then pick the index
of the class we want to visualize.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>imagenet_categories_url <span class="op">=</span> <span class="op">\</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>     <span class="st">"https://gist.githubusercontent.com/yrevar/942d3a0ac09ec9e5eb3a/raw/238f720ff059c1f82f368259d1ca4ffa5dd8f9f5/imagenet1000_clsidx_to_labels.txt"</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>labels <span class="op">=</span> <span class="bu">eval</span>(requests.get(imagenet_categories_url).text)</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>labels</span></code></pre>
</div>
<p>Well, that’s a lot! To simplify things, we have already picked out
the indices of a few interesting classes.</p>
<ul>
<li>157: Siberian Husky</li>
<li>162: Beagle</li>
<li>245: French Bulldog</li>
<li>281: Tabby Cat</li>
<li>285: Egyptian cat</li>
<li>360: Otter</li>
<li>537: Dog Sleigh</li>
<li>799: Sliding Door</li>
<li>918: Street Sign</li>
</ul>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># Specify the target class for visualization here. If you set this to None, the class with the highest score from the model will automatically be used.</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>visualized_class_id <span class="op">=</span> <span class="dv">245</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="im">import</span> cv2</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="im">from</span> pytorch_grad_cam <span class="im">import</span> GradCAM</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="im">from</span> pytorch_grad_cam.utils.image <span class="im">import</span> show_cam_on_image</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="im">from</span> pytorch_grad_cam.utils.model_targets <span class="im">import</span> ClassifierOutputTarget</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="kw">def</span> viz_gradcam(model, target_layers, class_id, input_tensor, rgb_image):</span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a><span class="co">    Visualize Grad-CAM heatmaps for a given model and target class.</span></span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a><span class="co">    1. model (torch.nn.Module): The neural network model.</span></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a><span class="co">    2. target_layers (list): List of layers to compute Grad-CAM for (usually the last convolutional layer).</span></span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a><span class="co">    3. class_id (int or None): Target class ID for which Grad-CAM is computed. If None, the model's prediction is used.</span></span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a><span class="co">    4. input_tensor (torch.Tensor): The input image tensor expected by the model.</span></span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a><span class="co">    5. rgb_image (numpy.ndarray): The original input image in RGB format, scaled to [0, 1].</span></span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a><span class="co">    None. Displays a Grad-CAM heatmap over the input image.</span></span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a>    <span class="co"># Step 1: Get predicted class if class_id is not specified</span></span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a>    <span class="cf">if</span> class_id <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a>        <span class="cf">with</span> torch.no_grad():  <span class="co"># Disable gradient computation for efficiency (not needed for inference)</span></span>
<span id="cb10-26"><a href="#cb10-26" tabindex="-1"></a>            outputs <span class="op">=</span> model(input_tensor)  <span class="co"># Run the input image through the model to get output scores</span></span>
<span id="cb10-27"><a href="#cb10-27" tabindex="-1"></a>            </span>
<span id="cb10-28"><a href="#cb10-28" tabindex="-1"></a>            <span class="co"># torch.argmax finds the index of the maximum value in the output tensor.</span></span>
<span id="cb10-29"><a href="#cb10-29" tabindex="-1"></a>            <span class="co"># dim=1 indicates we are finding the maximum value **along the class dimension** </span></span>
<span id="cb10-30"><a href="#cb10-30" tabindex="-1"></a>            <span class="co"># (assuming the shape of outputs is [batch_size, num_classes]).</span></span>
<span id="cb10-31"><a href="#cb10-31" tabindex="-1"></a>            predicted_class <span class="op">=</span> torch.argmax(outputs, dim<span class="op">=</span><span class="dv">1</span>).item()  <span class="co"># Extract the top class index.</span></span>
<span id="cb10-32"><a href="#cb10-32" tabindex="-1"></a>            </span>
<span id="cb10-33"><a href="#cb10-33" tabindex="-1"></a>            <span class="co"># .item() converts the PyTorch scalar tensor to a Python integer (e.g., tensor(245) -&gt; 245).</span></span>
<span id="cb10-34"><a href="#cb10-34" tabindex="-1"></a>            <span class="co"># This is necessary for further operations like accessing the class label from a list.</span></span>
<span id="cb10-35"><a href="#cb10-35" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Predicted Class: </span><span class="sc">{</span>labels[predicted_class]<span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span>predicted_class<span class="sc">}</span><span class="ss">)"</span>)  <span class="co"># Print the predicted label</span></span>
<span id="cb10-36"><a href="#cb10-36" tabindex="-1"></a>            </span>
<span id="cb10-37"><a href="#cb10-37" tabindex="-1"></a>            <span class="co"># Define the target for Grad-CAM visualization.</span></span>
<span id="cb10-38"><a href="#cb10-38" tabindex="-1"></a>            <span class="co"># ClassifierOutputTarget wraps the target class for Grad-CAM to calculate activations.</span></span>
<span id="cb10-39"><a href="#cb10-39" tabindex="-1"></a>            targets <span class="op">=</span> [ClassifierOutputTarget(predicted_class)]</span>
<span id="cb10-40"><a href="#cb10-40" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb10-41"><a href="#cb10-41" tabindex="-1"></a>        <span class="co"># If a specific class_id is provided, use it directly.</span></span>
<span id="cb10-42"><a href="#cb10-42" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Target Class: </span><span class="sc">{</span>labels[class_id]<span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span>class_id<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb10-43"><a href="#cb10-43" tabindex="-1"></a>        targets <span class="op">=</span> [ClassifierOutputTarget(class_id)]</span>
<span id="cb10-44"><a href="#cb10-44" tabindex="-1"></a>    </span>
<span id="cb10-45"><a href="#cb10-45" tabindex="-1"></a>    <span class="co"># Step 2: Select the Grad-CAM algorithm.</span></span>
<span id="cb10-46"><a href="#cb10-46" tabindex="-1"></a>    <span class="co"># Here, we use GradCAM, but this can be swapped for other algorithms like GradCAM++.</span></span>
<span id="cb10-47"><a href="#cb10-47" tabindex="-1"></a>    cam_algorithm <span class="op">=</span> GradCAM</span>
<span id="cb10-48"><a href="#cb10-48" tabindex="-1"></a></span>
<span id="cb10-49"><a href="#cb10-49" tabindex="-1"></a>    <span class="co"># Step 3: Initialize the Grad-CAM object.</span></span>
<span id="cb10-50"><a href="#cb10-50" tabindex="-1"></a>    <span class="co"># This links the model and the target layers where Grad-CAM will compute the gradients.</span></span>
<span id="cb10-51"><a href="#cb10-51" tabindex="-1"></a>    cam <span class="op">=</span> cam_algorithm(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers)</span>
<span id="cb10-52"><a href="#cb10-52" tabindex="-1"></a></span>
<span id="cb10-53"><a href="#cb10-53" tabindex="-1"></a>    <span class="co"># Step 4: Generate the Grad-CAM heatmap.</span></span>
<span id="cb10-54"><a href="#cb10-54" tabindex="-1"></a>    <span class="co"># - input_tensor: The input image tensor (preprocessed as required by the model).</span></span>
<span id="cb10-55"><a href="#cb10-55" tabindex="-1"></a>    <span class="co"># - targets: The target class for which we compute Grad-CAM (if None, model's prediction is used).</span></span>
<span id="cb10-56"><a href="#cb10-56" tabindex="-1"></a>    grayscale_cam <span class="op">=</span> cam(input_tensor<span class="op">=</span>input_tensor, targets<span class="op">=</span>targets)</span>
<span id="cb10-57"><a href="#cb10-57" tabindex="-1"></a></span>
<span id="cb10-58"><a href="#cb10-58" tabindex="-1"></a>    <span class="co"># Step 5: Extract the heatmap corresponding to the first input image.</span></span>
<span id="cb10-59"><a href="#cb10-59" tabindex="-1"></a>    <span class="co"># The result is [batch_size, height, width], so we select the first image: grayscale_cam[0, :].</span></span>
<span id="cb10-60"><a href="#cb10-60" tabindex="-1"></a>    grayscale_cam <span class="op">=</span> grayscale_cam[<span class="dv">0</span>, :]</span>
<span id="cb10-61"><a href="#cb10-61" tabindex="-1"></a></span>
<span id="cb10-62"><a href="#cb10-62" tabindex="-1"></a>    <span class="co"># Step 6: Overlay the Grad-CAM heatmap on the original input image.</span></span>
<span id="cb10-63"><a href="#cb10-63" tabindex="-1"></a>    <span class="co"># - show_cam_on_image: Combines the heatmap with the RGB image (values must be in [0, 1]).</span></span>
<span id="cb10-64"><a href="#cb10-64" tabindex="-1"></a>    cam_image <span class="op">=</span> show_cam_on_image(rgb_image, grayscale_cam, use_rgb<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-65"><a href="#cb10-65" tabindex="-1"></a></span>
<span id="cb10-66"><a href="#cb10-66" tabindex="-1"></a>    <span class="co"># Step 7: Convert the image from RGB to BGR (OpenCV's default format).</span></span>
<span id="cb10-67"><a href="#cb10-67" tabindex="-1"></a>    cam_image <span class="op">=</span> cv2.cvtColor(cam_image, cv2.COLOR_RGB2BGR)</span>
<span id="cb10-68"><a href="#cb10-68" tabindex="-1"></a></span>
<span id="cb10-69"><a href="#cb10-69" tabindex="-1"></a>    <span class="co"># Step 8: Display the Grad-CAM heatmap overlaid on the input image.</span></span>
<span id="cb10-70"><a href="#cb10-70" tabindex="-1"></a>    plt.imshow(cam_image)  <span class="co"># Show the image with the heatmap.</span></span>
<span id="cb10-71"><a href="#cb10-71" tabindex="-1"></a>    plt.axis(<span class="st">"off"</span>)       <span class="co"># Remove axes for cleaner visualization.</span></span>
<span id="cb10-72"><a href="#cb10-72" tabindex="-1"></a>    plt.show()             <span class="co"># Display the plot.</span></span></code></pre>
</div>
<p>Finally, we can start visualizing! Let’s begin by seeing what parts
of the image the model looks at to make its most confident
prediction.</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="va">None</span>, input_tensor<span class="op">=</span>input_tensor, rgb_image<span class="op">=</span>rgb_image)</span></code></pre>
</div>
<p>Interesting, it looks like the model totally ignores the cat and
makes a prediction based on the dog. If we set the output class to
“French Bulldog” (<code>class_id=245</code>), we see the same
visualization - meaning that the model is indeed looking at the correct
part of the image to make the correct prediction.</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">245</span>, input_tensor<span class="op">=</span>input_tensor, rgb_image<span class="op">=</span>rgb_image)</span></code></pre>
</div>
<p>Let’s see what the heatmap looks like when we force the model to look
at the cat.</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">281</span>, input_tensor<span class="op">=</span>input_tensor, rgb_image<span class="op">=</span>rgb_image)</span></code></pre>
</div>
<p>The model is indeed looking at the cat when asked to predict the
class “Tabby Cat” (class_id=281), as Grad-CAM highlights regions
relevant to that class. However, the model may still predict the “dog”
class overall because the dog’s features dominate the output logits when
no specific target class is specified.</p>
<p>Let’s see another example of this. The image has not only a dog and a
cat, but also a items in the background. Can the model correctly
identify the door?</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">799</span>, input_tensor<span class="op">=</span>input_tensor, rgb_image<span class="op">=</span>rgb_image)</span></code></pre>
</div>
<p>It can! However, it seems to also think of the shelf behind the dog
as a door.</p>
<p>Let’s try an unrelated object now. Where in the image does the model
see a crossword puzzle?</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">918</span>, input_tensor<span class="op">=</span>input_tensor, rgb_image<span class="op">=</span>rgb_image)</span></code></pre>
</div>
<p>Looks like our analysis has revealed a shortcoming of the model! It
seems to percieve cats and street signs similarly.</p>
<p>Ideally, when the target class is some unrelated object, a good model
will look at no significant part of the image. For example, the model
does a good job with the class for Dog Sleigh.</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">537</span>, input_tensor<span class="op">=</span>input_tensor, rgb_image<span class="op">=</span>rgb_image)</span></code></pre>
</div>
<p>Explaining model predictions though visualization techniques like
this can be very subjective and prone to error. However, this still
provides some degree of insight a completely black box model would not
provide.</p>
<p>Spend some time playing around with different classes and seeing
which part of the image the model looks at. Feel free to play around
with other base images as well. Have fun!</p>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-6-uncertainty-overview"><p>Content from <a href="6-uncertainty-overview.html">Estimating model uncertainty</a></p>
<hr>
<p>Last updated on 2024-12-19 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/6-uncertainty-overview.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 40 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What is model uncertainty, and how can it be categorized?<br>
</li>
<li>How do uncertainty estimation methods intersect with OOD detection
methods?<br>
</li>
<li>What are the computational challenges of estimating model
uncertainty?<br>
</li>
<li>When is uncertainty estimation useful, and what are its
limitations?<br>
</li>
<li>Why is OOD detection often preferred over traditional uncertainty
estimation techniques in modern applications?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Define and distinguish between aleatoric and epistemic uncertainty
in machine learning models.<br>
</li>
<li>Explore common techniques for estimating aleatoric and epistemic
uncertainty.<br>
</li>
<li>Understand why OOD detection has become a widely adopted approach in
many real-world applications.<br>
</li>
<li>Compare and contrast the goals and computational costs of
uncertainty estimation and OOD detection.<br>
</li>
<li>Summarize when and where different uncertainty estimation methods
are most useful.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="how-confident-is-my-model-will-it-generalize-to-new-data-or-subpopulations">How confident is my model? Will it generalize to new data or
subpopulations?<a class="anchor" aria-label="anchor" href="#how-confident-is-my-model-will-it-generalize-to-new-data-or-subpopulations"></a>
</h2>
<hr class="half-width">
<p>Understanding how confident a model is in its predictions is a
valuable tool for building trustworthy AI systems, especially in
high-stakes settings like healthcare or autonomous vehicles. Model
uncertainty estimation focuses on quantifying the model’s confidence and
is often used to identify predictions that require further review or
caution.</p>
<div class="section level3">
<h3 id="sources-of-uncertainty">Sources of uncertainty<a class="anchor" aria-label="anchor" href="#sources-of-uncertainty"></a>
</h3>
<p>At its core, model uncertainty starts with the <strong>data</strong>
itself, as all models learn to form embeddings (feature representations)
of the data. Uncertainty in the data—whether from inherent randomness or
insufficient coverage—propagates through the model’s embeddings, leading
to uncertainty in the outputs.</p>
<div class="section level4">
<h4 id="aleatoric-random-uncertainty">1) Aleatoric (Random) uncertainty<a class="anchor" aria-label="anchor" href="#aleatoric-random-uncertainty"></a>
</h4>
<p>Aleotoric or random uncertainty is the inherent noise in the data
that cannot be reduced, even with more data (observations OR missing
features).</p>
<ul>
<li>Inconsistent readings from faulty sensors (e.g., modern image
sensors exhibit “thermal noise” or “shot noise”, where pixel values
randomly fluctuate even under constant lighting)</li>
<li>Random crackling/static in recordings</li>
<li>Human errors in data entry</li>
<li>Any aspect of the data that is unpredictable</li>
</ul>
</div>
<div class="section level4">
<h4 id="methods-for-addressing-aleatoric-uncertainty">Methods for addressing aleatoric uncertainty<a class="anchor" aria-label="anchor" href="#methods-for-addressing-aleatoric-uncertainty"></a>
</h4>
<p>Since aleatoric/random uncertainty is generally considered inherent
(unless you upgrade sensors or remove whatever is causing the random
generating process), methods to address it focus on measuring the degree
of noise or uncertainty.</p>
<ul>
<li>
<strong>Predictive variance in linear regression</strong>: The
ability to derive error bars or prediction intervals in traditional
regression comes from the assumption that the errors (residuals) follow
a normal distribution and are homoskedastic (errors stay relatively
constant across different values of predictors).
<ul>
<li>In contrast, deep learning models are highly non-linear and have
millions (or billions) of parameters. The mapping between inputs and
outputs is not a simple linear equation but rather a complex,
multi-layer function. In addition, deep learning can overfit common
classes and underfit rarer clases. Because of these factors, errors are
rarely normally distributed and homoskedastic in deep learning
applications.</li>
</ul>
</li>
<li>
<strong>Heteroskedastic models</strong>: Use specialized loss
functions that allow the model to predict the noise level in the data
directly. These models are particularly critical in fields like
<em>robotics</em>, where sensor noise varies significantly depending on
environmental conditions. It is possible to build this functionality
into both linear models and modern deep learning models. However, these
methods may require some calibration, as ground truth measurements of
noise usually aren’t available.
<ul>
<li>Example application: Managing hospital reporting
inconsistencies.<br>
</li>
<li>Reference: Kendall, A., &amp; Gal, Y. (2017). “<a href="https://arxiv.org/abs/1703.04977" class="external-link">What uncertainties do we need in
Bayesian deep learning for computer vision?</a>”.</li>
</ul>
</li>
<li>
<strong>Data augmentation and perturbation analysis</strong>: Assess
variability in predictions by adding noise to the input data and
observing how much the model’s outputs change. A highly sensitive change
in predictions may indicate underlying noise or instability in the data.
For instance, in image classification, augmenting training data with
synthetic noise can help the model better handle real-world
imperfections stemming from sensor artifacts.
<ul>
<li>Example application: Handling motion blur in tumor detection.<br>
</li>
<li>Reference: Shorten, C., &amp; Khoshgoftaar, T. M. (2019). “<a href="https://journalofbigdata.springeropen.com/articles/10.1186/s40537-019-0197-0" class="external-link">A
survey on image data augmentation for deep learning.</a>”</li>
</ul>
</li>
</ul>
</div>
<div class="section level4">
<h4 id="subjectivity-and-ill-defined-problems">2) Subjectivity and ill-defined problems<a class="anchor" aria-label="anchor" href="#subjectivity-and-ill-defined-problems"></a>
</h4>
<ul>
<li>Overlapping classes, ambiguous labels due to subjective
interpretations</li>
<li>Ambiguous or conflicting text inputs.</li>
</ul>
</div>
<div class="section level4">
<h4 id="methods-for-addressing-subjectivity-and-ill-defined-problems">Methods for addressing subjectivity and ill-defined problems<a class="anchor" aria-label="anchor" href="#methods-for-addressing-subjectivity-and-ill-defined-problems"></a>
</h4>
<ul>
<li>
<strong>Reframe problme</strong>: If the overlap or subjectivity
stems from an ill-posed problem, reframing the task can help. Example:
Instead of classifying “happy” vs. “neutral” expressions (which
overlap), predict the intensity of happiness on a scale of 0–1. For
medical images, shift from hard “benign vs. malignant” classifications
to predicting risk scores.</li>
<li>
<strong>Consensus-based labeling (inter-annotator
agreement)</strong>: Aggregate labels from multiple annotators to reduce
subjectivity and quantify ambiguity. Use metrics like Cohen’s kappa or
Fleiss’ kappa to measure agreement between annotators. Example: In
medical imaging (e.g., tumor detection), combining expert radiologists’
opinions can reduce subjective bias in labeling.</li>
<li>
<strong>Probabilistic labeling or soft targets</strong>: Instead of
using hard labels (e.g., 0 or 1), assign probabilistic labels to account
for ambiguity in the data. Example: If 70% of annotators labeled an
image as “happy” and 30% as “neutral,” you can label it as [0.7, 0.3]
instead of forcing a binary decision.</li>
</ul>
</div>
<div class="section level4">
<h4 id="epistemic-uncertainty">3. Epistemic uncertainty<a class="anchor" aria-label="anchor" href="#epistemic-uncertainty"></a>
</h4>
<p><strong>Epistemic</strong> (ep·i·ste·mic) is an adjective that means,
“<em>relating to knowledge or to the degree of its validation.</em>”</p>
<p>Epistemic uncertainty refers to gaps in the model’s knowledge about
the data distribution, which can be reduced by using more data or
improved models. Aleatoric uncertainy can arise due to:</p>
<ul>
<li>
<strong>Out-of-distribution (OOD) data</strong>:
<ul>
<li>Tabular: Classifying user behavior from a new region not included in
training data. Predicting hospital demand during a rare pandemic with
limited historical data. Applying model trained on one location to
another.</li>
<li>Image: Recognizing a new species in wildlife monitoring. Detecting a
rare/unseen obstacle to automate driving. A model trained on
high-resolution images but tested on low-resolution inputs.</li>
<li>Text: Queries about topics completely outside the model’s domain
(e.g., financial queries in a healthcare chatbot). Interpreting slang or
idiomatic expressions unseen during training.</li>
</ul>
</li>
<li>
<strong>Sparse or insufficient data in feature space</strong>:
<ul>
<li>Tabular: High-dimensional data with many missing or sparsely sampled
features (e.g., genomic datasets).</li>
<li>Image: Limited labeled examples for rare diseases in medical imaging
datasets.</li>
<li>Text: Rare domain-specific terminology.</li>
</ul>
</li>
</ul>
</div>
<div class="section level4">
<h4 id="methods-for-addressing-epistemic-uncertainty">Methods for addressing epistemic uncertainty<a class="anchor" aria-label="anchor" href="#methods-for-addressing-epistemic-uncertainty"></a>
</h4>
<p>Epistemic uncertainty arises from the model’s lack of knowledge about
certain regions of the data space. Techniques to address this
uncertainty include:</p>
<ul>
<li>
<strong>Collect more data</strong>: Easier said than done! Focus on
gathering data from underrepresented scenarios or regions of the feature
space, particularly areas where the model exhibits high uncertainty
(e.g., rare medical conditions, edge cases in autonomous driving). This
directly reduces epistemic uncertainty by expanding the model’s
knowledge base.
<ul>
<li>
<strong>Active learning</strong>: Use model uncertainty estimates to
prioritize uncertain or ambiguous samples for annotation, enabling more
targeted data collection.</li>
</ul>
</li>
<li>
<strong>Ensemble models</strong>: These involve training multiple
models on the same data, each starting with different initializations or
random seeds. The ensemble’s predictions are aggregated, and the
variance in their outputs reflects uncertainty. This approach works well
because different models often capture different aspects of the data.
For example, if all models agree, the prediction is confident; if they
disagree, there is uncertainty. Ensembles are effective but
computationally expensive, as they require training and evaluating
multiple models.</li>
<li>
<strong>Bayesian neural networks</strong>: These networks
incorporate probabilistic layers to model uncertainty directly in the
weights of the network. Instead of assigning a single deterministic
weight to each connection, Bayesian neural networks assign distributions
to these weights, reflecting the uncertainty about their true values.
During inference, these distributions are sampled multiple times to
generate predictions, which naturally include uncertainty estimates.
While Bayesian neural networks are theoretically rigorous and align well
with the goal of epistemic uncertainty estimation, they are
computationally expensive and challenging to scale for large datasets or
deep architectures. This is because calculating or approximating
posterior distributions over all parameters becomes intractable as model
size grows. To address this, methods like variational inference or Monte
Carlo sampling are often used, but these approximations can introduce
inaccuracies, making Bayesian approaches less practical for many modern
applications. Despite these challenges, Bayesian neural networks remain
valuable for research contexts where precise uncertainty quantification
is needed or in domains where computational resources are less of a
concern.
<ul>
<li>Example application: Detecting rare tumor types in radiology.<br>
</li>
<li>Reference: Blundell, C., et al. (2015). “<a href="https://arxiv.org/abs/1505.05424" class="external-link">Weight uncertainty in neural
networks.</a>”</li>
</ul>
</li>
<li>
<strong>Out-of-distribution detection</strong>: Identifies inputs
that fall significantly outside the training distribution, flagging
areas where the model’s predictions are unreliable. Many OOD methods
produce continuous scores, such as Mahalanobis distance or energy-based
scores, which measure how novel or dissimilar an input is from the
training data. These scores can be interpreted as a form of epistemic
uncertainty, providing insight into how unfamiliar an input is. However,
OOD detection focuses on distinguishing ID from OOD inputs rather than
offering confidence estimates for predictions on ID inputs.
<ul>
<li>Example application: Flagging out-of-scope queries in chatbot
systems.<br>
</li>
<li>Reference: Hendrycks, D., &amp; Gimpel, K. (2017). “<a href="https://arxiv.org/abs/1610.02136" class="external-link">A baseline for detecting
misclassified and out-of-distribution examples in neural
networks.</a>”</li>
</ul>
</li>
</ul>
</div>
<div class="section level4">
<h4 id="why-is-ood-detection-widely-adopted">Why is OOD detection widely adopted?<a class="anchor" aria-label="anchor" href="#why-is-ood-detection-widely-adopted"></a>
</h4>
<p>Among epistemic uncertainty methods, OOD detection has become a
widely adopted approach in real-world applications due to its ability to
efficiently identify inputs that fall outside the training data
distribution, where predictions are inherently unreliable. Many OOD
detection techniques produce continuous scores that quantify the novelty
or dissimilarity of inputs, which can be interpreted as a form of
uncertainty. This makes OOD detection not only effective at rejecting
anomalous inputs but also useful for prioritizing inputs based on their
predicted risk.</p>
<p>For example, in autonomous vehicles, OOD detection can help flag
unexpected scenarios (e.g., unusual objects on the road) in near
real-time, enabling safer decision-making. Similarly, in NLP, OOD
methods are used to identify queries or statements that deviate from a
model’s training corpus, such as out-of-context questions in a chatbot
system. In the next couple of episodes, we’ll see how to implement
various OOD strategies.</p>
<div id="identify-aleatoric-and-epistemic-uncertainty" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="identify-aleatoric-and-epistemic-uncertainty" class="callout-inner">
<h3 class="callout-title">Identify aleatoric and epistemic
uncertainty</h3>
<div class="callout-content">
<p>For each scenario below, identify the sources of
<strong>aleatoric</strong> and <strong>epistemic</strong> uncertainty.
Provide specific examples based on the context of the application.</p>
<ol style="list-style-type: decimal">
<li>
<strong>Tabular data example:</strong> Hospital resource allocation
during seasonal flu outbreaks and pandemics.<br>
</li>
<li>
<strong>Image data example:</strong> Tumor detection in radiology
images.<br>
</li>
<li>
<strong>Text data example:</strong> Chatbot intent recognition.</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li><strong>Hospital resource allocation</strong></li>
</ol>
<ul>
<li>
<strong>Aleatoric uncertainty</strong>: Variability in seasonal flu
demand; inconsistent local reporting.<br>
</li>
<li>
<strong>Epistemic uncertainty</strong>: Limited data for rare
pandemics; incomplete understanding of emerging health crises.</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li><strong>Tumor detection in radiology images</strong></li>
</ol>
<ul>
<li>
<strong>Aleatoric uncertainty</strong>: Imaging artifacts such as
noise or motion blur.<br>
</li>
<li>
<strong>Epistemic uncertainty</strong>: Limited labeled data for
rare tumor types; novel imaging modalities.</li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li><strong>Chatbot intent recognition</strong></li>
</ol>
<ul>
<li>
<strong>Aleatoric uncertainty</strong>: Noise in user queries such
as typos or speech-to-text errors.<br>
</li>
<li>
<strong>Epistemic uncertainty</strong>: Lack of training data for
queries from out-of-scope domains; ambiguity due to unclear or
multi-intent queries.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level4">
<h4 id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h4>
<p>Uncertainty estimation is a critical component of building reliable
and trustworthy machine learning models, especially in high-stakes
applications. By understanding the distinction between aleatoric
uncertainty (inherent data noise) and epistemic uncertainty (gaps in the
model’s knowledge), practitioners can adopt tailored strategies to
improve model robustness and interpretability.</p>
<ul>
<li>Aleatoric uncertainty is irreducible noise in the data itself.
Addressing this requires models that can predict variability, such as
heteroscedastic loss functions, or strategies like data augmentation to
make models more resilient to imperfections.</li>
<li>Epistemic uncertainty arises from the model’s incomplete
understanding of the data distribution. It can be mitigated through
methods like Monte Carlo dropout, Bayesian neural networks, ensemble
models, and Out-of-Distribution (OOD) detection. Among these methods,
OOD detection has become a cornerstone for handling epistemic
uncertainty in practical applications. Its ability to flag anomalous or
out-of-distribution inputs makes it an essential tool for ensuring model
predictions are reliable in real-world scenarios.
<ul>
<li>In many cases, collecting more data and employing active learning
can directly address the root causes of epistemic uncertainty.</li>
</ul>
</li>
</ul>
<p>When choosing a method, it’s important to consider the trade-offs in
computational cost, model complexity, and the type of uncertainty being
addressed. Together, these techniques form a powerful toolbox, enabling
models to better navigate uncertainty and maintain trustworthiness in
dynamic environments. By combining these approaches strategically,
practitioners can ensure that their systems are not only accurate but
also robust, interpretable, and adaptable to the challenges of
real-world data.</p>
</div>
<div class="section level4">
<h4 id="references-and-methods">References and methods<a class="anchor" aria-label="anchor" href="#references-and-methods"></a>
</h4>
</div>
<div class="section level4">
<h4 id="methods-for-addressing-aleatoric-uncertainty-1">Methods for addressing aleatoric uncertainty<a class="anchor" aria-label="anchor" href="#methods-for-addressing-aleatoric-uncertainty-1"></a>
</h4>
<ol style="list-style-type: decimal">
<li><p><strong>Heteroscedastic models</strong>: Predict noise levels
directly using specialized loss functions.</p></li>
<li><p><strong>Data augmentation</strong>: Add noise to inputs to
improve robustness to imaging artifacts.</p></li>
</ol>
</div>
<div class="section level4">
<h4 id="methods-for-addressing-epistemic-uncertainty-1">Methods for addressing epistemic uncertainty<a class="anchor" aria-label="anchor" href="#methods-for-addressing-epistemic-uncertainty-1"></a>
</h4>
<ol style="list-style-type: decimal">
<li>
<strong>Ensemble models</strong>: Aggregate predictions to capture
model disagreement.
<ul>
<li>Example application: Predicting rare pandemic impacts on hospital
demand.<br>
</li>
<li>Reference: Leibig, C., et al. (2017). “Leveraging uncertainty
information from deep neural networks for disease detection.”<br><a href="https://www.nature.com/articles/s41598-017-17876-z" class="external-link">Scientific
Reports</a>.</li>
</ul>
</li>
<li>
<strong>Bayesian neural networks</strong>: Model uncertainty in
parameters for underrepresented scenarios.
<ul>
<li>Example application: Detecting rare tumor types in radiology.<br>
</li>
<li>Reference: Blundell, C., et al. (2015). “Weight uncertainty in
neural networks.”<br><a href="https://arxiv.org/abs/1505.05424" class="external-link">ArXiv</a>.</li>
</ul>
</li>
<li>
<strong>Out-of-distribution detection</strong>: Identify inputs
outside the training distribution.
<ul>
<li>Example application: Flagging out-of-scope queries in chatbot
systems.<br>
</li>
<li>Reference: Hendrycks, D., &amp; Gimpel, K. (2017). “A baseline for
detecting misclassified and out-of-distribution examples in neural
networks.”<br><a href="https://arxiv.org/abs/1610.02136" class="external-link">ArXiv</a>. <!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</li>
</ul>
</li>
</ol>
</div>
</div>
</section></section><section id="aio-7a-OOD-detection-overview"><p>Content from <a href="7a-OOD-detection-overview.html">OOD detection: overview</a></p>
<hr>
<p>Last updated on 2024-12-19 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/7a-OOD-detection-overview.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are out-of-distribution (OOD) data, and why is detecting them
important in machine learning models?</li>
<li>What are threshold-based methods, and how do they help detect OOD
data?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand the concept of out-of-distribution data and its
implications for machine learning models.</li>
<li>Learn the principles behind threshold-based OOD detection
methods.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="what-is-out-of-distribution-ood-data">What is out-of-distribution (OOD) data<a class="anchor" aria-label="anchor" href="#what-is-out-of-distribution-ood-data"></a>
</h2>
<hr class="half-width">
<p>Out-of-distribution (OOD) data refers to data that significantly
differs from the training data on which a machine learning model was
built, i.e., the in-distribution (ID). For example, the image below
compares the training data distribution of CIFAR-10, a popular dataset
used for image classification, with the vastly broader and more diverse
distribution of images found on the internet:</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-internet-vs-CIFAR10.jpg" alt="OpenAI: CIFAR-10 training distribution vs. internet" class="figure mx-auto d-block"><div class="figcaption">OpenAI: CIFAR-10 training distribution
vs. internet</div>
</figure><p>CIFAR-10 contains 60,000 images across 10 distinct classes (e.g.,
airplanes, dogs, trucks), with carefully curated examples for each
class. However, the internet features an essentially infinite variety of
images, many of which fall outside these predefined classes or include
unseen variations (e.g., new breeds of dogs or novel vehicle designs).
This contrast highlights the challenges models face when they encounter
data that significantly differs from their training distribution.</p>
</section><section><h2 class="section-heading" id="how-ood-data-manifests-in-ml-pipelines">How OOD data manifests in ML pipelines<a class="anchor" aria-label="anchor" href="#how-ood-data-manifests-in-ml-pipelines"></a>
</h2>
<hr class="half-width">
<p>The difference between in-distribution (ID) and OOD data can arise
from:</p>
<ul>
<li>
<strong>Semantic shift</strong>: The OOD sample belongs to a class
that was not present during training (classification). With continuous
prediction/regression, semantic shift occurs when the underlying
relationship between X and Y changes.</li>
<li>
<strong>Covariate shift</strong>: The OOD sample comes from a domain
where the input feature distribution is drastically different from the
training data. The input feature distribution changes, but the
underlying relationship between X and Y stays the same.</li>
</ul>
<p>Semantic shift often co-occurs with covariate shift.</p>
<div id="distinguishing-semantic-shift-vs.-covariate-shift" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="distinguishing-semantic-shift-vs.-covariate-shift" class="callout-inner">
<h3 class="callout-title">Distinguishing semantic shift vs. covariate shift</h3>
<div class="callout-content">
<p>You trained a model using the CIFAR-10 dataset to classify images
into 10 classes (e.g., airplanes, dogs, trucks). Now, you deploy the
model to classify images found on the internet. Consider the following
scenarios and classify each as <strong>Semantic Shift</strong>,
<strong>Covariate Shift</strong>, or <strong>Both</strong>. Provide
reasoning for your choice.</p>
<ol style="list-style-type: decimal">
<li><p><strong>Scenario A</strong>: The internet dataset contains images
of drones, which were not present in the CIFAR-10 dataset. The model
struggles to classify them.</p></li>
<li><p><strong>Scenario B</strong>: The internet dataset has dog images,
but these dogs are primarily captured in outdoor settings with
unfamiliar backgrounds and lighting conditions compared to the training
data.</p></li>
<li><p><strong>Scenario C</strong>: The internet dataset contains images
of hybrid animals (e.g., “wolf-dogs”) that do not belong to any CIFAR-10
class. The model predicts incorrectly.</p></li>
<li><p><strong>Scenario D</strong>: The internet dataset includes
high-resolution images of airplanes, while the CIFAR-10 dataset contains
only low-resolution airplane images. The model performs poorly on these
new airplane images.</p></li>
<li><p><strong>Scenario E</strong>: A researcher retrains the CIFAR-10
model using an updated dataset where labels for “trucks” are now
redefined to include pickup trucks, which were previously excluded. The
new labels confuse the original model.</p></li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>
<strong>Scenario A</strong>: <strong>Semantic Shift</strong>
<ul>
<li>Drones represent a new class not seen during training, so the model
encounters a semantic shift.</li>
</ul>
</li>
<li>
<strong>Scenario B</strong>: <strong>Covariate Shift</strong>
<ul>
<li>The distribution of input features (e.g., lighting, background)
changes, but the semantic relationship (e.g., dogs are still dogs)
remains intact.</li>
</ul>
</li>
<li>
<strong>Scenario C</strong>: <strong>Both</strong>
<ul>
<li>Hybrid animals represent a semantic shift (new class), and
unfamiliar feature distributions (e.g., traits of wolves and dogs
combined) also introduce covariate shift.</li>
</ul>
</li>
<li>
<strong>Scenario D</strong>: <strong>Covariate Shift</strong>
<ul>
<li>The resolution of the images (input features) changes, but the
semantic class of airplanes remains consistent.</li>
</ul>
</li>
<li>
<strong>Scenario E</strong>: <strong>Semantic Shift</strong>
<ul>
<li>The relationship between input features and class labels has
changed, as the definition of the “truck” class has been altered.</li>
</ul>
</li>
</ol>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="why-does-ood-data-matter">Why does OOD data matter?<a class="anchor" aria-label="anchor" href="#why-does-ood-data-matter"></a>
</h2>
<hr class="half-width">
<p>Models trained on a specific distribution might make incorrect
predictions on OOD data, leading to unreliable outputs. In critical
applications (e.g., healthcare, autonomous driving), encountering OOD
data without proper handling can have severe consequences.</p>
<div class="section level3">
<h3 id="ex1-tesla-crashes-into-jet">Ex1: Tesla crashes into jet<a class="anchor" aria-label="anchor" href="#ex1-tesla-crashes-into-jet"></a>
</h3>
<p>In April 2022, a <a href="https://www.newsweek.com/video-tesla-smart-summon-mode-ramming-3m-jet-viewed-34m-times-1700310" class="external-link">Tesla
Model Y crashed into a $3.5 million private jet</a> at an aviation trade
show in Spokane, Washington, while operating on the “Smart Summon”
feature. The feature allows Tesla vehicles to “autonomously” navigate
parking lots to their owners, but in this case, it resulted in a
significant mishap. The car continued to move forward even after making
contact with the jet, pushing the expensive aircraft and causing notable
damage.</p>
<p>The crash highlighted several issues with Tesla’s Smart Summon
feature, particularly its object detection capabilities. The system
failed to recognize and appropriately react to the presence of the jet,
a problem that has been observed in other scenarios where the car’s
sensors struggle with objects that are lifted off the ground or have
unusual shapes.</p>
</div>
<div class="section level3">
<h3 id="ex2-ibm-watson-for-oncology">Ex2: IBM Watson for Oncology<a class="anchor" aria-label="anchor" href="#ex2-ibm-watson-for-oncology"></a>
</h3>
<p>Around a decade ago, the excitement surrounding AI in healthcare
often exceeded its actual capabilities. In 2016, IBM launched Watson for
Oncology, an AI-powered platform for treatment recommendations, to much
public enthusiasm. However, it soon became apparent that the system was
both costly and unreliable, frequently generating flawed advice while
operating as an opaque “black box”. IBM Watson for Oncology faced
several issues due to OOD data. The system was primarily trained on data
from Memorial Sloan Kettering Cancer Center (MSK), which did not
generalize well to other healthcare settings. This led to:</p>
<ol style="list-style-type: decimal">
<li>Unsafe recommendations: Watson for Oncology provided treatment
recommendations that were not safe or aligned with standard care
guidelines in many cases outside of MSK. This happened because the
training data was not representative of the diverse medical practices
and patient populations in different regions</li>
<li>Bias in training data: The system’s recommendations were biased
towards the practices at MSK, failing to account for different treatment
protocols and patient needs elsewhere. This bias is a classic example of
an OOD issue, where the model encounters data (patients and treatments)
during deployment that significantly differ from its training data</li>
</ol>
<p>By 2022, IBM had taken Watson for Oncology offline, marking the end
of its commercial use.</p>
</div>
<div class="section level3">
<h3 id="ex3-doctors-using-gpt3">Ex3: Doctors using GPT3<a class="anchor" aria-label="anchor" href="#ex3-doctors-using-gpt3"></a>
</h3>
<div class="section level4">
<h4 id="misdiagnosis-and-inaccurate-medical-advice">Misdiagnosis and inaccurate medical advice<a class="anchor" aria-label="anchor" href="#misdiagnosis-and-inaccurate-medical-advice"></a>
</h4>
<p>In various studies and real-world applications, GPT-3 has been shown
to generate inaccurate medical advice when faced with OOD data. This can
be attributed to the fact that the training data, while extensive, does
not cover all possible medical scenarios and nuances, leading to
hallucinations or incorrect responses when encountering unfamiliar
input.</p>
<p>A <a href="https://hai.stanford.edu/news/generating-medical-errors-genai-and-erroneous-medical-references" class="external-link">study
published by researchers at Stanford</a> found that GPT-3, even when
using retrieval-augmented generation, provided unsupported medical
advice in about 30% of its statements. For example, it suggested the use
of a specific dosage for a defibrillator based on monophasic technology,
while the cited source only discussed biphasic technology, which
operates differently.</p>
</div>
<div class="section level4">
<h4 id="fake-medical-literature-references">Fake medical literature references<a class="anchor" aria-label="anchor" href="#fake-medical-literature-references"></a>
</h4>
<p>Another critical OOD issue is the generation of fake or non-existent
medical references by LLMs. When LLMs are prompted to provide citations
for their responses, they sometimes generate references that sound
plausible but do not actually exist. This can be particularly
problematic in academic and medical contexts where accurate sourcing is
crucial.</p>
<p>In <a href="https://hai.stanford.edu/news/generating-medical-errors-genai-and-erroneous-medical-references" class="external-link">evaluations
of GPT-3’s ability to generate medical literature references</a> , it
was found that a significant portion of the references were either
entirely fabricated or did not support the claims being made. This was
especially true for complex medical inquiries that the model had not
seen in its training data.</p>
<div id="recognizing-ood-data-in-your-work" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="recognizing-ood-data-in-your-work" class="callout-inner">
<h3 class="callout-title">Recognizing OOD data in your work</h3>
<div class="callout-content">
<p>Think of a scenario from your field of work or study where
encountering out-of-distribution (OOD) data would be problematic.
Consider the following:</p>
<ul>
<li>What would be the in-distribution (ID) data in that context?</li>
<li>What might constitute OOD data, and how could it impact the results
or outputs of your system/model?</li>
</ul>
<p>Share your example with the group. Discuss any strategies currently
used or that could be used to mitigate the challenges posed by OOD data
in your example.</p>
</div>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="detecting-and-handling-ood-data">Detecting and handling OOD data<a class="anchor" aria-label="anchor" href="#detecting-and-handling-ood-data"></a>
</h2>
<hr class="half-width">
<p>Given the problems posed by OOD data, a reliable model should
identify such instances, and then:</p>
<ol style="list-style-type: decimal">
<li>Reject them during inference</li>
<li>Ideally, hand these OOD instances to a model trained on a more
similar distribution (an in-distribution).</li>
</ol>
<p>The second step is much more complicated/involved since it requires
matching OOD data to essentially an infinite number of possible classes.
For the current scope of this workshop, we will focus on just the first
step.</p>
<div class="section level3">
<h3 id="threshold-based">Threshold-based<a class="anchor" aria-label="anchor" href="#threshold-based"></a>
</h3>
<p>How can we ensure our models do not perform poorly in the presence of
OOD data? Over the past several years, there have been a wide assortment
of new methods developed to tackle this task. The central idea behind
all of these methods is to define a threshold on a certain score or
confidence measure, beyond which the data point is considered
out-of-distribution. Typically, these scores are derived from the
model’s output probabilities, logits (pre-softmax outputs), or other
statistical measures of uncertainty. There are two general classes of
threshold-based OOD detection methods: <strong>output-based</strong> and
<strong>distance-based</strong>.</p>
<div class="section level4">
<h4 id="output-based-thresholds">1) Output-based thresholds<a class="anchor" aria-label="anchor" href="#output-based-thresholds"></a>
</h4>
<p>Output-based Out-of-Distribution (OOD) detection refers to methods
that determine whether a given input is out-of-distribution based on the
output of a trained model. The main approaches within output-based OOD
detection include:</p>
<ul>
<li>
<strong>Softmax scores</strong>: The softmax output of a neural
network represents the predicted probabilities for each class. A common
threshold-based method involves setting a confidence threshold, and if
the maximum softmax score of an instance falls below this threshold, it
is flagged as OOD.</li>
<li>
<strong>Energy</strong>: The energy-based method also uses the
network’s output but measures the uncertainty in a more nuanced way by
calculating an energy score. The energy score typically captures the
confidence more robustly, especially in high-dimensional spaces, and can
be considered a more general and reliable approach than just using
softmax probabilities.</li>
</ul>
</div>
<div class="section level4">
<h4 id="distance-based-thresholds">2) Distance-based thresholds<a class="anchor" aria-label="anchor" href="#distance-based-thresholds"></a>
</h4>
<p>Distance-based methods calculate the distance of an instance from the
distribution of training data features learned by the model. If the
distance is beyond a certain threshold, the instance is considered OOD.
Common distance-based approaches include:</p>
<ul>
<li>
<strong>Mahalanobis distance:</strong> This method calculates the
Mahalanobis distance of a data point from the mean of the training data
distribution. A high Mahalanobis distance indicates that the instance is
likely OOD.</li>
<li>
<strong>K-nearest neighbors (KNN):</strong> This method involves
computing the distance to the k-nearest neighbors in the training data.
If the average distance to these neighbors is high, the instance is
considered OOD.</li>
</ul>
<p>We will focus on output-based methods (softmax and energy) in the
next episode and then do a deep dive into distance-based methods in a
later next episode.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Out-of-distribution (OOD) data significantly differs from training
data and can lead to unreliable model predictions.</li>
<li>Threshold-based methods use model outputs or distances in feature
space to detect OOD instances by defining a score threshold.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div>
</section></section><section id="aio-7b-OOD-detection-softmax"><p>Content from <a href="7b-OOD-detection-softmax.html">OOD detection: softmax</a></p>
<hr>
<p>Last updated on 2024-12-19 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/7b-OOD-detection-softmax.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What is softmax-based out-of-distribution (OOD) detection, and how
does it work?</li>
<li>What are the strengths and limitations of using softmax scores for
OOD detection?</li>
<li>How do threshold choices affect the performance of softmax-based OOD
detection?</li>
<li>How can we assess and improve softmax-based OOD detection through
evaluation metrics and visualization?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand how softmax scores can be leveraged for OOD
detection.</li>
<li>Explore the advantages and drawbacks of using softmax-based methods
for OOD detection.</li>
<li>Learn how to visualize and interpret softmax-based OOD detection
performance using tools like PCA and probability density plots.</li>
<li>Investigate the impact of thresholds on the trade-offs between
detecting OOD and retaining in-distribution data.</li>
<li>Build a foundation for understanding more advanced output-based OOD
detection methods, such as energy-based detection.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>Softmax-based methods are among the most widely used techniques for
out-of-distribution (OOD) detection, leveraging the probabilistic
outputs of a model to differentiate between in-distribution (ID) and OOD
data. These methods are inherently tied to models employing a softmax
activation function in their final layer, such as logistic regression or
neural networks with a classification output layer.</p>
<p>The softmax function normalizes the logits (i.e., sum of neuron input
without passing through activation function) in the final layer,
squeezing the output into a range between 0 and 1. This is useful for
interpreting the model’s predictions as probabilities. Softmax
probabilities are computed as:</p>
<p><span class="math display">\[
P(y = k \mid x) = \frac{\exp(f_k(x))}{ \sum_{j} \exp(f_j(x))}
\]</span></p>
<p>In this lesson, we will train a logistic regression model to classify
images from the Fashion MNIST dataset and explore how its softmax
outputs can signal whether a given input belongs to the ID classes
(e.g., T-shirts or pants) or is OOD (e.g., sandals). While softmax is
most naturally applied in models with a logistic activation, alternative
approaches, such as applying softmax-like operations post hoc to models
with different architectures, are occasionally used. However, these
alternatives are less common and may require additional considerations.
By focusing on logistic regression, we aim to illustrate the fundamental
principles of softmax-based OOD detection in a simple and interpretable
context before extending these ideas to more complex architectures. ###
Prepare the ID (train and test) and OOD data In order to determine a
threshold that can separate ID data from OOD data (or ensure new test
data as ID), we need to sample data from both distributions. OOD data
used should be representative of potential new classes (i.e., semanitic
shift) that may be seen by your model, or distribution/covariate shifts
observed in your application area.</p>
<ul>
<li>ID = T-shirts/Blouses, Pants</li>
<li>OOD = any other class. For Illustrative purposes, we’ll focus on
images of sandals as the OOD class.</li>
</ul>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> accuracy_score</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="im">from</span> keras.datasets <span class="im">import</span> fashion_mnist</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="kw">def</span> prep_ID_OOD_datasests(ID_class_labels, OOD_class_labels):</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="co">    Prepares in-distribution (ID) and out-of-distribution (OOD) datasets </span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="co">    from the Fashion MNIST dataset.</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a><span class="co">    - ID_class_labels: list or array-like, labels for the in-distribution classes.</span></span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a><span class="co">                       Example: [0, 1] for T-shirts (0) and Trousers (1).</span></span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a><span class="co">    - OOD_class_labels: list or array-like, labels for the out-of-distribution classes.</span></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a><span class="co">                        Example: [5] for Sandals.</span></span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a><span class="co">    - train_data: np.array, training images for in-distribution classes.</span></span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a><span class="co">    - test_data: np.array, test images for in-distribution classes.</span></span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a><span class="co">    - ood_data: np.array, test images for out-of-distribution classes.</span></span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a><span class="co">    - train_labels: np.array, labels corresponding to the training images.</span></span>
<span id="cb1-23"><a href="#cb1-23" tabindex="-1"></a><span class="co">    - test_labels: np.array, labels corresponding to the test images.</span></span>
<span id="cb1-24"><a href="#cb1-24" tabindex="-1"></a><span class="co">    - ood_labels: np.array, labels corresponding to the OOD test images.</span></span>
<span id="cb1-25"><a href="#cb1-25" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" tabindex="-1"></a><span class="co">    Notes:</span></span>
<span id="cb1-27"><a href="#cb1-27" tabindex="-1"></a><span class="co">    - The function filters images based on provided class labels for ID and OOD.</span></span>
<span id="cb1-28"><a href="#cb1-28" tabindex="-1"></a><span class="co">    - Outputs include images and their corresponding labels.</span></span>
<span id="cb1-29"><a href="#cb1-29" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-30"><a href="#cb1-30" tabindex="-1"></a>    <span class="co"># Load Fashion MNIST dataset</span></span>
<span id="cb1-31"><a href="#cb1-31" tabindex="-1"></a>    (train_images, train_labels), (test_images, test_labels) <span class="op">=</span> fashion_mnist.load_data()</span>
<span id="cb1-32"><a href="#cb1-32" tabindex="-1"></a>    </span>
<span id="cb1-33"><a href="#cb1-33" tabindex="-1"></a>    <span class="co"># Prepare OOD data: Sandals = 5</span></span>
<span id="cb1-34"><a href="#cb1-34" tabindex="-1"></a>    ood_filter <span class="op">=</span> np.isin(test_labels, OOD_class_labels)</span>
<span id="cb1-35"><a href="#cb1-35" tabindex="-1"></a>    ood_data <span class="op">=</span> test_images[ood_filter]</span>
<span id="cb1-36"><a href="#cb1-36" tabindex="-1"></a>    ood_labels <span class="op">=</span> test_labels[ood_filter]</span>
<span id="cb1-37"><a href="#cb1-37" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'ood_data.shape=</span><span class="sc">{</span>ood_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb1-38"><a href="#cb1-38" tabindex="-1"></a>    </span>
<span id="cb1-39"><a href="#cb1-39" tabindex="-1"></a>    <span class="co"># Filter data for T-shirts (0) and Trousers (1) as in-distribution</span></span>
<span id="cb1-40"><a href="#cb1-40" tabindex="-1"></a>    train_filter <span class="op">=</span> np.isin(train_labels, ID_class_labels)</span>
<span id="cb1-41"><a href="#cb1-41" tabindex="-1"></a>    test_filter <span class="op">=</span> np.isin(test_labels, ID_class_labels)</span>
<span id="cb1-42"><a href="#cb1-42" tabindex="-1"></a>    </span>
<span id="cb1-43"><a href="#cb1-43" tabindex="-1"></a>    train_data <span class="op">=</span> train_images[train_filter]</span>
<span id="cb1-44"><a href="#cb1-44" tabindex="-1"></a>    train_labels <span class="op">=</span> train_labels[train_filter]</span>
<span id="cb1-45"><a href="#cb1-45" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'train_data.shape=</span><span class="sc">{</span>train_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb1-46"><a href="#cb1-46" tabindex="-1"></a>    </span>
<span id="cb1-47"><a href="#cb1-47" tabindex="-1"></a>    test_data <span class="op">=</span> test_images[test_filter]</span>
<span id="cb1-48"><a href="#cb1-48" tabindex="-1"></a>    test_labels <span class="op">=</span> test_labels[test_filter]</span>
<span id="cb1-49"><a href="#cb1-49" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'test_data.shape=</span><span class="sc">{</span>test_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb1-50"><a href="#cb1-50" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" tabindex="-1"></a>    <span class="cf">return</span> train_data, test_data, ood_data, train_labels, test_labels, ood_labels</span>
<span id="cb1-52"><a href="#cb1-52" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" tabindex="-1"></a><span class="kw">def</span> plot_data_sample(train_data, ood_data):</span>
<span id="cb1-55"><a href="#cb1-55" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-56"><a href="#cb1-56" tabindex="-1"></a><span class="co">    Plots a sample of in-distribution and OOD data.</span></span>
<span id="cb1-57"><a href="#cb1-57" tabindex="-1"></a></span>
<span id="cb1-58"><a href="#cb1-58" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb1-59"><a href="#cb1-59" tabindex="-1"></a><span class="co">    - train_data: np.array, array of in-distribution data images</span></span>
<span id="cb1-60"><a href="#cb1-60" tabindex="-1"></a><span class="co">    - ood_data: np.array, array of out-of-distribution data images</span></span>
<span id="cb1-61"><a href="#cb1-61" tabindex="-1"></a></span>
<span id="cb1-62"><a href="#cb1-62" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb1-63"><a href="#cb1-63" tabindex="-1"></a><span class="co">    - fig: matplotlib.figure.Figure, the figure object containing the plots</span></span>
<span id="cb1-64"><a href="#cb1-64" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-65"><a href="#cb1-65" tabindex="-1"></a>    fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb1-66"><a href="#cb1-66" tabindex="-1"></a>    N_samples <span class="op">=</span> <span class="dv">7</span></span>
<span id="cb1-67"><a href="#cb1-67" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N_samples):</span>
<span id="cb1-68"><a href="#cb1-68" tabindex="-1"></a>        plt.subplot(<span class="dv">2</span>, N_samples, i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb1-69"><a href="#cb1-69" tabindex="-1"></a>        plt.imshow(train_data[i], cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb1-70"><a href="#cb1-70" tabindex="-1"></a>        plt.title(<span class="st">"In-Dist"</span>)</span>
<span id="cb1-71"><a href="#cb1-71" tabindex="-1"></a>        plt.axis(<span class="st">'off'</span>)</span>
<span id="cb1-72"><a href="#cb1-72" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N_samples):</span>
<span id="cb1-73"><a href="#cb1-73" tabindex="-1"></a>        plt.subplot(<span class="dv">2</span>, N_samples, i <span class="op">+</span> N_samples<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb1-74"><a href="#cb1-74" tabindex="-1"></a>        plt.imshow(ood_data[i], cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb1-75"><a href="#cb1-75" tabindex="-1"></a>        plt.title(<span class="st">"OOD"</span>)</span>
<span id="cb1-76"><a href="#cb1-76" tabindex="-1"></a>        plt.axis(<span class="st">'off'</span>)</span>
<span id="cb1-77"><a href="#cb1-77" tabindex="-1"></a>    </span>
<span id="cb1-78"><a href="#cb1-78" tabindex="-1"></a>    <span class="cf">return</span> fig</span></code></pre>
</div>
<p>Load and prepare the ID data (train+test containing shirts and pants)
and OOD data (sandals)</p>
<p><strong>Why not just add the OOD class to training dataset?</strong>
OOD data is, by definition, not part of the training distribution. It
could encompass anything outside the known classes, which means you’d
need to collect a representative dataset for “everything else” to train
the OOD class. This is practically impossible because OOD data is often
diverse and unbounded (e.g., new species, novel medical conditions,
adversarial examples).</p>
<p>The key idea behind threshold-based methods is we want to vet our
model against a small sample of potential risk-cases using known OOD
data to determine an empirical threshold that <em>hopefully</em> extends
to other OOD cases that may arise in real-world scenarios.</p>
<p>That said, a common <em>next</em> step in OOD pipelines is to develop
new models that handle the OOD data (e.g., adding new classes). The
first step, however, is detecting the existence of such OOD data.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># ID: T-shirts (0) and Trousers (1)</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="co"># OOD: Sandals (5)</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>train_data, test_data, ood_data, train_labels, test_labels, ood_labels <span class="op">=</span> prep_ID_OOD_datasests(ID_class_labels<span class="op">=</span>[<span class="dv">0</span>,<span class="dv">1</span>], OOD_class_labels<span class="op">=</span>[<span class="dv">5</span>])</span></code></pre>
</div>
<p>Plot sample</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>fig <span class="op">=</span> plot_data_sample(train_data, ood_data)</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<section><h2 class="section-heading" id="visualizing-ood-and-id-data">Visualizing OOD and ID data<a class="anchor" aria-label="anchor" href="#visualizing-ood-and-id-data"></a>
</h2>
<hr class="half-width">
<div class="section level3">
<h3 id="pca">PCA<a class="anchor" aria-label="anchor" href="#pca"></a>
</h3>
<p>PCA visualization can provide insights into how well a model is
separating ID and OOD data. If the OOD data overlaps significantly with
ID data in the PCA space, it might indicate that the model could
struggle to correctly identify OOD samples.</p>
<p><strong>Focus on Linear Relationships</strong>: PCA is a linear
dimensionality reduction technique. It assumes that the directions of
maximum variance in the data can be captured by linear combinations of
the original features. This can be a limitation when the data has
complex, non-linear relationships, as PCA may not capture the true
structure of the data. However, if you’re using a linear model (as we
are here), PCA can be more appropriate for visualizing in-distribution
(ID) and out-of-distribution (OOD) data because both PCA and linear
models operate under linear assumptions. PCA will effectively capture
the main variance in the data as seen by the linear model, making it
easier to understand the decision boundaries and how OOD data deviates
from the ID data within those boundaries.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Flatten images for PCA and logistic regression</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>train_data_flat <span class="op">=</span> train_data.reshape((train_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>test_data_flat <span class="op">=</span> test_data.reshape((test_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>ood_data_flat <span class="op">=</span> ood_data.reshape((ood_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'train_data_flat.shape=</span><span class="sc">{</span>train_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'test_data_flat.shape=</span><span class="sc">{</span>test_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'ood_data_flat.shape=</span><span class="sc">{</span>ood_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># Perform PCA to visualize the first two principal components</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>pca <span class="op">=</span> PCA(n_components<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>train_data_pca <span class="op">=</span> pca.fit_transform(train_data_flat)</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>test_data_pca <span class="op">=</span> pca.transform(test_data_flat)</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>ood_data_pca <span class="op">=</span> pca.transform(ood_data_flat)</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co"># Plotting PCA components</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a>scatter1 <span class="op">=</span> plt.scatter(train_data_pca[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">0</span>], train_data_pca[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'blue'</span>, label<span class="op">=</span><span class="st">'T-shirt/top (ID)'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a>scatter2 <span class="op">=</span> plt.scatter(train_data_pca[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">0</span>], train_data_pca[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'red'</span>, label<span class="op">=</span><span class="st">'Pants (ID)'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a>scatter3 <span class="op">=</span> plt.scatter(ood_data_pca[:, <span class="dv">0</span>], ood_data_pca[:, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'green'</span>, label<span class="op">=</span><span class="st">'Sandals (OOD)'</span>, edgecolor<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a><span class="co"># Create a single legend for all classes</span></span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[scatter1, scatter2, scatter3], loc<span class="op">=</span><span class="st">"upper right"</span>)</span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a>plt.xlabel(<span class="st">'First Principal Component'</span>)</span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a>plt.ylabel(<span class="st">'Second Principal Component'</span>)</span>
<span id="cb5-19"><a href="#cb5-19" tabindex="-1"></a>plt.title(<span class="st">'PCA of In-Distribution and OOD Data'</span>)</span>
<span id="cb5-20"><a href="#cb5-20" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p>From this plot, we see that sandals are more likely to be confused as
T-shirts than pants. It also may be surprising to see that these data
clouds overlap so much given their semantic differences. Why might this
be?</p>
<ul>
<li>
<strong>Over-reliance on linear relationships</strong>: Part of this
has to do with the fact that we’re only looking at linear relationships
and treating each pixel as its own input feature, which is usually never
a great idea when working with image data. In our next example, we’ll
switch to the more modern approach of CNNs.</li>
<li>
<strong>Semantic gap != feature gap</strong>: Another factor of note
is that images that have a wide semantic gap may not necessarily
translate to a wide gap in terms of the data’s visual features (e.g.,
ankle boots and bags might both be small, have leather, and have
zippers). Part of an effective OOD detection scheme involves thinking
carefully about what sorts of data contanimations may be observed by the
model, and assessing how similar these contaminations may be to your
desired class labels. ## Train and evaluate model on ID data</li>
</ul>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>model <span class="op">=</span> LogisticRegression(max_iter<span class="op">=</span><span class="dv">10</span>, solver<span class="op">=</span><span class="st">'lbfgs'</span>, multi_class<span class="op">=</span><span class="st">'multinomial'</span>).fit(train_data_flat, train_labels) <span class="co"># 'lbfgs' is an efficient solver that works well for small to medium-sized datasets.</span></span></code></pre>
</div>
<p>Before we worry about the impact of OOD data, let’s first verify that
we have a reasonably accurate model for the ID data.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># Evaluate the model on in-distribution data</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>ID_preds <span class="op">=</span> model.predict(test_data_flat)</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>ID_accuracy <span class="op">=</span> accuracy_score(test_labels, ID_preds)</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'In-Distribution Accuracy: </span><span class="sc">{</span>ID_accuracy<span class="sc">:.2f}</span><span class="ss">'</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> accuracy_score, confusion_matrix, ConfusionMatrixDisplay</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="co"># Generate and display confusion matrix</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>cm <span class="op">=</span> confusion_matrix(test_labels, ID_preds, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>cm, display_labels<span class="op">=</span>[<span class="st">'T-shirt/top'</span>, <span class="st">'Pants'</span>])</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>disp.plot(cmap<span class="op">=</span>plt.cm.Blues)</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
</div>
</section><section><h2 class="section-heading" id="how-does-our-model-view-ood-data">How does our model view OOD data?<a class="anchor" aria-label="anchor" href="#how-does-our-model-view-ood-data"></a>
</h2>
<hr class="half-width">
<p>A basic question we can start with is to ask, on average, how are OOD
samples classified? Are they more likely to be Tshirts or pants? For
this kind of question, we can calculate the probability scores for the
OOD data, and compare this to the ID data.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># Predict probabilities using the model on OOD data (Sandals)</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>ood_probs <span class="op">=</span> model.predict_proba(ood_data_flat)</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>avg_ood_prob <span class="op">=</span> np.mean(ood_probs, <span class="dv">0</span>)</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Avg. probability of sandal being T-shirt: </span><span class="sc">{</span>avg_ood_prob[<span class="dv">0</span>]<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Avg. probability of sandal being pants: </span><span class="sc">{</span>avg_ood_prob[<span class="dv">1</span>]<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>id_probs <span class="op">=</span> model.predict_proba(test_data_flat) <span class="co"># a fairer comparison is to look at test set probabilities (just in case our model is overfitting)</span></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>id_probs_shirts <span class="op">=</span> id_probs[test_labels<span class="op">==</span><span class="dv">0</span>,:]</span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a>id_probs_pants <span class="op">=</span> id_probs[test_labels<span class="op">==</span><span class="dv">1</span>,:]</span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a>avg_tshirt_prob <span class="op">=</span> np.mean(id_probs_shirts, <span class="dv">0</span>)</span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a>avg_pants_prob <span class="op">=</span> np.mean(id_probs_pants, <span class="dv">0</span>)</span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Avg. probability of T-shirt being T-shirt: </span><span class="sc">{</span>avg_tshirt_prob[<span class="dv">0</span>]<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Avg. probability of pants being pants: </span><span class="sc">{</span>avg_pants_prob[<span class="dv">1</span>]<span class="sc">:.2f}</span><span class="ss">"</span>)</span></code></pre>
</div>
<p>Based on the difference in averages here, it looks like softmax may
provide at least a somewhat useful signal in separating ID and OOD data.
Let’s take a closer look by plotting histograms of all probability
scores across our classes of interest (ID-Tshirt, ID-Pants, and
OOD).</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co"># Creating the figure and subplots</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">4</span>), sharey<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>bins<span class="op">=</span><span class="dv">60</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="co"># Plotting the histogram of probabilities for OOD data (Sandals)</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>axes[<span class="dv">0</span>].hist(ood_probs[:, <span class="dv">0</span>], bins<span class="op">=</span>bins, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'T-shirt probability'</span>)</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>axes[<span class="dv">0</span>].set_xlabel(<span class="st">'Probability'</span>)</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>axes[<span class="dv">0</span>].set_ylabel(<span class="st">'Frequency'</span>)</span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'OOD Data (Sandals)'</span>)</span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>axes[<span class="dv">0</span>].legend()</span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a><span class="co"># Plotting the histogram of probabilities for ID data (T-shirt)</span></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>axes[<span class="dv">1</span>].hist(id_probs_shirts[:, <span class="dv">0</span>], bins<span class="op">=</span>bins, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'T-shirt probability'</span>, color<span class="op">=</span><span class="st">'orange'</span>)</span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a>axes[<span class="dv">1</span>].set_xlabel(<span class="st">'Probability'</span>)</span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'ID Data (T-shirt/top)'</span>)</span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a>axes[<span class="dv">1</span>].legend()</span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a><span class="co"># Plotting the histogram of probabilities for ID data (Pants)</span></span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a>axes[<span class="dv">2</span>].hist(id_probs_pants[:, <span class="dv">1</span>], bins<span class="op">=</span>bins, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Pants probability'</span>, color<span class="op">=</span><span class="st">'green'</span>)</span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a>axes[<span class="dv">2</span>].set_xlabel(<span class="st">'Probability'</span>)</span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a>axes[<span class="dv">2</span>].set_title(<span class="st">'ID Data (Pants)'</span>)</span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a>axes[<span class="dv">2</span>].legend()</span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a><span class="co"># Adjusting layout</span></span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a></span>
<span id="cb10-26"><a href="#cb10-26" tabindex="-1"></a><span class="co"># Displaying the plot</span></span>
<span id="cb10-27"><a href="#cb10-27" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p>Alternatively, for a better comparison across all three classes, we
can use a probability density plot. This will allow for an easier
comparison when the counts across classes lie on vastly different scales
(i.e., max of 35 vs max of 5000).</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> gaussian_kde</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="co"># Create figure</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="co"># Define bins</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">0.4</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a><span class="co"># Plot PDF for ID T-shirt (T-shirt probability)</span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>density_id_shirts <span class="op">=</span> gaussian_kde(id_probs_shirts[:, <span class="dv">0</span>])</span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>x_id_shirts <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1000</span>)</span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a>plt.plot(x_id_shirts, density_id_shirts(x_id_shirts), label<span class="op">=</span><span class="st">'ID T-shirt (T-shirt probability)'</span>, color<span class="op">=</span><span class="st">'orange'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a><span class="co"># Plot PDF for ID Pants (Pants probability)</span></span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a>density_id_pants <span class="op">=</span> gaussian_kde(id_probs_pants[:, <span class="dv">0</span>])</span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a>x_id_pants <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1000</span>)</span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a>plt.plot(x_id_pants, density_id_pants(x_id_pants), label<span class="op">=</span><span class="st">'ID Pants (T-shirt probability)'</span>, color<span class="op">=</span><span class="st">'green'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" tabindex="-1"></a><span class="co"># Plot PDF for OOD (T-shirt probability)</span></span>
<span id="cb11-20"><a href="#cb11-20" tabindex="-1"></a>density_ood <span class="op">=</span> gaussian_kde(ood_probs[:, <span class="dv">0</span>])</span>
<span id="cb11-21"><a href="#cb11-21" tabindex="-1"></a>x_ood <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1000</span>)</span>
<span id="cb11-22"><a href="#cb11-22" tabindex="-1"></a>plt.plot(x_ood, density_ood(x_ood), label<span class="op">=</span><span class="st">'OOD (T-shirt probability)'</span>, color<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb11-23"><a href="#cb11-23" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" tabindex="-1"></a><span class="co"># Adding labels and title</span></span>
<span id="cb11-25"><a href="#cb11-25" tabindex="-1"></a>plt.xlabel(<span class="st">'Probability'</span>)</span>
<span id="cb11-26"><a href="#cb11-26" tabindex="-1"></a>plt.ylabel(<span class="st">'Density'</span>)</span>
<span id="cb11-27"><a href="#cb11-27" tabindex="-1"></a>plt.title(<span class="st">'Probability Density Distributions for OOD and ID Data'</span>)</span>
<span id="cb11-28"><a href="#cb11-28" tabindex="-1"></a>plt.ylim([<span class="dv">0</span>,<span class="dv">20</span>])</span>
<span id="cb11-29"><a href="#cb11-29" tabindex="-1"></a>plt.legend()</span>
<span id="cb11-30"><a href="#cb11-30" tabindex="-1"></a></span>
<span id="cb11-31"><a href="#cb11-31" tabindex="-1"></a><span class="co">#plt.savefig('../images/OOD-detection_PSDs.png', dpi=300, bbox_inches='tight')</span></span>
<span id="cb11-32"><a href="#cb11-32" tabindex="-1"></a></span>
<span id="cb11-33"><a href="#cb11-33" tabindex="-1"></a><span class="co"># Displaying the plot</span></span>
<span id="cb11-34"><a href="#cb11-34" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p>Unfortunately, we observe a significant amount of overlap between OOD
data and high T-shirt probability. Furthermore, the blue line doesn’t
seem to decrease much as you move from 0.9 to 1, suggesting that even a
very high threshold is likely to lead to OOD contamination (while also
tossing out a significant portion of ID data).</p>
<p>For pants, the problem is much less severe. It looks like a low
threshold (on this T-shirt probability scale) can separate nearly all
OOD samples from being pants.</p>
<div class="section level3">
<h3 id="setting-a-threshold">Setting a threshold<a class="anchor" aria-label="anchor" href="#setting-a-threshold"></a>
</h3>
<p>Let’s put our observations to the test and produce a confusion matrix
that includes ID-pants, ID-Tshirts, and OOD class labels. We’ll start
with a high threshold of 0.9 to see how that performs.</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="kw">def</span> softmax_thresh_classifications(probs, threshold):</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="co">    Classifies data points into categories based on softmax probabilities and a specified threshold.</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a><span class="co">    - probs: np.array</span></span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a><span class="co">        A 2D array of shape (n_samples, n_classes) containing the softmax probabilities for each sample </span></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a><span class="co">        across all classes. Each row corresponds to a single sample, and each column corresponds to </span></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a><span class="co">        the probability of a specific class.</span></span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a><span class="co">    - threshold: float</span></span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a><span class="co">        A probability threshold for classification. Samples are classified into a specific class if </span></span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a><span class="co">        their corresponding probability exceeds the threshold.</span></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a><span class="co">    - classifications: np.array</span></span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a><span class="co">        A 1D array of shape (n_samples,) where:</span></span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a><span class="co">        - 1 indicates the sample is classified as the second class (e.g., "pants").</span></span>
<span id="cb12-18"><a href="#cb12-18" tabindex="-1"></a><span class="co">        - 0 indicates the sample is classified as the first class (e.g., "shirts").</span></span>
<span id="cb12-19"><a href="#cb12-19" tabindex="-1"></a><span class="co">        - -1 indicates the sample is classified as out-of-distribution (OOD) because no class probability</span></span>
<span id="cb12-20"><a href="#cb12-20" tabindex="-1"></a><span class="co">          exceeds the threshold.</span></span>
<span id="cb12-21"><a href="#cb12-21" tabindex="-1"></a></span>
<span id="cb12-22"><a href="#cb12-22" tabindex="-1"></a><span class="co">    Notes:</span></span>
<span id="cb12-23"><a href="#cb12-23" tabindex="-1"></a><span class="co">    - The function assumes binary classification with probabilities for two classes provided in the `probs` array.</span></span>
<span id="cb12-24"><a href="#cb12-24" tabindex="-1"></a><span class="co">    - If neither class probability exceeds the threshold, the sample is flagged as OOD with a classification of -1.</span></span>
<span id="cb12-25"><a href="#cb12-25" tabindex="-1"></a><span class="co">    - This approach is suitable for threshold-based OOD detection tasks where probabilities can serve as confidence scores.</span></span>
<span id="cb12-26"><a href="#cb12-26" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb12-27"><a href="#cb12-27" tabindex="-1"></a>    classifications <span class="op">=</span> np.where(probs[:, <span class="dv">1</span>] <span class="op">&gt;=</span> threshold, <span class="dv">1</span>,  <span class="co"># classified as pants</span></span>
<span id="cb12-28"><a href="#cb12-28" tabindex="-1"></a>                               np.where(probs[:, <span class="dv">0</span>] <span class="op">&gt;=</span> threshold, <span class="dv">0</span>,  <span class="co"># classified as shirts</span></span>
<span id="cb12-29"><a href="#cb12-29" tabindex="-1"></a>                                        <span class="op">-</span><span class="dv">1</span>))  <span class="co"># classified as OOD</span></span>
<span id="cb12-30"><a href="#cb12-30" tabindex="-1"></a>    <span class="cf">return</span> classifications</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> precision_recall_fscore_support</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="co"># Assuming ood_probs, id_probs, and train_labels are defined</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="co"># Threshold values</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>upper_threshold <span class="op">=</span> <span class="fl">0.9</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="co"># Classifying OOD examples (sandals)</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a>ood_classifications <span class="op">=</span> softmax_thresh_classifications(ood_probs, upper_threshold)</span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="co"># Classifying ID examples (T-shirts and pants)</span></span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a>id_classifications <span class="op">=</span> softmax_thresh_classifications(id_probs, upper_threshold)</span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a><span class="co"># Combine OOD and ID classifications and true labels</span></span>
<span id="cb13-14"><a href="#cb13-14" tabindex="-1"></a>all_predictions <span class="op">=</span> np.concatenate([ood_classifications, id_classifications])</span>
<span id="cb13-15"><a href="#cb13-15" tabindex="-1"></a>all_true_labels <span class="op">=</span> np.concatenate([<span class="op">-</span><span class="dv">1</span> <span class="op">*</span> np.ones(ood_classifications.shape), test_labels])</span>
<span id="cb13-16"><a href="#cb13-16" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" tabindex="-1"></a>all_true_labels <span class="co"># Sandals (-1), T-shirts (0), Trousers (1)</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="co"># Confusion matrix</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>cm <span class="op">=</span> confusion_matrix(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="co"># Plotting the confusion matrix</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>cm, display_labels<span class="op">=</span>[<span class="st">"Shirt"</span>, <span class="st">"Pants"</span>, <span class="st">"OOD"</span>])</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a>disp.plot(cmap<span class="op">=</span>plt.cm.Blues)</span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>plt.title(<span class="st">'Confusion Matrix for OOD and ID Classification'</span>)</span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>plt.show()</span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a><span class="co"># Looking at F1, precision, and recall</span></span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a>precision, recall, f1, _ <span class="op">=</span> precision_recall_fscore_support(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>], average<span class="op">=</span><span class="st">'macro'</span>) <span class="co"># macro = average scores across classes</span></span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a><span class="co"># ID: T-shirts (0) and Trousers (1)</span></span>
<span id="cb14-15"><a href="#cb14-15" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"F1: </span><span class="sc">{</span>f1<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb14-16"><a href="#cb14-16" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Precision: </span><span class="sc">{</span>precision<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb14-17"><a href="#cb14-17" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Recall: </span><span class="sc">{</span>recall<span class="sc">}</span><span class="ss">"</span>)</span></code></pre>
</div>
<p>Even with a high threshold of 0.9, we end up with nearly a couple
hundred OOD samples classified as ID. In addition, over 800 ID samples
had to be tossed out due to uncertainty.</p>
</div>
<div class="section level3">
<h3 id="quick-exercise">Quick exercise<a class="anchor" aria-label="anchor" href="#quick-exercise"></a>
</h3>
<p>What threhsold is required to ensure that no OOD samples are
incorrectly considered as IID? What percentage of ID samples are
mistaken as OOD at this threshold?</p>
<p>With a very conservative threshold, we can make sure very few OOD
samples are incorrectly classified as ID. However, the flip side is that
conservative thresholds tend to incorrectly classify many ID samples as
being OOD. In this case, we incorrectly assume almost 20% of shirts are
OOD samples.</p>
</div>
</section><section><h2 class="section-heading" id="iterative-threshold-determination">Iterative Threshold Determination<a class="anchor" aria-label="anchor" href="#iterative-threshold-determination"></a>
</h2>
<hr class="half-width">
<p>In practice, selecting an appropriate threshold is an iterative
process that balances the trade-off between correctly identifying
in-distribution (ID) data and accurately flagging out-of-distribution
(OOD) data. Here’s how you can iteratively determine the threshold:</p>
<ul>
<li><p><strong>Define evaluation metrics</strong>: While confusion
matrices are an excellent tool when you’re ready to more closely examine
the data, we need a single metric that can summarize threshold
performance so we can easily compare across threshold. Common metrics
include accuracy, precision, recall, or the F1 score for both ID and OOD
detection.</p></li>
<li><p><strong>Evaluate over a range of thresholds</strong>: Test
different threshold values and evaluate the performance on a validation
set containing both ID and OOD data.</p></li>
<li><p><strong>Select the optimal threshold</strong>: Choose the
threshold that provides the best balance according to your chosen
metrics.</p></li>
</ul>
<p>Use the below code to determine what threshold should be set to
ensure precision = 100%. What threshold is required for recall to be
100%? What threshold gives the highest F1 score?</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="kw">def</span> eval_softmax_thresholds(thresholds, ood_probs, id_probs):</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a><span class="co">    Evaluates the performance of softmax-based classification at various thresholds by calculating precision, </span></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="co">    recall, and F1 scores for in-distribution (ID) and out-of-distribution (OOD) data.</span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a><span class="co">    - thresholds: list or np.array</span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a><span class="co">        A list or array of threshold values to evaluate. Each threshold is applied to classify samples based </span></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a><span class="co">        on their softmax probabilities.</span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a><span class="co">    - ood_probs: np.array</span></span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a><span class="co">        A 2D array of shape (n_ood_samples, n_classes) containing the softmax probabilities for OOD samples </span></span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a><span class="co">        across all classes.</span></span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a><span class="co">    - id_probs: np.array</span></span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a><span class="co">        A 2D array of shape (n_id_samples, n_classes) containing the softmax probabilities for ID samples </span></span>
<span id="cb15-15"><a href="#cb15-15" tabindex="-1"></a><span class="co">        across all classes.</span></span>
<span id="cb15-16"><a href="#cb15-16" tabindex="-1"></a></span>
<span id="cb15-17"><a href="#cb15-17" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb15-18"><a href="#cb15-18" tabindex="-1"></a><span class="co">    - precisions: list</span></span>
<span id="cb15-19"><a href="#cb15-19" tabindex="-1"></a><span class="co">        A list of precision values computed for each threshold.</span></span>
<span id="cb15-20"><a href="#cb15-20" tabindex="-1"></a><span class="co">    - recalls: list</span></span>
<span id="cb15-21"><a href="#cb15-21" tabindex="-1"></a><span class="co">        A list of recall values computed for each threshold.</span></span>
<span id="cb15-22"><a href="#cb15-22" tabindex="-1"></a><span class="co">    - f1_scores: list</span></span>
<span id="cb15-23"><a href="#cb15-23" tabindex="-1"></a><span class="co">        A list of F1 scores computed for each threshold.</span></span>
<span id="cb15-24"><a href="#cb15-24" tabindex="-1"></a></span>
<span id="cb15-25"><a href="#cb15-25" tabindex="-1"></a><span class="co">    Notes:</span></span>
<span id="cb15-26"><a href="#cb15-26" tabindex="-1"></a><span class="co">    - The function assumes binary classification for ID classes (e.g., T-shirts and pants) and uses -1 to </span></span>
<span id="cb15-27"><a href="#cb15-27" tabindex="-1"></a><span class="co">      represent OOD classifications.</span></span>
<span id="cb15-28"><a href="#cb15-28" tabindex="-1"></a><span class="co">    - True labels for ID samples are taken from `test_labels` (defined externally).</span></span>
<span id="cb15-29"><a href="#cb15-29" tabindex="-1"></a><span class="co">    - True labels for OOD samples are set to -1, indicating their OOD nature.</span></span>
<span id="cb15-30"><a href="#cb15-30" tabindex="-1"></a><span class="co">    - Precision, recall, and F1 scores are calculated using macro-averaging, which treats each class equally </span></span>
<span id="cb15-31"><a href="#cb15-31" tabindex="-1"></a><span class="co">      regardless of the number of samples.</span></span>
<span id="cb15-32"><a href="#cb15-32" tabindex="-1"></a></span>
<span id="cb15-33"><a href="#cb15-33" tabindex="-1"></a><span class="co">    Example Usage:</span></span>
<span id="cb15-34"><a href="#cb15-34" tabindex="-1"></a><span class="co">    ```</span></span>
<span id="cb15-35"><a href="#cb15-35" tabindex="-1"></a><span class="co">    thresholds = np.linspace(0.5, 1.0, 50)</span></span>
<span id="cb15-36"><a href="#cb15-36" tabindex="-1"></a><span class="co">    precisions, recalls, f1_scores = eval_softmax_thresholds(thresholds, ood_probs, id_probs)</span></span>
<span id="cb15-37"><a href="#cb15-37" tabindex="-1"></a><span class="co">    ```</span></span>
<span id="cb15-38"><a href="#cb15-38" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb15-39"><a href="#cb15-39" tabindex="-1"></a>    <span class="co"># Store evaluation metrics for each threshold</span></span>
<span id="cb15-40"><a href="#cb15-40" tabindex="-1"></a>    precisions <span class="op">=</span> []</span>
<span id="cb15-41"><a href="#cb15-41" tabindex="-1"></a>    recalls <span class="op">=</span> []</span>
<span id="cb15-42"><a href="#cb15-42" tabindex="-1"></a>    f1_scores <span class="op">=</span> []</span>
<span id="cb15-43"><a href="#cb15-43" tabindex="-1"></a>    </span>
<span id="cb15-44"><a href="#cb15-44" tabindex="-1"></a>    <span class="cf">for</span> threshold <span class="kw">in</span> thresholds:</span>
<span id="cb15-45"><a href="#cb15-45" tabindex="-1"></a>        <span class="co"># Classifying OOD examples</span></span>
<span id="cb15-46"><a href="#cb15-46" tabindex="-1"></a>        ood_classifications <span class="op">=</span> softmax_thresh_classifications(ood_probs, threshold)</span>
<span id="cb15-47"><a href="#cb15-47" tabindex="-1"></a>        </span>
<span id="cb15-48"><a href="#cb15-48" tabindex="-1"></a>        <span class="co"># Classifying ID examples</span></span>
<span id="cb15-49"><a href="#cb15-49" tabindex="-1"></a>        id_classifications <span class="op">=</span> softmax_thresh_classifications(id_probs, threshold)</span>
<span id="cb15-50"><a href="#cb15-50" tabindex="-1"></a>        </span>
<span id="cb15-51"><a href="#cb15-51" tabindex="-1"></a>        <span class="co"># Combine OOD and ID classifications and true labels</span></span>
<span id="cb15-52"><a href="#cb15-52" tabindex="-1"></a>        all_predictions <span class="op">=</span> np.concatenate([ood_classifications, id_classifications])</span>
<span id="cb15-53"><a href="#cb15-53" tabindex="-1"></a>        all_true_labels <span class="op">=</span> np.concatenate([<span class="op">-</span><span class="dv">1</span> <span class="op">*</span> np.ones(ood_classifications.shape), test_labels])</span>
<span id="cb15-54"><a href="#cb15-54" tabindex="-1"></a>        </span>
<span id="cb15-55"><a href="#cb15-55" tabindex="-1"></a>        <span class="co"># Evaluate metrics</span></span>
<span id="cb15-56"><a href="#cb15-56" tabindex="-1"></a>        precision, recall, f1, _ <span class="op">=</span> precision_recall_fscore_support(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>], average<span class="op">=</span><span class="st">'macro'</span>)</span>
<span id="cb15-57"><a href="#cb15-57" tabindex="-1"></a>        precisions.append(precision)</span>
<span id="cb15-58"><a href="#cb15-58" tabindex="-1"></a>        recalls.append(recall)</span>
<span id="cb15-59"><a href="#cb15-59" tabindex="-1"></a>        f1_scores.append(f1)</span>
<span id="cb15-60"><a href="#cb15-60" tabindex="-1"></a>        </span>
<span id="cb15-61"><a href="#cb15-61" tabindex="-1"></a>    <span class="cf">return</span> precisions, recalls, f1_scores</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="co"># Define thresholds to evaluate</span></span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>thresholds <span class="op">=</span> np.linspace(<span class="fl">.5</span>, <span class="dv">1</span>, <span class="dv">50</span>)</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a><span class="co"># Evaluate on all thresholds</span></span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>precisions, recalls, f1_scores <span class="op">=</span> eval_softmax_thresholds(thresholds, ood_probs, id_probs)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="kw">def</span> plot_metrics_vs_thresholds(thresholds, f1_scores, precisions, recalls, OOD_signal):</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a><span class="co">    Plots evaluation metrics (Precision, Recall, and F1 Score) as functions of threshold values for </span></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a><span class="co">    softmax-based or energy-based OOD detection, and identifies the best threshold for each metric.</span></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a><span class="co">    - thresholds: list or np.array</span></span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a><span class="co">        A list or array of threshold values used for classification.</span></span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a><span class="co">    - f1_scores: list or np.array</span></span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a><span class="co">        A list or array of F1 scores computed at each threshold.</span></span>
<span id="cb17-11"><a href="#cb17-11" tabindex="-1"></a><span class="co">    - precisions: list or np.array</span></span>
<span id="cb17-12"><a href="#cb17-12" tabindex="-1"></a><span class="co">        A list or array of precision values computed at each threshold.</span></span>
<span id="cb17-13"><a href="#cb17-13" tabindex="-1"></a><span class="co">    - recalls: list or np.array</span></span>
<span id="cb17-14"><a href="#cb17-14" tabindex="-1"></a><span class="co">        A list or array of recall values computed at each threshold.</span></span>
<span id="cb17-15"><a href="#cb17-15" tabindex="-1"></a><span class="co">    - OOD_signal: str</span></span>
<span id="cb17-16"><a href="#cb17-16" tabindex="-1"></a><span class="co">        A descriptive label for the signal being used for OOD detection, such as "Softmax" or "Energy".</span></span>
<span id="cb17-17"><a href="#cb17-17" tabindex="-1"></a></span>
<span id="cb17-18"><a href="#cb17-18" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb17-19"><a href="#cb17-19" tabindex="-1"></a><span class="co">    - fig: matplotlib.figure.Figure</span></span>
<span id="cb17-20"><a href="#cb17-20" tabindex="-1"></a><span class="co">        The figure object containing the plot.</span></span>
<span id="cb17-21"><a href="#cb17-21" tabindex="-1"></a><span class="co">    - best_f1_threshold: float</span></span>
<span id="cb17-22"><a href="#cb17-22" tabindex="-1"></a><span class="co">        The threshold value corresponding to the highest F1 score.</span></span>
<span id="cb17-23"><a href="#cb17-23" tabindex="-1"></a><span class="co">    - best_precision_threshold: float</span></span>
<span id="cb17-24"><a href="#cb17-24" tabindex="-1"></a><span class="co">        The threshold value corresponding to the highest precision.</span></span>
<span id="cb17-25"><a href="#cb17-25" tabindex="-1"></a><span class="co">    - best_recall_threshold: float</span></span>
<span id="cb17-26"><a href="#cb17-26" tabindex="-1"></a><span class="co">        The threshold value corresponding to the highest recall.</span></span>
<span id="cb17-27"><a href="#cb17-27" tabindex="-1"></a></span>
<span id="cb17-28"><a href="#cb17-28" tabindex="-1"></a><span class="co">    Notes:</span></span>
<span id="cb17-29"><a href="#cb17-29" tabindex="-1"></a><span class="co">    - The function identifies and highlights the best threshold for each metric (F1 Score, Precision, Recall).</span></span>
<span id="cb17-30"><a href="#cb17-30" tabindex="-1"></a><span class="co">    - It generates a line plot for each metric as a function of the threshold and marks the best thresholds </span></span>
<span id="cb17-31"><a href="#cb17-31" tabindex="-1"></a><span class="co">      with vertical dashed lines.</span></span>
<span id="cb17-32"><a href="#cb17-32" tabindex="-1"></a><span class="co">    - This visualization is particularly useful for assessing the trade-offs between precision, recall, </span></span>
<span id="cb17-33"><a href="#cb17-33" tabindex="-1"></a><span class="co">      and F1 score when selecting a classification threshold.</span></span>
<span id="cb17-34"><a href="#cb17-34" tabindex="-1"></a></span>
<span id="cb17-35"><a href="#cb17-35" tabindex="-1"></a><span class="co">    Example Usage:</span></span>
<span id="cb17-36"><a href="#cb17-36" tabindex="-1"></a><span class="co">    ```</span></span>
<span id="cb17-37"><a href="#cb17-37" tabindex="-1"></a><span class="co">    fig, best_f1, best_precision, best_recall = plot_metrics_vs_thresholds(</span></span>
<span id="cb17-38"><a href="#cb17-38" tabindex="-1"></a><span class="co">        thresholds, f1_scores, precisions, recalls, OOD_signal='Softmax'</span></span>
<span id="cb17-39"><a href="#cb17-39" tabindex="-1"></a><span class="co">    )</span></span>
<span id="cb17-40"><a href="#cb17-40" tabindex="-1"></a><span class="co">    plt.show()</span></span>
<span id="cb17-41"><a href="#cb17-41" tabindex="-1"></a><span class="co">    ```</span></span>
<span id="cb17-42"><a href="#cb17-42" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb17-43"><a href="#cb17-43" tabindex="-1"></a>    <span class="co"># Find the best thresholds for each metric</span></span>
<span id="cb17-44"><a href="#cb17-44" tabindex="-1"></a>    best_f1_index <span class="op">=</span> np.argmax(f1_scores)</span>
<span id="cb17-45"><a href="#cb17-45" tabindex="-1"></a>    best_f1_threshold <span class="op">=</span> thresholds[best_f1_index]</span>
<span id="cb17-46"><a href="#cb17-46" tabindex="-1"></a>    </span>
<span id="cb17-47"><a href="#cb17-47" tabindex="-1"></a>    best_precision_index <span class="op">=</span> np.argmax(precisions)</span>
<span id="cb17-48"><a href="#cb17-48" tabindex="-1"></a>    best_precision_threshold <span class="op">=</span> thresholds[best_precision_index]</span>
<span id="cb17-49"><a href="#cb17-49" tabindex="-1"></a>    </span>
<span id="cb17-50"><a href="#cb17-50" tabindex="-1"></a>    best_recall_index <span class="op">=</span> np.argmax(recalls)</span>
<span id="cb17-51"><a href="#cb17-51" tabindex="-1"></a>    best_recall_threshold <span class="op">=</span> thresholds[best_recall_index]</span>
<span id="cb17-52"><a href="#cb17-52" tabindex="-1"></a>    </span>
<span id="cb17-53"><a href="#cb17-53" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best F1 threshold: </span><span class="sc">{</span>best_f1_threshold<span class="sc">}</span><span class="ss">, F1 Score: </span><span class="sc">{</span>f1_scores[best_f1_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb17-54"><a href="#cb17-54" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Precision threshold: </span><span class="sc">{</span>best_precision_threshold<span class="sc">}</span><span class="ss">, Precision: </span><span class="sc">{</span>precisions[best_precision_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb17-55"><a href="#cb17-55" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Recall threshold: </span><span class="sc">{</span>best_recall_threshold<span class="sc">}</span><span class="ss">, Recall: </span><span class="sc">{</span>recalls[best_recall_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb17-56"><a href="#cb17-56" tabindex="-1"></a></span>
<span id="cb17-57"><a href="#cb17-57" tabindex="-1"></a>    <span class="co"># Create a new figure</span></span>
<span id="cb17-58"><a href="#cb17-58" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb17-59"><a href="#cb17-59" tabindex="-1"></a></span>
<span id="cb17-60"><a href="#cb17-60" tabindex="-1"></a>    <span class="co"># Plot metrics as functions of the threshold</span></span>
<span id="cb17-61"><a href="#cb17-61" tabindex="-1"></a>    ax.plot(thresholds, precisions, label<span class="op">=</span><span class="st">'Precision'</span>, color<span class="op">=</span><span class="st">'g'</span>)</span>
<span id="cb17-62"><a href="#cb17-62" tabindex="-1"></a>    ax.plot(thresholds, recalls, label<span class="op">=</span><span class="st">'Recall'</span>, color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb17-63"><a href="#cb17-63" tabindex="-1"></a>    ax.plot(thresholds, f1_scores, label<span class="op">=</span><span class="st">'F1 Score'</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb17-64"><a href="#cb17-64" tabindex="-1"></a>    </span>
<span id="cb17-65"><a href="#cb17-65" tabindex="-1"></a>    <span class="co"># Add best threshold indicators</span></span>
<span id="cb17-66"><a href="#cb17-66" tabindex="-1"></a>    ax.axvline(x<span class="op">=</span>best_f1_threshold, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best F1 Threshold: </span><span class="sc">{</span>best_f1_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb17-67"><a href="#cb17-67" tabindex="-1"></a>    ax.axvline(x<span class="op">=</span>best_precision_threshold, color<span class="op">=</span><span class="st">'g'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best Precision Threshold: </span><span class="sc">{</span>best_precision_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb17-68"><a href="#cb17-68" tabindex="-1"></a>    ax.axvline(x<span class="op">=</span>best_recall_threshold, color<span class="op">=</span><span class="st">'b'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best Recall Threshold: </span><span class="sc">{</span>best_recall_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb17-69"><a href="#cb17-69" tabindex="-1"></a>    ax.set_xlabel(<span class="ss">f'</span><span class="sc">{</span>OOD_signal<span class="sc">}</span><span class="ss"> Threshold'</span>)</span>
<span id="cb17-70"><a href="#cb17-70" tabindex="-1"></a>    ax.set_ylabel(<span class="st">'Metric Value'</span>)</span>
<span id="cb17-71"><a href="#cb17-71" tabindex="-1"></a>    ax.set_title(<span class="st">'Evaluation Metrics as Functions of Threshold'</span>)</span>
<span id="cb17-72"><a href="#cb17-72" tabindex="-1"></a>    ax.legend()</span>
<span id="cb17-73"><a href="#cb17-73" tabindex="-1"></a></span>
<span id="cb17-74"><a href="#cb17-74" tabindex="-1"></a>    <span class="cf">return</span> fig, best_f1_threshold, best_precision_threshold, best_recall_threshold</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>fig, best_f1_threshold, best_precision_threshold, best_recall_threshold <span class="op">=</span> plot_metrics_vs_thresholds(thresholds, f1_scores, precisions, recalls, <span class="st">'Softmax'</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="co"># Threshold values</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>upper_threshold <span class="op">=</span> best_f1_threshold</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a><span class="co"># upper_threshold = best_precision_threshold</span></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a><span class="co"># Classifying OOD examples (sandals)</span></span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a>ood_classifications <span class="op">=</span> softmax_thresh_classifications(ood_probs, upper_threshold)</span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a><span class="co"># Classifying ID examples (T-shirts and pants)</span></span>
<span id="cb19-9"><a href="#cb19-9" tabindex="-1"></a>id_classifications <span class="op">=</span> softmax_thresh_classifications(id_probs, upper_threshold)</span>
<span id="cb19-10"><a href="#cb19-10" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" tabindex="-1"></a><span class="co"># Combine OOD and ID classifications and true labels</span></span>
<span id="cb19-12"><a href="#cb19-12" tabindex="-1"></a>all_predictions <span class="op">=</span> np.concatenate([ood_classifications, id_classifications])</span>
<span id="cb19-13"><a href="#cb19-13" tabindex="-1"></a>all_true_labels <span class="op">=</span> np.concatenate([<span class="op">-</span><span class="dv">1</span> <span class="op">*</span> np.ones(ood_classifications.shape), test_labels])</span>
<span id="cb19-14"><a href="#cb19-14" tabindex="-1"></a></span>
<span id="cb19-15"><a href="#cb19-15" tabindex="-1"></a><span class="co"># Confusion matrix</span></span>
<span id="cb19-16"><a href="#cb19-16" tabindex="-1"></a>cm <span class="op">=</span> confusion_matrix(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb19-17"><a href="#cb19-17" tabindex="-1"></a></span>
<span id="cb19-18"><a href="#cb19-18" tabindex="-1"></a><span class="co"># Plotting the confusion matrix</span></span>
<span id="cb19-19"><a href="#cb19-19" tabindex="-1"></a>disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>cm, display_labels<span class="op">=</span>[<span class="st">"Shirt"</span>, <span class="st">"Pants"</span>, <span class="st">"OOD"</span>])</span>
<span id="cb19-20"><a href="#cb19-20" tabindex="-1"></a>disp.plot(cmap<span class="op">=</span>plt.cm.Blues)</span>
<span id="cb19-21"><a href="#cb19-21" tabindex="-1"></a>plt.title(<span class="st">'Confusion Matrix for OOD and ID Classification'</span>)</span>
<span id="cb19-22"><a href="#cb19-22" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<div class="section level4">
<h4 id="discuss">Discuss<a class="anchor" aria-label="anchor" href="#discuss"></a>
</h4>
<p>How might you use these tools to ensure that a model trained on
health data from hospital A will reliably predict new test data from
hospital B?</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Softmax-based OOD detection uses the model’s output probabilities to
identify instances that do not belong to the training distribution.</li>
<li>Threshold selection is critical and involves trade-offs between
retaining in-distribution data and detecting OOD samples.</li>
<li>Visualizations such as PCA and probability density plots help
illustrate how OOD data overlaps with in-distribution data in feature
space.</li>
<li>While simple and widely used, softmax-based methods have
limitations, including sensitivity to threshold choices and reduced
reliability in high-dimensional settings.</li>
<li>Understanding softmax-based OOD detection lays the groundwork for
exploring more advanced techniques like energy-based detection.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-7c-OOD-detection-energy"><p>Content from <a href="7c-OOD-detection-energy.html">OOD detection: energy</a></p>
<hr>
<p>Last updated on 2024-12-19 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/7c-OOD-detection-energy.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are energy-based methods for out-of-distribution (OOD)
detection, and how do they compare to softmax-based approaches?</li>
<li>How does the energy metric enhance separability between
in-distribution and OOD data?</li>
<li>What are the challenges and limitations of energy-based OOD
detection methods?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand the concept of energy-based OOD detection and its
theoretical foundations.</li>
<li>Compare energy-based methods to softmax-based approaches,
highlighting their strengths and limitations.</li>
<li>Learn how to implement energy-based OOD detection using tools like
PyTorch-OOD.</li>
<li>Explore challenges in applying energy-based methods, including
threshold tuning and generalizability to diverse OOD scenarios.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="example-2-energy-based-ood-detection">Example 2: Energy-Based OOD Detection<a class="anchor" aria-label="anchor" href="#example-2-energy-based-ood-detection"></a>
</h1>
<p>Traditional approaches, such as softmax-based methods, rely on output
probabilities to flag OOD data. While simple and intuitive, these
methods often struggle to distinguish OOD data effectively in complex
scenarios, especially in high-dimensional spaces.</p>
<p>Energy-based OOD detection offers a modern and robust alternative.
This “output-based” approach leverages the <strong>energy
score</strong>, a scalar value derived from a model’s output logits, to
measure the compatibility between input data and the model’s learned
distribution.</p>
<div class="section level3">
<h3 id="understanding-energy-scores">Understanding energy scores<a class="anchor" aria-label="anchor" href="#understanding-energy-scores"></a>
</h3>
<p>To understand energy-based OOD detection, we start by defining the
<strong>energy function E(x)</strong>, which measures how “compatible”
an input x is with a model’s learned distribution.</p>
</div>
<div class="section level3">
<h3 id="energy-function">1. Energy function<a class="anchor" aria-label="anchor" href="#energy-function"></a>
</h3>
<p>For a given input x and output logits f(x) — the raw outputs of a
neural network — the energy of x is defined as:</p>
<p><span class="math display">\[
E(x) = -\log \left( \sum_{k} \exp(f_k(x)) \right)
\]</span></p>
<p>where:<br>
- f_k(x) is the logit corresponding to class k,<br>
- The sum is taken over all classes k.</p>
<p>This equation compresses the logits into a single scalar value: the
energy score.</p>
<ul>
<li>Lower energy E(x) reflects <strong>higher
compatitibility</strong>,<br>
</li>
<li>Higher energy E(x) reflects <strong>lower
compatitibility</strong>.</li>
</ul>
</div>
<div class="section level3">
<h3 id="energy-to-probability">2. Energy to probability<a class="anchor" aria-label="anchor" href="#energy-to-probability"></a>
</h3>
<p>Using the Gibbs distribution, the energy can be converted into a
probability that reflects how likely x is under the model’s learned
distribution. The relationship is:</p>
<p><span class="math display">\[
P(x) \propto \exp(-E(x))
\]</span></p>
<p>Here:<br>
- Lower energy <span class="math inline">\(E(x)\)</span> leads to a
<strong>higher probability</strong>,<br>
- Higher energy <span class="math inline">\(E(x)\)</span> leads to a
<strong>lower probability</strong>.</p>
<p>The exponential relationship ensures that even small differences in
energy values translate to significant changes in probability.</p>
<p>If your stakeholders or downstream tasks require interpretable
confidence scores, a Gibbs-based probability might make the thresholding
process more understandable and adaptable. However, the raw energy
scores can be more sensitive to OOD data since they do not compress
their values between 0 and 1. ### 3. Why energy works better than
softmax</p>
<p>Softmax probabilities are computed as:</p>
<p><span class="math display">\[
P(y = k \mid x) = \frac{\exp(f_k(x))}{ \sum_{j} \exp(f_j(x))}
\]</span></p>
<p>The softmax function normalizes the logits <span class="math inline">\(f(x)\)</span>, squeezing the output into a range
between 0 and 1. While this is useful for interpreting the model’s
predictions as probabilities, it introduces
<strong>overconfidence</strong> for OOD inputs. Specifically: - Even
when none of the logits <span class="math inline">\(f_k(x)\)</span> are
strongly aligned with any class (e.g., low magnitudes for all logits),
softmax still distributes the probabilities across the known classes. -
The normalization ensures the total probability sums to 1, which can
mask the uncertainty by making the scores appear confident for OOD
inputs.</p>
<p>Energy-based methods, on the other hand, do not normalize the logits
into probabilities by default. Instead, the <strong>energy
score</strong> summarizes the raw logits as:</p>
<p><span class="math display">\[
E(x) = -\log \sum_{j} \exp(f_j(x))
\]</span></p>
<div class="section level4">
<h4 id="key-difference-sensitivity-to-logits-no-normalization">Key difference: sensitivity to logits / no normalization<a class="anchor" aria-label="anchor" href="#key-difference-sensitivity-to-logits-no-normalization"></a>
</h4>
<ul>
<li>
<strong>Softmax</strong>: The output probabilities are dominated by
the largest logit relative to the others, even if all logits are small.
This can produce overconfident predictions for OOD data because the
softmax function distributes probabilities across known classes.</li>
<li>
<strong>Energy</strong>: By summarizing the raw logits directly,
energy scores provide a more nuanced view of the model’s uncertainty,
without forcing outputs into an overconfident probability
distribution.</li>
</ul>
</div>
</div>
<div class="section level3">
<h3 id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h3>
<ul>
<li>Energy E(x) directly measures compatibility with the model.<br>
</li>
<li>Lower energy → Higher compatibility (in-distribution),<br>
</li>
<li>Higher energy → Lower compatibility (OOD data).<br>
</li>
<li>The exponential relationship ensures sensitivity to even small
deviations, making energy-based detection more robust than softmax-based
methods.</li>
</ul>
</div>
<div class="section level2">
<h2 id="worked-example-comparing-softmax-and-energy">Worked example: comparing softmax and energy<a class="anchor" aria-label="anchor" href="#worked-example-comparing-softmax-and-energy"></a>
</h2>
<p>In this hands-on example, we’ll repeat the same investigation as
before with a couple of adjustments:</p>
<ul>
<li>Use CNN to train model</li>
<li>Compare both softmax and energy scores with respect to ID and OOD
data. We can do this easily using the PyTorch-OOD library.</li>
</ul>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> accuracy_score</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="im">from</span> keras.datasets <span class="im">import</span> fashion_mnist</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="kw">def</span> prep_ID_OOD_datasests(ID_class_labels, OOD_class_labels):</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="co">    Prepares in-distribution (ID) and out-of-distribution (OOD) datasets </span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="co">    from the Fashion MNIST dataset.</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a><span class="co">    - ID_class_labels: list or array-like, labels for the in-distribution classes.</span></span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a><span class="co">                       Example: [0, 1] for T-shirts (0) and Trousers (1).</span></span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a><span class="co">    - OOD_class_labels: list or array-like, labels for the out-of-distribution classes.</span></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a><span class="co">                        Example: [5] for Sandals.</span></span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a><span class="co">    - train_data: np.array, training images for in-distribution classes.</span></span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a><span class="co">    - test_data: np.array, test images for in-distribution classes.</span></span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a><span class="co">    - ood_data: np.array, test images for out-of-distribution classes.</span></span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a><span class="co">    - train_labels: np.array, labels corresponding to the training images.</span></span>
<span id="cb1-23"><a href="#cb1-23" tabindex="-1"></a><span class="co">    - test_labels: np.array, labels corresponding to the test images.</span></span>
<span id="cb1-24"><a href="#cb1-24" tabindex="-1"></a><span class="co">    - ood_labels: np.array, labels corresponding to the OOD test images.</span></span>
<span id="cb1-25"><a href="#cb1-25" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" tabindex="-1"></a><span class="co">    Notes:</span></span>
<span id="cb1-27"><a href="#cb1-27" tabindex="-1"></a><span class="co">    - The function filters images based on provided class labels for ID and OOD.</span></span>
<span id="cb1-28"><a href="#cb1-28" tabindex="-1"></a><span class="co">    - Outputs include images and their corresponding labels.</span></span>
<span id="cb1-29"><a href="#cb1-29" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-30"><a href="#cb1-30" tabindex="-1"></a>    <span class="co"># Load Fashion MNIST dataset</span></span>
<span id="cb1-31"><a href="#cb1-31" tabindex="-1"></a>    (train_images, train_labels), (test_images, test_labels) <span class="op">=</span> fashion_mnist.load_data()</span>
<span id="cb1-32"><a href="#cb1-32" tabindex="-1"></a>    </span>
<span id="cb1-33"><a href="#cb1-33" tabindex="-1"></a>    <span class="co"># Prepare OOD data: Sandals = 5</span></span>
<span id="cb1-34"><a href="#cb1-34" tabindex="-1"></a>    ood_filter <span class="op">=</span> np.isin(test_labels, OOD_class_labels)</span>
<span id="cb1-35"><a href="#cb1-35" tabindex="-1"></a>    ood_data <span class="op">=</span> test_images[ood_filter]</span>
<span id="cb1-36"><a href="#cb1-36" tabindex="-1"></a>    ood_labels <span class="op">=</span> test_labels[ood_filter]</span>
<span id="cb1-37"><a href="#cb1-37" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'ood_data.shape=</span><span class="sc">{</span>ood_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb1-38"><a href="#cb1-38" tabindex="-1"></a>    </span>
<span id="cb1-39"><a href="#cb1-39" tabindex="-1"></a>    <span class="co"># Filter data for T-shirts (0) and Trousers (1) as in-distribution</span></span>
<span id="cb1-40"><a href="#cb1-40" tabindex="-1"></a>    train_filter <span class="op">=</span> np.isin(train_labels, ID_class_labels)</span>
<span id="cb1-41"><a href="#cb1-41" tabindex="-1"></a>    test_filter <span class="op">=</span> np.isin(test_labels, ID_class_labels)</span>
<span id="cb1-42"><a href="#cb1-42" tabindex="-1"></a>    </span>
<span id="cb1-43"><a href="#cb1-43" tabindex="-1"></a>    train_data <span class="op">=</span> train_images[train_filter]</span>
<span id="cb1-44"><a href="#cb1-44" tabindex="-1"></a>    train_labels <span class="op">=</span> train_labels[train_filter]</span>
<span id="cb1-45"><a href="#cb1-45" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'train_data.shape=</span><span class="sc">{</span>train_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb1-46"><a href="#cb1-46" tabindex="-1"></a>    </span>
<span id="cb1-47"><a href="#cb1-47" tabindex="-1"></a>    test_data <span class="op">=</span> test_images[test_filter]</span>
<span id="cb1-48"><a href="#cb1-48" tabindex="-1"></a>    test_labels <span class="op">=</span> test_labels[test_filter]</span>
<span id="cb1-49"><a href="#cb1-49" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'test_data.shape=</span><span class="sc">{</span>test_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb1-50"><a href="#cb1-50" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" tabindex="-1"></a>    <span class="cf">return</span> train_data, test_data, ood_data, train_labels, test_labels, ood_labels</span>
<span id="cb1-52"><a href="#cb1-52" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" tabindex="-1"></a><span class="kw">def</span> plot_data_sample(train_data, ood_data):</span>
<span id="cb1-55"><a href="#cb1-55" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-56"><a href="#cb1-56" tabindex="-1"></a><span class="co">    Plots a sample of in-distribution and OOD data.</span></span>
<span id="cb1-57"><a href="#cb1-57" tabindex="-1"></a></span>
<span id="cb1-58"><a href="#cb1-58" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb1-59"><a href="#cb1-59" tabindex="-1"></a><span class="co">    - train_data: np.array, array of in-distribution data images</span></span>
<span id="cb1-60"><a href="#cb1-60" tabindex="-1"></a><span class="co">    - ood_data: np.array, array of out-of-distribution data images</span></span>
<span id="cb1-61"><a href="#cb1-61" tabindex="-1"></a></span>
<span id="cb1-62"><a href="#cb1-62" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb1-63"><a href="#cb1-63" tabindex="-1"></a><span class="co">    - fig: matplotlib.figure.Figure, the figure object containing the plots</span></span>
<span id="cb1-64"><a href="#cb1-64" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-65"><a href="#cb1-65" tabindex="-1"></a>    fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb1-66"><a href="#cb1-66" tabindex="-1"></a>    N_samples <span class="op">=</span> <span class="dv">7</span></span>
<span id="cb1-67"><a href="#cb1-67" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N_samples):</span>
<span id="cb1-68"><a href="#cb1-68" tabindex="-1"></a>        plt.subplot(<span class="dv">2</span>, N_samples, i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb1-69"><a href="#cb1-69" tabindex="-1"></a>        plt.imshow(train_data[i], cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb1-70"><a href="#cb1-70" tabindex="-1"></a>        plt.title(<span class="st">"In-Dist"</span>)</span>
<span id="cb1-71"><a href="#cb1-71" tabindex="-1"></a>        plt.axis(<span class="st">'off'</span>)</span>
<span id="cb1-72"><a href="#cb1-72" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N_samples):</span>
<span id="cb1-73"><a href="#cb1-73" tabindex="-1"></a>        plt.subplot(<span class="dv">2</span>, N_samples, i <span class="op">+</span> N_samples<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb1-74"><a href="#cb1-74" tabindex="-1"></a>        plt.imshow(ood_data[i], cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb1-75"><a href="#cb1-75" tabindex="-1"></a>        plt.title(<span class="st">"OOD"</span>)</span>
<span id="cb1-76"><a href="#cb1-76" tabindex="-1"></a>        plt.axis(<span class="st">'off'</span>)</span>
<span id="cb1-77"><a href="#cb1-77" tabindex="-1"></a>    </span>
<span id="cb1-78"><a href="#cb1-78" tabindex="-1"></a>    <span class="cf">return</span> fig</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>train_data, test_data, ood_data, train_labels, test_labels, ood_labels <span class="op">=</span> prep_ID_OOD_datasests([<span class="dv">0</span>,<span class="dv">1</span>], [<span class="dv">5</span>]) <span class="co">#list(range(2,10)) use remaining 8 classes in dataset as OOD</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>fig <span class="op">=</span> plot_data_sample(train_data, ood_data)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
</div>
<div class="section level2">
<h2 id="visualizing-ood-and-id-data">Visualizing OOD and ID data<a class="anchor" aria-label="anchor" href="#visualizing-ood-and-id-data"></a>
</h2>
<div class="section level3">
<h3 id="umap-or-similar">UMAP (or similar)<a class="anchor" aria-label="anchor" href="#umap-or-similar"></a>
</h3>
<p>Recall in our previous example, we used PCA to visualize the ID and
OOD data distributions. This was appropriate given that we were
evaluating OOD/ID data in the context of a linear model. However, when
working with nonlinear models such as CNNs, it makes more sense to
investigate how the data is represented in a nonlinear space. Nonlinear
embedding methods, such as Uniform Manifold Approximation and Projection
(UMAP), are more suitable in such scenarios.</p>
<p>UMAP is a non-linear dimensionality reduction technique that
preserves both the global structure and the local neighborhood
relationships in the data. UMAP is often better at maintaining the
continuity of data points that lie on non-linear manifolds. It can
reveal nonlinear patterns and structures that PCA might miss, making it
a valuable tool for analyzing ID and OOD distributions.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>plot_umap <span class="op">=</span> <span class="va">True</span> </span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="cf">if</span> plot_umap:</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>    <span class="im">import</span> umap</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>    <span class="co"># Flatten images for PCA and logistic regression</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>    train_data_flat <span class="op">=</span> train_data.reshape((train_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>    test_data_flat <span class="op">=</span> test_data.reshape((test_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>    ood_data_flat <span class="op">=</span> ood_data.reshape((ood_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>    </span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'train_data_flat.shape=</span><span class="sc">{</span>train_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'test_data_flat.shape=</span><span class="sc">{</span>test_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'ood_data_flat.shape=</span><span class="sc">{</span>ood_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>    </span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a>    <span class="co"># Perform UMAP to visualize the data</span></span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a>    umap_reducer <span class="op">=</span> umap.UMAP(n_components<span class="op">=</span><span class="dv">2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a>    combined_data <span class="op">=</span> np.vstack([train_data_flat, ood_data_flat])</span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a>    combined_labels <span class="op">=</span> np.hstack([train_labels, np.full(ood_data_flat.shape[<span class="dv">0</span>], <span class="dv">2</span>)])  <span class="co"># Use 2 for OOD class</span></span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a>    </span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a>    umap_results <span class="op">=</span> umap_reducer.fit_transform(combined_data)</span>
<span id="cb3-19"><a href="#cb3-19" tabindex="-1"></a>    </span>
<span id="cb3-20"><a href="#cb3-20" tabindex="-1"></a>    <span class="co"># Split the results back into in-distribution and OOD data</span></span>
<span id="cb3-21"><a href="#cb3-21" tabindex="-1"></a>    umap_in_dist <span class="op">=</span> umap_results[:<span class="bu">len</span>(train_data_flat)]</span>
<span id="cb3-22"><a href="#cb3-22" tabindex="-1"></a>    umap_ood <span class="op">=</span> umap_results[<span class="bu">len</span>(train_data_flat):]</span></code></pre>
</div>
<p>The warning message indicates that UMAP has overridden the n_jobs
parameter to 1 due to the random_state being set. This behavior ensures
reproducibility by using a single job. If you want to avoid the warning
and still use parallelism, you can remove the random_state parameter.
However, removing random_state will mean that the results might not be
reproducible.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="cf">if</span> plot_umap:</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>    umap_alpha <span class="op">=</span> <span class="fl">.1</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>    <span class="co"># Plotting UMAP components</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>    </span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>    <span class="co"># Plot in-distribution data</span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>    scatter1 <span class="op">=</span> plt.scatter(umap_in_dist[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">0</span>], umap_in_dist[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'blue'</span>, label<span class="op">=</span><span class="st">'T-shirts (ID)'</span>, alpha<span class="op">=</span>umap_alpha)</span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>    scatter2 <span class="op">=</span> plt.scatter(umap_in_dist[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">0</span>], umap_in_dist[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'red'</span>, label<span class="op">=</span><span class="st">'Trousers (ID)'</span>, alpha<span class="op">=</span>umap_alpha)</span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a>    </span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a>    <span class="co"># Plot OOD data</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a>    scatter3 <span class="op">=</span> plt.scatter(umap_ood[:, <span class="dv">0</span>], umap_ood[:, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'green'</span>, label<span class="op">=</span><span class="st">'OOD'</span>, edgecolor<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span>umap_alpha)</span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a>    </span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a>    <span class="co"># Create a single legend for all classes</span></span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a>    plt.legend(handles<span class="op">=</span>[scatter1, scatter2, scatter3], loc<span class="op">=</span><span class="st">"upper right"</span>)</span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a>    plt.xlabel(<span class="st">'First UMAP Component'</span>)</span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a>    plt.ylabel(<span class="st">'Second UMAP Component'</span>)</span>
<span id="cb4-18"><a href="#cb4-18" tabindex="-1"></a>    plt.title(<span class="st">'UMAP of In-Distribution and OOD Data'</span>)</span>
<span id="cb4-19"><a href="#cb4-19" tabindex="-1"></a>    plt.show()</span></code></pre>
</div>
<p>With UMAP, we see our data clusters into more meaningful groups
(compared to PCA). Our nonlinear model should hopefully have no problem
separating these three clusters. ### Preparing data for CNN Next, we’ll
prepare our data for a pytorch (torch) CNN.</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="co"># Convert to PyTorch tensors and normalize</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>train_data_tensor <span class="op">=</span> torch.tensor(train_data, dtype<span class="op">=</span>torch.float32).unsqueeze(<span class="dv">1</span>) <span class="op">/</span> <span class="fl">255.0</span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>test_data_tensor <span class="op">=</span> torch.tensor(test_data, dtype<span class="op">=</span>torch.float32).unsqueeze(<span class="dv">1</span>) <span class="op">/</span> <span class="fl">255.0</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>ood_data_tensor <span class="op">=</span> torch.tensor(ood_data, dtype<span class="op">=</span>torch.float32).unsqueeze(<span class="dv">1</span>) <span class="op">/</span> <span class="fl">255.0</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>train_labels_tensor <span class="op">=</span> torch.tensor(train_labels, dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>test_labels_tensor <span class="op">=</span> torch.tensor(test_labels, dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a><span class="co"># TensorDataset provides a convenient way to couple input data with their corresponding labels, making it easier to pass them into a DataLoader.</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a>train_dataset <span class="op">=</span> torch.utils.data.TensorDataset(train_data_tensor, train_labels_tensor)</span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a>test_dataset <span class="op">=</span> torch.utils.data.TensorDataset(test_data_tensor, test_labels_tensor)</span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a>ood_dataset <span class="op">=</span> torch.utils.data.TensorDataset(ood_data_tensor, torch.zeros(ood_data_tensor.shape[<span class="dv">0</span>], dtype<span class="op">=</span>torch.<span class="bu">long</span>))</span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a><span class="co"># DataLoader is used to efficiently load and manage batches of data</span></span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a><span class="co"># - It provides iterators over the data for training/testing.</span></span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a><span class="co"># - Supports options like batch size, shuffling, and parallel data loading</span></span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a>train_loader <span class="op">=</span> torch.utils.data.DataLoader(train_dataset, batch_size<span class="op">=</span><span class="dv">64</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb5-19"><a href="#cb5-19" tabindex="-1"></a>test_loader <span class="op">=</span> torch.utils.data.DataLoader(test_dataset, batch_size<span class="op">=</span><span class="dv">64</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb5-20"><a href="#cb5-20" tabindex="-1"></a>ood_loader <span class="op">=</span> torch.utils.data.DataLoader(ood_dataset, batch_size<span class="op">=</span><span class="dv">64</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="define-cnn-class">Define CNN class<a class="anchor" aria-label="anchor" href="#define-cnn-class"></a>
</h3>
<p>Next, we’ll define a simple Convolutional Neural Network (CNN) to
classify in-distribution (ID) data. This CNN will serve as the backbone
for our experiments, enabling us to analyze its predictions on both ID
and OOD data. The model will include convolutional layers for feature
extraction and fully connected layers for classification.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="co"># Define a simple CNN model</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="kw">class</span> SimpleCNN(nn.Module):</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>        <span class="bu">super</span>(SimpleCNN, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>        <span class="va">self</span>.conv1 <span class="op">=</span> nn.Conv2d(<span class="dv">1</span>, <span class="dv">32</span>, kernel_size<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>        <span class="va">self</span>.conv2 <span class="op">=</span> nn.Conv2d(<span class="dv">32</span>, <span class="dv">64</span>, kernel_size<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>        <span class="va">self</span>.fc1 <span class="op">=</span> nn.Linear(<span class="dv">64</span><span class="op">*</span><span class="dv">5</span><span class="op">*</span><span class="dv">5</span>, <span class="dv">128</span>)  <span class="co"># Updated this line</span></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>        <span class="va">self</span>.fc2 <span class="op">=</span> nn.Linear(<span class="dv">128</span>, <span class="dv">2</span>)</span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a>        x <span class="op">=</span> F.relu(F.max_pool2d(<span class="va">self</span>.conv1(x), <span class="dv">2</span>))</span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a>        x <span class="op">=</span> F.relu(F.max_pool2d(<span class="va">self</span>.conv2(x), <span class="dv">2</span>))</span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a>        x <span class="op">=</span> x.view(<span class="op">-</span><span class="dv">1</span>, <span class="dv">64</span><span class="op">*</span><span class="dv">5</span><span class="op">*</span><span class="dv">5</span>)  <span class="co"># Updated this line</span></span>
<span id="cb6-18"><a href="#cb6-18" tabindex="-1"></a>        x <span class="op">=</span> F.relu(<span class="va">self</span>.fc1(x))</span>
<span id="cb6-19"><a href="#cb6-19" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.fc2(x)</span>
<span id="cb6-20"><a href="#cb6-20" tabindex="-1"></a>        <span class="cf">return</span> x</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">'cpu'</span>)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>model <span class="op">=</span> SimpleCNN().to(device)</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="train-model">Train model<a class="anchor" aria-label="anchor" href="#train-model"></a>
</h3>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="kw">def</span> train_model(model, train_loader, criterion, optimizer, epochs<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="co">    Trains a given PyTorch model using a specified dataset, loss function, and optimizer.</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a><span class="co">    - model (nn.Module): The neural network model to train.</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a><span class="co">    - train_loader (DataLoader): DataLoader object providing the training dataset in batches.</span></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a><span class="co">    - criterion (nn.Module): Loss function used for optimization (e.g., CrossEntropyLoss).</span></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a><span class="co">    - optimizer (torch.optim.Optimizer): Optimizer for adjusting model weights (e.g., Adam, SGD).</span></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a><span class="co">    - epochs (int): Number of training iterations over the entire dataset.</span></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a><span class="co">    - None: Prints the loss for each epoch during training.</span></span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a><span class="co">    Workflow:</span></span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a><span class="co">    1. Iterate over the dataset for the given number of epochs.</span></span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a><span class="co">    2. For each batch, forward propagate inputs, compute the loss, and backpropagate gradients.</span></span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a><span class="co">    3. Update model weights using the optimizer and reset gradients after each step.</span></span>
<span id="cb8-19"><a href="#cb8-19" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb8-20"><a href="#cb8-20" tabindex="-1"></a>    model.train()  <span class="co"># Set the model to training mode</span></span>
<span id="cb8-21"><a href="#cb8-21" tabindex="-1"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(epochs):</span>
<span id="cb8-22"><a href="#cb8-22" tabindex="-1"></a>        running_loss <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb8-23"><a href="#cb8-23" tabindex="-1"></a>        <span class="cf">for</span> inputs, labels <span class="kw">in</span> train_loader:</span>
<span id="cb8-24"><a href="#cb8-24" tabindex="-1"></a>            <span class="co"># Move inputs and labels to the appropriate device (CPU or GPU)</span></span>
<span id="cb8-25"><a href="#cb8-25" tabindex="-1"></a>            inputs, labels <span class="op">=</span> inputs.to(device), labels.to(device)</span>
<span id="cb8-26"><a href="#cb8-26" tabindex="-1"></a>            </span>
<span id="cb8-27"><a href="#cb8-27" tabindex="-1"></a>            <span class="co"># Reset gradients from the previous step to avoid accumulation</span></span>
<span id="cb8-28"><a href="#cb8-28" tabindex="-1"></a>            optimizer.zero_grad()</span>
<span id="cb8-29"><a href="#cb8-29" tabindex="-1"></a>            </span>
<span id="cb8-30"><a href="#cb8-30" tabindex="-1"></a>            <span class="co"># Forward pass: Compute model predictions</span></span>
<span id="cb8-31"><a href="#cb8-31" tabindex="-1"></a>            outputs <span class="op">=</span> model(inputs)</span>
<span id="cb8-32"><a href="#cb8-32" tabindex="-1"></a>            </span>
<span id="cb8-33"><a href="#cb8-33" tabindex="-1"></a>            <span class="co"># Compute the loss between predictions and true labels</span></span>
<span id="cb8-34"><a href="#cb8-34" tabindex="-1"></a>            loss <span class="op">=</span> criterion(outputs, labels)</span>
<span id="cb8-35"><a href="#cb8-35" tabindex="-1"></a>            </span>
<span id="cb8-36"><a href="#cb8-36" tabindex="-1"></a>            <span class="co"># Backward pass: Compute gradients of the loss w.r.t. model parameters</span></span>
<span id="cb8-37"><a href="#cb8-37" tabindex="-1"></a>            loss.backward()</span>
<span id="cb8-38"><a href="#cb8-38" tabindex="-1"></a>            </span>
<span id="cb8-39"><a href="#cb8-39" tabindex="-1"></a>            <span class="co"># Update model weights using gradients and optimizer rules</span></span>
<span id="cb8-40"><a href="#cb8-40" tabindex="-1"></a>            optimizer.step()</span>
<span id="cb8-41"><a href="#cb8-41" tabindex="-1"></a>            </span>
<span id="cb8-42"><a href="#cb8-42" tabindex="-1"></a>            <span class="co"># Accumulate the batch loss for reporting</span></span>
<span id="cb8-43"><a href="#cb8-43" tabindex="-1"></a>            running_loss <span class="op">+=</span> loss.item()</span>
<span id="cb8-44"><a href="#cb8-44" tabindex="-1"></a>        </span>
<span id="cb8-45"><a href="#cb8-45" tabindex="-1"></a>        <span class="co"># Print the average loss for the current epoch</span></span>
<span id="cb8-46"><a href="#cb8-46" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f'Epoch </span><span class="sc">{</span>epoch<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">, Loss: </span><span class="sc">{</span>running_loss<span class="op">/</span><span class="bu">len</span>(train_loader)<span class="sc">}</span><span class="ss">'</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>criterion <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>optimizer <span class="op">=</span> optim.Adam(model.parameters(), lr<span class="op">=</span><span class="fl">0.001</span>)</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>train_model(model, train_loader, criterion, optimizer)</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="evaluate-the-model">Evaluate the model<a class="anchor" aria-label="anchor" href="#evaluate-the-model"></a>
</h3>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> confusion_matrix, ConfusionMatrixDisplay</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="co"># Function to plot confusion matrix</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="kw">def</span> plot_confusion_matrix(labels, predictions, title):</span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a><span class="co">    Plots a confusion matrix for a classification task.</span></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a><span class="co">    - labels (array-like): True labels for the dataset.</span></span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a><span class="co">    - predictions (array-like): Model-predicted labels.</span></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a><span class="co">    - title (str): Title for the confusion matrix plot.</span></span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a><span class="co">    - None: Displays the confusion matrix plot.</span></span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a>    <span class="co"># Compute the confusion matrix</span></span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a>    cm <span class="op">=</span> confusion_matrix(labels, predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a>    </span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a>    <span class="co"># Create a display object for the confusion matrix</span></span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a>    disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>cm, display_labels<span class="op">=</span>[<span class="st">"T-shirt/top"</span>, <span class="st">"Trouser"</span>])</span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a>    </span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a>    <span class="co"># Plot the confusion matrix with a color map</span></span>
<span id="cb10-26"><a href="#cb10-26" tabindex="-1"></a>    disp.plot(cmap<span class="op">=</span>plt.cm.Blues)</span>
<span id="cb10-27"><a href="#cb10-27" tabindex="-1"></a>    plt.title(title)</span>
<span id="cb10-28"><a href="#cb10-28" tabindex="-1"></a>    plt.show()</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="co"># Function to evaluate the model on a given dataset</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="kw">def</span> evaluate_model(model, dataloader, device):</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="co">    Evaluates a PyTorch model on a given dataset.</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a><span class="co">    - model (torch.nn.Module): The trained PyTorch model to evaluate.</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a><span class="co">    - dataloader (torch.utils.data.DataLoader): DataLoader object providing the dataset in batches.</span></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a><span class="co">    - device (torch.device): Device on which to perform the evaluation (CPU or GPU).</span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a><span class="co">    - all_labels (np.array): True labels for the entire dataset.</span></span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a><span class="co">    - all_predictions (np.array): Model predictions for the entire dataset.</span></span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a>    model.<span class="bu">eval</span>()  <span class="co"># Set the model to evaluation mode</span></span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a>    all_labels <span class="op">=</span> []  <span class="co"># To store true labels</span></span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a>    all_predictions <span class="op">=</span> []  <span class="co"># To store model predictions</span></span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a>    </span>
<span id="cb11-19"><a href="#cb11-19" tabindex="-1"></a>    <span class="co"># Disable gradient computation during evaluation</span></span>
<span id="cb11-20"><a href="#cb11-20" tabindex="-1"></a>    <span class="cf">with</span> torch.no_grad():</span>
<span id="cb11-21"><a href="#cb11-21" tabindex="-1"></a>        <span class="cf">for</span> inputs, labels <span class="kw">in</span> dataloader:</span>
<span id="cb11-22"><a href="#cb11-22" tabindex="-1"></a>            <span class="co"># Move inputs and labels to the specified device</span></span>
<span id="cb11-23"><a href="#cb11-23" tabindex="-1"></a>            inputs, labels <span class="op">=</span> inputs.to(device), labels.to(device)</span>
<span id="cb11-24"><a href="#cb11-24" tabindex="-1"></a>            </span>
<span id="cb11-25"><a href="#cb11-25" tabindex="-1"></a>            <span class="co"># Forward pass to get model outputs</span></span>
<span id="cb11-26"><a href="#cb11-26" tabindex="-1"></a>            outputs <span class="op">=</span> model(inputs)</span>
<span id="cb11-27"><a href="#cb11-27" tabindex="-1"></a>            </span>
<span id="cb11-28"><a href="#cb11-28" tabindex="-1"></a>            <span class="co"># Get predicted class labels (index with the highest probability)</span></span>
<span id="cb11-29"><a href="#cb11-29" tabindex="-1"></a>            _, preds <span class="op">=</span> torch.<span class="bu">max</span>(outputs, <span class="dv">1</span>)</span>
<span id="cb11-30"><a href="#cb11-30" tabindex="-1"></a>            </span>
<span id="cb11-31"><a href="#cb11-31" tabindex="-1"></a>            <span class="co"># Append true labels and predictions to the lists</span></span>
<span id="cb11-32"><a href="#cb11-32" tabindex="-1"></a>            all_labels.extend(labels.cpu().numpy())</span>
<span id="cb11-33"><a href="#cb11-33" tabindex="-1"></a>            all_predictions.extend(preds.cpu().numpy())</span>
<span id="cb11-34"><a href="#cb11-34" tabindex="-1"></a>    </span>
<span id="cb11-35"><a href="#cb11-35" tabindex="-1"></a>    <span class="co"># Convert lists to NumPy arrays for easier processing</span></span>
<span id="cb11-36"><a href="#cb11-36" tabindex="-1"></a>    <span class="cf">return</span> np.array(all_labels), np.array(all_predictions)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="co"># Evaluate the model on the test dataset</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>test_labels, test_predictions <span class="op">=</span> evaluate_model(model, test_loader, device)</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="co"># Plot confusion matrix for test dataset</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>plot_confusion_matrix(test_labels, test_predictions, <span class="st">"Confusion Matrix for Test Data"</span>)</span></code></pre>
</div>
<div class="section level4">
<h4 id="comparing-softmax-vs-energy-scores">Comparing softmax vs energy scores<a class="anchor" aria-label="anchor" href="#comparing-softmax-vs-energy-scores"></a>
</h4>
<p>Let’s take a look at both the softmax and energy scores generated by
both the ID test set and the OOD data we extracted earlier.</p>
<p>With PyTorch-OOD, we can easily calculate both measures.</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="co"># 1. Computing softmax scores</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="im">from</span> pytorch_ood.detector <span class="im">import</span> MaxSoftmax</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="co"># Initialize the softmax-based OOD detector</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>softmax_detector <span class="op">=</span> MaxSoftmax(model)</span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="co"># Compute softmax scores</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a><span class="kw">def</span> get_OOD_scores(detector, dataloader):</span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="co">    Computes softmax-based scores for a given OOD detector and dataset.</span></span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a><span class="co">    - detector: An initialized OOD detector (e.g., MaxSoftmax).</span></span>
<span id="cb13-14"><a href="#cb13-14" tabindex="-1"></a><span class="co">    - dataloader: DataLoader providing the dataset for which scores are to be computed.</span></span>
<span id="cb13-15"><a href="#cb13-15" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb13-17"><a href="#cb13-17" tabindex="-1"></a><span class="co">    - scores: A NumPy array of softmax scores for all data points.</span></span>
<span id="cb13-18"><a href="#cb13-18" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb13-19"><a href="#cb13-19" tabindex="-1"></a>    scores <span class="op">=</span> []</span>
<span id="cb13-20"><a href="#cb13-20" tabindex="-1"></a>    detector.model.<span class="bu">eval</span>()  <span class="co"># Ensure the model is in evaluation mode</span></span>
<span id="cb13-21"><a href="#cb13-21" tabindex="-1"></a>    <span class="cf">with</span> torch.no_grad():  <span class="co"># Disable gradient computation for efficiency</span></span>
<span id="cb13-22"><a href="#cb13-22" tabindex="-1"></a>        <span class="cf">for</span> inputs, _ <span class="kw">in</span> dataloader:</span>
<span id="cb13-23"><a href="#cb13-23" tabindex="-1"></a>            inputs <span class="op">=</span> inputs.to(device)  <span class="co"># Move inputs to the correct device</span></span>
<span id="cb13-24"><a href="#cb13-24" tabindex="-1"></a>            score <span class="op">=</span> detector.predict(inputs)  <span class="co"># Get the max softmax score</span></span>
<span id="cb13-25"><a href="#cb13-25" tabindex="-1"></a>            scores.extend(score.cpu().numpy())  <span class="co"># Move scores to CPU and convert to NumPy array</span></span>
<span id="cb13-26"><a href="#cb13-26" tabindex="-1"></a>    <span class="cf">return</span> np.array(scores)</span>
<span id="cb13-27"><a href="#cb13-27" tabindex="-1"></a></span>
<span id="cb13-28"><a href="#cb13-28" tabindex="-1"></a><span class="co"># Compute softmax scores for ID and OOD data</span></span>
<span id="cb13-29"><a href="#cb13-29" tabindex="-1"></a>id_softmax_scores <span class="op">=</span> get_OOD_scores(softmax_detector, test_loader)</span>
<span id="cb13-30"><a href="#cb13-30" tabindex="-1"></a>ood_softmax_scores <span class="op">=</span> get_OOD_scores(softmax_detector, ood_loader)</span>
<span id="cb13-31"><a href="#cb13-31" tabindex="-1"></a></span>
<span id="cb13-32"><a href="#cb13-32" tabindex="-1"></a>id_softmax_scores <span class="co"># values are negative to align with other OOD measures, such as energy (more negative is better)</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="co"># 2. Computing energy</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a><span class="im">from</span> pytorch_ood.detector <span class="im">import</span> EnergyBased</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="co"># Initialize the energy-based OOD detector</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>energy_detector <span class="op">=</span> EnergyBased(model)</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>id_energy_scores <span class="op">=</span> get_OOD_scores(energy_detector, test_loader)</span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a>ood_energy_scores <span class="op">=</span> get_OOD_scores(energy_detector, ood_loader)</span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>id_energy_scores</span></code></pre>
</div>
</div>
</div>
<div class="section level3">
<h3 id="plot-probability-densities">Plot probability densities<a class="anchor" aria-label="anchor" href="#plot-probability-densities"></a>
</h3>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> gaussian_kde</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="co"># Plot PSDs</span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a><span class="co"># Function to plot PSD</span></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a><span class="kw">def</span> plot_psd(id_scores, ood_scores, method_name):</span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a>    alpha <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a>    <span class="co"># Plot PSD for ID scores</span></span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a>    id_density <span class="op">=</span> gaussian_kde(id_scores)</span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a>    x_id <span class="op">=</span> np.linspace(id_scores.<span class="bu">min</span>(), id_scores.<span class="bu">max</span>(), <span class="dv">1000</span>)</span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a>    plt.plot(x_id, id_density(x_id), label<span class="op">=</span><span class="ss">f'ID (</span><span class="sc">{</span>method_name<span class="sc">}</span><span class="ss">)'</span>, color<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb15-15"><a href="#cb15-15" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" tabindex="-1"></a>    <span class="co"># Plot PSD for OOD scores</span></span>
<span id="cb15-17"><a href="#cb15-17" tabindex="-1"></a>    ood_density <span class="op">=</span> gaussian_kde(ood_scores)</span>
<span id="cb15-18"><a href="#cb15-18" tabindex="-1"></a>    x_ood <span class="op">=</span> np.linspace(ood_scores.<span class="bu">min</span>(), ood_scores.<span class="bu">max</span>(), <span class="dv">1000</span>)</span>
<span id="cb15-19"><a href="#cb15-19" tabindex="-1"></a>    plt.plot(x_ood, ood_density(x_ood), label<span class="op">=</span><span class="ss">f'OOD (</span><span class="sc">{</span>method_name<span class="sc">}</span><span class="ss">)'</span>, color<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb15-20"><a href="#cb15-20" tabindex="-1"></a></span>
<span id="cb15-21"><a href="#cb15-21" tabindex="-1"></a>    plt.xlabel(<span class="st">'Score'</span>)</span>
<span id="cb15-22"><a href="#cb15-22" tabindex="-1"></a>    plt.ylabel(<span class="st">'Density'</span>)</span>
<span id="cb15-23"><a href="#cb15-23" tabindex="-1"></a>    plt.title(<span class="ss">f'Probability Density Distributions for </span><span class="sc">{</span>method_name<span class="sc">}</span><span class="ss"> Scores'</span>)</span>
<span id="cb15-24"><a href="#cb15-24" tabindex="-1"></a>    plt.legend()</span>
<span id="cb15-25"><a href="#cb15-25" tabindex="-1"></a>    plt.show()</span>
<span id="cb15-26"><a href="#cb15-26" tabindex="-1"></a></span>
<span id="cb15-27"><a href="#cb15-27" tabindex="-1"></a><span class="co"># Plot PSD for softmax scores</span></span>
<span id="cb15-28"><a href="#cb15-28" tabindex="-1"></a>plot_psd(id_softmax_scores, ood_softmax_scores, <span class="st">'Softmax'</span>)</span>
<span id="cb15-29"><a href="#cb15-29" tabindex="-1"></a></span>
<span id="cb15-30"><a href="#cb15-30" tabindex="-1"></a><span class="co"># Plot PSD for energy scores</span></span>
<span id="cb15-31"><a href="#cb15-31" tabindex="-1"></a>plot_psd(id_energy_scores, ood_energy_scores, <span class="st">'Energy'</span>)</span></code></pre>
</div>
</div>
</div>
<div class="section level2">
<h2 id="recap-and-limitations">Recap and limitations<a class="anchor" aria-label="anchor" href="#recap-and-limitations"></a>
</h2>
<p>The energy-based approach for out-of-distribution (OOD) detection has
several strengths, particularly its ability to effectively separate
in-distribution (ID) and OOD data by leveraging the raw logits of a
model. However, it is not without limitations. Here are the key
drawbacks:</p>
<ol style="list-style-type: decimal">
<li>Dependence on well-defined classes: Energy scores rely on logits
that correspond to clearly defined classes in the model. If the model’s
logits are not well-calibrated or if the task involves ambiguous or
overlapping classes, the energy scores may not provide reliable OOD
separation.</li>
<li>Energy thresholds tuned on one dataset may not generalize well to
other datasets or domains (depending on how expansive/variable your OOD
calibration set is)</li>
</ol>
</div>
<div class="section level2">
<h2 id="references-and-supplemental-resources">References and supplemental resources<a class="anchor" aria-label="anchor" href="#references-and-supplemental-resources"></a>
</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=hgLC9_9ZCJI" class="external-link uri">https://www.youtube.com/watch?v=hgLC9_9ZCJI</a></li>
<li>Generalized Out-of-Distribution Detection: A Survey: <a href="https://arxiv.org/abs/2110.11334" class="external-link uri">https://arxiv.org/abs/2110.11334</a>
</li>
</ul>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Energy-based OOD detection is a modern and more robust alternative
to softmax-based methods, leveraging energy scores to improve
separability between in-distribution and OOD data.</li>
<li>By calculating an energy value for each input, these methods provide
a more nuanced measure of compatibility between data and the model’s
learned distribution.</li>
<li>Non-linear visualizations, like UMAP, offer better insights into how
OOD and ID data are represented in high-dimensional feature spaces
compared to linear methods like PCA.</li>
<li>PyTorch-OOD simplifies the implementation of energy-based and other
OOD detection methods, making it accessible for real-world
applications.</li>
<li>While energy-based methods excel in many scenarios, challenges
include tuning thresholds across diverse OOD classes and ensuring
generalizability to unseen distributions.</li>
<li>Transitioning to energy-based detection lays the groundwork for
exploring training-time regularization and hybrid approaches.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div></section><section id="aio-7d-OOD-detection-distance"><p>Content from <a href="7d-OOD-detection-distance.html">OOD detection: distance-based</a></p>
<hr>
<p>Last updated on 2024-12-19 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/7d-OOD-detection-distance.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 40 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How do distance-based methods like Mahalanobis distance and KNN work
for OOD detection?</li>
<li>What is contrastive learning and how does it improve feature
representations?</li>
<li>How does contrastive learning enhance the effectiveness of
distance-based OOD detection methods?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Gain a thorough understanding of distance-based OOD detection
methods, including Mahalanobis distance and KNN.</li>
<li>Learn the principles of contrastive learning and its role in
improving feature representations.</li>
<li>Explore the synergy between contrastive learning and distance-based
OOD detection methods to enhance detection performance.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h3>
<p>Distance-based Out-of-Distribution (OOD) detection relies on
measuring the proximity of a data point to the training data’s feature
space. Unlike threshold-based methods such as softmax or energy,
distance-based approaches compute the similarity of the feature
representation of an input to the known classes’ clusters.</p>
</div>
<div class="section level3">
<h3 id="advantages">Advantages<a class="anchor" aria-label="anchor" href="#advantages"></a>
</h3>
<ul>
<li>
<strong>Class-agnostic</strong>: Can detect OOD data regardless of
the class label.</li>
<li>
<strong>Highly interpretable</strong>: Uses well-defined
mathematical distances like Euclidean or Mahalanobis.</li>
</ul>
</div>
<div class="section level3">
<h3 id="disadvantages">Disadvantages<a class="anchor" aria-label="anchor" href="#disadvantages"></a>
</h3>
<ul>
<li>
<strong>Requires feature extraction</strong>: Needs a model that
produces meaningful embeddings.</li>
<li>
<strong>Computationally intensive</strong>: Calculating distances
can be expensive, especially with high-dimensional embeddings.</li>
</ul>
<p>We will use the Mahalanobis distance as the core metric in this
notebook. ### Mahalanobis Distance The Mahalanobis distance measures the
distance of a point from a distribution, accounting for the variance and
correlations of the data:</p>
<p><span class="math display">\[
D_M(x) = \sqrt{(x - \mu)^T \Sigma^{-1} (x - \mu)}
\]</span> where: - x: The input data point. - <span class="math inline">\(mu\)</span>: The mean vector of the distribution.
- Sigma: The covariance matrix of the distribution. The inverse of the
covariance matrix is used to “whiten” the feature space, ensuring that
features with larger variances do not dominate the distance computation.
This adjustment also accounts for correlations between features,
transforming the data into a space where all features are uncorrelated
and standardized. This approach is robust for high-dimensional data as
it accounts for correlations between features.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> accuracy_score</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="im">from</span> keras.datasets <span class="im">import</span> fashion_mnist</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="kw">def</span> prep_ID_OOD_datasests(ID_class_labels, OOD_class_labels):</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="co">    Prepares in-distribution (ID) and out-of-distribution (OOD) datasets </span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="co">    from the Fashion MNIST dataset.</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a><span class="co">    - ID_class_labels: list or array-like, labels for the in-distribution classes.</span></span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a><span class="co">                       Example: [0, 1] for T-shirts (0) and Trousers (1).</span></span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a><span class="co">    - OOD_class_labels: list or array-like, labels for the out-of-distribution classes.</span></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a><span class="co">                        Example: [5] for Sandals.</span></span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a><span class="co">    - train_data: np.array, training images for in-distribution classes.</span></span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a><span class="co">    - test_data: np.array, test images for in-distribution classes.</span></span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a><span class="co">    - ood_data: np.array, test images for out-of-distribution classes.</span></span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a><span class="co">    - train_labels: np.array, labels corresponding to the training images.</span></span>
<span id="cb1-23"><a href="#cb1-23" tabindex="-1"></a><span class="co">    - test_labels: np.array, labels corresponding to the test images.</span></span>
<span id="cb1-24"><a href="#cb1-24" tabindex="-1"></a><span class="co">    - ood_labels: np.array, labels corresponding to the OOD test images.</span></span>
<span id="cb1-25"><a href="#cb1-25" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" tabindex="-1"></a><span class="co">    Notes:</span></span>
<span id="cb1-27"><a href="#cb1-27" tabindex="-1"></a><span class="co">    - The function filters images based on provided class labels for ID and OOD.</span></span>
<span id="cb1-28"><a href="#cb1-28" tabindex="-1"></a><span class="co">    - Outputs include images and their corresponding labels.</span></span>
<span id="cb1-29"><a href="#cb1-29" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-30"><a href="#cb1-30" tabindex="-1"></a>    <span class="co"># Load Fashion MNIST dataset</span></span>
<span id="cb1-31"><a href="#cb1-31" tabindex="-1"></a>    (train_images, train_labels), (test_images, test_labels) <span class="op">=</span> fashion_mnist.load_data()</span>
<span id="cb1-32"><a href="#cb1-32" tabindex="-1"></a>    </span>
<span id="cb1-33"><a href="#cb1-33" tabindex="-1"></a>    <span class="co"># Prepare OOD data: Sandals = 5</span></span>
<span id="cb1-34"><a href="#cb1-34" tabindex="-1"></a>    ood_filter <span class="op">=</span> np.isin(test_labels, OOD_class_labels)</span>
<span id="cb1-35"><a href="#cb1-35" tabindex="-1"></a>    ood_data <span class="op">=</span> test_images[ood_filter]</span>
<span id="cb1-36"><a href="#cb1-36" tabindex="-1"></a>    ood_labels <span class="op">=</span> test_labels[ood_filter]</span>
<span id="cb1-37"><a href="#cb1-37" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'ood_data.shape=</span><span class="sc">{</span>ood_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb1-38"><a href="#cb1-38" tabindex="-1"></a>    </span>
<span id="cb1-39"><a href="#cb1-39" tabindex="-1"></a>    <span class="co"># Filter data for T-shirts (0) and Trousers (1) as in-distribution</span></span>
<span id="cb1-40"><a href="#cb1-40" tabindex="-1"></a>    train_filter <span class="op">=</span> np.isin(train_labels, ID_class_labels)</span>
<span id="cb1-41"><a href="#cb1-41" tabindex="-1"></a>    test_filter <span class="op">=</span> np.isin(test_labels, ID_class_labels)</span>
<span id="cb1-42"><a href="#cb1-42" tabindex="-1"></a>    </span>
<span id="cb1-43"><a href="#cb1-43" tabindex="-1"></a>    train_data <span class="op">=</span> train_images[train_filter]</span>
<span id="cb1-44"><a href="#cb1-44" tabindex="-1"></a>    train_labels <span class="op">=</span> train_labels[train_filter]</span>
<span id="cb1-45"><a href="#cb1-45" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'train_data.shape=</span><span class="sc">{</span>train_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb1-46"><a href="#cb1-46" tabindex="-1"></a>    </span>
<span id="cb1-47"><a href="#cb1-47" tabindex="-1"></a>    test_data <span class="op">=</span> test_images[test_filter]</span>
<span id="cb1-48"><a href="#cb1-48" tabindex="-1"></a>    test_labels <span class="op">=</span> test_labels[test_filter]</span>
<span id="cb1-49"><a href="#cb1-49" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'test_data.shape=</span><span class="sc">{</span>test_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb1-50"><a href="#cb1-50" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" tabindex="-1"></a>    <span class="cf">return</span> train_data, test_data, ood_data, train_labels, test_labels, ood_labels</span>
<span id="cb1-52"><a href="#cb1-52" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" tabindex="-1"></a><span class="kw">def</span> plot_data_sample(train_data, ood_data):</span>
<span id="cb1-55"><a href="#cb1-55" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-56"><a href="#cb1-56" tabindex="-1"></a><span class="co">    Plots a sample of in-distribution and OOD data.</span></span>
<span id="cb1-57"><a href="#cb1-57" tabindex="-1"></a></span>
<span id="cb1-58"><a href="#cb1-58" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb1-59"><a href="#cb1-59" tabindex="-1"></a><span class="co">    - train_data: np.array, array of in-distribution data images</span></span>
<span id="cb1-60"><a href="#cb1-60" tabindex="-1"></a><span class="co">    - ood_data: np.array, array of out-of-distribution data images</span></span>
<span id="cb1-61"><a href="#cb1-61" tabindex="-1"></a></span>
<span id="cb1-62"><a href="#cb1-62" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb1-63"><a href="#cb1-63" tabindex="-1"></a><span class="co">    - fig: matplotlib.figure.Figure, the figure object containing the plots</span></span>
<span id="cb1-64"><a href="#cb1-64" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-65"><a href="#cb1-65" tabindex="-1"></a>    fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb1-66"><a href="#cb1-66" tabindex="-1"></a>    N_samples <span class="op">=</span> <span class="dv">7</span></span>
<span id="cb1-67"><a href="#cb1-67" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N_samples):</span>
<span id="cb1-68"><a href="#cb1-68" tabindex="-1"></a>        plt.subplot(<span class="dv">2</span>, N_samples, i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb1-69"><a href="#cb1-69" tabindex="-1"></a>        plt.imshow(train_data[i], cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb1-70"><a href="#cb1-70" tabindex="-1"></a>        plt.title(<span class="st">"In-Dist"</span>)</span>
<span id="cb1-71"><a href="#cb1-71" tabindex="-1"></a>        plt.axis(<span class="st">'off'</span>)</span>
<span id="cb1-72"><a href="#cb1-72" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N_samples):</span>
<span id="cb1-73"><a href="#cb1-73" tabindex="-1"></a>        plt.subplot(<span class="dv">2</span>, N_samples, i <span class="op">+</span> N_samples<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb1-74"><a href="#cb1-74" tabindex="-1"></a>        plt.imshow(ood_data[i], cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb1-75"><a href="#cb1-75" tabindex="-1"></a>        plt.title(<span class="st">"OOD"</span>)</span>
<span id="cb1-76"><a href="#cb1-76" tabindex="-1"></a>        plt.axis(<span class="st">'off'</span>)</span>
<span id="cb1-77"><a href="#cb1-77" tabindex="-1"></a>    </span>
<span id="cb1-78"><a href="#cb1-78" tabindex="-1"></a>    <span class="cf">return</span> fig</span>
<span id="cb1-79"><a href="#cb1-79" tabindex="-1"></a></span>
<span id="cb1-80"><a href="#cb1-80" tabindex="-1"></a>train_data, test_data, ood_data, train_labels, test_labels, ood_labels <span class="op">=</span> prep_ID_OOD_datasests([<span class="dv">0</span>,<span class="dv">1</span>], [<span class="dv">5</span>]) <span class="co">#list(range(2,10)) use remaining 8 classes in dataset as OOD</span></span>
<span id="cb1-81"><a href="#cb1-81" tabindex="-1"></a>fig <span class="op">=</span> plot_data_sample(train_data, ood_data)</span>
<span id="cb1-82"><a href="#cb1-82" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="preparing-data-for-cnn">Preparing data for CNN<a class="anchor" aria-label="anchor" href="#preparing-data-for-cnn"></a>
</h3>
<p>Next, we’ll prepare our data for a pytorch (torch) CNN.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="co"># Convert to PyTorch tensors and normalize</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>train_data_tensor <span class="op">=</span> torch.tensor(train_data, dtype<span class="op">=</span>torch.float32).unsqueeze(<span class="dv">1</span>) <span class="op">/</span> <span class="fl">255.0</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>test_data_tensor <span class="op">=</span> torch.tensor(test_data, dtype<span class="op">=</span>torch.float32).unsqueeze(<span class="dv">1</span>) <span class="op">/</span> <span class="fl">255.0</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>ood_data_tensor <span class="op">=</span> torch.tensor(ood_data, dtype<span class="op">=</span>torch.float32).unsqueeze(<span class="dv">1</span>) <span class="op">/</span> <span class="fl">255.0</span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>train_labels_tensor <span class="op">=</span> torch.tensor(train_labels, dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>test_labels_tensor <span class="op">=</span> torch.tensor(test_labels, dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a><span class="co"># TensorDataset provides a convenient way to couple input data with their corresponding labels, making it easier to pass them into a DataLoader.</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>train_dataset <span class="op">=</span> torch.utils.data.TensorDataset(train_data_tensor, train_labels_tensor)</span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a>test_dataset <span class="op">=</span> torch.utils.data.TensorDataset(test_data_tensor, test_labels_tensor)</span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a>ood_dataset <span class="op">=</span> torch.utils.data.TensorDataset(ood_data_tensor, torch.zeros(ood_data_tensor.shape[<span class="dv">0</span>], dtype<span class="op">=</span>torch.<span class="bu">long</span>))</span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a><span class="co"># DataLoader is used to efficiently load and manage batches of data</span></span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a><span class="co"># - It provides iterators over the data for training/testing.</span></span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a><span class="co"># - Supports options like batch size, shuffling, and parallel data loading</span></span>
<span id="cb2-18"><a href="#cb2-18" tabindex="-1"></a>train_loader <span class="op">=</span> torch.utils.data.DataLoader(train_dataset, batch_size<span class="op">=</span><span class="dv">64</span>, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-19"><a href="#cb2-19" tabindex="-1"></a>test_loader <span class="op">=</span> torch.utils.data.DataLoader(test_dataset, batch_size<span class="op">=</span><span class="dv">64</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-20"><a href="#cb2-20" tabindex="-1"></a>ood_loader <span class="op">=</span> torch.utils.data.DataLoader(ood_dataset, batch_size<span class="op">=</span><span class="dv">64</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="define-cnn-class">Define CNN class<a class="anchor" aria-label="anchor" href="#define-cnn-class"></a>
</h3>
<p>Next, we’ll define a simple Convolutional Neural Network (CNN) to
classify in-distribution (ID) data. This CNN will serve as the backbone
for our experiments, enabling us to analyze its predictions on both ID
and OOD data. The model will include convolutional layers for feature
extraction and fully connected layers for classification.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="co"># Define a simple CNN model</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="kw">class</span> SimpleCNN(nn.Module):</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>        <span class="bu">super</span>(SimpleCNN, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>        <span class="co"># First convolutional layer:</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>        <span class="co"># Input channels = 1 (grayscale images), output channels = 32, kernel size = 3x3</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>        <span class="co"># Output size after conv1: (32, H-2, W-2) due to 3x3 kernel (reduces spatial dimensions by 2 in each direction)</span></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a>        <span class="va">self</span>.conv1 <span class="op">=</span> nn.Conv2d(<span class="dv">1</span>, <span class="dv">32</span>, kernel_size<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a>        <span class="co"># Second convolutional layer:</span></span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a>        <span class="co"># Input channels = 32, output channels = 64, kernel size = 3x3</span></span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a>        <span class="co"># Output size after conv2: (64, H-4, W-4) due to two 3x3 kernels</span></span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a>        <span class="va">self</span>.conv2 <span class="op">=</span> nn.Conv2d(<span class="dv">32</span>, <span class="dv">64</span>, kernel_size<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a>        <span class="co"># Fully connected layer (penultimate layer):</span></span>
<span id="cb3-19"><a href="#cb3-19" tabindex="-1"></a>        <span class="co"># Input size = 64 * 5 * 5, output size = 30</span></span>
<span id="cb3-20"><a href="#cb3-20" tabindex="-1"></a>        <span class="co"># 5x5 is derived from input image size (28x28) reduced by two 3x3 kernels and two 2x2 max-pooling operations</span></span>
<span id="cb3-21"><a href="#cb3-21" tabindex="-1"></a>        <span class="va">self</span>.fc1 <span class="op">=</span> nn.Linear(<span class="dv">64</span> <span class="op">*</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span>, <span class="dv">30</span>)</span>
<span id="cb3-22"><a href="#cb3-22" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" tabindex="-1"></a>        <span class="co"># Final fully connected layer (classification layer):</span></span>
<span id="cb3-24"><a href="#cb3-24" tabindex="-1"></a>        <span class="co"># Input size = 128 (penultimate layer output), output size = 2 (binary classification)</span></span>
<span id="cb3-25"><a href="#cb3-25" tabindex="-1"></a>        <span class="va">self</span>.fc2 <span class="op">=</span> nn.Linear(<span class="dv">30</span>, <span class="dv">2</span>)</span>
<span id="cb3-26"><a href="#cb3-26" tabindex="-1"></a></span>
<span id="cb3-27"><a href="#cb3-27" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb3-28"><a href="#cb3-28" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb3-29"><a href="#cb3-29" tabindex="-1"></a><span class="co">        Defines the forward pass of the model.</span></span>
<span id="cb3-30"><a href="#cb3-30" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb3-31"><a href="#cb3-31" tabindex="-1"></a><span class="co">        Parameters:</span></span>
<span id="cb3-32"><a href="#cb3-32" tabindex="-1"></a><span class="co">        - x: Input tensor of shape (batch_size, channels, height, width), e.g., (64, 1, 28, 28) for grayscale images.</span></span>
<span id="cb3-33"><a href="#cb3-33" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb3-34"><a href="#cb3-34" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb3-35"><a href="#cb3-35" tabindex="-1"></a><span class="co">        - logits: Output tensor of shape (batch_size, num_classes), e.g., (64, 2).</span></span>
<span id="cb3-36"><a href="#cb3-36" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb3-37"><a href="#cb3-37" tabindex="-1"></a></span>
<span id="cb3-38"><a href="#cb3-38" tabindex="-1"></a>        <span class="co"># Apply first convolutional layer followed by ReLU and 2x2 max-pooling</span></span>
<span id="cb3-39"><a href="#cb3-39" tabindex="-1"></a>        <span class="co"># Input size: (batch_size, 1, 28, 28)</span></span>
<span id="cb3-40"><a href="#cb3-40" tabindex="-1"></a>        <span class="co"># Output size after conv1: (batch_size, 32, 26, 26)</span></span>
<span id="cb3-41"><a href="#cb3-41" tabindex="-1"></a>        <span class="co"># Output size after max-pooling: (batch_size, 32, 13, 13)</span></span>
<span id="cb3-42"><a href="#cb3-42" tabindex="-1"></a>        x <span class="op">=</span> F.relu(F.max_pool2d(<span class="va">self</span>.conv1(x), <span class="dv">2</span>))</span>
<span id="cb3-43"><a href="#cb3-43" tabindex="-1"></a></span>
<span id="cb3-44"><a href="#cb3-44" tabindex="-1"></a>        <span class="co"># Apply second convolutional layer followed by ReLU and 2x2 max-pooling</span></span>
<span id="cb3-45"><a href="#cb3-45" tabindex="-1"></a>        <span class="co"># Input size: (batch_size, 32, 13, 13)</span></span>
<span id="cb3-46"><a href="#cb3-46" tabindex="-1"></a>        <span class="co"># Output size after conv2: (batch_size, 64, 11, 11)</span></span>
<span id="cb3-47"><a href="#cb3-47" tabindex="-1"></a>        <span class="co"># Output size after max-pooling: (batch_size, 64, 5, 5)</span></span>
<span id="cb3-48"><a href="#cb3-48" tabindex="-1"></a>        x <span class="op">=</span> F.relu(F.max_pool2d(<span class="va">self</span>.conv2(x), <span class="dv">2</span>))</span>
<span id="cb3-49"><a href="#cb3-49" tabindex="-1"></a></span>
<span id="cb3-50"><a href="#cb3-50" tabindex="-1"></a>        <span class="co"># Flatten the tensor for the fully connected layers</span></span>
<span id="cb3-51"><a href="#cb3-51" tabindex="-1"></a>        <span class="co"># Input size: (batch_size, 64, 5, 5)</span></span>
<span id="cb3-52"><a href="#cb3-52" tabindex="-1"></a>        <span class="co"># Output size after flattening: (batch_size, 64*5*5)</span></span>
<span id="cb3-53"><a href="#cb3-53" tabindex="-1"></a>        x <span class="op">=</span> x.view(<span class="op">-</span><span class="dv">1</span>, <span class="dv">64</span> <span class="op">*</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span>)</span>
<span id="cb3-54"><a href="#cb3-54" tabindex="-1"></a></span>
<span id="cb3-55"><a href="#cb3-55" tabindex="-1"></a>        <span class="co"># Apply the first fully connected layer (penultimate layer) with ReLU</span></span>
<span id="cb3-56"><a href="#cb3-56" tabindex="-1"></a>        <span class="co"># Input size: (batch_size, 64*5*5)</span></span>
<span id="cb3-57"><a href="#cb3-57" tabindex="-1"></a>        <span class="co"># Output size: (batch_size, 128)</span></span>
<span id="cb3-58"><a href="#cb3-58" tabindex="-1"></a>        x <span class="op">=</span> F.relu(<span class="va">self</span>.fc1(x))</span>
<span id="cb3-59"><a href="#cb3-59" tabindex="-1"></a></span>
<span id="cb3-60"><a href="#cb3-60" tabindex="-1"></a>        <span class="co"># Apply the final fully connected layer (classification layer)</span></span>
<span id="cb3-61"><a href="#cb3-61" tabindex="-1"></a>        <span class="co"># Input size: (batch_size, 128)</span></span>
<span id="cb3-62"><a href="#cb3-62" tabindex="-1"></a>        <span class="co"># Output size: (batch_size, 2)</span></span>
<span id="cb3-63"><a href="#cb3-63" tabindex="-1"></a>        logits <span class="op">=</span> <span class="va">self</span>.fc2(x)</span>
<span id="cb3-64"><a href="#cb3-64" tabindex="-1"></a></span>
<span id="cb3-65"><a href="#cb3-65" tabindex="-1"></a>        <span class="cf">return</span> logits</span>
<span id="cb3-66"><a href="#cb3-66" tabindex="-1"></a></span>
<span id="cb3-67"><a href="#cb3-67" tabindex="-1"></a>    <span class="kw">def</span> extract_penultimate(<span class="va">self</span>, x):</span>
<span id="cb3-68"><a href="#cb3-68" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb3-69"><a href="#cb3-69" tabindex="-1"></a><span class="co">        Extracts embeddings from the penultimate layer of the model.</span></span>
<span id="cb3-70"><a href="#cb3-70" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb3-71"><a href="#cb3-71" tabindex="-1"></a><span class="co">        Parameters:</span></span>
<span id="cb3-72"><a href="#cb3-72" tabindex="-1"></a><span class="co">        - x: Input tensor of shape (batch_size, channels, height, width), e.g., (64, 1, 28, 28).</span></span>
<span id="cb3-73"><a href="#cb3-73" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb3-74"><a href="#cb3-74" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb3-75"><a href="#cb3-75" tabindex="-1"></a><span class="co">        - embeddings: Output tensor from the penultimate layer of shape (batch_size, 128).</span></span>
<span id="cb3-76"><a href="#cb3-76" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb3-77"><a href="#cb3-77" tabindex="-1"></a></span>
<span id="cb3-78"><a href="#cb3-78" tabindex="-1"></a>        <span class="co"># Apply convolutional layers and max-pooling (same as in forward)</span></span>
<span id="cb3-79"><a href="#cb3-79" tabindex="-1"></a>        x <span class="op">=</span> F.relu(F.max_pool2d(<span class="va">self</span>.conv1(x), <span class="dv">2</span>))</span>
<span id="cb3-80"><a href="#cb3-80" tabindex="-1"></a>        x <span class="op">=</span> F.relu(F.max_pool2d(<span class="va">self</span>.conv2(x), <span class="dv">2</span>))</span>
<span id="cb3-81"><a href="#cb3-81" tabindex="-1"></a>        x <span class="op">=</span> x.view(<span class="op">-</span><span class="dv">1</span>, <span class="dv">64</span> <span class="op">*</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span>)</span>
<span id="cb3-82"><a href="#cb3-82" tabindex="-1"></a></span>
<span id="cb3-83"><a href="#cb3-83" tabindex="-1"></a>        <span class="co"># Stop at the penultimate layer (fc1) and return the output</span></span>
<span id="cb3-84"><a href="#cb3-84" tabindex="-1"></a>        embeddings <span class="op">=</span> F.relu(<span class="va">self</span>.fc1(x))</span>
<span id="cb3-85"><a href="#cb3-85" tabindex="-1"></a>        <span class="cf">return</span> embeddings</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">'cpu'</span>)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>model <span class="op">=</span> SimpleCNN().to(device)</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="train-cnn">Train CNN<a class="anchor" aria-label="anchor" href="#train-cnn"></a>
</h3>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="kw">def</span> train_model(model, train_loader, criterion, optimizer, epochs<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="co">    Trains a given PyTorch model using a specified dataset, loss function, and optimizer.</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="co">    - model (nn.Module): The neural network model to train.</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a><span class="co">    - train_loader (DataLoader): DataLoader object providing the training dataset in batches.</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co">    - criterion (nn.Module): Loss function used for optimization (e.g., CrossEntropyLoss).</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co">    - optimizer (torch.optim.Optimizer): Optimizer for adjusting model weights (e.g., Adam, SGD).</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a><span class="co">    - epochs (int): Number of training iterations over the entire dataset.</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a><span class="co">    - None: Prints the loss for each epoch during training.</span></span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a><span class="co">    Workflow:</span></span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a><span class="co">    1. Iterate over the dataset for the given number of epochs.</span></span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a><span class="co">    2. For each batch, forward propagate inputs, compute the loss, and backpropagate gradients.</span></span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a><span class="co">    3. Update model weights using the optimizer and reset gradients after each step.</span></span>
<span id="cb5-19"><a href="#cb5-19" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-20"><a href="#cb5-20" tabindex="-1"></a>    model.train()  <span class="co"># Set the model to training mode</span></span>
<span id="cb5-21"><a href="#cb5-21" tabindex="-1"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(epochs):</span>
<span id="cb5-22"><a href="#cb5-22" tabindex="-1"></a>        running_loss <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb5-23"><a href="#cb5-23" tabindex="-1"></a>        <span class="cf">for</span> inputs, labels <span class="kw">in</span> train_loader:</span>
<span id="cb5-24"><a href="#cb5-24" tabindex="-1"></a>            <span class="co"># Move inputs and labels to the appropriate device (CPU or GPU)</span></span>
<span id="cb5-25"><a href="#cb5-25" tabindex="-1"></a>            inputs, labels <span class="op">=</span> inputs.to(device), labels.to(device)</span>
<span id="cb5-26"><a href="#cb5-26" tabindex="-1"></a>            </span>
<span id="cb5-27"><a href="#cb5-27" tabindex="-1"></a>            <span class="co"># Reset gradients from the previous step to avoid accumulation</span></span>
<span id="cb5-28"><a href="#cb5-28" tabindex="-1"></a>            optimizer.zero_grad()</span>
<span id="cb5-29"><a href="#cb5-29" tabindex="-1"></a>            </span>
<span id="cb5-30"><a href="#cb5-30" tabindex="-1"></a>            <span class="co"># Forward pass: Compute model predictions</span></span>
<span id="cb5-31"><a href="#cb5-31" tabindex="-1"></a>            outputs <span class="op">=</span> model(inputs)</span>
<span id="cb5-32"><a href="#cb5-32" tabindex="-1"></a>            </span>
<span id="cb5-33"><a href="#cb5-33" tabindex="-1"></a>            <span class="co"># Compute the loss between predictions and true labels</span></span>
<span id="cb5-34"><a href="#cb5-34" tabindex="-1"></a>            loss <span class="op">=</span> criterion(outputs, labels)</span>
<span id="cb5-35"><a href="#cb5-35" tabindex="-1"></a>            </span>
<span id="cb5-36"><a href="#cb5-36" tabindex="-1"></a>            <span class="co"># Backward pass: Compute gradients of the loss w.r.t. model parameters</span></span>
<span id="cb5-37"><a href="#cb5-37" tabindex="-1"></a>            loss.backward()</span>
<span id="cb5-38"><a href="#cb5-38" tabindex="-1"></a>            </span>
<span id="cb5-39"><a href="#cb5-39" tabindex="-1"></a>            <span class="co"># Update model weights using gradients and optimizer rules</span></span>
<span id="cb5-40"><a href="#cb5-40" tabindex="-1"></a>            optimizer.step()</span>
<span id="cb5-41"><a href="#cb5-41" tabindex="-1"></a>            </span>
<span id="cb5-42"><a href="#cb5-42" tabindex="-1"></a>            <span class="co"># Accumulate the batch loss for reporting</span></span>
<span id="cb5-43"><a href="#cb5-43" tabindex="-1"></a>            running_loss <span class="op">+=</span> loss.item()</span>
<span id="cb5-44"><a href="#cb5-44" tabindex="-1"></a>        </span>
<span id="cb5-45"><a href="#cb5-45" tabindex="-1"></a>        <span class="co"># Print the average loss for the current epoch</span></span>
<span id="cb5-46"><a href="#cb5-46" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f'Epoch </span><span class="sc">{</span>epoch<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">, Loss: </span><span class="sc">{</span>running_loss<span class="op">/</span><span class="bu">len</span>(train_loader)<span class="sc">}</span><span class="ss">'</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>criterion <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>optimizer <span class="op">=</span> optim.Adam(model.parameters(), lr<span class="op">=</span><span class="fl">0.001</span>)</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>train_model(model, train_loader, criterion, optimizer)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="kw">def</span> extract_features(model, dataloader, device):</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="co">    Extracts embeddings from the penultimate layer of the model.</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="co">    - model: The trained PyTorch model.</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="co">    - dataloader: DataLoader providing the dataset.</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="co">    - device: Torch device (e.g., 'cpu' or 'cuda').</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a><span class="co">    - features: NumPy array of embeddings from the penultimate layer.</span></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a><span class="co">    - labels: NumPy array of corresponding labels.</span></span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a>    model.<span class="bu">eval</span>()</span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a>    features, labels <span class="op">=</span> [], []</span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a>    <span class="cf">with</span> torch.no_grad():</span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a>        <span class="cf">for</span> inputs, targets <span class="kw">in</span> dataloader:</span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a>            inputs <span class="op">=</span> inputs.to(device)</span>
<span id="cb7-19"><a href="#cb7-19" tabindex="-1"></a>            embeddings <span class="op">=</span> model.extract_penultimate(inputs)  <span class="co"># Extract embeddings</span></span>
<span id="cb7-20"><a href="#cb7-20" tabindex="-1"></a>            <span class="co"># embeddings = model(inputs)  # Extract embeddings from output neurons (N= number of classes; limited feature representation)</span></span>
<span id="cb7-21"><a href="#cb7-21" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" tabindex="-1"></a>            features.append(embeddings.cpu().numpy())</span>
<span id="cb7-23"><a href="#cb7-23" tabindex="-1"></a>            labels.append(targets.cpu().numpy())</span>
<span id="cb7-24"><a href="#cb7-24" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" tabindex="-1"></a>    <span class="co"># Combine features and labels into arrays</span></span>
<span id="cb7-26"><a href="#cb7-26" tabindex="-1"></a>    features <span class="op">=</span> np.vstack(features)</span>
<span id="cb7-27"><a href="#cb7-27" tabindex="-1"></a>    labels <span class="op">=</span> np.concatenate(labels)</span>
<span id="cb7-28"><a href="#cb7-28" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" tabindex="-1"></a>    <span class="co"># Report shape as a sanity check</span></span>
<span id="cb7-30"><a href="#cb7-30" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Extracted features shape: </span><span class="sc">{</span>features<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-31"><a href="#cb7-31" tabindex="-1"></a>    <span class="cf">return</span> features, labels</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="co"># from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a><span class="co"># Compute Mahalanobis distance</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a><span class="kw">def</span> compute_mahalanobis_distance(features, mean, covariance):</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>    inv_covariance <span class="op">=</span> np.linalg.inv(covariance)</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>    distances <span class="op">=</span> []</span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> features:</span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a>        diff <span class="op">=</span> x <span class="op">-</span> mean</span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>        distance <span class="op">=</span> np.sqrt(np.dot(np.dot(diff, inv_covariance), diff.T))</span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a>        distances.append(distance)</span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a>    <span class="cf">return</span> np.array(distances)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># Calculate mean and covariance of ID features</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>id_features, id_labels <span class="op">=</span> extract_features(model, train_loader, device)</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>mean <span class="op">=</span> np.mean(id_features, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a><span class="co"># from sklearn.covariance import EmpiricalCovariance</span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="co"># covariance = EmpiricalCovariance().fit(id_features).covariance_</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="im">from</span> sklearn.covariance <span class="im">import</span> LedoitWolf</span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="co"># Use a shrinkage estimator for covariance</span></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a>covariance <span class="op">=</span> LedoitWolf().fit(id_features).covariance_</span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a><span class="co"># Compute Mahalanobis distances for ID and OOD data</span></span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a>ood_features, _ <span class="op">=</span> extract_features(model, ood_loader, device)</span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a>id_distances <span class="op">=</span> compute_mahalanobis_distance(id_features, mean, covariance)</span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a>ood_distances <span class="op">=</span> compute_mahalanobis_distance(ood_features, mean, covariance)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co"># Visualize Mahalanobis distances</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>plt.hist(id_distances, bins<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'ID'</span>)</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>plt.hist(ood_distances, bins<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'OOD'</span>)</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>plt.xlabel(<span class="st">'Mahalanobis Distance'</span>)</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>plt.ylabel(<span class="st">'Frequency'</span>)</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>plt.legend()</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>plt.title(<span class="st">'Mahalanobis Distances for ID and OOD Data'</span>)</span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="discussion-overlapping-mahalanobis-distance-distributions">Discussion: Overlapping Mahalanobis distance distributions<a class="anchor" aria-label="anchor" href="#discussion-overlapping-mahalanobis-distance-distributions"></a>
</h3>
<p>After plotting the Mahalanobis distances for in-distribution (ID) and
out-of-distribution (OOD) data, we may observe some overlap between the
two distributions. This overlap reveals one of the limitations of
distance-based methods: <strong>the separability of ID and OOD data is
highly dependent on the quality of the feature representations</strong>.
The model’s learned features might not adequately distinguish between ID
and OOD data, especially when OOD samples share semantic or structural
similarities with ID data.</p>
</div>
<div class="section level3">
<h3 id="a-solution-contrastive-learning">A solution? Contrastive learning<a class="anchor" aria-label="anchor" href="#a-solution-contrastive-learning"></a>
</h3>
<p>In classical training regimes, models are trained with a <em>limited
worldview</em>. They learn to distinguish between pre-defined classes
based only on the data they’ve seen during training. You don’t know what
you don’t know!</p>
<p>For instance, consider a child learning to identify animals based on
a set of flashcards with pictures of cats, dogs, and birds. If you show
them a picture of a fox or a turtle, they might struggle because their
understanding is constrained by the categories they’ve been explicitly
taught. This is analogous to the way models trained with supervised
learning approach classification—they build decision boundaries tailored
to the training classes but struggle with new, unseen data.</p>
<p>Now, consider teaching the child differently. Instead of focusing
solely on identifying “cat” or “dog,” you teach them to group animals by
broader characteristics—like furry vs. scaly or walking vs. swimming.
This approach helps the child form a more generalized understanding of
the world, enabling them to recognize new animals by connecting them to
familiar patterns. Contrastive learning aims to achieve something
similar for machine learning models.</p>
<p><strong>Contrastive learning</strong> creates feature spaces that are
less dependent on specific classes and more attuned to broader semantic
relationships. By learning to pull similar data points closer in feature
space and push dissimilar ones apart, contrastive methods generate
representations that are robust to shifts in data and can naturally
cluster unseen categories. This makes contrastive learning particularly
promising for improving OOD detection, as it helps models generalize
beyond their training distribution.</p>
<p>Unlike traditional training methods that rely heavily on explicit
class labels, contrastive learning optimizes the feature space itself,
encouraging the model to group similar data points together and push
dissimilar ones apart. For example:</p>
<ul>
<li>Positive pairs (e.g., augmented views of the same image) are
encouraged to be close in the feature space.</li>
<li>Negative pairs (e.g., different images or samples from different
distributions) are pushed apart.</li>
</ul>
<p>This results in a <em>feature space with semantic clusters</em>,
where data points with similar meanings are grouped together, even
across unseen distributions.</p>
<div class="section level4">
<h4 id="challenges-and-trade-offs">Challenges and trade-offs<a class="anchor" aria-label="anchor" href="#challenges-and-trade-offs"></a>
</h4>
<ul>
<li>
<strong>Training complexity:</strong> Contrastive learning requires
large amounts of diverse data and careful design of augmentations or
sampling strategies.</li>
<li>
<strong>Unsupervised nature:</strong> While contrastive learning
does not rely on explicit labels, defining meaningful positive and
negative pairs is non-trivial.</li>
</ul>
</div>
</div>
<div class="section level3">
<h3 id="concluding-thoughts-and-future-directions">Concluding thoughts and future directions<a class="anchor" aria-label="anchor" href="#concluding-thoughts-and-future-directions"></a>
</h3>
<p>While contrastive learning provides an exciting opportunity to
improve OOD detection, it represents a shift from the traditional
threshold- or distance-based approaches we have discussed so far. By
learning a feature space that is inherently more generalizable and
robust, contrastive learning offers a promising solution to the
challenges posed by overlapping Mahalanobis distance distributions.</p>
<p>If you’re interested, we can explore specific contrastive learning
methods like <strong>SimCLR</strong> or <strong>MoCo</strong> in future
sessions, diving into how their objectives help create robust feature
spaces! <!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 --></p>
</div></section><section id="aio-8-releasing-a-model"><p>Content from <a href="8-releasing-a-model.html">Documenting and releasing a model</a></p>
<hr>
<p>Last updated on 2024-09-25 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/8-releasing-a-model.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Why is model sharing important in the context of reproducibility and
responsible use?</li>
<li>What are the challenges, risks, and ethical considerations related
to sharing models?</li>
<li>How can model-sharing best practices be applied using tools like
model cards and the Hugging Face platform?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand the importance of model sharing and best practices to
ensure reproducibility and responsible use of models.</li>
<li>Understand the challenges, risks, and ethical concerns associated
with model sharing.</li>
<li>Apply model-sharing best practices through using model cards and the
Hugging Face platform.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Model cards are the standard technique for communicating information
about how machine learning systems were trained and how they should and
should not be used.</li>
<li>Models can be shared and reused via the Hugging Face platform.</li>
</ul>
</div>
</div>
</div>
<div id="why-should-we-share-trained-models" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="why-should-we-share-trained-models" class="callout-inner">
<h3 class="callout-title">Why should we share trained models?</h3>
<div class="callout-content">
<p>Discuss in small groups and report out: <em>Why do you believe it is
or isn’t important to share ML models? How has model-sharing contributed
to your experiences or projects?</em></p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<ul>
<li>
<strong>Accelerating research</strong>: Sharing models allows
researchers and practitioners to build upon existing work, accelerating
the pace of innovation in the field.</li>
<li>
<strong>Knowledge exchange</strong>: Model sharing promotes
knowledge exchange and collaboration within the machine learning
community, fostering a culture of open science.</li>
<li>
<strong>Reproducibility</strong>: Sharing models, along with
associated code and data, enhances reproducibility, enabling others to
validate and verify the results reported in research papers.</li>
<li>
<strong>Benchmarking</strong>: Shared models serve as benchmarks for
comparing new models and algorithms, facilitating the evaluation and
improvement of state-of-the-art techniques.</li>
<li>
<strong>Education / Accessibility to state-of-the-art
architectures</strong>: Shared models provide valuable resources for
educational purposes, allowing students and learners to explore and
experiment with advanced machine learning techniques.</li>
<li>
<strong>Repurpose (transfer learning and finetuning)</strong>: Some
models (i.e., foundation models) can be repurposed for a wide variety of
tasks. This is especially useful when working with limited data. Data
scarcity</li>
<li>
<strong>Resource efficiency</strong>: Instead of training a model
from the ground up, practitioners can use existing models as a starting
point, saving time, computational resources, and energy.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="challenges-and-risks-of-model-sharing" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="challenges-and-risks-of-model-sharing" class="callout-inner">
<h3 class="callout-title">Challenges and risks of model sharing</h3>
<div class="callout-content">
<p>Discuss in small groups and report out: <em>What are some potential
challenges, risks, or ethical concerns associated with model sharing and
reproducing ML workflows?</em></p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<ul>
<li>
<strong>Privacy concerns</strong>: Sharing models that were trained
on sensitive or private data raises privacy concerns. The potential
disclosure of personal information through the model poses a risk to
individuals and can lead to unintended consequences.</li>
<li>
<strong>Informed consent</strong>: If models involve user data,
ensuring informed consent is crucial. Sharing models trained on
user-generated content without clear consent may violate privacy norms
and regulations.</li>
<li>
<strong>Intellectual property</strong>: Models may be developed
within organizations with proprietary data and methodologies. Sharing
such models without proper consent or authorization may lead to
intellectual property disputes and legal consequences.</li>
<li>
<strong>Model robustness and generalization</strong>: Reproduced
models may not generalize well to new datasets or real-world scenarios.
Failure to account for the limitations of the original model can result
in reduced performance and reliability in diverse settings.</li>
<li>
<strong>Lack of reproducibility</strong>: Incomplete documentation,
missing details, or changes in dependencies over time can hinder the
reproducibility of ML workflows. This lack of reproducibility can impede
scientific progress and validation of research findings.</li>
<li>
<strong>Unintended use and misuse</strong>: Shared models may be
used in unintended ways, leading to ethical concerns. Developers should
consider the potential consequences of misuse, particularly in
applications with societal impact, such as healthcare or law
enforcement.</li>
<li>
<strong>Responsible AI considerations</strong>: Ethical
considerations, such as fairness, accountability, and transparency,
should be addressed during model sharing. Failing to consider these
aspects can result in models that inadvertently discriminate or lack
interpretability. Models used for decision-making, especially in
critical areas like healthcare or finance, should be ethically deployed.
Transparent documentation and disclosure of how decisions are made are
essential for responsible AI adoption.</li>
</ul>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="saving-the-model-locally">Saving the model locally<a class="anchor" aria-label="anchor" href="#saving-the-model-locally"></a>
</h2>
<hr class="half-width">
<p>Let’s review the simplest method for sharing a model first — saving
the model locally. When working with PyTorch, it’s important to know how
to save and load models efficiently. This process ensures that you can
pause your work, share your models, or deploy them for inference without
having to retrain them from scratch each time.</p>
<div class="section level3">
<h3 id="defining-the-model">Defining the model<a class="anchor" aria-label="anchor" href="#defining-the-model"></a>
</h3>
<p>As an example, we’ll configure a simple perceptron (single hidden
layer) in PyTorch. We’ll define a bare bones class for this just so we
can initialize the model.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Dict, Any</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="kw">class</span> MyModel(nn.Module):</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, config: Dict[<span class="bu">str</span>, <span class="bu">int</span>]):</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>        <span class="co"># Parameter is a trainable tensor initialized with random values</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>        <span class="va">self</span>.param <span class="op">=</span> nn.Parameter(torch.rand(config[<span class="st">"num_channels"</span>], config[<span class="st">"hidden_size"</span>]))</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>        <span class="co"># Linear layer (fully connected layer) for the output</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>        <span class="va">self</span>.linear <span class="op">=</span> nn.Linear(config[<span class="st">"hidden_size"</span>], config[<span class="st">"num_classes"</span>])</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>        <span class="co"># Store the configuration</span></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>        <span class="va">self</span>.config <span class="op">=</span> config</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x: torch.Tensor) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>        <span class="co"># Forward pass: Add the input to the param tensor, then pass through the linear layer</span></span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.linear(x <span class="op">+</span> <span class="va">self</span>.param)</span></code></pre>
</div>
<p>Initialize model by calling the class with configuration
settings.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Create model instance with specific configuration</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>config <span class="op">=</span> {<span class="st">"num_channels"</span>: <span class="dv">3</span>, <span class="st">"hidden_size"</span>: <span class="dv">32</span>, <span class="st">"num_classes"</span>: <span class="dv">10</span>}</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>model <span class="op">=</span> MyModel(config<span class="op">=</span>config)</span></code></pre>
</div>
<p>We can then write a function to save out the model. We’ll need both
the model weights and the model’s configuration (hyperparameter
settings). We’ll save the configurations as a json since a key/value
format is convenient here.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="im">import</span> json</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="co"># Function to save model and config locally</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="kw">def</span> save_model(model: nn.Module, model_path: <span class="bu">str</span>, config_path: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>    <span class="co"># Save model state dict (weights and biases) as a .pth file</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>    torch.save(model.state_dict(), model_path) <span class="co">#</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>    <span class="co"># Save config</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(config_path, <span class="st">'w'</span>) <span class="im">as</span> f:</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>        json.dump(model.config, f)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Save the model and config locally</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>save_model(model, <span class="st">"my_awesome_model.pth"</span>, <span class="st">"my_awesome_model_config.json"</span>)</span></code></pre>
</div>
<p>To load the model back in, we can write another function</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># Function to load model and config locally</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="kw">def</span> load_model(model_class: Any, model_path: <span class="bu">str</span>, config_path: <span class="bu">str</span>) <span class="op">-&gt;</span> nn.Module:</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>    <span class="co"># Load config</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(config_path, <span class="st">'r'</span>) <span class="im">as</span> f:</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>        config <span class="op">=</span> json.load(f)</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>    <span class="co"># Create model instance with config</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>    model <span class="op">=</span> model_class(config<span class="op">=</span>config)</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>    <span class="co"># Load model state dict</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>    model.load_state_dict(torch.load(model_path))</span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>    <span class="cf">return</span> model</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># Load the model and config locally</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>loaded_model <span class="op">=</span> load_model(MyModel, <span class="st">"my_awesome_model.pth"</span>, <span class="st">"my_awesome_model_config.json"</span>)</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co"># Verify the loaded model</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="bu">print</span>(loaded_model)</span></code></pre>
</div>
</div>
</section><section><h2 class="section-heading" id="saving-a-model-to-hugging-face">Saving a model to Hugging Face<a class="anchor" aria-label="anchor" href="#saving-a-model-to-hugging-face"></a>
</h2>
<hr class="half-width">
<p>To share your model with a wider audience, we recommend uploading
your model to Hugging Face. Hugging Face is a very popular machine
learning (ML) platform and community that helps users build, deploy,
share, and train machine learning models. It has quickly become the
go-to option for sharing models with the public.</p>
<div class="section level3">
<h3 id="create-a-hugging-face-account-and-access-token">Create a Hugging Face account and access Token<a class="anchor" aria-label="anchor" href="#create-a-hugging-face-account-and-access-token"></a>
</h3>
<p>If you haven’t completed these steps from the setup, make sure to do
this now.</p>
<p><strong>Create account</strong>: To create an account on Hugging
Face, visit: <a href="https://huggingface.co/join" class="external-link">huggingface.co/join</a>. Enter an
email address and password, and follow the instructions provided via
Hugging Face (you may need to verify your email address) to complete the
process.</p>
<p><strong>Setup access token</strong>: Once you have your account
created, you’ll need to generate an access token so that you can
upload/share models to your Hugging Face account during the workshop. To
generate a token, visit the <a href="https://huggingface.co/settings/tokens" class="external-link">Access Tokens setting
page</a> after logging in.</p>
</div>
<div class="section level3">
<h3 id="login-to-hugging-face-account">Login to Hugging Face account<a class="anchor" aria-label="anchor" href="#login-to-hugging-face-account"></a>
</h3>
<p>To login, you will need to retrieve your access token from the <a href="https://huggingface.co/settings/tokens" class="external-link">Access Tokens setting
page</a></p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="op">!</span>huggingface<span class="op">-</span>cli login</span></code></pre>
</div>
<p>You might get a message saying you cannot authenticate through
git-credential as no helper is defined on your machine. This warning
message should not stop you from being able to complete this episode,
but it may mean that the token won’t be stored on your machine for
future use.</p>
<p>Once logged in, we will need to edit our model class definition to
include Hugging Face’s “push_to_hub” attribute. To enable the
push_to_hub functionality, you’ll need to include the
PyTorchModelHubMixin “mixin class” provided by the huggingface_hub
library. A mixin class is a type of class used in object-oriented
programming to “mix in” additional properties and methods into a class.
The PyTorchModelHubMixin class adds methods to your PyTorch model to
enable easy saving and loading from the Hugging Face Model Hub.</p>
<p>Here’s how you can adjust the code to incorporate both saving/loading
locally and pushing the model to the Hugging Face Hub.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="im">from</span> huggingface_hub <span class="im">import</span> PyTorchModelHubMixin <span class="co"># NEW</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="kw">class</span> MyModel(nn.Module, PyTorchModelHubMixin): <span class="co"># PyTorchModelHubMixin is new</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, config: Dict[<span class="bu">str</span>, Any]):</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>        <span class="co"># Initialize layers and parameters</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>        <span class="va">self</span>.param <span class="op">=</span> nn.Parameter(torch.rand(config[<span class="st">"num_channels"</span>], config[<span class="st">"hidden_size"</span>]))</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>        <span class="va">self</span>.linear <span class="op">=</span> nn.Linear(config[<span class="st">"hidden_size"</span>], config[<span class="st">"num_classes"</span>])</span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>        <span class="va">self</span>.config <span class="op">=</span> config</span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x: torch.Tensor) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.linear(x <span class="op">+</span> <span class="va">self</span>.param)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># Create model instance with specific configuration</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>config <span class="op">=</span> {<span class="st">"num_channels"</span>: <span class="dv">3</span>, <span class="st">"hidden_size"</span>: <span class="dv">32</span>, <span class="st">"num_classes"</span>: <span class="dv">10</span>}</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>model <span class="op">=</span> MyModel(config<span class="op">=</span>config)</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="bu">print</span>(model)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co"># push to the hub</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>model.push_to_hub(<span class="st">"my-awesome-model"</span>, config<span class="op">=</span>config)</span></code></pre>
</div>
<p><strong>Verifying</strong>: To check your work, head back over to
your Hugging Face account and click your profile icon in the top-right
of the website. Click “Profile” from there to view all of your uploaded
models. Alternatively, you can search for your username (or model name)
from the <a href="https://huggingface.co/models" class="external-link">Model Hub</a>.</p>
<div class="section level4">
<h4 id="loading-the-model-from-hugging-face">Loading the model from Hugging Face<a class="anchor" aria-label="anchor" href="#loading-the-model-from-hugging-face"></a>
</h4>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="co"># reload</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>model <span class="op">=</span> MyModel.from_pretrained(<span class="st">"your-username/my-awesome-model"</span>)</span></code></pre>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="uploading-transformer-models-to-hugging-face">Uploading transformer models to Hugging Face<a class="anchor" aria-label="anchor" href="#uploading-transformer-models-to-hugging-face"></a>
</h2>
<hr class="half-width">
<p>Key Differences</p>
<ul>
<li>
<strong>Saving and Loading the Tokenizer</strong>: Transformer
models require a tokenizer that needs to be saved and loaded with the
model. This is not necessary for custom PyTorch models that typically do
not require a separate tokenizer.</li>
<li>
<strong>Using Pre-trained Classes</strong>: Transformer models use
classes like AutoModelForSequenceClassification and AutoTokenizer from
the transformers library, which are pre-built and designed for specific
tasks (e.g., sequence classification).</li>
<li>
<strong>Methods for Saving and Loading</strong>: The transformers
library provides save_pretrained and from_pretrained methods for both
models and tokenizers, which handle the serialization and
deserialization processes seamlessly.</li>
</ul>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> AutoModelForSequenceClassification, AutoTokenizer</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="co"># Load a pre-trained model and tokenizer</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>model_name <span class="op">=</span> <span class="st">"bert-base-uncased"</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>model <span class="op">=</span> AutoModelForSequenceClassification.from_pretrained(model_name, num_labels<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(model_name)</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a><span class="co"># Save the model and tokenizer locally</span></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>model.save_pretrained(<span class="st">"my_transformer_model"</span>)</span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>tokenizer.save_pretrained(<span class="st">"my_transformer_model"</span>)</span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a><span class="co"># Load the model and tokenizer from the saved directory</span></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a>loaded_model <span class="op">=</span> AutoModelForSequenceClassification.from_pretrained(<span class="st">"my_transformer_model"</span>)</span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a>loaded_tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(<span class="st">"my_transformer_model"</span>)</span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a><span class="co"># Verify the loaded model and tokenizer</span></span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a><span class="bu">print</span>(loaded_model)</span>
<span id="cb12-18"><a href="#cb12-18" tabindex="-1"></a><span class="bu">print</span>(loaded_tokenizer)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="co"># Push the model and tokenizer to Hugging Face Hub</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>model.push_to_hub(<span class="st">"my-awesome-transformer-model"</span>)</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>tokenizer.push_to_hub(<span class="st">"my-awesome-transformer-model"</span>)</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a><span class="co"># Load the model and tokenizer from the Hugging Face Hub</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>hub_model <span class="op">=</span> AutoModelForSequenceClassification.from_pretrained(<span class="st">"user-name/my-awesome-transformer-model"</span>)</span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a>hub_tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(<span class="st">"user-name/my-awesome-transformer-model"</span>)</span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a><span class="co"># Verify the model and tokenizer loaded from the hub</span></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="bu">print</span>(hub_model)</span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a><span class="bu">print</span>(hub_tokenizer)</span></code></pre>
</div>
<div id="what-pieces-must-be-well-documented-to-ensure-reproducible-and-responsible-model-sharing" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="what-pieces-must-be-well-documented-to-ensure-reproducible-and-responsible-model-sharing" class="callout-inner">
<h3 class="callout-title">What pieces must be well-documented to ensure reproducible and responsible model sharing?</h3>
<div class="callout-content">
<p>Discuss in small groups and report out: <em>What type of information
needs to be included in the documentation when sharing a model?</em></p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" data-bs-parent="#accordionSolution3" aria-labelledby="headingSolution3">
<div class="accordion-body">
<ul>
<li>Environment setup</li>
<li>Training data
<ul>
<li>How the data was collected</li>
<li>Who owns the data: data license and usage terms</li>
<li>Basic descriptive statistics: number of samples, features, classes,
etc.</li>
<li>Note any class imbalance or general bias issues</li>
<li>Description of data distribution to help prevent out-of-distribution
failures.</li>
</ul>
</li>
<li>Preprocessing steps.
<ul>
<li>Data splitting</li>
<li>Standardization method</li>
<li>Feature selection</li>
<li>Outlier detection and other filters</li>
</ul>
</li>
<li>Model architecture, hyperparameters and, training procedure (e.g.,
dropout or early stopping)</li>
<li>Model weights</li>
<li>Evaluation metrics. Results and performance. The more tasks/datasets
you can evaluate on, the better.</li>
<li>Ethical considerations: Include investigations of bias/fairness when
applicable (i.e., if your model involves human data or affects
decision-making involving humans)</li>
<li>Contact info</li>
<li>Acknowledgments</li>
<li>Examples and demos (highly recommended)</li>
</ul>
</div>
</div>
</div>
</div>
<div id="document-your-model" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="document-your-model" class="callout-inner">
<h3 class="callout-title">Document your model</h3>
<div class="callout-content">
<p>For this challenge, you have two options:</p>
<ol style="list-style-type: decimal">
<li><p>Start writing a model card for a model you have created for your
research. The solution from the previous challenge or this <a href="https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/templates/modelcard_template.md" class="external-link">template</a>
from Hugging Face are good places to start, but note that not all fields
may be relevant, depending on what your model does.</p></li>
<li><p>Find a model on <a href="https://huggingface.co/" class="external-link">HuggingFace</a>
that has a model card, for example, you could search for models using
terms like “sentiment classification” or “medical”. Read the model card
and evaluate whether the information is clear and complete. Would you be
able to recreate the model based on the information presented? Do you
feel that there is enough information to be able to evaluate you would
be able to adapt this model for your purposes? You can refer to the
previous challenge’s solution for ideas of what information should be
included, but note that not all sections are relevant to all
models.</p></li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" data-bs-parent="#accordionSolution4" aria-labelledby="headingSolution4">
<div class="accordion-body">
<p>Pair up with a classmate and discuss what you wrote/read. Do model
cards seem like a useful tool for you moving forwards?</p>
</div>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section>
</div>
    </main>
</div>
<!-- END  : inst/pkgdown/templates/content-extra.html -->

      </div>
<!--/div.row-->
      		<footer class="row footer mx-md-3"><hr>
<div class="col-md-6">
        <p>This lesson is subject to the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a></p>
        <p>

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/README.md" class="external-link">Edit on GitHub</a>

	
        | <a href="https://github.com/carpentries-incubator/fair-explainable-ml/blob/main/CONTRIBUTING.md" class="external-link">Contributing</a>
        | <a href="https://github.com/carpentries-incubator/fair-explainable-ml/" class="external-link">Source</a></p>
				<p><a href="https://github.com/carpentries-incubator/fair-explainable-ml/blob/main/CITATION" class="external-link">Cite</a> | <a href="mailto:apmeyer4@wisc.edu">Contact</a> | <a href="https://carpentries.org/about/" class="external-link">About</a></p>
			</div>
			<div class="col-md-6">

        <p>Materials licensed under <a href="LICENSE.html">CC-BY 4.0</a> by the authors</p>

        <p>Template licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/" class="external-link">CC-BY 4.0</a> by <a href="https://carpentries.org/" class="external-link">The Carpentries</a></p>
        <p>Built with <a href="https://github.com/carpentries/sandpaper/tree/0.16.10" class="external-link">sandpaper (0.16.10)</a>, <a href="https://github.com/carpentries/pegboard/tree/0.7.7" class="external-link">pegboard (0.7.7)</a>, and <a href="https://github.com/carpentries/varnish/tree/1.0.5" class="external-link">varnish (1.0.5)</a></p>
			</div>
		</footer>
</div> <!-- / div.container -->
	<div id="to-top">
		<a href="#top">
      <i class="search-icon" data-feather="arrow-up" role="img" aria-label="Back To Top"></i><br><!-- <span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top --><span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top
		</a>
	</div>
  <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "TrainingMaterial",
  "@id": "https://carpentries-incubator.github.io/fair-explainable-ml/instructor/aio.html",
  "inLanguage": "en",
  "dct:conformsTo": "https://bioschemas.org/profiles/TrainingMaterial/1.0-RELEASE",
  "description": "A Carpentries Lesson teaching foundational data and coding skills to researchers worldwide",
  "keywords": "fairness, explainability, fair machine learning, interpretable machine learning, xai, lesson, The Carpentries",
  "name": "All in One View",
  "creativeWorkStatus": "active",
  "url": "https://carpentries-incubator.github.io/fair-explainable-ml/instructor/aio.html",
  "identifier": "https://carpentries-incubator.github.io/fair-explainable-ml/instructor/aio.html",
  "dateCreated": "2023-12-05",
  "dateModified": "2024-12-19",
  "datePublished": "2024-12-19"
}

  </script><script>
		feather.replace();
	</script>
</body>
</html><!-- END:   inst/pkgdown/templates/layout.html-->

