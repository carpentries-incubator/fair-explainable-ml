<!DOCTYPE html>
<!-- START: inst/pkgdown/templates/layout.html --><!-- Generated by pkgdown: do not edit by hand --><html lang="en" data-bs-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Trustworthy AI: Explainability, Bias, Fairness, and Safety: All in One View</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="../assets/themetoggle.js"></script><link rel="stylesheet" type="text/css" href="../assets/styles.css">
<script src="../assets/scripts.js" type="text/javascript"></script><!-- mathjax --><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      config: ["MMLorHTML.js"],
      jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [['\\(', '\\)']],
        displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
        processEscapes: true
      }
    });
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><!-- Responsive Favicon for The Carpentries --><link rel="apple-touch-icon" sizes="180x180" href="../favicons/incubator/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicons/incubator/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../favicons/incubator/favicon-16x16.png">
<link rel="manifest" href="../favicons/incubator/site.webmanifest">
<link rel="mask-icon" href="../favicons/incubator/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="white">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="black">
</head>
<body>
    <header id="top" class="navbar navbar-expand-md top-nav incubator"><svg xmlns="http://www.w3.org/2000/svg" class="d-none"><symbol id="check2" viewbox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path></symbol><symbol id="circle-half" viewbox="0 0 16 16"><path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path></symbol><symbol id="moon-stars-fill" viewbox="0 0 16 16"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path><path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"></path></symbol><symbol id="sun-fill" viewbox="0 0 16 16"><path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></symbol></svg><a class="visually-hidden-focusable skip-link" href="#main-content">Skip to main content</a>
  <div class="container-fluid top-nav-container">
    <div class="col-md-8">
      <div class="large-logo">
        <img id="incubator-logo" alt="Carpentries Incubator" src="../assets/images/incubator-logo.svg"><span class="badge text-bg-danger">
          <abbr title="This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.">
            <a href="https://cdh.carpentries.org/the-lesson-life-cycle.html#early-development-pre-alpha-through-alpha" class="external-link alert-link">
              <i aria-hidden="true" class="icon" data-feather="alert-octagon" style="border-radius: 5px"></i>
              Pre-Alpha
            </a>
            <span class="visually-hidden">This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.</span>
          </abbr>
        </span>

      </div>
    </div>
    <div class="selector-container">
      <div id="theme-selector">
        <li class="nav-item dropdown" id="theme-button-list">
          <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
            <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="bd-theme-text">
<li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                Light
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                Dark
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                Auto
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
          </ul>
</li>
      </div>

      <div class="dropdown" id="instructor-dropdown">
        <button class="btn btn-secondary dropdown-toggle bordered-button" type="button" id="dropdownMenu1" data-bs-toggle="dropdown" aria-expanded="false">
          <i aria-hidden="true" class="icon" data-feather="eye"></i> Instructor View <i data-feather="chevron-down"></i>
        </button>
        <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
<li><button class="dropdown-item" type="button" onclick="window.location.href='../aio.html';">Learner View</button></li>
        </ul>
</div>
    </div>
  </div>
  <hr></header><nav class="navbar navbar-expand-xl bottom-nav incubator" aria-label="Main Navigation"><div class="container-fluid nav-container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle Navigation">
      <span class="navbar-toggler-icon"></span>
      <span class="menu-title">Menu</span>
    </button>
    <div class="nav-logo">
      <img class="small-logo" alt="Carpentries Incubator" src="../assets/images/incubator-logo-sm.svg">
</div>
    <div class="lesson-title-md">
      Trustworthy AI: Explainability, Bias, Fairness, and Safety
    </div>
    <div class="search-icon-sm">
      <!-- TODO: do not show until we have search
        <i role="img" aria-label="Search the All In One page" data-feather="search"></i>
      -->
    </div>
    <div class="desktop-nav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
<li class="nav-item">
          <span class="lesson-title">
            Trustworthy AI: Explainability, Bias, Fairness, and Safety
          </span>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/key-points.html">Key Points</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/instructor-notes.html">Instructor Notes</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/images.html">Extract All Images</a>
        </li>
        <li class="nav-item dropdown">
          <button class="nav-link dropdown-toggle" id="navbarDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            More <i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
<hr>
<li><a class="dropdown-item" href="reference.html">Reference</a></li>
          </ul>
</li>
      </ul>
</div>
    <!--
    <form class="d-flex col-md-2 search-form">
      <fieldset disabled>
      <input class="form-control me-2 searchbox" type="search" placeholder="" aria-label="">
        <button class="btn btn-outline-success tablet-search-button"  type="submit">
          <i class="search-icon" data-feather="search" role="img" aria-label="Search the All In One page"></i>
        </button>
      </fieldset>
    </form>
    -->
    <a id="search-button" class="btn btn-primary" href="../instructor/aio.html" role="button" aria-label="Search the All In One page">Search the All In One page</a>
  </div>
<!--/div.container-fluid -->
</nav><div class="col-md-12 mobile-title">
  Trustworthy AI: Explainability, Bias, Fairness, and Safety
</div>

<aside class="col-md-12 lesson-progress"><div style="width: %" class="percentage">
    %
  </div>
  <div class="progress incubator">
    <div class="progress-bar incubator" role="progressbar" style="width: %" aria-valuenow="" aria-label="Lesson Progress" aria-valuemin="0" aria-valuemax="100">
    </div>
  </div>
</aside><div class="container">
      <div class="row">
        <!-- START: inst/pkgdown/templates/navbar.html -->
<div id="sidebar-col" class="col-lg-4">
  <div id="sidebar" class="sidebar">
      <nav aria-labelledby="flush-headingEleven"><button role="button" aria-label="close menu" alt="close menu" aria-expanded="true" aria-controls="sidebar" class="collapse-toggle" data-collapse="Collapse " data-episodes="Episodes ">
          <i class="search-icon" data-feather="x" role="img"></i>
        </button>
        <div class="sidebar-inner">
          <div class="row mobile-row" id="theme-row-mobile">
            <div class="col" id="theme-selector">
              <li class="nav-item dropdown" id="theme-button-list">
                <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
                  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><span class="d-lg-none ms-1" id="bd-theme-text">Toggle Theme</span>
                </button>
                <ul class="dropdown-menu dropdown-menu-right" aria-labelledby="bd-theme-text">
<li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                      Light
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                      Dark
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                      <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                      Auto
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                </ul>
</li>
            </div>
          </div>
          <div class="row mobile-row">
            <div class="col">
              <div class="sidenav-view-selector">
                <div class="accordion accordion-flush" id="accordionFlush9">
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingNine">
                      <button class="accordion-button collapsed" id="instructor" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <i id="eye" aria-hidden="true" class="icon" data-feather="eye"></i> Instructor View
                      </button>
                    </h2>
                    <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlush2">
                      <div class="accordion-body">
                        <a href="../aio.html">Learner View</a>
                      </div>
                    </div>
                  </div>
<!--/div.accordion-item-->
                </div>
<!--/div.accordion-flush-->
              </div>
<!--div.sidenav-view-selector -->
            </div>
<!--/div.col -->

            <hr>
</div>
<!--/div.mobile-row -->

          <div class="accordion accordion-flush" id="accordionFlush11">
            <div class="accordion-item">

              <button id="chapters" class="accordion-button show" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                <h2 class="accordion-header chapters" id="flush-headingEleven">
                  EPISODES
                </h2>
              </button>
              <div id="flush-collapseEleven" class="accordion-collapse show collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlush11">

                <div class="accordion-body">
                  <div class="accordion accordion-flush" id="accordionFlush1">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading1">
        <a href="index.html">Summary and Schedule</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush2">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading2">
        <a href="0-introduction.html">1. Overview</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush3">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading3">
        <a href="1-preparing-to-train.html">2. Preparing to train a model</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush4">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading4">
        <a href="2-model-eval-and-fairness.html">3. Model evaluation and fairness</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush5">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading5">
        <a href="3-model-fairness-deep-dive.html">4. Model fairness: hands-on</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush6">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading6">
        <a href="4-explainability-vs-interpretability.html">5. Interpretablility versus explainability</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush7">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading7">
        <a href="5a-explainable-AI-method-overview.html">6. Explainability methods overview</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush8">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading8">
        <a href="5b-deep-dive-into-methods.html">7. Explainability methods: deep dive</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush9">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading9">
        <a href="5c-probes.html">8. Explainability methods: linear probe</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush10">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading10">
        <a href="5d-gradcam.html">9. Explainability methods: GradCAM</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush11">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading11">
        <a href="6-confidence-intervals.html">10. Estimating model uncertainty: overview</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush12">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading12">
        <a href="7a-OOD-detection-overview.html">11. OOD detection: overview</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush13">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading13">
        <a href="7b-OOD-detection-output-based.html">12. OOD detection: output-based methods</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush14">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading14">
        <a href="7c-OOD-detection-distance-based.html">13. OOD detection: distance-based</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush15">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading15">
        <a href="7d-OOD-detection-algo-design.html">14. OOD detection: training-time regularization</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush16">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading16">
        <a href="8-releasing-a-model.html">15. Documenting and releasing a model</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

                </div>
              </div>
            </div>

            <hr class="half-width">
<div class="accordion accordion-flush lesson-resources" id="accordionFlush12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingTwelve">
                  <button class="accordion-button collapsed" id="lesson-resources" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                    RESOURCES
                  </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlush12">
                  <div class="accordion-body">
                    <ul>
<li>
                        <a href="../instructor/key-points.html">Key Points</a>
                      </li>
                      <li>
                        <a href="../instructor/instructor-notes.html">Instructor Notes</a>
                      </li>
                      <li>
                        <a href="../instructor/images.html">Extract All Images</a>
                      </li>
                      <hr>
<li><a class="dropdown-item" href="reference.html">Reference</a></li>
                    </ul>
</div>
                </div>
              </div>
            </div>
            <hr class="half-width lesson-resources">
<a href="../instructor/aio.html">See all in one page</a>


            <hr class="d-none d-sm-block d-md-none">
<div class="d-grid gap-1">

            </div>
          </div>
<!-- /div.accordion -->
        </div>
<!-- /div.sidebar-inner -->
      </nav>
</div>
<!-- /div.sidebar -->
  </div>
<!-- /div.sidebar-col -->
<!-- END:   inst/pkgdown/templates/navbar.html-->

        <!-- START: inst/pkgdown/templates/content-extra.html -->
  <div class="col-xl-8 col-lg-12 primary-content">
    <main id="main-content" class="main-content"><div class="container lesson-content">
        
        
<section id="aio-0-introduction"><p>Content from <a href="0-introduction.html">Overview</a></p>
<hr>
<p>Last updated on 2024-10-17 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/0-introduction.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 31 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What do we mean by “Trustworthy AI”?</li>
<li>How is this workshop structured, and what content does it
cover?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Define trustworthy AI and its various components.</li>
<li>Be prepared to dive into the rest of the workshop.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="what-is-trustworthy-ai">What is trustworthy AI?<a class="anchor" aria-label="anchor" href="#what-is-trustworthy-ai"></a>
</h2>
<hr class="half-width">
<div id="discussion1" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Discussion</h3>
<div class="callout-content">
<p>Take a moment to brainstorm what keywords/concepts come to mind when
we mention “Trustworthy AI”. Share your thoughts with the class.</p>
</div>
</div>
</div>
<p>Artificial intelligence (AI) and machine learning (ML) are being used
widely to improve upon human capabilities (either in
speed/convenience/cost or accuracy) in a variety of domains: medicine,
social media, news, marketing, policing, and more. It is important that
the decisions made by AI/ML models uphold values that we, as a society,
care about.</p>
<p>Trustworthy AI is a large and growing sub-field of AI that aims to
ensure that AI models are trained and deployed in ways that are ethical
and responsible.</p>
</section><section><h2 class="section-heading" id="the-ai-bill-of-rights">The AI Bill of Rights<a class="anchor" aria-label="anchor" href="#the-ai-bill-of-rights"></a>
</h2>
<hr class="half-width">
<p>In October 2022, the Biden administration released a <a href="https://www.whitehouse.gov/ostp/ai-bill-of-rights/" class="external-link">Blueprint for
an AI Bill of Rights</a>, a non-binding document that outlines how
automated systems and AI should behave in order to protect Americans’
rights.</p>
<p>The blueprint is centered around five principles:</p>
<ul>
<li>Safe and Effective Systems – AI systems should work as expected, and
should not cause harm</li>
<li>Algorithmic Discrimination Protections – AI systems should not
discriminate or produce inequitable outcomes</li>
<li>Data Privacy – data collection should be limited to what is
necessary for the system functionality, and you should have control over
how and if your data is used</li>
<li>Notice and Explanation – it should be transparent when an AI system
is being used, and there should be an explanation of how particular
decisions are reached</li>
<li>Human Alternatives, Consideration, and Fallback – you should be able
to opt out of engaging with AI systems, and a human should be available
to remedy any issues</li>
</ul></section><section><h2 class="section-heading" id="this-workshop">This workshop<a class="anchor" aria-label="anchor" href="#this-workshop"></a>
</h2>
<hr class="half-width">
<p>This workshop centers around four principles that are important to
trustworthy AI: <em>scientific validity</em>, <em>fairness</em>,
<em>transparency</em>, and <em>accountability</em>. We summarize each
principle here.</p>
<div class="section level3">
<h3 id="scientific-validity">Scientific validity<a class="anchor" aria-label="anchor" href="#scientific-validity"></a>
</h3>
<p>In order to be trustworthy, a model and its predictions need to be
founded on good science. A model is not going to perform well if is not
trained on the correct data, if it fits the underlying data poorly, or
if it cannot recognize its own limitations. Scientific validity is
closely linked to the AI Bill of Rights principle of “safe and effective
systems”.</p>
<p>In this workshop, we cover the following topics relating to
scientific validity:</p>
<ul>
<li>Defining the problem (Preparing to Train a Model episode)</li>
<li>Training and evaluating a model, especially selecting an accuracy
metric, avoiding over/underfitting, and preventing data leakage (Model
Evaluation and Fairness episode)</li>
<li>Estimating model uncertainty (Estimating Model Uncertainty
episode)</li>
<li>Out-of-distribution detection (OOD Detection episodes)</li>
</ul>
</div>
<div class="section level3">
<h3 id="fairness">Fairness<a class="anchor" aria-label="anchor" href="#fairness"></a>
</h3>
<p>As stated in the AI Bill of Rights, AI systems should not be
discriminatory or produce inequitable outcomes. In the Model Evaluation
and Fairness episode we discuss various definitions of fairness in the
context of AI, and overview how model developers try to make their
models more fair.</p>
</div>
<div class="section level3">
<h3 id="transparency">Transparency<a class="anchor" aria-label="anchor" href="#transparency"></a>
</h3>
<p>Transparency – i.e., insight into <em>how</em> a model makes its
decisions – is important for trustworthy AI, as we want models that make
the right decisions <em>for the right reasons</em>. Transparency can be
achieved via <em>explanations</em> or by using inherently
<em>interpretable</em> models. We discuss transparency in the follow
episodes:</p>
<ul>
<li>Interpretability vs Explainability</li>
<li>Explainability Methods Overview</li>
<li>Explainability Methods: Deep Dive, Linear Probe, and GradCAM
episodes</li>
</ul>
</div>
<div class="section level3">
<h3 id="accountability">Accountability<a class="anchor" aria-label="anchor" href="#accountability"></a>
</h3>
<p>Accountability is important for trustworthy AI because, inevitably,
models will make mistakes or cause harm. Accountability is multi-faceted
and largely non-technical, which is not to say unimportant, but just
that it falls partially out of scope of this technical workshop.</p>
<p>We discuss two facets of accountability, model documentation and
model sharing, in the Documenting and Releasing a Model episode.</p>
<p>For those who are interested, we recommend these papers to learn more
about different aspects of AI accountability:</p>
<ol style="list-style-type: decimal">
<li>
<a href="https://arxiv.org/pdf/1711.01134" class="external-link">Accountability of AI
Under the Law: The Role of Explanation</a> by Finale Doshi-Velez and
colleagues. This paper discusses how explanations can be used in a legal
context to determine accountability for harms caused by AI.</li>
<li>
<a href="https://dl.acm.org/doi/abs/10.1145/3351095.3372873" class="external-link">Closing
the AI accountability gap: defining an end-to-end framework for internal
algorithmic auditing</a> by Deborah Raji and colleagues proposes a
framework for auditing algorithms. A key contribution of this paper is
defining an auditing procedure over the whole model development and
implementation pipeline, rather than narrowly focusing on the modeling
stages.</li>
<li>
<a href="https://ieeexplore.ieee.org/abstract/document/10516659" class="external-link">AI
auditing: The Broken Bus on the Road to AI Accountability</a> by Abeba
Birhane and colleagues challenges previous work on AI accountability,
arguing that most existing AI auditing systems are not effective. They
propose necessary traits for effective AI audits, based on a review of
existing practices.</li>
</ol>
</div>
<div class="section level3">
<h3 id="topics-we-do-not-cover">Topics we do not cover<a class="anchor" aria-label="anchor" href="#topics-we-do-not-cover"></a>
</h3>
<p>Trustworthy AI is a large, and growing, area of study. As of
September 24, 2024, <strong>there are about 18,000 articles on Google
Scholar that mention Trustworthy AI and were published in the first 9
months of 2024</strong>.</p>
<p>There are different Trustworthy AI methods for different types of
models – e.g., decisions trees or linear models that are commonly used
with tabular data, neural networks that are used with image data, or
large multi-modal foundation models. In this workshop, we focus
primarily on neural networks for the specific techniques we show in the
technical implementations. That being said, much of the conceptual
content is relevant to any model type.</p>
<p>Many of the topics we do not cover are sub-topics of the broad
categories – e.g., fairness, explainability, or OOD detection – of the
workshop and are important for specific use cases, but less relevant for
a general audience. But, there are a few major areas of research that we
don’t have time to touch on. We summarize a few of them here:</p>
<div class="section level4">
<h4 id="data-privacy">Data Privacy<a class="anchor" aria-label="anchor" href="#data-privacy"></a>
</h4>
<p>In the US’s Blueprint for an AI Bill of Rights, one principle is data
privacy, meaning that people should be aware how their data is being
used, companies should not collect more data than they need, and people
should be able to consent and/or opt out of data collection and
usage.</p>
<p>A lack of data privacy poses several risks: first, whenever data is
collected, it can be subject to data breaches. This risk is unavoidable,
but collecting only the data that is truly necessary mitigates this
risk, as does implementing safeguards to how data is stored and and
accessed. Second, when data is used to train ML models, that data can
sometimes be identifying by attackers. For instance, large language
models like ChatGPT are known to release private data that was part of
the training corpus when prompted in clever ways (see this <a href="https://not-just-memorization.github.io/extracting-training-data-from-chatgpt.html" class="external-link">blog
post</a> for more information).<br>
Membership inference attacks, where an attacker determines whether a
particular individual’s data was in the training corpus, are another
vulnerability. These attacks may reveal things about a person directly
(e.g., if the training dataset consisted of only people with a
particular medical condition), or can be used to setup downstream
attacks to gain more information.</p>
<p>There are several areas of active research relating to data
privacy.</p>
<ul>
<li>
<a href="https://link.springer.com/chapter/10.1007/978-3-540-79228-4_1" class="external-link">Differential
privacy</a> is a statistical technique that protects the privacy of
individual data points. Models can be trained using differential privacy
to provably prevent future attacks, but this currently comes at a high
cost to accuracy.</li>
<li>
<a href="https://ieeexplore.ieee.org/abstract/document/9599369" class="external-link">Federated
learning</a> trains models using decentralized data from a variety of
sources. Since the data is not shared centrally, there is less risk of
data breaches or unauthorized data usage.</li>
</ul>
</div>
<div class="section level4">
<h4 id="generative-ai-risks">Generative AI risks<a class="anchor" aria-label="anchor" href="#generative-ai-risks"></a>
</h4>
<p>We touch on fairness issues with generative AI in the Model
Evaluation and Fairness episode. But generative AI poses other risks,
too, many of which are just starting to be researched and understood
given how new widely-available generative AI is. We discuss one such
risk, disinformation, briefly here:</p>
<ul>
<li>Disinformation: A major risk of generative AI is the creation of
misleading or fake and malicious content, often known as <a href="https://timreview.ca/article/1282" class="external-link">deep fakes</a>. Deep fakes pose
risks to individuals (e.g., creating content that harms an individual’s
reputation) and society (e.g., fake news articles or pictures that look
real).</li>
</ul>
<div id="accordionInstructor1" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor1" aria-expanded="false" aria-controls="collapseInstructor1">
  <h3 class="accordion-header" id="headingInstructor1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Instructor Note </h3>
</button>
<div id="collapseInstructor1" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor1" aria-labelledby="headingInstructor1">
<div class="accordion-body">
<p>Inline instructor notes can help inform instructors of timing
challenges associated with the lessons. They appear in the “Instructor
View”</p>
</div>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div>
</section></section><section id="aio-1-preparing-to-train"><p>Content from <a href="1-preparing-to-train.html">Preparing to train a model</a></p>
<hr>
<p>Last updated on 2024-10-17 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/1-preparing-to-train.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>For what prediction tasks is machine learning an appropriate
tool?</li>
<li>How can inappropriate target variable choice lead to suboptimal
outcomes in a machine learning pipeline?</li>
<li>What forms of “bias” can occur in machine learning, and where do
these biases come from?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Judge what tasks are appropriate for machine learning</li>
<li>Understand why the choice of prediction task / target variable is
important.</li>
<li>Describe how bias can appear in training data and algorithms.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="choosing-appropriate-tasks">Choosing appropriate tasks<a class="anchor" aria-label="anchor" href="#choosing-appropriate-tasks"></a>
</h2>
<hr class="half-width">
<p>Machine learning is a rapidly advancing, powerful technology that is
helping to drive innovation. Before embarking on a machine learning
project, we need to consider the task carefully. Many machine learning
efforts are not solving problems that need to be solved. Or, the problem
may be valid, but the machine learning approach makes incorrect
assumptions and fails to solve the problem effectively. Worse, many
applications of machine learning are not for the public good.</p>
<p>We will start by considering the <a href="https://www.nih.gov/health-information/nih-clinical-research-trials-you/guiding-principles-ethical-research" class="external-link">NIH
Guiding Principles for Ethical Research</a>, which provide a useful set
of considerations for any project.</p>
<div id="discussion1" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Take a look at the <a href="https://www.nih.gov/health-information/nih-clinical-research-trials-you/guiding-principles-ethical-research" class="external-link">NIH
Guiding Principles for Ethical Research</a>.</p>
<p>What are the main principles?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<p>A summary of the principles is listed below:</p>
<ul>
<li>Social and clinical value: Does the social or clinical value of
developing and implementing the model outweigh the risk and burden of
the people involved?</li>
<li>Scientific validity: Once created, will the model provide valid,
meaningful outputs?</li>
<li>Fair subject selection: Are the people who contribute and benefit
from the model selected fairly, and not through vulnerability,
privilege, or other unrelated factors?</li>
<li>Favorable risk-benefit ratio: Do the potential benefits of of
developing and implementing the model outweigh the risks?</li>
<li>Independent review: Has the project been reviewed by someone
independent of the project, and has an Institutional Review Board (IRB)
been approached where appropriate?</li>
<li>Informed consent: Are participants whose data contributes to
development and implementation of the model, as well as downstream
recipients of the model, kept informed?</li>
<li>Respect for potential and enrolled subjects: Is the privacy of
participants respected and are steps taken to continuously monitor the
effect of the model on downstream participants?</li>
</ul>
</div>
</div>
</div>
</div>
<p>AI tasks are often most controversial when they involve human
subjects, and especially visual representations of people. We’ll discuss
two case studies that use people’s faces as a prediction tool, and
discuss whether these uses of AI are appropriate.</p>
<div class="section level3">
<h3 id="case-study-1-physiognomy">Case study 1: Physiognomy<a class="anchor" aria-label="anchor" href="#case-study-1-physiognomy"></a>
</h3>
<p>In 2019, Nature Medicine <a href="https://www.nature.com/articles/s41591-018-0279-0.epdf" class="external-link">published
a paper</a> that describes a model that can identify genetic disorders
from a photograph of a patient’s face. The abstract of the paper is
copied below:</p>
<blockquote>
<p>Syndromic genetic conditions, in aggregate, affect 8% of the
population. Many syndromes have recognizable facial features that are
highly informative to clinical geneticists. Recent studies show that
facial analysis technologies measured up to the capabilities of expert
clinicians in syndrome identification. However, these technologies
identified only a few disease phenotypes, limiting their role in
clinical settings, where hundreds of diagnoses must be considered. Here
we present a facial image analysis framework, DeepGestalt, using
computer vision and deep-learning algorithms, that quantifies
similarities to hundreds of syndromes.</p>
<p>DeepGestalt outperformed clinicians in three initial experiments, two
with the goal of distinguishing subjects with a target syndrome from
other syndromes, and one of separating different genetic sub-types in
Noonan syndrome. On the final experiment reflecting a real clinical
setting problem, DeepGestalt achieved 91% top-10 accuracy in identifying
the correct syndrome on 502 different images. The model was trained on a
dataset of over 17,000 images representing more than 200 syndromes,
curated through a community-driven phenotyping platform. DeepGestalt
potentially adds considerable value to phenotypic evaluations in
clinical genetics, genetic testing, research and precision medicine.</p>
</blockquote>
<ul>
<li>What is the proposed value of the algorithm?</li>
<li>What are the potential risks?</li>
<li>Are you supportive of this kind of research?</li>
<li>What safeguards, if any, would you want to be used when developing
and using this algorithm?</li>
</ul>
<div id="accordionInstructor1" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor1" aria-expanded="false" aria-controls="collapseInstructor1">
  <h3 class="accordion-header" id="headingInstructor1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Discussion points </h3>
</button>
<div id="collapseInstructor1" class="accordion-collapse collapse" aria-labelledby="headingInstructor1" data-bs-parent="#accordionInstructor1">
<div class="accordion-body">
<ul>
<li>The algorithm could help doctors figure out what rare disease a
patient has.</li>
<li>First, if the algorithm is used in the wrong hands, it could be used
to discriminate against people with diseases. Second, if the algorithm
is not accurate (false positive or false negative), trusting its results
could lead to improper medical care.</li>
<li>Safeguards could include: requiring extensive testing to ensure that
the algorithm maintains similar accuracy across racial and gender
groups, making sure the algorithm is only accessible to medical
professionals, and requiring follow-up testing to confirm the
algorithm’s diagnosis.</li>
</ul>
</div>
</div>
</div>
</div>
<p>Media reports about this paper were largely positive, e.g., <a href="https://www.genengnews.com/insights/a-i-gets-in-the-face-of-rare-genetic-diseases/" class="external-link">reporting
that clinicians are excited about the new technology</a>.</p>
</div>
<div class="section level3">
<h3 id="case-study-2">Case study 2:<a class="anchor" aria-label="anchor" href="#case-study-2"></a>
</h3>
<p>There is a long history of physiognomy, the “science” of trying to
read someone’s character from their face. With the advent of machine
learning, this discredited area of research has made a comeback. There
have been numerous studies attempting to guess characteristics such as
trustworthness, criminality, and political and sexual orientation.</p>
<p>In 2018, for example, researchers suggested that neural networks
could be used to detect sexual orientation from facial images. The
abstract is copied below:</p>
<blockquote>
<p>We show that faces contain much more information about sexual
orientation than can be perceived and interpreted by the human brain. We
used deep neural networks to extract features from 35,326 facial images.
These features were entered into a logistic regression aimed at
classifying sexual orientation. Given a single facial image, a
classifier could correctly distinguish between gay and heterosexual men
in 81% of cases, and in 74% of cases for women. Human judges achieved
much lower accuracy: 61% for men and 54% for women. The accuracy of the
algorithm increased to 91% and 83%, respectively, given five facial
images per person.</p>
<p>Facial features employed by the classifier included both fixed (e.g.,
nose shape) and transient facial features (e.g., grooming style).
Consistent with the prenatal hormone theory of sexual orientation, gay
men and women tended to have gender-atypical facial morphology,
expression, and grooming styles. Prediction models aimed at gender alone
allowed for detecting gay males with 57% accuracy and gay females with
58% accuracy. Those findings advance our understanding of the origins of
sexual orientation and the limits of human perception. Additionally,
given that companies and governments are increasingly using computer
vision algorithms to detect people’s intimate traits, our findings
expose a threat to the privacy and safety of gay men and women.</p>
</blockquote>
<div id="discussion2" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Discussion</h3>
<div class="callout-content">
<p>Discuss the following questions.</p>
<ul>
<li>What is the proposed value of the algorithm?</li>
<li>What are the potential risks?</li>
<li>Are you supportive of this kind of research?</li>
<li>What distinguishes this use of AI from the use of AI described in
Case Study 1?</li>
</ul>
</div>
</div>
</div>
<div id="accordionInstructor2" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor2" aria-expanded="false" aria-controls="collapseInstructor2">
  <h3 class="accordion-header" id="headingInstructor2">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Discussion points </h3>
</button>
<div id="collapseInstructor2" class="accordion-collapse collapse" aria-labelledby="headingInstructor2" data-bs-parent="#accordionInstructor2">
<div class="accordion-body">
<ul>
<li>The algorithm proposes detecting an individual’s sexual orientation
from images of their face. It is unclear why this is something that
needs to be algorithmically detected by any entity.</li>
<li>If the algorithm is used by anti-LGBTQ entities, it could be used to
harass members of the LGBTQ community (as well as non-LGBTQ people who
are flagged as LGBTQ by the algorithm). If the algorithm is accurate, it
could be used to “out” individuals who are gay but do not want to
publicly share that information.</li>
<li>The first case study aims to detect disease. The implication of this
research – at least, as suggested by the linked article – is that it can
help doctors with diagnosis and give individuals affected by the disease
access to treatment. Conversely, if there is a medical reason for
knowing someone’s sexual orientation, it is not necessary to use AI –
the doctor can just ask the patient.</li>
</ul>
</div>
</div>
</div>
</div>
<p>Media reports of this algorithm were largely negative, with a <a href="https://www.scientificamerican.com/blog/observations/can-we-read-a-persons-character-from-facial-images/" class="external-link">Scientific
American article</a> highlighting the connections to physiognomy and
raising concern over government use of these algorithms:</p>
<blockquote>
<p>This is precisely the kind of “scientific” claim that can motivate
repressive governments to apply AI algorithms to images of their
citizens. And what is it to stop them from “reading” intelligence,
political orientation and criminal inclinations from these images?</p>
</blockquote>
</div>
</section><section><h2 class="section-heading" id="choosing-the-outcome-variable">Choosing the outcome variable<a class="anchor" aria-label="anchor" href="#choosing-the-outcome-variable"></a>
</h2>
<hr class="half-width">
<p>Sometimes, choosing the outcome variable is easy: for instance, when
building a model to predict how warm it will be out tomorrow, the
temperature can be the outcome variable because it’s measurable (i.e.,
you know what temperature it was yesterday and today) and your
predictions won’t cause a feedback loop (e.g., given a set of past
weather data, the weather next Monday won’t change based on what your
model predicts tomorrow’s temperature to be).</p>
<p>By contrast, sometimes it’s not possible to measure the target
prediction subject directly, and sometimes predictions can cause
feedback loops.</p>
<div class="section level3">
<h3 id="case-study-proxy-variables">Case Study: Proxy variables<a class="anchor" aria-label="anchor" href="#case-study-proxy-variables"></a>
</h3>
<p>Consider the scenario described in the challenge below.</p>
<div id="discussion3" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Suppose that you work for a hospital and are asked to build a model
to predict which patients are high-risk and need extra care to prevent
negative health outcomes.</p>
<p>Discuss the following with a partner or small group: 1. What is the
goal target variable? 2. What are challenges in measuring the target
variable in the training data (i.e., former patients)? 3. Are there
other variables that are easier to measure, but can approximate the
target variable, that could serve as proxies? 3. How do social
inequities interplay with the value of the target variable versus the
value of the proxies?</p>
</div>
</div>
</div>
<div id="accordionInstructor3" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor3" aria-expanded="false" aria-controls="collapseInstructor3">
  <h3 class="accordion-header" id="headingInstructor3">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Discussion points </h3>
</button>
<div id="collapseInstructor3" class="accordion-collapse collapse" aria-labelledby="headingInstructor3" data-bs-parent="#accordionInstructor3">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>The goal target variable is healthcare need.</li>
<li>Patients’ healthcare needs are unknown unless they have seen a
doctor. Patients who have less access to medical care may have
under-documented needs. There might also be differences between doctors
or hospital systems in how health conditions are documented.</li>
<li>In the US, there are standard ways that healthcare <em>billing</em>
information needs to be documented (this information may be more
standardized than medical conditions). There may be more complete data
from acute medical emergencies (i.e., emergency room visits) than there
is for chronic conditions.</li>
<li>In the US, healthcare access is often tied to employment, which
means that wealthier people (who in the US, also tend to be white) have
more access to healthcare.</li>
</ol>
</div>
</div>
</div>
</div>
<p>The “challenge” scenario is not hypothetical: A well-known <a href="https://escholarship.org/content/qt6h92v832/qt6h92v832.pdf" class="external-link">study
by Obermeyer et al.</a> analyzed an algorithm that hospitals used to
assign patients risk scores for various conditions. The algorithm had
access to various patient data, such as demographics (e.g., age and
sex), the number of chronic conditions, insurance type, diagnoses, and
medical costs. The algorithm did not have access to the patient’s race.
The patient risk score determined the level of care the patient should
receive, with higher-risk patients receiving additional care.</p>
<p>Ideally, the target variable would be health needs, but this can be
challenging to measure: how do you compare the severity of two different
conditions? Do you count chronic and acute conditions equally? In the
system described by Obermeyer et al., the hospital decided to use
<strong>health-care costs</strong> as a proxy for health needs, perhaps
reasoning that this data is at least standardized across patients and
doctors.</p>
<p>However, Obermeyer et al. reveal that the algorithm is biased against
Black patients. That is, if there are two individuals – one white and
one Black – with equal health, the algorithm tends to assign a higher
risk score to the white patient, thus giving them access to higher care
quality. The authors blame the choice of proxy variable for the racial
disparities.</p>
<p>The authors go on to describe how, due to how health-care access is
structured in the US, richer patients have more healthcare expenses,
even if they are equally (un)healthy to a lower-income patient. The
richer patients are also more likely to be white.</p>
<p>Consider the following:</p>
<ul>
<li>How could the algorithm developers have caught this problem
earlier?</li>
<li>Is this a technical mistake or a process-based mistake? Why?</li>
</ul>
<div id="accordionInstructor4" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor4" aria-expanded="false" aria-controls="collapseInstructor4">
  <h3 class="accordion-header" id="headingInstructor4">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Discussion points </h3>
</button>
<div id="collapseInstructor4" class="accordion-collapse collapse" aria-labelledby="headingInstructor4" data-bs-parent="#accordionInstructor4">
<div class="accordion-body">
<ul>
<li>The algorithm developers could have tested specifically checked for
racial bias in their solution.</li>
<li>Discussion about the choice of target variable, including
implementing models with different targets and comparing the results,
could have exposed the bias.</li>
<li>Possibly a more diverse development team – e.g., including
individuals who have firsthand experience with struggling to access
healthcare – would have spotted the issue.</li>
<li>Note that it’s easier to see the mistake in hindsight than in the
moment.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="case-study-feedback-loop">Case study: Feedback loop<a class="anchor" aria-label="anchor" href="#case-study-feedback-loop"></a>
</h3>
<p>Consider social media, like Instagram or TikTok’s “for you page” or
Facebook or Twitter’s newsfeed. The algorithms that determine what to
show are complex (and proprietary!) but a large part of the algorithms’
objective is engagement: the number of clicks, views, or re-posts. For
instance, this focus on engagement can create an “echo chamber” where
individual users solely see content that aligns with their political
ideology, thereby maximizing the positive engagement with each post. But
the impact of social media feedback loops spreads beyond politics: <a href="https://arxiv.org/pdf/2305.11316" class="external-link">researchers have explored</a>
how similar feedback loops exist for mental health conditions such as
eating disorders. If someone finds themselves in this area of social
media, it’s likely because they have, or have risk factors for, an
eating disorder, and seeing pro-eating disorder content can drive
engagement, but ultimately be very bad for mental health.</p>
<p>Consider the following questions:</p>
<ul>
<li>Why do social media companies optimize for engagement?</li>
<li>What would be an alternative optimization target? How would the
outcomes differ, both for users and for the companies’ profits?</li>
</ul>
<div id="accordionInstructor5" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor5" aria-expanded="false" aria-controls="collapseInstructor5">
  <h3 class="accordion-header" id="headingInstructor5">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Discussion points </h3>
</button>
<div id="collapseInstructor5" class="accordion-collapse collapse" aria-labelledby="headingInstructor5" data-bs-parent="#accordionInstructor5">
<div class="accordion-body">
<ul>
<li>Social media companies optimize for engagement to maximize profits:
if users keep using the service, they can sell more ads and bring in
more revenue.</li>
<li>It’s hard to come up with an alternate optimization target that
could be easily operationalized. Alternate goals could be <em>social
connection</em>, <em>learning</em>, <em>broadening one’s worldview</em>,
or even <em>entertainment</em>. But how would any of these goals be
measured?</li>
</ul>
</div>
</div>
</div>
</div>
<p><strong>Recap - Choosing the right outcome variable</strong>:
Sometimes, choosing the outcome variable is straightforward, like
predicting tomorrow’s temperature. Other times, it gets tricky,
especially when we can’t directly measure what we want to predict. It’s
important to choose the right outcome variable because this decision
plays a crucial role in ensuring our models are trustworthy, “fair”
(more on this later), and unbiased. A poor choice can lead to biased
results and unintended consequences, making it harder for our models to
be effective and reliable.</p>
</div>
</section><section><h2 class="section-heading" id="understanding-bias">Understanding bias<a class="anchor" aria-label="anchor" href="#understanding-bias"></a>
</h2>
<hr class="half-width">
<p>Now that we’ve covered the importance of the outcome variable, let’s
talk about bias. Bias can show up in various ways during the modeling
process, impacting our results and fairness. If we don’t consider bias
from the beginning, we risk creating models that don’t work well for
everyone or that reinforce existing inequalities.</p>
<p>So, what exactly do we mean by bias? The term is a little overloaded
and can refer to different things depending on context. However, there
are two general types/definitions of bias:</p>
<ul>
<li>(Statistical) bias: This refers to the tendency of an algorithm to
produce one solution over another, even when other options may be just
as good or better. Statistical bias can arise from several sources
(discussed below), including how data is collected and processed.</li>
<li>(Social) bias: outcomes are unfair to one or more social groups.
Social bias can be the result of statistical bias (i.e., an algorithm
giving preferential treatment to one social group over others), but can
also occur outside of a machine learning context.</li>
</ul>
<div class="section level3">
<h3 id="sources-of-statistical-bias">Sources of statistical bias<a class="anchor" aria-label="anchor" href="#sources-of-statistical-bias"></a>
</h3>
<div class="section level4">
<h4 id="algorithmic-bias">Algorithmic bias<a class="anchor" aria-label="anchor" href="#algorithmic-bias"></a>
</h4>
<p>Algorithmic bias is the tendency of an algorithm to favor one
solution over another. Algorithmic bias is not always bad, and may
sometimes be encoded for by algorithm developers. For instance, linear
regression with L0-regularization displays algorithmic bias towards
sparse classifiers (i.e., classifiers where most weights are 0). This
bias may be desirable in settings where human interpretability is
important.</p>
<p>But algorithmic bias can also occur unintentionally: for instance, if
there is data bias (described below), this may lead algorithm developers
to select an algorithm that is ill-suited to underrepresented groups.
Then, even if the data bias is rectified, sticking with the original
algorithm choice may not fix biased outcomes.</p>
</div>
<div class="section level4">
<h4 id="data-bias">Data bias:<a class="anchor" aria-label="anchor" href="#data-bias"></a>
</h4>
<p>Data bias is when the available training data is not accurate or
representative of the target population. Data bias is extremely common
(it’s often hard to collect perfectly-representative, and
perfectly-accurate data), and care arise in multiple ways:</p>
<ul>
<li>Measurement error - if a tool is not well calibrated, measurements
taken by that tool won’t be accurate. Likewise, human biases can lead to
measurement error, for instance, if people systematically over-report
their height on dating apps, or if doctors do not believe patient’s
self-reports of their pain levels.</li>
<li>Response bias - for instance, when conducting a survey about
customer satisfaction, customers who had very positive or very negative
experiences may be more likely to respond.</li>
<li>Representation bias - the data is not well representative of the
whole population. For instance, doing clinical trials primarily on white
men means that women and other races are not well represented in
data.</li>
</ul>
<p>Through the rest of this lesson, if we use the term “bias” without
any additional context, we will be referring to social bias that stems
from statistical bias.</p>
<div id="case-study" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="case-study" class="callout-inner">
<h3 class="callout-title">Case Study</h3>
<div class="callout-content">
<p>With a partner or small group, choose one of the three case study
options. Read or watch individually, then discuss as a group how bias
manifested in the training data, and what strategies could correct for
it.</p>
<p>After the discussion, share with the whole workshop what you
discussed.</p>
<ol style="list-style-type: decimal">
<li><a href="https://www.technologyreview.com/2019/02/13/137444/predictive-policing-algorithms-ai-crime-dirty-data/" class="external-link">Predictive
policing</a></li>
<li>
<a href="http://gendershades.org/" class="external-link">Facial recognition</a> (video, 5
min.)</li>
<li><a href="https://www.aclu.org/news/womens-rights/why-amazons-automated-hiring-tool-discriminated-against" class="external-link">Amazon
hiring tool</a></li>
</ol>
</div>
</div>
</div>
<div id="accordionInstructor6" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor6" aria-expanded="false" aria-controls="collapseInstructor6">
  <h3 class="accordion-header" id="headingInstructor6">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Discussion points </h3>
</button>
<div id="collapseInstructor6" class="accordion-collapse collapse" aria-labelledby="headingInstructor6" data-bs-parent="#accordionInstructor6">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>Policing data does not provide a complete picture of crime: it only
contains data about crimes that are reported. Some neighborhoods (in the
US, usually poor neighborhoods with predominantly Black and Brown
residents) are over-policed relative to other neighborhoods. As a
result, data will suggest that the over-policed neighborhoods have more
crime, and then will send more officers to patrol those areas, resulting
in a feedback loop. Using techniques to clean and balance the data could
help, but the article’s authors also point towards using non-technical
solutions, such as algorithmic accountability and oversight
frameworks.</li>
<li>Commercially-available facial recognition systems have much higher
accuracies on white men than on darker-skinned women. This discrepancy
is attributed to imbalances in the training data. This problem could
have been avoided if development teams were more diverse: e.g., if
someone thought to evaluate the model on darker-skinned people during
the development process. Then, collecting more data from
underrepresented groups could improve accuracy on those
individuals.</li>
<li>Amazon tried to automate the resume-screening part of its hiring
process, relying on data (e.g., resumes) from existing employees.
However, the AI learned to discriminate against women because Amazon’s
existing technical staff skewed heavily male. This could have been
avoided in a couple ways: first, if Amazon did not have an existing
gender skew, the data would have been cleaner. Second, given the gender
skew in Amazon’s employees, model developers could have built in
safeguards, e.g., mechanisms to satisfy some notion of fairness, such as
deciding to interview an equal proportion of male and female job
applicants.</li>
</ol>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Some tasks are not appropriate for machine learning due to ethical
concerns.</li>
<li>Machine learning tasks should have a valid prediction target that
maps clearly to the real-world goal.</li>
<li>Training data can be biased due to societal inequities, errors in
the data collection process, and lack of attention to careful sampling
practices.</li>
<li>“Bias” also refers to statistical bias, and certain algorithms can
be biased towards some solutions.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div>
</section></section><section id="aio-2-model-eval-and-fairness"><p>Content from <a href="2-model-eval-and-fairness.html">Model evaluation and fairness</a></p>
<hr>
<p>Last updated on 2024-10-15 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/2-model-eval-and-fairness.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What metrics do we use to evaluate models?</li>
<li>What are some common pitfalls in model evaluation?</li>
<li>How do we define fairness and bias in machine learning
outcomes?</li>
<li>What types of bias and unfairness can occur in generative AI?</li>
<li>What techniques exist to improve the fairness of ML models?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Reason about model performance through standard evaluation
metrics.</li>
<li>Recall how underfitting, overfitting, and data leakage impact model
performance.</li>
<li>Understand and distinguish between various notions of fairness in
machine learning.</li>
<li>Understand general approaches for improving the fairness of ML
models.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="accuracy-metrics">Accuracy metrics<a class="anchor" aria-label="anchor" href="#accuracy-metrics"></a>
</h2>
<hr class="half-width">
<p>Stakeholders often want to know the accuracy of a machine learning
model – what percent of predictions are correct? Accuracy can be
decomposed into further metrics: e.g., in a binary prediction setting,
recall (the fraction of positive samples that are classified correctly)
and precision (the fraction of samples classified as positive that
actually are positive) are commonly-used metrics.</p>
<p>Suppose we have a model that performs binary classification (+, -) on
a test dataset of 1000 samples (let <span class="math inline">\(n\)</span>=1000). A <em>confusion matrix</em>
defines how many predictions we make in each of four quadrants: true
positive with positive prediction (++), true positive with negative
prediction (+-), true negative with positive prediction (-+), and true
negative with negative prediction (–).</p>
<table class="table">
<thead><tr class="header">
<th></th>
<th>True +</th>
<th>True -</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Predicted +</td>
<td>300</td>
<td>80</td>
</tr>
<tr class="even">
<td>Predicted -</td>
<td>25</td>
<td>595</td>
</tr>
</tbody>
</table>
<p>So, for instance, 80 samples have a true class of + but get predicted
as members of -.</p>
<p>We can compute the following metrics:</p>
<ul>
<li>Accuracy: What fraction of predictions are correct?
<ul>
<li>(300 + 595) / 100 = 0.895</li>
<li>Accuracy is 89.5%</li>
</ul>
</li>
<li>Precision: What fraction of predicted positives are true positives?
<ul>
<li>300 / (300 + 80) = 0.789</li>
<li>Precision is 78.9%</li>
</ul>
</li>
<li>Recall: What fraction of true positives are classified as positive?
<ul>
<li>300 / (300 + 25) = 0.923</li>
<li>Recall is 92.3%</li>
</ul>
</li>
</ul>
<div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>We’ve discussed binary classification but for other types of tasks
there are different metrics. For example,</p>
<ul>
<li>Multi-class problems often use <a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.top_k_accuracy_score.html" class="external-link">Top-K
accuracy</a>, a metric of how often the true response appears in their
top-K guesses.</li>
<li>Regression tasks often use the <a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" class="external-link">Area
Under the ROC curve (AUC ROC)</a> as a measure of how well the
classifier performs at different thresholds.</li>
</ul>
</div>
</div>
</div>
<div id="what-accuracy-metric-to-use" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="what-accuracy-metric-to-use" class="callout-inner">
<h3 class="callout-title">What accuracy metric to use?</h3>
<div class="callout-content">
<p>Different accuracy metrics may be more relevant in different
situations. Discuss with a partner or small groups whether precision,
recall, or some combination of the two is most relevant in the following
prediction tasks:</p>
<ol style="list-style-type: decimal">
<li>Deciding what patients are high risk for a disease and who should
get additional low-cost screening.</li>
<li>Deciding what patients are high risk for a disease and should start
taking medication to lower the disease risk. The medication is expensive
and can have unpleasant side effects.</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li><p>It is best if all patients who need the screening get it, and
there is little downside for doing screenings unnecessarily because the
screening costs are low. Thus, a high recall score is optimal.</p></li>
<li><p>Given the costs and side effects of the medicine, we do not want
patients not at risk for the disease to take the medication. So, a high
precision score is ideal.</p></li>
</ol>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="model-evaluation-pitfalls">Model evaluation pitfalls<a class="anchor" aria-label="anchor" href="#model-evaluation-pitfalls"></a>
</h2>
<hr class="half-width">
<div class="section level3">
<h3 id="overfitting-and-underfitting">Overfitting and underfitting<a class="anchor" aria-label="anchor" href="#overfitting-and-underfitting"></a>
</h3>
<p><strong>Overfitting</strong> is characterized by worse performance on
the test set than on the train set and can be fixed by switching to a
simpler model architecture or by adding regularization.</p>
<p><strong>Underfitting</strong> is characterized by poor performance on
both the training and test datasets. It can be fixed by collecting more
training data, switching to a more complex model architecture, or
improving feature quality.</p>
<figure><img src="https://kharshit.github.io/img/overfitting.png" alt="graphs of overfitting and underfitting" class="figure mx-auto d-block"><div class="figcaption">Example of overfitting/underfitting</div>
</figure><p>If you need a refresher on how to detect overfitting and underfitting
in your models, <a href="https://towardsdatascience.com/learning-curve-to-identify-overfitting-underfitting-problems-133177f38df5" class="external-link">this
article</a> is a good resource.</p>
</div>
<div class="section level3">
<h3 id="data-leakage">Data Leakage<a class="anchor" aria-label="anchor" href="#data-leakage"></a>
</h3>
<p>Data leakage occurs when the model has access to the test data during
training and results in overconfidence in the model’s performance.</p>
<p><a href="https://www.sciencedirect.com/science/article/pii/S2666389923001599" class="external-link">Recent
work</a> by Sayash Kapoor and Arvind Narayanan shows that data leakage
is incredibly widespread in papers that use ML across several scientific
fields. They define 8 common ways that data leakage occurs,
including:</p>
<ol style="list-style-type: decimal">
<li>No test set: there is no hold-out test-set, rather, the model is
evaluated on a subset of the training data. This is the “obvious,”
canonical example of data leakage.</li>
<li>Preprocessing on whole dataset: when preprocessing occurs on the
train + test sets, rather than just the train set, the model learns
information about the test set that it should not have access to until
later. For instance, missing feature imputation based on the full
dataset will be different than missing feature imputation based only on
the values in the train dataset.</li>
<li>Illegitimate features: sometimes, there are features that are
proxies for the outcome variable. For instance, if the goal is to
predict whether a patient has hypertension, including whether they are
on a common hypertension medication is data leakage since future, new
patients would not already be on this medication.</li>
<li>Temporal leakage: if the model predicts a future outcome, the train
set should contain information from the future. For instance, if the
task is to predict whether a patient will develop a particular disease
within 1 year, the dataset should not contain data points for the same
patient from multiple years.</li>
</ol>
</div>
</section><section><h2 class="section-heading" id="measuring-fairness">Measuring fairness<a class="anchor" aria-label="anchor" href="#measuring-fairness"></a>
</h2>
<hr class="half-width">
<p>What does it mean for a machine learning model to be fair or
unbiased? There is no single definition of fairness, and we can talk
about fairness at several levels (ranging from training data, to model
internals, to how a model is deployed in practice). Similarly, bias is
often used as a catch-all term for any behavior that we think is unfair.
Even though there is no tidy definition of unfairness or bias, we can
use aggregate model outputs to gain an overall understanding of how
models behave with respect to different demographic groups – an approach
called group fairness.</p>
<p>In general, if there are no differences between groups in the real
world (e.g., if we lived in a utopia with no racial or gender gaps),
achieving fairness is easy. But, in practice, in many social settings
where prediction tools are used, there are differences between groups,
e.g., due to historical and current discrimination.</p>
<p>For instance, in a loan prediction setting in the United States, the
average white applicant may be better positioned to repay a loan than
the average Black applicant due to differences in generational wealth,
education opportunities, and other factors stemming from anti-Black
racism. Suppose that a bank uses a machine learning model to decide who
gets a loan. Suppose that 50% of white applicants are granted a loan,
with a precision of 90% and a recall of 70% – in other words, 90% of
white people granted loans end up repaying them, and 70% of all people
who would have repaid the loan, if given the opportunity, get the loan.
Consider the following scenarios:</p>
<ul>
<li>(Demographic parity) We give loans to 50% of Black applicants in a
way that maximizes overall accuracy</li>
<li>(Equalized odds) We give loans to X% of Black applicants, where X is
chosen to maximize accuracy subject to keeping precision equal to
90%.</li>
<li>(Group level calibration) We give loans to X% of Black applicants,
where X is chosen to maximize accuracy while keeping recall equal to
70%.</li>
</ul>
<p>There are <em>many</em> notions of statistical group fairness, but
most boil down to one of the three above options: demographic parity,
equalized odds, and group-level calibration. All three are forms of
<em>distributional</em> (or <em>outcome</em>) fairness. Another
dimension, though, is <em>procedural</em> fairness: whether decisions
are made in a just way, regardless of final outcomes. Procedural
fairness contains many facets, but one way to operationalize it is to
consider individual fairness (also called counterfactual fairness),
which was suggested in 2012 by <a href="https://dl.acm.org/doi/abs/10.1145/2090236.2090255" class="external-link">Dwork et
al.</a> as a way to ensure that “similar individuals [are treated]
similarly”. For instance, if two individuals differ only on their race
or gender, they should receive the same outcome from an algorithm that
decides whether to approve a loan application.</p>
<p>In practice, it’s hard to use individual fairness because defining a
complete set of rules about when two individuals are sufficiently
“similar” is challenging.</p>
<div id="matching-fairness-terminology-with-definitions" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="matching-fairness-terminology-with-definitions" class="callout-inner">
<h3 class="callout-title">Matching fairness terminology with definitions</h3>
<div class="callout-content">
<p>Match the following types of formal fairness with their definitions.
(A) Individual fairness, (B) Equalized odds, (C) Demographic parity, and
(D) Group-level calibration</p>
<ol style="list-style-type: decimal">
<li>The model is equally accurate across all demographic groups.</li>
<li>Different demographic groups have the same true positive rates and
false positive rates.</li>
<li>Similar people are treated similarly.</li>
<li>People from different demographic groups receive each outcome at the
same rate.</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p>A - 3, B - 2, C - 4, D - 1</p>
</div>
</div>
</div>
</div>
<p>But some types of unfairness cannot be directly measured by
group-level statistical data. In particular, generative AI opens up new
opportunities for bias and unfairness. Bias can occur through
representational harms (e.g., creating content that over-represents one
population subgroup at the expense of another), or through stereotypes
(e.g., creating content that reinforces real-world stereotypes about a
group of people). We’ll discuss some specific examples of bias in
generative models next.</p>
</section><section><h2 class="section-heading" id="fairness-in-generative-ai">Fairness in generative AI<a class="anchor" aria-label="anchor" href="#fairness-in-generative-ai"></a>
</h2>
<hr class="half-width">
<p>Generative models learn from statistical patterns in real-world data.
These statistical patterns reflect instances of bias in real-world data
- what data is available on the internet, what stereotypes does it
reinforce, and what forms of representation are missing?</p>
<div class="section level3">
<h3 id="natural-language">Natural language<a class="anchor" aria-label="anchor" href="#natural-language"></a>
</h3>
<p>One set of social stereotypes that large AI models can learn is
gender based. For instance, certain occupations are associated with men,
and others with women. For instance, in the U.S., doctors are
historically and stereotypically usually men.</p>
<p>In 2016, Caliskan et al. <a href="https://www.fatml.org/schedule/2016/presentation/semantics-derived-automatically-language-corpora" class="external-link">showed
that machine translation systems exhibit gender bias</a>, for instance,
by reverting to stereotypical gendered pronouns in ambiguous
translations, like in Turkish – a language without gendered pronouns –
to English.</p>
<p>In response, Google <a href="https://blog.research.google/2018/12/providing-gender-specific-translations.html" class="external-link">tweaked
their translator algorithms</a> to identify and correct for gender
stereotypes in Turkish and several other widely-spoken languages. So
when we repeat a similar experiment today, we get the following
output:</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e4-turkish-nlp-stereotypes.png" alt='Screenshot of Google Translate output. The English sentence "The doctor is on her lunch break" is translated to Turkish, and then the Turkish output is translated back to English as either "The doctor is on his lunch break" or "The doctor is on his lunch break".' class="figure mx-auto d-block"><div class="figcaption">Turkish Google Translate example (screenshot
from 1/9/2024)</div>
</figure><p>But for other, less widely-spoken languages, the original problem
persists:</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e4-norwegian-nlp-stereotypes.png" alt='Screenshot of Google Translate output. The English sentence "The doctor is on her lunch break" is translated to Norwegian, and then the Norwegian output is translated back to English as "The doctor is on his lunch break".' class="figure mx-auto d-block"><div class="figcaption">Norwegian Google Translate example (screenshot
from 1/9/2024)</div>
</figure><p>We’re not trying to slander Google Translate here – the translation,
without additional context, is ambiguous. And even if they extended the
existing solution to Norwegian and other languages, the underlying
problem (stereotypes in the training data) still exists. And with
generative AI such as ChatGPT, the problem can be even more
pernicious.</p>
<div id="red-teaming-large-language-models" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="red-teaming-large-language-models" class="callout-inner">
<h3 class="callout-title">Red-teaming large language models</h3>
<div class="callout-content">
<p>In cybersecurity, “red-teaming” is when well-intentioned people think
like a hacker in order to make a system safer. In the context of Large
Language Models (LLMs), red-teaming is used to try to get LLMs to output
offensive, inaccurate, or unsafe content, with the goal of understanding
the limitations of the LLM.</p>
<p>Try out red-teaming with ChatGPT or another LLM. Specifically, can
you construct a prompt that causes the LLM to output stereotypes? Here
are some example prompts, but feel free to get creative!</p>
<ul>
<li><p>“Tell me a story about a doctor” (or other profession with
gender)</p></li>
<li><p>If you speak a language other than English, how does are
ambiguous gendered pronouns handled? For instance, try the prompt
“Translate ‘The doctor is here’ to Spanish”. Is a masculine or feminine
pronoun used for the doctor in Spanish?</p></li>
</ul>
<p>If you use LLMs in your research, consider whether any of these
issues are likely to be present for your use cases. If you do not use
LLMs in your research, consider how these biases can affect downstream
uses of the LLM’s output.</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" aria-labelledby="headingSolution3" data-bs-parent="#accordionSolution3">
<div class="accordion-body">
<p>Most publicly-available LLM providers set up guardrails to avoid
propagating biases present in their training data. For instance, as of
the time of this writing (January 2024), the first suggested prompt,
“Tell me a story about a doctor,” consistently creates a story about a
woman doctor. Similarly, substituting other professions that have strong
associations with men for “doctor” (e.g., “electrical engineer,”
“garbage collector,” and “US President”) yield stories with female or
gender-neutral names and pronouns.</p>
</div>
</div>
</div>
</div>
<div id="discussing-other-fairness-issues" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="discussing-other-fairness-issues" class="callout-inner">
<h3 class="callout-title">Discussing other fairness issues</h3>
<div class="callout-content">
<p>If you use LLMs in your research, consider whether any of these
issues are likely to be present for your use cases. Share your thoughts
in small groups with other workshop participants.</p>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="image-generation">Image generation<a class="anchor" aria-label="anchor" href="#image-generation"></a>
</h3>
<p>The same problems that language modeling face also affect image
generation. Consider, for instance, Melon et al. <a href="https://arxiv.org/pdf/2003.03808.pdf" class="external-link">developed an algorithm
called Pulse</a> that can convert blurry images to higher resolution.
But, biases were quickly unearthed and <a href="https://twitter.com/Chicken3gg/status/1274314622447820801?s=20&amp;t=_oORPJBJRaBW_J0zresFJQ" class="external-link">shared
via social media</a>.</p>
<div id="discussion5" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Who is shown in this blurred picture? <img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e4-obama.png" alt="blurry image of Barack Obama" class="figure"></p>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" aria-labelledby="headingSolution4" data-bs-parent="#accordionSolution4">
<div class="accordion-body">
<p>While the picture is of Barack Obama, the upsampled image shows a
white face. <img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e4-obama-upsampled.png" alt="Unblurred version of the pixelated picture of Obama. Instead of showing Obama, it shows a white man." class="figure"></p>
<p>You can <a href="https://colab.research.google.com/github/tg-bomze/Face-Depixelizer/blob/master/Face_Depixelizer_Eng.ipynb#scrollTo=fU0aGtD4Nl4W" class="external-link">try
the model here</a>.</p>
</div>
</div>
</div>
</div>
<p>Menon and colleagues subsequently updated their paper to discuss this
issue of bias. They assert that the problems inherent in the PULSE model
are largely a result of the <a href="https://arxiv.org/abs/1812.04948" class="external-link">underlying StyleGAN model</a>,
which they had used in their work.</p>
<blockquote>
<p>Overall, it seems that sampling from StyleGAN yields white faces much
more frequently than faces of people of color … This bias extends to any
downstream application of StyleGAN, including the implementation of
PULSE using StyleGAN.</p>
<p>…</p>
<p>Results indicate a racial bias among the generated pictures, with
close to three-fourths (72.6%) of the pictures representing White
people. Asian (13.8%) and Black (10.1%) are considerably less frequent,
while Indians represent only a minor fraction of the pictures
(3.4%).</p>
</blockquote>
<p>These remarks get at a central issue: biases in any building block of
a system (data, base models, etc.) get propagated forwards. In
generative AI, such as text-to-image systems, this can result in
representational harms, <a href="https://arxiv.org/pdf/2211.03759.pdf" class="external-link">as documented by Bianchi et
al.</a> Fixing these issues of bias is still an active area of research.
One important step is to be careful in data collection, and try to get a
balanced dataset that does not contain harmful stereotypes. But large
language models use massive training datasets, so it is not possible to
manually verify data quality. Instead, researchers use heuristic
approaches to improve data quality, and then rely on various techniques
to improve models’ fairness, which we discuss next.</p>
</div>
</section><section><h2 class="section-heading" id="improving-fairness-of-models">Improving fairness of models<a class="anchor" aria-label="anchor" href="#improving-fairness-of-models"></a>
</h2>
<hr class="half-width">
<p>Model developers frequently try to improve the fairness of there
model by intervening at one of three stages: pre-processing,
in-processing, or post-processing. We’ll cover techniques within each of
these paradigms in turn.</p>
<p>We start, though, by discussing why removing the sensitive
attribute(s) is not sufficient. Consider the task of deciding which loan
applicants are funded. Suppose we are concerned with racial bias in the
model outputs. If we remove race from the set of attributes available to
the model, the model cannot make <em>overly</em> racist decisions.
However, it could instead make decisions based on zip code, which in the
US is a very good proxy for race.</p>
<p>Can we simply remove all proxy variables? We could likely remove zip
code, if we cannot identify a causal relationship between where someone
lives and whether they will be able to repay a loan. But what about an
attribute like educational achievement? Someone with a college degree
(compared with someone with, say, less than a high school degree) has
better employment opportunities and therefore might reasonably be
expected to be more likely to be able to repay a loan. However,
educational attainment is still a proxy for race in the United States
due to historical (and ongoing) discrimination.</p>
<p><strong>Pre-processing</strong> generally modifies the dataset used
for learning. Techniques in this category include:</p>
<ul>
<li><p>Oversampling/undersampling: instead of training a machine
learning model on all of the data, <em>undersample</em> the majority
class by removing some of the majority class samples from the dataset in
order to have a more balanced dataset. Alternatively,
<em>oversample</em> the minority class by duplicating samples belonging
to this group.</p></li>
<li><p>Data augmentation: the number of samples from minority groups may
be increased by generating synthetic data with a generative adversarial
network (GAN). We won’t cover this method in this workshop (using a GAN
can be more computationally expensive than other techniques). If you’re
interested, you can learn more about this method from the paper <a href="https://link.springer.com/chapter/10.1007/978-3-030-58542-6_23" class="external-link">Inclusive
GAN: Improving Data and Minority Coverage in Generative
Models</a>.</p></li>
<li><p>Changing feature representations: various techniques have been
proposed to increase fairness by removing unfairness from the data
directly. To do so, the data is converted into an alternate
representation so that differences between demographic groups are
minimized, yet enough information is maintained in order to be able to
learn a model that performs well. An advantage of this method is that it
is model-agnostic, however, a challenge is it reduces the
interpretability of interpretable models and makes post-hoc
explainability less meaningful for black-box models.</p></li>
</ul>
<div id="pros-and-cons-of-preprocessing-options" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="pros-and-cons-of-preprocessing-options" class="callout-inner">
<h3 class="callout-title">Pros and cons of preprocessing options</h3>
<div class="callout-content">
<p>Discuss what you think the pros and cons of the different
pre-processing options are. What techniques might work better in
different settings?</p>
</div>
</div>
</div>
<div id="accordionSolution5" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution5" aria-expanded="false" aria-controls="collapseSolution5">
  <h4 class="accordion-header" id="headingSolution5"> Show me the solution </h4>
</button>
<div id="collapseSolution5" class="accordion-collapse collapse" aria-labelledby="headingSolution5" data-bs-parent="#accordionSolution5">
<div class="accordion-body">
<p>A downside of oversampling is that it may violate statistical
assumptions about independence of samples. A downside of undersampling
is that the total amount of data is reduced, potentially resulting in
models that perform less well overall.</p>
<p>A downside of using GANs to generate additional data is that this
process may be expensive and require higher levels of ML expertise.</p>
<p>A challenge with all techniques is that if there is not sufficient
data from minority groups, it may be hard to achieve good performance on
the groups without simply collecting more or higher-quality data.</p>
</div>
</div>
</div>
</div>
<p><strong>In-processing</strong> modifies the learning algorithm. Some
specific in-processing techniques include:</p>
<ul>
<li><p>Reweighting samples: many machine learning models allow for
reweighting individual samples, i.e., indicating that misclassifying
certain, rarer, samples should be penalized more severely in the loss
function. In the code example, we show how to reweight samples using
AIF360’s <a href="https://aif360.readthedocs.io/en/latest/modules/generated/aif360.algorithms.preprocessing.Reweighing.html" class="external-link">Reweighting</a>
function.</p></li>
<li><p>Incorporating fairness into the loss function: reweighting
explicitly instructs the loss function to penalize the misclassification
of certain samples more harshly. However, another option is to add a
term to the loss function corresponding to the fairness metric of
interest.</p></li>
</ul>
<p><strong>Post-processing</strong> modifies an existing model to
increase its fairness. Techniques in this category often compute a
custom <em>threshold</em> for each demographic group in order to satisfy
a specific notion of group fairness. For instance, if a machine learning
model for a binary prediction task uses 0.5 as a cutoff (e.g., raw
scores less than 0.5 get a prediction of 0 and others get a prediction
of 1), fair post-processing techniques may select different thresholds,
e.g., 0.4 or 0.6 for different demographic groups.</p>
<p>In the next episode, we explore two different bias mitigations
strategies implemented in the <a href="https://aif360.readthedocs.io/en/stable/" class="external-link">AIF360 Fairness
Toolkit</a>. <!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 --></p>
</section></section><section id="aio-3-model-fairness-deep-dive"><p>Content from <a href="3-model-fairness-deep-dive.html">Model fairness: hands-on</a></p>
<hr>
<p>Last updated on 2024-10-17 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/3-model-fairness-deep-dive.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How can we use AI Fairness 360 – a common toolkit – for measuring
and improving model fairness?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Describe and implement two different ways of modifying the machine
learning modeling process to improve the fairness of a model.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<hr>
<p>In this episode, we will explore, hands-on, how to measure and
improve fairness of ML models.</p>
<p>This notebook is adapted from AIF360’s <a href="https://github.com/Trusted-AI/AIF360/blob/master/examples/tutorial_medical_expenditure.ipynb" class="external-link">Medical
Expenditure Tutorial</a>.</p>
<p>The tutorial uses data from the <a href="https://meps.ahrq.gov/mepsweb/" class="external-link">Medical Expenditure Panel
Survey</a>. We include a short description of the data below. For more
details, especially on the preprocessing, please see the AIF360
tutorial.</p>
<p>To begin, we’ll import some generally-useful packages.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># import numpy</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="co"># import Markdown for nice display</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Markdown, display</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="co"># import matplotlib</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="co"># import defaultdict (we'll use this instead of dict because it allows us to initialize a dictionary with a default value)</span></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span></code></pre>
</div>
<section><h2 class="section-heading" id="scenario-and-data">Scenario and data<a class="anchor" aria-label="anchor" href="#scenario-and-data"></a>
</h2>
<hr class="half-width">
<p>The goal is to develop a healthcare utilization scoring model – i.e.,
to predict which patients will have the highest utilization of
healthcare resources.</p>
<p>The original dataset contains information about various types of
medical visits; the AIF360 preprocessing created a single output feature
‘UTILIZATION’ that combines utilization across all visit types. Then,
this feature is binarized based on whether utilization is high, defined
as &gt;= 10 visits. Around 17% of the dataset has high utilization.</p>
<p>The sensitive feature (that we will base fairness scores on) is
defined as race. Other predictors include demographics, health
assessment data, past diagnoses, and physical/mental limitations.</p>
<p>The data is divided into years (we follow the lead of AIF360’s
tutorial and use 2015), and further divided into Panels. We use Panel 19
(the first half of 2015).</p>
<div class="section level3">
<h3 id="loading-the-data">Loading the data<a class="anchor" aria-label="anchor" href="#loading-the-data"></a>
</h3>
<p>Before starting, make sure you have downloaded the data as described
in the <a href="https://carpentries-incubator.github.io/fair-explainable-ml/#download-and-move-the-data-needed" class="external-link">setup
instructions</a>.</p>
<p>First, we need to import the dataset from the AI Fairness 360
library. Then, we can load in the data and create the
train/validation/test splits. The rest of the code in the following
blocks sets up information about the privileged and unprivileged groups.
(Recall, we focus on race as the sensitive feature.)</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="im">from</span> aif360.datasets <span class="im">import</span> MEPSDataset19 <span class="co"># import the dataset</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># assign train, validation, and test data. </span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="co"># Split the data into 50% train, 30% val, and 20% test</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>(dataset_orig_panel19_train,</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a> dataset_orig_panel19_val,</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a> dataset_orig_panel19_test) <span class="op">=</span> MEPSDataset19().split([<span class="fl">0.5</span>, <span class="fl">0.8</span>], shuffle<span class="op">=</span><span class="va">True</span>) </span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>sens_ind <span class="op">=</span> <span class="dv">0</span> <span class="co"># sensitive attribute index is 0</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>sens_attr <span class="op">=</span> dataset_orig_panel19_train.protected_attribute_names[sens_ind] <span class="co"># sensitive attribute name</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="co"># find the attribute values that correspond to the privileged and unprivileged groups</span></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a>unprivileged_groups <span class="op">=</span> [{sens_attr: v} <span class="cf">for</span> v <span class="kw">in</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>                       dataset_orig_panel19_train.unprivileged_protected_attributes[sens_ind]]</span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a>privileged_groups <span class="op">=</span> [{sens_attr: v} <span class="cf">for</span> v <span class="kw">in</span></span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a>                     dataset_orig_panel19_train.privileged_protected_attributes[sens_ind]]</span></code></pre>
</div>
<p>Check object type.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="bu">type</span>(dataset_orig_panel19_train)</span></code></pre>
</div>
<p>Preview data.</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>dataset_orig_panel19_train.convert_to_dataframe()[<span class="dv">0</span>].head()</span></code></pre>
</div>
<p>Show details about the data.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="kw">def</span> describe(train:MEPSDataset19<span class="op">=</span><span class="va">None</span>, val:MEPSDataset19<span class="op">=</span><span class="va">None</span>, test:MEPSDataset19<span class="op">=</span><span class="va">None</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co">        Print information about the test dataset (and train and validation dataset, if </span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co">        provided). Prints the dataset shape, favorable and unfavorable labels, </span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="co">        protected attribute names, and feature names.</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>    <span class="cf">if</span> train <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>        display(Markdown(<span class="st">"#### Training Dataset shape"</span>))</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>        <span class="bu">print</span>(train.features.shape) <span class="co"># print the shape of the training dataset - should be (7915, 138)</span></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>    <span class="cf">if</span> val <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>        display(Markdown(<span class="st">"#### Validation Dataset shape"</span>))</span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>        <span class="bu">print</span>(val.features.shape)</span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Test Dataset shape"</span>))</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>    <span class="bu">print</span>(test.features.shape)</span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Favorable and unfavorable labels"</span>))</span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a>    <span class="bu">print</span>(test.favorable_label, test.unfavorable_label) <span class="co"># print favorable and unfavorable labels. Should be 1, 0</span></span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Protected attribute names"</span>))</span>
<span id="cb6-18"><a href="#cb6-18" tabindex="-1"></a>    <span class="bu">print</span>(test.protected_attribute_names) <span class="co"># print protected attribute name, "RACE"</span></span>
<span id="cb6-19"><a href="#cb6-19" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Privileged and unprivileged protected attribute values"</span>))</span>
<span id="cb6-20"><a href="#cb6-20" tabindex="-1"></a>    <span class="bu">print</span>(test.privileged_protected_attributes, </span>
<span id="cb6-21"><a href="#cb6-21" tabindex="-1"></a>          test.unprivileged_protected_attributes) <span class="co"># print protected attribute values. Should be [1, 0]</span></span>
<span id="cb6-22"><a href="#cb6-22" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Dataset feature names</span><span class="ch">\n</span><span class="st"> See [MEPS documentation](https://meps.ahrq.gov/data_stats/download_data/pufs/h181/h181doc.pdf) for details on the various features"</span>))</span>
<span id="cb6-23"><a href="#cb6-23" tabindex="-1"></a>    <span class="bu">print</span>(test.feature_names) <span class="co"># print feature names</span></span>
<span id="cb6-24"><a href="#cb6-24" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" tabindex="-1"></a>describe(dataset_orig_panel19_train, dataset_orig_panel19_val, dataset_orig_panel19_test) <span class="co"># call our function "describe"</span></span></code></pre>
</div>
<p>Next, we will look at whether the dataset contains bias; i.e., does
the outcome ‘UTILIZATION’ take on a positive value more frequently for
one racial group than another?</p>
<p>To check for biases, we will use the BinaryLabelDatasetMetric class
from the AI Fairness 360 toolkit. This class creates an object that –
given a dataset and user-defined sets of “privileged” and “unprivileged”
groups – can compute various fairness scores. We will call the function
MetricTextExplainer (also in AI Fairness 360) on the
BinaryLabelDatasetMetric object to compute the disparate impact. The
disparate impact score will be between 0 and 1, where 1 indicates <em>no
bias</em> and 0 indicates extreme bias. In other words, we want a score
that is close to 1, because this indicates that different demographic
groups have similar outcomes under the model. A commonly used threshold
for an “acceptable” disparate impact score is 0.8, because under U.S.
law in various domains (e.g., employment and housing), the disparate
impact between racial groups can be no larger than 80%.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># import BinaryLabelDatasetMetric (class of metrics)</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="im">from</span> aif360.metrics <span class="im">import</span> BinaryLabelDatasetMetric</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="co"># import MetricTextExplainer to be able to print descriptions of metrics</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="im">from</span> aif360.explainers <span class="im">import</span> MetricTextExplainer </span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>metric_orig_panel19_train <span class="op">=</span> BinaryLabelDatasetMetric(</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>        dataset_orig_panel19_train, <span class="co"># train data</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>        unprivileged_groups<span class="op">=</span>unprivileged_groups, <span class="co"># pass in names of unprivileged and privileged groups</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>        privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>explainer_orig_panel19_train <span class="op">=</span> MetricTextExplainer(metric_orig_panel19_train) <span class="co"># create a MetricTextExplainer object</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a><span class="bu">print</span>(explainer_orig_panel19_train.disparate_impact()) <span class="co"># print disparate impact</span></span></code></pre>
</div>
<p>We see that the disparate impact is about 0.53, which means the
privileged group has the favorable outcome at about 2x the rate as the
unprivileged group does.</p>
<p>(In this case, the “favorable” outcome is label=1, i.e., high
utilization) ## Train a model</p>
<p>We will train a logistic regression classifier. To do so, we have to
import various functions from sklearn: a scaler, the logistic regression
class, and make_pipeline.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> make_pipeline <span class="co"># allows to stack modeling steps</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> Pipeline <span class="co"># allow us to reference the Pipeline object type</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>dataset <span class="op">=</span> dataset_orig_panel19_train <span class="co"># use the train dataset</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>model <span class="op">=</span> make_pipeline(StandardScaler(), <span class="co"># scale the data to have mean 0 and variance 1</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>                      LogisticRegression(solver<span class="op">=</span><span class="st">'liblinear'</span>, </span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>                                         random_state<span class="op">=</span><span class="dv">1</span>) <span class="co"># logistic regression model</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>                    )</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>fit_params <span class="op">=</span> {<span class="st">'logisticregression__sample_weight'</span>: dataset.instance_weights} <span class="co"># use the instance weights to fit the model</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>lr_orig_panel19 <span class="op">=</span> model.fit(dataset.features, dataset.labels.ravel(), <span class="op">**</span>fit_params) <span class="co"># fit the model</span></span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="validate-the-model">Validate the model<a class="anchor" aria-label="anchor" href="#validate-the-model"></a>
</h3>
<p>We want to validate the model – that is, check that it has good
accuracy and fairness when evaluated on the <em>validation</em> dataset.
(By contrast, during training, we only optimize for accuracy and
fairness on the training dataset.)</p>
<p>Recall that a logistic regression model can output probabilities
(i.e., <code>model.predict(dataset).scores</code>) and we can determine
our own threshold for predicting class 0 or 1. One goal of the
validation process is to select the <em>threshold</em> for the model,
i.e., the value <em>v</em> so that if the model’s output is greater than
<em>v</em>, we will predict the label 1.</p>
<p>The following function, <code>test</code>, computes performance on
the logistic regression model based on a variety of thresholds, as
indicated by <code>thresh_arr</code>, an array of threshold values. The
threshold values we test are determined through the function
<code>np.linspace</code>. We will continue to focus on disparate impact,
but all other metrics are described in the <a href="https://aif360.readthedocs.io/en/stable/modules/generated/aif360.metrics.ClassificationMetric.html#aif360.metrics.ClassificationMetric" class="external-link">AIF360
documentation</a>.</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="co"># Import the ClassificationMetric class to be able to compute metrics for the model</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="im">from</span> aif360.metrics <span class="im">import</span> ClassificationMetric</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="kw">def</span> test(dataset: MEPSDataset19, model:Pipeline, thresh_arr: np.ndarray) <span class="op">-&gt;</span> <span class="bu">dict</span>: </span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>    <span class="co">''' </span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="co">        Given a dataset, model, and list of potential cutoff thresholds, compute various metrics</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="co">        for the model. Returns a dictionary of the metrics, including balanced accuracy, average odds</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a><span class="co">        difference, disparate impact, statistical parity difference, equal opportunity difference, and</span></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a><span class="co">        theil index.</span></span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>        <span class="co"># sklearn classifier</span></span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>        y_val_pred_prob <span class="op">=</span> model.predict_proba(dataset.features) <span class="co"># get the predicted probabilities</span></span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">AttributeError</span> <span class="im">as</span> e:</span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a>        <span class="bu">print</span>(e)</span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a>        <span class="co"># aif360 inprocessing algorithm</span></span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a>        y_val_pred_prob <span class="op">=</span> model.predict(dataset).scores <span class="co"># get the predicted scores</span></span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a>        pos_ind <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a>        </span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a>    pos_ind <span class="op">=</span> np.where(model.classes_ <span class="op">==</span> dataset.favorable_label)[<span class="dv">0</span>][<span class="dv">0</span>] <span class="co"># get the index corresponding to the positive class</span></span>
<span id="cb12-18"><a href="#cb12-18" tabindex="-1"></a>    metric_arrs <span class="op">=</span> defaultdict(<span class="bu">list</span>) <span class="co"># create a dictionary to store the metrics</span></span>
<span id="cb12-19"><a href="#cb12-19" tabindex="-1"></a>    </span>
<span id="cb12-20"><a href="#cb12-20" tabindex="-1"></a>    <span class="co"># repeat the following for each potential cutoff threshold</span></span>
<span id="cb12-21"><a href="#cb12-21" tabindex="-1"></a>    <span class="cf">for</span> thresh <span class="kw">in</span> thresh_arr:</span>
<span id="cb12-22"><a href="#cb12-22" tabindex="-1"></a>        y_val_pred <span class="op">=</span> (y_val_pred_prob[:, pos_ind] <span class="op">&gt;</span> thresh).astype(np.float64) <span class="co"># get the predicted labels</span></span>
<span id="cb12-23"><a href="#cb12-23" tabindex="-1"></a></span>
<span id="cb12-24"><a href="#cb12-24" tabindex="-1"></a>        dataset_pred <span class="op">=</span> dataset.copy() <span class="co"># create a copy of the dataset</span></span>
<span id="cb12-25"><a href="#cb12-25" tabindex="-1"></a>        dataset_pred.labels <span class="op">=</span> y_val_pred <span class="co"># assign the predicted labels to the new dataset</span></span>
<span id="cb12-26"><a href="#cb12-26" tabindex="-1"></a>        metric <span class="op">=</span> ClassificationMetric( <span class="co"># create a ClassificationMetric object</span></span>
<span id="cb12-27"><a href="#cb12-27" tabindex="-1"></a>                dataset, dataset_pred,</span>
<span id="cb12-28"><a href="#cb12-28" tabindex="-1"></a>                unprivileged_groups<span class="op">=</span>unprivileged_groups,</span>
<span id="cb12-29"><a href="#cb12-29" tabindex="-1"></a>                privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb12-30"><a href="#cb12-30" tabindex="-1"></a></span>
<span id="cb12-31"><a href="#cb12-31" tabindex="-1"></a>        <span class="co"># various metrics - can look up what they are on your own</span></span>
<span id="cb12-32"><a href="#cb12-32" tabindex="-1"></a>        metric_arrs[<span class="st">'bal_acc'</span>].append((metric.true_positive_rate()</span>
<span id="cb12-33"><a href="#cb12-33" tabindex="-1"></a>                                     <span class="op">+</span> metric.true_negative_rate()) <span class="op">/</span> <span class="dv">2</span>) <span class="co"># balanced accuracy</span></span>
<span id="cb12-34"><a href="#cb12-34" tabindex="-1"></a>        metric_arrs[<span class="st">'avg_odds_diff'</span>].append(metric.average_odds_difference()) <span class="co"># average odds difference</span></span>
<span id="cb12-35"><a href="#cb12-35" tabindex="-1"></a>        metric_arrs[<span class="st">'disp_imp'</span>].append(metric.disparate_impact()) <span class="co"># disparate impact</span></span>
<span id="cb12-36"><a href="#cb12-36" tabindex="-1"></a>        metric_arrs[<span class="st">'stat_par_diff'</span>].append(metric.statistical_parity_difference()) <span class="co"># statistical parity difference</span></span>
<span id="cb12-37"><a href="#cb12-37" tabindex="-1"></a>        metric_arrs[<span class="st">'eq_opp_diff'</span>].append(metric.equal_opportunity_difference()) <span class="co"># equal opportunity difference</span></span>
<span id="cb12-38"><a href="#cb12-38" tabindex="-1"></a>        metric_arrs[<span class="st">'theil_ind'</span>].append(metric.theil_index()) <span class="co"># theil index</span></span>
<span id="cb12-39"><a href="#cb12-39" tabindex="-1"></a>    </span>
<span id="cb12-40"><a href="#cb12-40" tabindex="-1"></a>    <span class="cf">return</span> metric_arrs</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>thresh_arr <span class="op">=</span> np.linspace(<span class="fl">0.01</span>, <span class="fl">0.5</span>, <span class="dv">50</span>) <span class="co"># create an array of 50 potential cutoff thresholds ranging from 0.01 to 0.5</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>val_metrics <span class="op">=</span> test(dataset<span class="op">=</span>dataset_orig_panel19_val, </span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>                   model<span class="op">=</span>lr_orig_panel19,</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a>                   thresh_arr<span class="op">=</span>thresh_arr) <span class="co"># call our function "test" with the validation data and lr model</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>lr_orig_best_ind <span class="op">=</span> np.argmax(val_metrics[<span class="st">'bal_acc'</span>]) <span class="co"># get the index of the best balanced accuracy</span></span></code></pre>
</div>
<p>We will plot <code>val_metrics</code>. The x-axis will be the
threshold we use to output the label 1 (i.e., if the raw score is larger
than the threshold, we output 1).</p>
<p>The y-axis will show both balanced accuracy (in blue) and disparate
impact (in red).</p>
<p>Note that we plot 1 - Disparate Impact, so now a score of 0 indicates
no bias.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="kw">def</span> plot(x:np.ndarray, x_name:<span class="bu">str</span>, y_left:np.ndarray, y_left_name:<span class="bu">str</span>, y_right:np.ndarray, y_right_name:<span class="bu">str</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a><span class="co">        Create a matplotlib plot with two y-axes and a single x-axis. </span></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>    fig, ax1 <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">7</span>)) <span class="co"># create a figure and axis</span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a>    ax1.plot(x, y_left) <span class="co"># plot the left y-axis data</span></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>    ax1.set_xlabel(x_name, fontsize<span class="op">=</span><span class="dv">16</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>) <span class="co"># set the x-axis label</span></span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a>    ax1.set_ylabel(y_left_name, color<span class="op">=</span><span class="st">'b'</span>, fontsize<span class="op">=</span><span class="dv">16</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)  <span class="co"># set the left y-axis label</span></span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>    ax1.xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">14</span>) <span class="co"># set the x-axis tick label size</span></span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a>    ax1.yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">14</span>) <span class="co"># set the left y-axis tick label size</span></span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a>    ax1.set_ylim(<span class="fl">0.5</span>, <span class="fl">0.8</span>) <span class="co"># set the left y-axis limits</span></span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a>    ax2 <span class="op">=</span> ax1.twinx() <span class="co"># create a second y-axis that shares the same x-axis</span></span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a>    ax2.plot(x, y_right, color<span class="op">=</span><span class="st">'r'</span>) <span class="co"># plot the right y-axis data</span></span>
<span id="cb14-15"><a href="#cb14-15" tabindex="-1"></a>    ax2.set_ylabel(y_right_name, color<span class="op">=</span><span class="st">'r'</span>, fontsize<span class="op">=</span><span class="dv">16</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>) <span class="co"># set the right y-axis label</span></span>
<span id="cb14-16"><a href="#cb14-16" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'DI'</span> <span class="kw">in</span> y_right_name: </span>
<span id="cb14-17"><a href="#cb14-17" tabindex="-1"></a>        ax2.set_ylim(<span class="fl">0.</span>, <span class="fl">0.7</span>) <span class="co"># set the right y-axis limits  if we're plotting disparate impact</span></span>
<span id="cb14-18"><a href="#cb14-18" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb14-19"><a href="#cb14-19" tabindex="-1"></a>        ax2.set_ylim(<span class="op">-</span><span class="fl">0.25</span>, <span class="fl">0.1</span>)  <span class="co"># set the right y-axis limits if we're plotting 1-DI</span></span>
<span id="cb14-20"><a href="#cb14-20" tabindex="-1"></a></span>
<span id="cb14-21"><a href="#cb14-21" tabindex="-1"></a>    best_ind <span class="op">=</span> np.argmax(y_left) <span class="co"># get the index of the best balanced accuracy</span></span>
<span id="cb14-22"><a href="#cb14-22" tabindex="-1"></a>    ax2.axvline(np.array(x)[best_ind], color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">':'</span>) <span class="co"># add a vertical line at the best balanced accuracy</span></span>
<span id="cb14-23"><a href="#cb14-23" tabindex="-1"></a>    ax2.yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">14</span>) <span class="co"># set the right y-axis tick label size</span></span>
<span id="cb14-24"><a href="#cb14-24" tabindex="-1"></a>    ax2.grid(<span class="va">True</span>) <span class="co"># add a grid</span></span>
<span id="cb14-25"><a href="#cb14-25" tabindex="-1"></a>disp_imp <span class="op">=</span> np.array(val_metrics[<span class="st">'disp_imp'</span>]) <span class="co"># disparate impact (DI)</span></span>
<span id="cb14-26"><a href="#cb14-26" tabindex="-1"></a>disp_imp_err <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> disp_imp <span class="co"># calculate 1 - DI</span></span>
<span id="cb14-27"><a href="#cb14-27" tabindex="-1"></a>plot(thresh_arr, <span class="st">'Classification Thresholds'</span>,</span>
<span id="cb14-28"><a href="#cb14-28" tabindex="-1"></a>     val_metrics[<span class="st">'bal_acc'</span>], <span class="st">'Balanced Accuracy'</span>,</span>
<span id="cb14-29"><a href="#cb14-29" tabindex="-1"></a>     disp_imp_err, <span class="st">'1 - DI'</span>) <span class="co"># Plot balanced accuracy and 1-DI against the classification thresholds</span></span></code></pre>
</div>
<div id="interpreting-the-plot" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="interpreting-the-plot" class="callout-inner">
<h3 class="callout-title">Interpreting the plot</h3>
<div class="callout-content">
<p>Answer the following questions:</p>
<ol style="list-style-type: decimal">
<li><p>When the classification threshold is 0.1, what is the
(approximate) accuracy and 1-DI score? What about when the
classification threshold is 0.5?</p></li>
<li><p>If you were developing the model, what classification threshold
would you choose based on this graph? Why?</p></li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li><p>Using a threshold of 0.1, the accuracy is about 0.71 and the 1-DI
score is about 0.71. Using a threshold of 0.5, the accuracy is about
0.69 and the 1-DI score is about 0.79.</p></li>
<li><p>The optimal accuracy occurs with a threshold of 0.19 (indicated
by the dotted vertical line). However, the disparate impact is quite bad
at this threshold. Choosing a slightly smaller threshold, e.g., around
0.15, yields similarly high-accuracy and is slightly fairer. However,
there’s no “good” outcome here: whenever the accuracy is near-optimal,
the 1-DI score is high. If you were the model developer, you might want
to consider interventions to improve the accuracy/fairness tradeoff,
some of which we discuss below.</p></li>
</ol>
</div>
</div>
</div>
</div>
<p>If you like, you can plot other metrics, e.g., average odds
difference.</p>
<p>In the next cell, we write a function to print out a variety of other
metrics. Instead of considering disparate impact directly, we will
consider 1 - disparate impact. Recall that a disparate impact of 0 is
very bad, and 1 is perfect – thus, considering 1 - disparate impact
means that 0 is perfect and 1 is very bad, similar to the other metrics
we consider. <strong>I.e., all of these metrics have a value of 0 if
they are perfectly fair</strong>.</p>
<p>We print the value of several metrics here for illustrative purposes
(i.e., to see that multiple metrics are not able to be optimized
simultaneously). In practice, when evaluating a model it is typical ot
choose a single fairness metric to use based on the details of the
situation. You can learn more details about the various metrics in the
<a href="https://aif360.readthedocs.io/en/stable/modules/generated/aif360.metrics.ClassificationMetric.html#aif360.metrics.ClassificationMetric" class="external-link">AIF360
documentation</a>.</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="kw">def</span> describe_metrics(metrics: <span class="bu">dict</span>, thresh_arr: np.ndarray) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a><span class="co">        Given a dictionary of metrics and a list of potential cutoff thresholds, print the best</span></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="co">        threshold (based on 'bal_acc' balanced accuracy dictionary entry) and the corresponding</span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a><span class="co">        values of other metrics at the selected threshold.</span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>    best_ind <span class="op">=</span> np.argmax(metrics[<span class="st">'bal_acc'</span>]) <span class="co"># get the index of the best balanced accuracy</span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Threshold corresponding to Best balanced accuracy: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(thresh_arr[best_ind]))</span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Best balanced accuracy: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'bal_acc'</span>][best_ind]))</span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a>    disp_imp_at_best_ind <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> metrics[<span class="st">'disp_imp'</span>][best_ind] <span class="co"># calculate 1 - DI at the best index</span></span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Corresponding 1-DI value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(disp_imp_at_best_ind))</span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Corresponding average odds difference value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'avg_odds_diff'</span>][best_ind]))</span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Corresponding statistical parity difference value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'stat_par_diff'</span>][best_ind]))</span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Corresponding equal opportunity difference value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'eq_opp_diff'</span>][best_ind]))</span>
<span id="cb15-15"><a href="#cb15-15" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Corresponding Theil index value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'theil_ind'</span>][best_ind]))</span>
<span id="cb15-16"><a href="#cb15-16" tabindex="-1"></a></span>
<span id="cb15-17"><a href="#cb15-17" tabindex="-1"></a>describe_metrics(val_metrics, thresh_arr) <span class="co"># call the function</span></span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="test-the-model">Test the model<a class="anchor" aria-label="anchor" href="#test-the-model"></a>
</h3>
<p>Now that we have used the validation data to select the best
threshold, we will evaluate the test the model on the test data.</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>lr_metrics <span class="op">=</span> test(dataset<span class="op">=</span>dataset_orig_panel19_test,</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>                       model<span class="op">=</span>lr_orig_panel19,</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>                       thresh_arr<span class="op">=</span>[thresh_arr[lr_orig_best_ind]]) <span class="co"># call our function "test" with the test data and lr model</span></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>describe_metrics(lr_metrics, [thresh_arr[lr_orig_best_ind]]) <span class="co"># print the metrics for the test data</span></span></code></pre>
</div>
</div>
</section><section><h2 class="section-heading" id="mitigate-bias-with-in-processing">Mitigate bias with in-processing<a class="anchor" aria-label="anchor" href="#mitigate-bias-with-in-processing"></a>
</h2>
<hr class="half-width">
<p>We will use reweighting as an in-processing step to try to increase
fairness. AIF360 has a function that performs reweighting that we will
use. If you’re interested, you can look at details about how it works in
<a href="https://aif360.readthedocs.io/en/latest/modules/generated/aif360.algorithms.preprocessing.Reweighing.html" class="external-link">the
documentation</a>.</p>
<p>If you look at the documentation, you will see that AIF360 classifies
reweighting as a preprocessing, not an in-processing intervention.
Technically, AIF360’s implementation modifies the dataset, not the
learning algorithm so it is pre-processing. But, it is functionally
equivalent to modifying the learning algorithm’s loss function, so we
follow the convention of the fair ML field and call it
in-processing.</p>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="im">from</span> aif360.algorithms.preprocessing <span class="im">import</span> Reweighing</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="co"># Reweighting is a AIF360 class to reweight the data </span></span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>RW <span class="op">=</span> Reweighing(unprivileged_groups<span class="op">=</span>unprivileged_groups,</span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>                privileged_groups<span class="op">=</span>privileged_groups) <span class="co"># create a Reweighing object with the unprivileged and privileged groups</span></span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a>dataset_transf_panel19_train <span class="op">=</span> RW.fit_transform(dataset_orig_panel19_train) <span class="co"># reweight the training data</span></span></code></pre>
</div>
<p>We’ll also define metrics for the reweighted data and print out the
disparate impact of the dataset.</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>metric_transf_panel19_train <span class="op">=</span> BinaryLabelDatasetMetric(</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>        dataset_transf_panel19_train, <span class="co"># use train data</span></span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a>        unprivileged_groups<span class="op">=</span>unprivileged_groups, <span class="co"># pass in unprivileged and privileged groups</span></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a>        privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a>explainer_transf_panel19_train <span class="op">=</span> MetricTextExplainer(metric_transf_panel19_train) <span class="co"># create a MetricTextExplainer object</span></span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a><span class="bu">print</span>(explainer_transf_panel19_train.disparate_impact()) <span class="co"># print disparate impact</span></span></code></pre>
</div>
<p>Then, we’ll train a model, validate it, and evaluate of the test
data.</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="co"># train</span></span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>dataset <span class="op">=</span> dataset_transf_panel19_train  <span class="co"># use the reweighted training data</span></span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a>model <span class="op">=</span> make_pipeline(StandardScaler(),</span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>                      LogisticRegression(solver<span class="op">=</span><span class="st">'liblinear'</span>, random_state<span class="op">=</span><span class="dv">1</span>)) <span class="co"># model pipeline</span></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a>fit_params <span class="op">=</span> {<span class="st">'logisticregression__sample_weight'</span>: dataset.instance_weights}</span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a>lr_transf_panel19 <span class="op">=</span> model.fit(dataset.features, dataset.labels.ravel(), <span class="op">**</span>fit_params) <span class="co"># fit the model</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="co"># validate</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>thresh_arr <span class="op">=</span> np.linspace(<span class="fl">0.01</span>, <span class="fl">0.5</span>, <span class="dv">50</span>) <span class="co"># check 50 thresholds between 0.01 and 0.5</span></span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>val_metrics <span class="op">=</span> test(dataset<span class="op">=</span>dataset_orig_panel19_val,</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>                   model<span class="op">=</span>lr_transf_panel19,</span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>                   thresh_arr<span class="op">=</span>thresh_arr) <span class="co"># call our function "test" with the validation data and lr model</span></span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a>lr_transf_best_ind <span class="op">=</span> np.argmax(val_metrics[<span class="st">'bal_acc'</span>]) <span class="co"># get the index of the best balanced accuracy</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="co"># plot validation results</span></span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>disp_imp <span class="op">=</span> np.array(val_metrics[<span class="st">'disp_imp'</span>]) <span class="co"># get the disparate impact values</span></span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a>disp_imp_err <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> np.minimum(disp_imp, <span class="dv">1</span><span class="op">/</span>disp_imp) <span class="co"># calculate 1 - min(DI, 1/DI)</span></span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a>plot(thresh_arr, <span class="co"># use the classification thresholds as the x-axis</span></span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a>     <span class="st">'Classification Thresholds'</span>, </span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a>     val_metrics[<span class="st">'bal_acc'</span>],  <span class="co"># plot accuracy on the first y-axis</span></span>
<span id="cb22-7"><a href="#cb22-7" tabindex="-1"></a>     <span class="st">'Balanced Accuracy'</span>, </span>
<span id="cb22-8"><a href="#cb22-8" tabindex="-1"></a>     disp_imp_err, <span class="co"># plot 1 - min(DI, 1/DI) on the second y-axis</span></span>
<span id="cb22-9"><a href="#cb22-9" tabindex="-1"></a>     <span class="st">'1 - min(DI, 1/DI)'</span></span>
<span id="cb22-10"><a href="#cb22-10" tabindex="-1"></a>     )</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>describe_metrics(val_metrics, thresh_arr) <span class="co"># describe validation results</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="test">Test<a class="anchor" aria-label="anchor" href="#test"></a>
</h3>
<div class="codewrapper sourceCode" id="cb24">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>lr_transf_metrics <span class="op">=</span> test(dataset<span class="op">=</span>dataset_orig_panel19_test,</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>                         model<span class="op">=</span>lr_transf_panel19,</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>                         thresh_arr<span class="op">=</span>[thresh_arr[lr_transf_best_ind]]) <span class="co"># call our function "test" with the test data and lr model</span></span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a>describe_metrics(lr_transf_metrics, [thresh_arr[lr_transf_best_ind]]) <span class="co"># describe test results</span></span></code></pre>
</div>
<p>We see that the disparate impact score on the test data is better
after reweighting than it was originally.</p>
<p>How do the other fairness metrics compare?</p>
</div>
</section><section><h2 class="section-heading" id="mitigate-bias-with-preprocessing">Mitigate bias with preprocessing<a class="anchor" aria-label="anchor" href="#mitigate-bias-with-preprocessing"></a>
</h2>
<hr class="half-width">
<p>We will use a method, <a href="https://fairlearn.org/main/api_reference/generated/fairlearn.postprocessing.ThresholdOptimizer.html#fairlearn.postprocessing.ThresholdOptimizer" class="external-link">ThresholdOptimizer</a>,
that is implemented in the library <a href="https://fairlearn.org/" class="external-link">Fairlearn</a>. ThresholdOptimizer finds
custom thresholds for each demographic group so as to achieve parity in
the desired group fairness metric.</p>
<p>We will focus on demographic parity, but feel free to try other
metrics if you’re curious on how it does.</p>
<p>The first step is creating the ThresholdOptimizer object. We pass in
the demographic parity constraint, and indicate that we would like to
optimize the balanced accuracy score (other options include accuracy,
and true or false positive rate – see <a href="https://fairlearn.org/main/api_reference/generated/fairlearn.postprocessing.ThresholdOptimizer.html#fairlearn.postprocessing.ThresholdOptimizer" class="external-link">the
documentation</a> for more details).</p>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="im">from</span> fairlearn.postprocessing <span class="im">import</span> ThresholdOptimizer <span class="co"># import ThresholdOptimizer</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb26">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="co"># create a ThresholdOptimizer object</span></span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>to <span class="op">=</span> ThresholdOptimizer(estimator<span class="op">=</span>model, </span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a>                        constraints<span class="op">=</span><span class="st">"demographic_parity"</span>, <span class="co"># set the constraint to demographic parity</span></span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a>                        objective<span class="op">=</span><span class="st">"balanced_accuracy_score"</span>, <span class="co"># optimize for balanced accuracy</span></span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a>                        prefit<span class="op">=</span><span class="va">True</span>) </span></code></pre>
</div>
<p>Next, we fit the ThresholdOptimizer object to the validation
data.</p>
<div class="codewrapper sourceCode" id="cb27">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>to.fit(dataset_orig_panel19_val.features, dataset_orig_panel19_val.labels, </span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>       sensitive_features<span class="op">=</span>dataset_orig_panel19_val.protected_attributes[:,<span class="dv">0</span>]) <span class="co"># fit the ThresholdOptimizer object</span></span></code></pre>
</div>
<p>Then, we’ll create a helper function, <code>mini_test</code> to allow
us to call the <code>describe_metrics</code> function even though we are
no longer evaluating our method as a variety of thresholds.</p>
<p>After that, we call the ThresholdOptimizer’s predict function on the
validation and test data, and then compute metrics and print the
results.</p>
<div class="codewrapper sourceCode" id="cb28">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="kw">def</span> mini_test(dataset:MEPSDataset19, preds:np.ndarray) <span class="op">-&gt;</span> <span class="bu">dict</span>:</span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a><span class="co">        Given a dataset and predictions, compute various metrics for the model. Returns a dictionary of the metrics,</span></span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a><span class="co">        including balanced accuracy, average odds difference, disparate impact, statistical parity difference, equal</span></span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a><span class="co">        opportunity difference, and theil index.</span></span>
<span id="cb28-6"><a href="#cb28-6" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb28-7"><a href="#cb28-7" tabindex="-1"></a>    metric_arrs <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb28-8"><a href="#cb28-8" tabindex="-1"></a>    dataset_pred <span class="op">=</span> dataset.copy()</span>
<span id="cb28-9"><a href="#cb28-9" tabindex="-1"></a>    dataset_pred.labels <span class="op">=</span> preds</span>
<span id="cb28-10"><a href="#cb28-10" tabindex="-1"></a>    metric <span class="op">=</span> ClassificationMetric(</span>
<span id="cb28-11"><a href="#cb28-11" tabindex="-1"></a>            dataset, dataset_pred,</span>
<span id="cb28-12"><a href="#cb28-12" tabindex="-1"></a>            unprivileged_groups<span class="op">=</span>unprivileged_groups,</span>
<span id="cb28-13"><a href="#cb28-13" tabindex="-1"></a>            privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb28-14"><a href="#cb28-14" tabindex="-1"></a></span>
<span id="cb28-15"><a href="#cb28-15" tabindex="-1"></a>    <span class="co"># various metrics - can look up what they are on your own</span></span>
<span id="cb28-16"><a href="#cb28-16" tabindex="-1"></a>    metric_arrs[<span class="st">'bal_acc'</span>].append((metric.true_positive_rate()</span>
<span id="cb28-17"><a href="#cb28-17" tabindex="-1"></a>                                    <span class="op">+</span> metric.true_negative_rate()) <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb28-18"><a href="#cb28-18" tabindex="-1"></a>    metric_arrs[<span class="st">'avg_odds_diff'</span>].append(metric.average_odds_difference())</span>
<span id="cb28-19"><a href="#cb28-19" tabindex="-1"></a>    metric_arrs[<span class="st">'disp_imp'</span>].append(metric.disparate_impact())</span>
<span id="cb28-20"><a href="#cb28-20" tabindex="-1"></a>    metric_arrs[<span class="st">'stat_par_diff'</span>].append(metric.statistical_parity_difference())</span>
<span id="cb28-21"><a href="#cb28-21" tabindex="-1"></a>    metric_arrs[<span class="st">'eq_opp_diff'</span>].append(metric.equal_opportunity_difference())</span>
<span id="cb28-22"><a href="#cb28-22" tabindex="-1"></a>    metric_arrs[<span class="st">'theil_ind'</span>].append(metric.theil_index())</span>
<span id="cb28-23"><a href="#cb28-23" tabindex="-1"></a>    </span>
<span id="cb28-24"><a href="#cb28-24" tabindex="-1"></a>    <span class="cf">return</span> metric_arrs</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb29">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="co"># get predictions for validation dataset using the ThresholdOptimizer</span></span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a>to_val_preds <span class="op">=</span> to.predict(dataset_orig_panel19_val.features, </span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a>                          sensitive_features<span class="op">=</span>dataset_orig_panel19_val.protected_attributes[:,<span class="dv">0</span>])</span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a><span class="co"># get predictions for test dataset using the ThresholdOptimizer</span></span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a>to_test_preds <span class="op">=</span> to.predict(dataset_orig_panel19_test.features, </span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a>                           sensitive_features<span class="op">=</span>dataset_orig_panel19_test.protected_attributes[:,<span class="dv">0</span>])</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb30">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>to_val_metrics <span class="op">=</span> mini_test(dataset_orig_panel19_val, to_val_preds) <span class="co"># compute metrics for the validation set</span></span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>to_test_metrics <span class="op">=</span> mini_test(dataset_orig_panel19_test, to_test_preds) <span class="co"># compute metrics for the test set</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb31">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Remember, `Threshold corresponding to Best balanced accuracy` is just a placeholder here."</span>)</span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>describe_metrics(to_val_metrics, [<span class="dv">0</span>]) <span class="co"># check accuracy (ignore other metrics for now)</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb32">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Remember, `Threshold corresponding to Best balanced accuracy` is just a placeholder here."</span>)</span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a>describe_metrics(to_test_metrics, [<span class="dv">0</span>]) <span class="co"># check accuracy (ignore other metrics for now)</span></span></code></pre>
</div>
<p>Scroll up and see how these results compare with the original
classifier and with the in-processing technique.</p>
<p>A major difference is that the accuracy is lower, now. In practice,
it might be better to use an algorithm that allows a custom tradeoff
between the accuracy sacrifice and increased levels of fairness.</p>
<p>We can also see what threshold is being used for each demographic
group by examining the
<code>interpolated_thresholder_.interpretation_dict</code> property of
the ThresholdOptimzer.</p>
<div class="codewrapper sourceCode" id="cb33">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a>threshold_rules_by_group <span class="op">=</span> to.interpolated_thresholder_.interpolation_dict <span class="co"># get the threshold rules by group</span></span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>threshold_rules_by_group <span class="co"># print the threshold rules by group</span></span></code></pre>
</div>
<p>Recall that a value of 1 in the Race column corresponds to White
people, while a value of 0 corresponds to non-White people.</p>
<p>Due to the inherent randomness of the ThresholdOptimizer, you might
get slightly different results than your neighbors. When we ran the
previous cell, the output was</p>
<p><code>{0.0: {'p0': 0.9287205987170348,   'operation0': [&gt;0.5],   'p1': 0.07127940128296517,   'operation1': [&gt;-inf]},  1.0: {'p0': 0.002549618320610717,   'operation0': [&gt;inf],   'p1': 0.9974503816793893,   'operation1': [&gt;0.5]}}</code></p>
<p>This tells us that for non-White individuals:</p>
<ul>
<li><p>If the score is above 0.5, predict 1.</p></li>
<li><p>Otherwise, predict 1 with probability 0.071</p></li>
</ul>
<p>And for White individuals:</p>
<ul>
<li>If the score is above 0.5, predict 1 with probability 0.997</li>
</ul>
<div id="discuss" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="discuss" class="callout-inner">
<h3 class="callout-title">Discuss</h3>
<div class="callout-content">
<p>What are the pros and cons of improving the model fairness by
introducing randomization?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p><strong>Pros:</strong> Randomization can be effective at increasing
fairness.</p>
<p><strong>Cons:</strong> There is less predictability and
explainability in model outcomes. Even though model outputs are fair in
aggregate according to a defined group fairness metric, decisions may
feel unfair on an individual basis because similar individual (or even
the same individual, at different times) are treated unequally.
Randomization may not be appropriate in settings (e.g., medical
diagnosis) where accuracy is paramount.</p>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>It’s important to consider many dimensions of model performance: a
single accuracy score is not sufficient.</li>
<li>There is no single definition of “fair machine learning”: different
notions of fairness are appropriate in different contexts.</li>
<li>Representational harms and stereotypes can be perpetuated by
generative AI.</li>
<li>The fairness of a model can be improved by using techniques like
data reweighting and model postprocessing.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-4-explainability-vs-interpretability"><p>Content from <a href="4-explainability-vs-interpretability.html">Interpretablility versus explainability</a></p>
<hr>
<p>Last updated on 2024-11-13 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/4-explainability-vs-interpretability.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 2 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are model interpretability and model explainability? Why are
they important?</li>
<li>How do you choose between interpretable models and explainable
models in different contexts?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand and distinguish between explainable machine learning
models and interpretable machine learning models.</li>
<li>Make informed model selection choices based on the goals of your
model.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>
<strong>Model Explainability vs. Model Interpretability:</strong>
<ul>
<li>
<strong>Interpretability:</strong> The degree to which a human can
understand the cause of a decision made by a model, crucial for
verifying correctness and ensuring compliance.</li>
<li>
<strong>Explainability:</strong> The extent to which the internal
mechanics of a machine learning model can be articulated in human terms,
important for transparency and building trust.</li>
</ul>
</li>
<li>
<strong>Choosing Between Explainable and Interpretable
Models:</strong>
<ul>
<li>
<strong>When Transparency is Critical:</strong> Use interpretable
models when understanding how decisions are made is essential.</li>
<li>
<strong>When Performance is a Priority:</strong> Use explainable
models when accuracy is more important, leveraging techniques like LIME
and SHAP to clarify complex models.</li>
</ul>
</li>
<li>
<strong>Accuracy vs. Complexity:</strong>
<ul>
<li>The relationship between model complexity and accuracy is not always
linear. Increasing complexity can improve accuracy up to a point but may
lead to overfitting, highlighting the gray area in model selection. This
is illustrated by the accuracy vs. complexity plot, which shows
different models on these axes.</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="section level3">
<h3 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h3>
<p>In this lesson, we will explore the concepts of interpretability and
explainability in machine learning models. For applied scientists,
choosing the right model for your research data is critical. Whether
you’re working with patient data, environmental factors, or financial
information, understanding how a model arrives at its predictions can
significantly impact your work.</p>
<div class="section level4">
<h4 id="interpretability">Interpretability<a class="anchor" aria-label="anchor" href="#interpretability"></a>
</h4>
<p>In the context of machine learning, interpretability is the degree to
which a human can understand the cause of a decision made by a model,
crucial for verifying correctness and ensuring compliance.</p>
<p><strong>“Interpretable” models</strong>: Generally refers to models
that are inherently understandable, such as…</p>
<ul>
<li>Linear regression: Examining the coefficients along with confidence
intervals (CIs) helps understand the strength and direction of the
relationship between features and predictions.</li>
<li>Decision trees: Visualizing decision trees allows users to see the
rules that lead to specific predictions, clarifying how features
interact in the decision-making process.</li>
<li>Rule-based classifiers. These models provide clear insights into how
input features influence predictions, making it easier for users to
verify and trust the outcomes.</li>
</ul>
<p>However, as we scale up these models (e.g., high-dimensional
regression models or random forests), it is important to note that the
complexity can increase significantly, potentially making these models
less interpretable than their simpler counterparts.</p>
</div>
<div class="section level4">
<h4 id="explainability">Explainability<a class="anchor" aria-label="anchor" href="#explainability"></a>
</h4>
<p>The extent to which the internal mechanics of a machine learning
model can be articulated in human terms, important for transparency and
building trust.</p>
<p><strong>Explainable models</strong>: Typical refers to more complex
models, such as neural networks or ensemble methods, that may act as
black boxes. While these models can deliver high accuracy, they require
additional techniques (like LIME and SHAP) to explain their
decisions.</p>
<p><strong>Explainability methods preview:</strong> Various
explainability methods exist to help clarify how complex models work.
For instance…</p>
<ul>
<li>
<strong>LIME (Local Interpretable Model-agnostic
Explanations)</strong> provides insights into individual predictions by
approximating the model locally with a simpler, interpretable
model.</li>
<li>
<strong>SHAP (SHapley Additive exPlanations)</strong> assigns each
feature an importance value for a particular prediction, helping
understand the contribution of each feature.</li>
<li>
<strong>Saliency Maps</strong> visually highlight which parts of an
input (e.g., in images) are most influential for a model’s
prediction.</li>
</ul>
<p>These techniques, which we’ll talk more about in a later episode,
bridge the gap between complex models and user understanding, enhancing
transparency while still leveraging powerful algorithms.</p>
</div>
</div>
<div class="section level3">
<h3 id="accuracy-vs--complexity">Accuracy vs. Complexity<a class="anchor" aria-label="anchor" href="#accuracy-vs--complexity"></a>
</h3>
<p>The traditional idea that simple models (e.g., regression, decision
trees) are inherently interpretable and complex models (neural nets) are
truly black-box is increasingly inadequate. Modern interpretable models,
such as high-dimensional regression or tree-based methods with hundreds
of variables, can be as difficult to understand as neural networks. This
leads to a more fluid spectrum of complexity versus accuracy.</p>
<p>The accuracy vs. complexity plot from the AAAI tutorial helps to
visualize the continuous relationship between model complexity,
accuracy, and interpretability. It showcases that the trade-off is not
always straightforward, and some models can achieve a balance between
interpretability and strong performance.</p>
<p>This evolving landscape demonstrates that the old clusters of
“interpretable” versus “black-box” models break down. Instead, we must
evaluate models across the dimensions of complexity and accuracy.</p>
<p>Understanding the trade-off between model complexity and accuracy is
crucial for effective model selection. As model complexity increases,
accuracy typically improves. However, more complicated models become
more difficult to interpret and explain.</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/accuracy_vs_complexity.png" alt="Accuracy vs. Complexity Plot" class="figure mx-auto d-block"><div class="figcaption">Accuracy vs. Complexity Plot</div>
</figure><p><strong>Discussion of the Plot:</strong></p>
<ul>
<li>
<strong>X-Axis:</strong> Represents model complexity, ranging from
simple models (like linear regression) to complex models (like deep
neural networks).</li>
<li>
<strong>Y-Axis:</strong> Represents accuracy, demonstrating how well
each model performs on a given task.</li>
</ul>
<p>This plot illustrates that while simpler models offer clarity and
ease of understanding, they may not effectively capture complex
relationships in the data. Conversely, while complex models can achieve
higher accuracy, they may sacrifice interpretability, which can hinder
trust in their predictions.</p>
</div>
<div class="section level3">
<h3 id="exploring-model-choices">Exploring Model Choices<a class="anchor" aria-label="anchor" href="#exploring-model-choices"></a>
</h3>
<p>We will analyze a few real-world scenarios and discuss the trade-offs
between “<em>interpretable models</em>” (e.g., regression, decision
trees, etc.) and “<em>explainable models</em>” (e.g., neural nets).</p>
<p>For each scenario, you’ll consider key factors like accuracy,
complexity, and transparency, and answer discussion questions to
evaluate the strengths and limitations of each approach.</p>
<p>Here are some of the questions you’ll reflect on during the
exercises:</p>
<ul>
<li>What are the advantages of using interpretable models versus
explainable (black box) models in the given context?</li>
<li>What are the potential drawbacks of each approach?</li>
<li>How might the specific goals of the task influence your choice of
model?</li>
<li>Are there situations where high accuracy justifies the use of less
interpretable models?</li>
</ul>
<p>As you work through these exercises, keep in mind the broader
implications of these decisions, especially in fields like healthcare,
where model transparency can directly impact trust and outcomes.</p>
<div id="exercise-1-model-selection-for-predicting-covid-19-progression-a-study-by-giotta-et-al." class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="exercise-1-model-selection-for-predicting-covid-19-progression-a-study-by-giotta-et-al." class="callout-inner">
<h3 class="callout-title">Exercise 1: Model Selection for Predicting
COVID-19 Progression, a study by <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9602523/" class="external-link">Giotta et
al.</a>
</h3>
<div class="callout-content">
<p><strong>Scenario:</strong><br>
In the early days of the COVID-19 pandemic, healthcare professionals
faced unprecedented challenges in predicting which patients were at
higher risk of severe outcomes. Accurate predictions of death or the
need for intensive care could guide resource allocation and improve
patient care. A study explored the use of various biomarkers to build
predictive models, highlighting the importance of both accuracy and
transparency in such high-stakes settings.</p>
<p><strong>Objective:</strong><br>
Predict severe outcomes (death or transfer to intensive care) in
COVID-19 patients using biomarkers.</p>
<p><strong>Dataset features:</strong><br>
The dataset includes biomarkers from three categories:<br>
- <strong>Hematological markers:</strong> White blood cell count,
neutrophils, lymphocytes, platelets, hemoglobin, etc.<br>
- <strong>Biochemical markers:</strong> Albumin, bilirubin, creatinine,
cardiac troponin, LDH, etc.<br>
- <strong>Inflammatory markers:</strong> CRP, serum ferritin,
interleukins, TNFα, etc.</p>
<p>These features are critical for understanding disease progression and
predicting outcomes.</p>
<div class="section level3">
<h3 id="discussion-questions">Discussion questions<a class="anchor" aria-label="anchor" href="#discussion-questions"></a>
</h3>
<div class="section level4">
<h4 id="compare-the-advantages">Compare the advantages<a class="anchor" aria-label="anchor" href="#compare-the-advantages"></a>
</h4>
<ul>
<li>What are the advantages of using interpretable models such as
decision trees in predicting COVID-19 outcomes?</li>
<li>What are the advantages of using black box models such as neural
networks in this scenario?</li>
</ul>
</div>
<div class="section level4">
<h4 id="assess-the-drawbacks">Assess the drawbacks<a class="anchor" aria-label="anchor" href="#assess-the-drawbacks"></a>
</h4>
<ul>
<li>What are the potential drawbacks of using interpretable models like
decision trees?</li>
<li>What are the potential drawbacks of using black box models in
healthcare settings?</li>
</ul>
</div>
<div class="section level4">
<h4 id="decision-making-criteria">Decision-making criteria<a class="anchor" aria-label="anchor" href="#decision-making-criteria"></a>
</h4>
<ul>
<li>In what situations might you prioritize an interpretable model over
a black box model, and why?</li>
<li>Are there scenarios where the higher accuracy of black box models
justifies their use despite their lack of transparency?</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<div class="section level4">
<h4 id="compare-the-advantages-1">Compare the advantages<a class="anchor" aria-label="anchor" href="#compare-the-advantages-1"></a>
</h4>
<ul>
<li>
<strong>Interpretable models:</strong> Allow healthcare
professionals to understand and trust the model’s decisions, providing
clear insights into which biomarkers contribute most to predicting bad
outcomes. This transparency is crucial in critical fields such as
healthcare, where understanding the decision-making process can inform
treatment plans and improve patient outcomes.</li>
<li>
<strong>Black box models:</strong> Often provide higher predictive
accuracy, which can be crucial for identifying patterns in complex
datasets. They can capture non-linear relationships and interactions
that simpler models might miss.</li>
</ul>
</div>
<div class="section level4">
<h4 id="assess-the-drawbacks-1">Assess the drawbacks<a class="anchor" aria-label="anchor" href="#assess-the-drawbacks-1"></a>
</h4>
<ul>
<li>
<strong>Interpretable models:</strong> May not capture complex
relationships in the data as effectively as black box models,
potentially leading to lower predictive accuracy in some cases.</li>
<li>
<strong>Black box models:</strong> Can be difficult to interpret,
which hinders trust and adoption by medical professionals. Without
understanding the model’s reasoning, it becomes challenging to validate
its correctness, ensure regulatory compliance, and effectively debug or
refine the model.</li>
</ul>
</div>
<div class="section level4">
<h4 id="decision-making-criteria-1">Decision-making criteria<a class="anchor" aria-label="anchor" href="#decision-making-criteria-1"></a>
</h4>
<ul>
<li>
<strong>Interpretable models:</strong> When transparency, trust, and
regulatory compliance are critical, such as in healthcare settings where
understanding and validating decisions is essential.</li>
<li>
<strong>Black box models:</strong> When the need for high predictive
accuracy outweighs the need for transparency, and when supplementary
methods for interpreting the model’s output can be employed.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="exercise-2-covid-19-diagnosis-using-chest-x-rays-a-study-by-ucar-and-korkmaz" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="exercise-2-covid-19-diagnosis-using-chest-x-rays-a-study-by-ucar-and-korkmaz" class="callout-inner">
<h3 class="callout-title">Exercise 2: COVID-19 Diagnosis Using Chest
X-Rays, a study by <a href="https://www.sciencedirect.com/science/article/pii/S0306987720307702" class="external-link">Ucar
and Korkmaz</a>
</h3>
<div class="callout-content">
<p><strong>Objective:</strong> Diagnose COVID-19 through chest
X-rays.</p>
<p><strong>Motivation:</strong></p>
<p>The COVID-19 pandemic has had an unprecedented impact on global
health, affecting millions of people worldwide. One of the critical
challenges in managing this pandemic is the rapid and accurate diagnosis
of infected individuals. Traditional methods, such as the Reverse
Transcription Polymerase Chain Reaction (RT-PCR) test, although widely
used, have several drawbacks. These tests are time-consuming, require
specialized equipment and personnel, and often suffer from low detection
rates, necessitating multiple tests to confirm a diagnosis.</p>
<p>In this context, radiological imaging, particularly chest X-rays, has
emerged as a valuable tool for COVID-19 diagnosis. Early studies have
shown that COVID-19 causes specific abnormalities in chest X-rays, such
as ground-glass opacities, which can be used as indicators of the
disease. However, interpreting these images requires expertise and time,
both of which are in short supply during a pandemic.</p>
<p>To address these challenges, researchers have turned to machine
learning techniques…</p>
<p><strong>Dataset Specification:</strong> <a href="https://ars.els-cdn.com/content/image/1-s2.0-S0306987720307702-gr5.jpg" class="external-link">Chest
X-ray images</a></p>
<p><strong>Real-World Impact:</strong></p>
<p>The COVID-19 pandemic highlighted the urgent need for rapid and
accurate diagnostic tools. Traditional methods like RT-PCR tests, while
effective, are often time-consuming and have variable detection rates.
Using chest X-rays for diagnosis offers a quicker and more accessible
alternative. By analyzing chest X-rays, healthcare providers can swiftly
identify COVID-19 cases, enabling timely treatment and isolation
measures. Developing a machine learning method that can quickly and
accurately analyze chest X-rays can significantly enhance the speed and
efficiency of the healthcare response, especially in areas with limited
access to RT-PCR testing.</p>
<p><strong>Discussion Questions:</strong></p>
<ol style="list-style-type: decimal">
<li>
<strong>Compare the Advantages:</strong>
<ul>
<li>What are the advantages of using deep neural networks in diagnosing
COVID-19 from chest X-rays?</li>
<li>What are the advantages of traditional methods, such as genomic data
analysis, for COVID-19 diagnosis?</li>
</ul>
</li>
<li>
<strong>Assess the Drawbacks:</strong>
<ul>
<li>What are the potential drawbacks of using deep neural networks for
COVID-19 diagnosis from chest X-rays?</li>
<li>How do these drawbacks compare to those of traditional methods?</li>
</ul>
</li>
<li>
<strong>Decision-Making Criteria:</strong>
<ul>
<li>In what situations might you prioritize using deep neural networks
over traditional methods, and why?</li>
<li>Are there scenarios where the rapid availability of X-ray results
justifies the use of deep neural networks despite potential
drawbacks?</li>
</ul>
</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>
<strong>Compare the Advantages:</strong>
<ul>
<li>
<strong>Deep Neural Networks:</strong> Provide high accuracy (e.g.,
98%) in diagnosing COVID-19 from chest X-rays, offering a quick and
non-invasive diagnostic tool. They can handle large amounts of image
data and identify complex patterns that might be missed by human
eyes.</li>
<li>
<strong>Traditional Methods:</strong> Provide detailed and specific
diagnostic information by analyzing genomic data and biomarkers, which
can be crucial for understanding the virus’s behavior and patient
response.</li>
</ul>
</li>
<li>
<strong>Assess the Drawbacks:</strong>
<ul>
<li>
<strong>Deep Neural Networks:</strong> Require large labeled
datasets for training, which may not always be available. The models can
be seen as “black boxes”, making it challenging to interpret their
decisions without additional explainability methods.</li>
<li>
<strong>Traditional Methods:</strong> Time-consuming and may have
lower detection accuracy. They often require specialized equipment and
personnel, leading to delays in diagnosis.</li>
</ul>
</li>
<li>
<strong>Decision-Making Criteria:</strong>
<ul>
<li>
<strong>Prioritizing Deep Neural Networks:</strong> When rapid
diagnosis is critical, and chest X-rays are readily available. Useful in
large-scale screening scenarios where speed is more critical than the
detailed understanding provided by genomic data.</li>
<li>
<strong>Using Traditional Methods:</strong> When detailed and
specific information about the virus is needed for treatment planning,
and when the availability of genomic data and biomarkers is not a
bottleneck.</li>
</ul>
</li>
</ol>
</div>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div></section><section id="aio-5a-explainable-AI-method-overview"><p>Content from <a href="5a-explainable-AI-method-overview.html">Explainability methods overview</a></p>
<hr>
<p>Last updated on 2024-11-13 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/5a-explainable-AI-method-overview.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are the major categories of explainability methods, and how do
they differ?</li>
<li>How do you determine which explainability method to use for a
specific use case?</li>
<li>What are the trade-offs between black-box and white-box approaches
to explainability?</li>
<li>How do post-hoc explanation methods compare to inherently
interpretable models in terms of utility and reliability?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand the key differences between black-box and white-box
explanation methods.</li>
<li>Explore the trade-offs between post-hoc explainability and inherent
interpretability in models.</li>
<li>Identify and categorize different explainability techniques based on
their scope, model access, and approach.</li>
<li>Learn when to apply specific explainability techniques for various
machine learning tasks.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="fantastic-explainability-methods-and-where-to-use-them">Fantastic Explainability Methods and Where to Use Them<a class="anchor" aria-label="anchor" href="#fantastic-explainability-methods-and-where-to-use-them"></a>
</h2>
<hr class="half-width">
<p>We will now take a bird’s-eye view of explainability methods that are
widely applied on complex models like neural networks. We will get a
sense of when to use which kind of method, and what the tradeoffs
between these methods are.</p>
</section><section><h2 class="section-heading" id="three-axes-of-use-cases-for-understanding-model-behavior">Three axes of use cases for understanding model behavior<a class="anchor" aria-label="anchor" href="#three-axes-of-use-cases-for-understanding-model-behavior"></a>
</h2>
<hr class="half-width">
<p>When deciding which explainability method to use, it is helpful to
define your setting along three axes. This helps in understanding the
context in which the model is being used, and the kind of insights you
are looking to gain from the model.</p>
<div class="section level3">
<h3 id="inherently-interpretable-vs-post-hoc-explainable">Inherently Interpretable vs Post Hoc Explainable<a class="anchor" aria-label="anchor" href="#inherently-interpretable-vs-post-hoc-explainable"></a>
</h3>
<p>Understanding the tradeoff between interpretability and complexity is
crucial in machine learning. Simple models like decision trees, random
forests, and linear regression offer transparency and ease of
understanding, making them ideal for explaining predictions to
stakeholders. In contrast, neural networks, while powerful, lack
interpretability due to their complexity. Post hoc explainable
techniques can be applied to neural networks to provide explanations for
predictions, but it’s essential to recognize that using such methods
involves a tradeoff between model complexity and interpretability.</p>
<p>Striking the right balance between these factors is key to selecting
the most suitable model for a given task, considering both its
predictive performance and the need for interpretability.</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-interpretability-vs-complexity.png" alt="_Credits: AAAI 2021 Tutorial on Explaining Machine Learning Predictions: State of the Art, Challenges, Opportunities._" class="figure mx-auto d-block"><div class="figcaption">The tradeoff between Interpretability and
Complexity</div>
</figure>
</div>
<div class="section level3">
<h3 id="local-vs-global-explanations">Local vs Global Explanations<a class="anchor" aria-label="anchor" href="#local-vs-global-explanations"></a>
</h3>
<p>Local explanations focus on describing model behavior within a
specific neighborhood, providing insights into individual predictions.
Conversely, global explanations aim to elucidate overall model behavior,
offering a broader perspective. While global explanations may be more
comprehensive, they run the risk of being overly complex.</p>
<p>Both types of explanations are valuable for uncovering biases and
ensuring that the model makes predictions for the right reasons. The
tradeoff between local and global explanations has a long history in
statistics, with methods like linear regression (global) and kernel
smoothing (local) illustrating the importance of considering both
perspectives in statistical analysis.</p>
</div>
<div class="section level3">
<h3 id="black-box-vs-white-box-approaches">Black box vs White Box Approaches<a class="anchor" aria-label="anchor" href="#black-box-vs-white-box-approaches"></a>
</h3>
<p>Techniques that require access to model internals (e.g., model
architecture and model weights) are called “white box” while techniques
that only need query access to the model are called “black box”. Even
without access to the model weights, black box or top down approaches
can shed a lot of light on model behavior. For example, by simply
evaluating the model on certain kinds of data, high level biases or
trends in the model’s decision making process can be unearthed.</p>
<p>White box approaches use the weights and activations of the model to
understand its behavior. These classes or methods are more complex and
diverse, and we will discuss them in more detail later in this episode.
Some large models are closed-source due to commercial or safety
concerns; for example, users can’t get access to the weights of GPT-4.
This limits the use of white box explanations for such models.</p>
</div>
</section><section><h2 class="section-heading" id="classes-of-explainability-methods-for-understanding-model-behavior">Classes of Explainability Methods for Understanding Model
Behavior<a class="anchor" aria-label="anchor" href="#classes-of-explainability-methods-for-understanding-model-behavior"></a>
</h2>
<hr class="half-width">
<div class="section level3">
<h3 id="diagnostic-testing">Diagnostic Testing<a class="anchor" aria-label="anchor" href="#diagnostic-testing"></a>
</h3>
<p>This is the simplest approach towards explaining model behavior. This
involves applying a series of unit tests to the model, where each test
is a sample input where you know what the correct output should be. By
identifying test examples that break the heuristics the model relies on
(called counterfactuals), you can gain insights into the high-level
behavior of the model.</p>
<p><strong>Example Methods:</strong> <a href="https://arxiv.org/abs/1902.01007" class="external-link">Counterfactuals</a>, <a href="https://arxiv.org/abs/2005.04118" class="external-link">Unit tests</a></p>
<p><strong>Pros and Cons:</strong> These methods allow for gaining
insights into the high-level behavior of the model without the needing
access to model weights. This is especially useful with recent powerful
closed-source models like GPT-4. One challenge with this approach is
that it is hard to identify in advance what heuristics a model may
depend on.</p>
</div>
<div class="section level3">
<h3 id="baking-interpretability-into-models">Baking interpretability into models<a class="anchor" aria-label="anchor" href="#baking-interpretability-into-models"></a>
</h3>
<p>Some recent research has focused on tweaking highly complex models
like neural networks, towards making them more interpretable inherently.
One such example with language models involves training the model to
generate rationales for its prediction, in addition to its original
prediction. This approach has gained some traction, and there are even
<a href="https://arxiv.org/abs/1911.03429" class="external-link">public benchmarks</a> for
evaluating the quality of these generated rationales.</p>
<p><strong>Example methods:</strong> <a href="https://arxiv.org/abs/2004.14546" class="external-link">Rationales with WT5</a>, <a href="https://arxiv.org/abs/1606.04155" class="external-link">Older approaches for
rationales</a></p>
<p><strong>Pros and cons:</strong> These models hope to achieve the best
of both worlds: complex models that are also inherently interpretable.
However, research in this direction is still new, and there are no
established and reliable approaches for real world applications just
yet.</p>
</div>
<div class="section level3">
<h3 id="identifying-decision-rules-of-the-model">Identifying Decision Rules of the Model:<a class="anchor" aria-label="anchor" href="#identifying-decision-rules-of-the-model"></a>
</h3>
<p>In this class of methods, we try find a set of rules that generally
explain the decision making process of the model. Loosely, these rules
would be of the form “if a specific condition is met, then the model
will predict a certain class”.</p>
<p><strong>Example methods:</strong> <a href="https://aaai.org/papers/11491-anchors-high-precision-model-agnostic-explanations/" class="external-link">Anchors</a>,
<a href="https://arxiv.org/abs/1908.07125" class="external-link">Universal Adversarial
Triggers</a></p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-anchors-example.png" alt='Table caption: "Generated anchors for Tabular datasets". Table shows the following rules: for the adult dataset, predict less than 50K if no capital gain or loss and never married. Predict over 50K if country is US, married, and work hours over 45. For RCDV dataset, predict not rearrested if person has no priors, no prison violations, and crime not against property. Predict re-arrested if person is male, black, has 1-5 priors, is not married, and the crime not against property. For the Lending dataset, predict bad loan if FICO score is less than 650. Predict good loan if FICO score is between 650 and 700 and loan amount is between 5400 and 10000.' class="figure mx-auto d-block"><div class="figcaption">Example use of anchors (table from <a href="https://aaai.org/papers/11491-anchors-high-precision-model-agnostic-explanations/" class="external-link">Ribeiro
et al.</a>)</div>
</figure><p><strong>Pros and cons:</strong> Some global rules help find “bugs” in
the model, or identify high level biases. But finding such broad
coverage rules is challenging. Furthermore, these rules only showcase
the model’s weaknesses, but give next to no insight as to why these
weaknesses exist.</p>
</div>
<div class="section level3">
<h3 id="visualizing-model-weights-or-representations">Visualizing model weights or representations<a class="anchor" aria-label="anchor" href="#visualizing-model-weights-or-representations"></a>
</h3>
<p>Just like how a picture tells a thousand words, visualizations can
help encapsulate complex model behavior in a simple image.
Visualizations are commonly used in explaining neural networks, where
the weights or data representations of the model are directly
visualized. Many such approaches involve reducing the high-dimensional
weights or representations to a 2D or 3D space, using techniques like
PCA, tSNE, or UMAP. Alternatively, these visualizations can retain their
high dimensional representation, but use color or size to identify which
dimensions or neurons are more important.</p>
<p><strong>Example methods:</strong> <a href="https://arxiv.org/abs/1612.08220" class="external-link">Visualizing attention
heatmaps</a>, Weight visualizations, Model activation visualizations</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-visualization-heatmap.png" alt="Image shows a grid with 3 rows and 50 columns. Each cell is colored on a scale of -1.5 (white) to 0.9 (dark blue). Darker colors are concentrated in the first row in seemingly-random columns." class="figure mx-auto d-block"><div class="figcaption">Example usage of visualizing attention heatmaps
for part-of-speech (POS) identification task using word2vec-encoded
vectors. Each cell is a unit in a neural network (each row is a layer
and each column is a dimension). Darker colors indicates that a unit is
more importance for predictive accuracy (table from <a href="https://arxiv.org/pdf/1612.08220" class="external-link">Li et al.</a>.)</div>
</figure><p><strong>Pros and cons:</strong> Gleaning model behaviour from
visualizations is very intuitive and user-friendly, and visualizations
sometimes have interactive interfaces. However, visualizations can be
misleading, especially when high-dimensional vectors are reduced to 2D,
leading to a loss of information (crowding issue).</p>
<p>An iconic debate exemplifying the validity of visualizations has
centered around attention heatmaps. Research has shown them to be <a href="https://arxiv.org/abs/1902.10186" class="external-link">unreliable</a>, and then <a href="https://arxiv.org/abs/1908.04626" class="external-link">reliable again</a>. (Check out
the titles of these papers!) Thus, visualization can only be used as an
additional step in an analysis, and not as a standalone method.</p>
</div>
<div class="section level3">
<h3 id="understanding-the-impact-of-training-examples">Understanding the impact of training examples<a class="anchor" aria-label="anchor" href="#understanding-the-impact-of-training-examples"></a>
</h3>
<p>These techniques unearth which training data instances caused the
model to generate a specific prediction for a given sample. At a high
level, these techniques mathematically identify what training samples
that – if removed from the training process – are most influential for
causing a particular prediction.</p>
<p><strong>Example methods:</strong> <a href="https://arxiv.org/abs/1703.04730" class="external-link">Influence functions</a>, <a href="https://arxiv.org/abs/1811.09720" class="external-link">Representer point
selection</a></p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-influence.png" alt="Two images. On the left, several antelope are standing in the background on a grassy field. On the right, several zebra graze in a field in the background, while there is one antelope in the foreground and other antelope in the background." class="figure mx-auto d-block"><div class="figcaption">Example usage of representer point selection.
The image on the left is a test image that is misclassified as a deer
(the true label is antelope). The image on the right is the most
influential training point. We see that this image is labeled “zebra,”
but contains both zebras and antelopes. (example adapted from <a href="https://arxiv.org/pdf/1811.09720" class="external-link">Yeh et al.</a>.)</div>
</figure><p><strong>Pros and cons:</strong> The insights from these approaches
are actionable - by identifying the data responsible for a prediction,
it can help correct labels or annotation artifacts in that data.
Unfortunately, these methods scale poorly with the size of the model and
training data, quickly becoming computationally expensive. Furthermore,
even knowing which datapoints had a high influence on a prediction, we
don’t know what it was about that datapoint that caused the
influence.</p>
</div>
<div class="section level3">
<h3 id="understanding-the-impact-of-a-single-example">Understanding the impact of a single example:<a class="anchor" aria-label="anchor" href="#understanding-the-impact-of-a-single-example"></a>
</h3>
<p>For a single input, what parts of the input were most important in
generating the model’s prediction? These methods study the signal sent
by various features to the model, and observe how the model reacts to
changes in these features.</p>
<p><strong>Example methods:</strong> <a href="https://arxiv.org/abs/1312.6034" class="external-link">Saliency Maps</a>, <a href="https://arxiv.org/abs/1602.04938" class="external-link">LIME</a>/<a href="https://arxiv.org/abs/1705.07874" class="external-link">SHAP</a>, Perturbations (<a href="https://arxiv.org/abs/1804.07781" class="external-link">Input reduction</a>, <a href="https://arxiv.org/abs/1712.06751" class="external-link">Adversarial
Perturbations</a>)</p>
<p>These methods can be further subdivided into two categories:
gradient-based methods that rely on white-box model access to directly
see the impact of changing a single input, and perturbation-based
methods that manually perturb an input and re-query the model to see how
the prediction changes.</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-smoothgrad.png" alt='Two rows images (5 images per row). Leftmost column shows two different pictures, each containing a cat and a dog. Remaining columns show the saliency maps using different techniques (VanillaGrad, InteGrad, GuidedBackProp, and SmoothGrad). Each saliency map has red dots (indicated regions that are influential for predicting "dog") and blue dots (influential for predicting "cat"). All methods except GuidedBackProp have good overlap between the respective dots and where the animals appear in the image. SmoothGrad has the most precise mapping.' class="figure mx-auto d-block"><div class="figcaption">Example saliency maps. The right 4 columns show
the result of different saliency method techniques, where red dots
indicate regions that are influential for predicting “dog” and blue dots
indicate regions that are influential for predicting “cat”. The image
creators argue that their method, SmoothGrad, is most effective at
mapping model behavior to images. (Image taken from <a href="https://arxiv.org/pdf/1706.03825" class="external-link">Smilkov et al.</a>)</div>
</figure><p><strong>Pros and cons:</strong> These methods are fast to compute,
and flexible in their use across models. However, the insights gained
from these methods are not actionable - knowing which part of the input
caused the prediction does not highlight why that part caused it. On
finding issues in the prediction process, it is also hard to pick up on
if there is an underlying issue in the model, or just the specific
inputs tested on. Relatedly, these methods can be unstable, and can even
be <a href="https://proceedings.neurips.cc/paper_files/paper/2019/hash/7fea637fd6d02b8f0adf6f7dc36aed93-Abstract.html" class="external-link">fooled
by adversarial examples</a>.</p>
</div>
<div class="section level3">
<h3 id="probing-internal-representations">Probing internal representations<a class="anchor" aria-label="anchor" href="#probing-internal-representations"></a>
</h3>
<p>As the name suggests, this class of methods aims to probe the
internals of a model, to discover what kind of information or knowledge
is stored inside the model. Probes are often administered to a specific
component of the model, like a set of neurons or layers within a neural
network.</p>
<p><strong>Example methods:</strong> <a href="https://direct.mit.edu/coli/article/48/1/207/107571/Probing-Classifiers-Promises-Shortcomings-and" class="external-link">Probing
classifiers</a>, <a href="https://proceedings.neurips.cc/paper/2020/hash/92650b2e92217715fe312e6fa7b90d82-Abstract.html" class="external-link">Causal
tracing</a></p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-probe.png" alt='The phrase "The nurse examined the farmer for injuries because PRONOUN" is shown twice, once with PRONOUN=she and once with PRONOUN=he. Each word is annotated with the importance of three different attention heads. The distribution of which heads are important with each pronoun differs for all words, but especially for nurse and farmer.' class="figure mx-auto d-block"><div class="figcaption">Example probe output. The image shows the result
from probing three attention heads. We see that gender stereotypes are
encoded into the model because the heads that are important for nurse
and farmer change depending on the final pronoun. Specifically, Head
5-10 attends to the stereotypical gender assignment while Head 4-6
attends to the anti-stereotypical gender assignment. (Image taken from
<a href="https://proceedings.neurips.cc/paper/2020/hash/92650b2e92217715fe312e6fa7b90d82-Abstract.html" class="external-link">Vig
et al.</a>)</div>
</figure><p><strong>Pros and cons:</strong> Probes have shown that it is possible
to find highly interpretable components in a complex model, e.g., MLP
layers in transformers have been shown to store factual knowledge in a
structured manner. However, there is no systematic way of finding
interpretable components, and many components may remain elusive to
humans to understand. Furthermore, the model components that have been
shown to contain certain knowledge may not actually play a role in the
model’s prediction.</p>
<div id="is-that-all" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="is-that-all" class="callout-inner">
<h3 class="callout-title">Is that all?</h3>
<div class="callout-content">
<p>Nope! We’ve discussed a few of the common explanation techniques, but
many others exist. In particular, specialized model architectures often
need their own explanation algorithms. For instance, <a href="https://ieeexplore.ieee.org/abstract/document/9875989?casa_token=BiFHRXv7_9gAAAAA:wPV-PXOpCLFg2g1qYgEQ7QF_LKZs32cOXEJBvwjK3z43sXeaGfvQ9e1QePW03MTLq4lrUsh4Jw" class="external-link">Yuan
et al.</a> give an overview of different explanation techniques for
graph neural networks (GNNs).</p>
</div>
</div>
</div>
<div id="classifying-explanation-techniques" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="classifying-explanation-techniques" class="callout-inner">
<h3 class="callout-title">Classifying explanation techniques</h3>
<div class="callout-content">
<p>For each of the explanation techniques described above, discuss the
following with a partner:</p>
<ul>
<li>Does it require black-box or white-box model access?</li>
<li>Are the explanations it provides global or local?</li>
<li>Is the technique post-hoc or does it rely on inherent
interpretability of the model?</li>
</ul>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<table class="table">
<colgroup>
<col width="54%">
<col width="21%">
<col width="10%">
<col width="13%">
</colgroup>
<thead><tr class="header">
<th>Approach</th>
<th>Post Hoc or Inherently Interpretable?</th>
<th>Local or Global?</th>
<th>White Box or Black Box?</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><a href="#diagnostic-testing">Diagnostic Testing</a></td>
<td>Post Hoc</td>
<td>Global</td>
<td>Black Box</td>
</tr>
<tr class="even">
<td><a href="#baking-interpretability-into-models">Baking
interpretability into models</a></td>
<td>Inherently Interpretable</td>
<td>Local</td>
<td>White Box</td>
</tr>
<tr class="odd">
<td><a href="#identifying-decision-rules-of-the-model">Identifying
Decision Rules of the Model</a></td>
<td>Post Hoc</td>
<td>Both</td>
<td>White Box</td>
</tr>
<tr class="even">
<td><a href="#visualizing-model-weights-or-representations">Visualizing
model weights or representations</a></td>
<td>Post Hoc</td>
<td>Global</td>
<td>White Box</td>
</tr>
<tr class="odd">
<td><a href="#understanding-the-impact-of-training-examples">Understanding the
impact of training examples</a></td>
<td>Post Hoc</td>
<td>Local</td>
<td>White Box</td>
</tr>
<tr class="even">
<td><a href="#understanding-the-impact-of-a-single-example">Understanding the
impact of a single example</a></td>
<td>Post Hoc</td>
<td>Local</td>
<td>Both</td>
</tr>
<tr class="odd">
<td><a href="#probing-internal-representations">Probing internal
representations of a model</a></td>
<td>Post Hoc</td>
<td>Global/Local</td>
<td>White Box</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<p>What explanation should you use when? There is no simple answer, as
it depends upon your goals (i.e., why you need an explanation), who the
audience is, the model architecture, and the availability of model
internals (e.g., there is no white-box access to ChatGPT unless you work
for Open AI!). The next exercise asks you to consider different
scenarios and discuss what explanation techniques are appropriate.</p>
<div id="discussion2" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Think about the following scenarios and suggest which explainability
method would be most appropriate to use, and what information could be
gained from that method. Furthermore, think about the limitations of
your findings.</p>
<p><em>Note:</em> These are open-ended questions, and there is no
correct answer. Feel free to break into discussion groups to discuss the
scenarios.</p>
<p><strong>Scenario 1</strong>: Suppose that you are an ML engineer
working at a tech company. A fast-food chain company consults with you
about sentimental analysis based on feedback they collected on Yelp and
their survey. You use an open sourced LLM such as Llama-2 and finetune
it on the review text data. The fast-food company asks to provide
explanations for the model: Is there any outlier review? How does each
review in the data affect the finetuned model? Which part of the
language in the review indicates that a customer likes or dislikes the
food? Can you score the food quality according to the reviews? Does the
review show a trend over time? What item is gaining popularity or losing
popularity? Q: Can you suggest a few explainability methods that may be
useful for answering these questions?</p>
<p><strong>Scenario 2</strong>: Suppose that you are a radiologist who
analyzes medical images of patients with the help of machine learning
models. You use black-box models (e.g., CNNs, Vision Transformers) to
complement human expertise and get useful information before making
high-stake decisions. Which areas of a medical image most likely
explains the output of a black-box? Can we visualize and understand what
features are captured by the intermediate components of the black-box
models? How do we know if there is a distribution shift? How can we tell
if an image is an out-of-distribution example? Q: Can you suggest a few
explainability methods that may be useful for answering these
questions?</p>
<p><strong>Scenario 3</strong>: Suppose that you work on genomics and
you just collected samples of single-cell data into a table: each row
records gene expression levels, and each column represents a single
cell. You are interested in scientific hypotheses about evolution of
cells. You believe that only a few genes are playing a role in your
study. What exploratory data analysis techniques would you use to
examine the dataset? How do you check whether there are potential
outliers, irregularities in the dataset? You believe that only a few
genes are playing a role in your study. What can you do to find the set
of most explanatory genes? How do you know if there is clustering, and
if there is a trajectory of changes in the cells? Q: Can you explain the
decisions you make for each method you use?</p>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<p>There are many available explanation techniques and they differ along
three dimensions: model access (white-box or black-box), explanation
scope (global or local), and approach (inherently interpretable or
post-hoc). There’s often no objectively-right answer of which
explanation technique to use in a given situation, as the different
methods have different tradeoffs.</p>
<div class="section level3">
<h3 id="references-and-further-reading">References and Further Reading<a class="anchor" aria-label="anchor" href="#references-and-further-reading"></a>
</h3>
<p>This lesson provides a gentle overview into the world of
explainability methods. If you’d like to know more, here are some
resources to get you started:</p>
<ul>
<li>Tutorials on Explainability:
<ul>
<li><a href="https://github.com/Eric-Wallace/interpretability-tutorial-emnlp2020/blob/master/tutorial_slides.pdf" class="external-link">Wallace,
E., Gardner, M., &amp; Singh, S. (2020, November). Interpreting
predictions of NLP models. In Proceedings of the 2020 Conference on
Empirical Methods in Natural Language Processing: Tutorial Abstracts
(pp. 20-23).</a></li>
<li><a href="https://explainml-tutorial.github.io/aaai21" class="external-link">Lakkaraju, H.,
Adebayo, J., &amp; Singh, S. (2020). Explaining machine learning
predictions: State-of-the-art, challenges, and opportunities. NeurIPS
Tutorial.</a></li>
<li><a href="https://sebastiangehrmann.github.io/assets/files/acl_2020_interpretability_tutorial.pdf" class="external-link">Belinkov,
Y., Gehrmann, S., &amp; Pavlick, E. (2020, July). Interpretability and
analysis in neural NLP. In Proceedings of the 58th annual meeting of the
association for computational linguistics: tutorial abstracts
(pp. 1-5).</a></li>
</ul>
</li>
<li>Research papers:
<ul>
<li><a href="https://arxiv.org/abs/2308.00189" class="external-link">Holtzman, A., West, P.,
&amp; Zettlemoyer, L. (2023). Generative Models as a Complex Systems
Science: How can we make sense of large language model behavior?. arXiv
preprint arXiv:2308.00189.</a></li>
</ul>
</li>
</ul>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-5b-deep-dive-into-methods"><p>Content from <a href="5b-deep-dive-into-methods.html">Explainability methods: deep dive</a></p>
<hr>
<p>Last updated on 2024-11-15 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/5b-deep-dive-into-methods.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How can we identify which parts of an input contribute most to a
model’s prediction?<br>
</li>
<li>What insights can saliency maps, GradCAM, and similar techniques
provide about model behavior?<br>
</li>
<li>What are the strengths and limitations of gradient-based
explainability methods?<br>
</li>
<li>How can probing classifiers help us understand what a model has
learned?<br>
</li>
<li>What are the limitations of probing classifiers, and how can they be
addressed?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Explain how saliency maps and GradCAM work and their applications in
understanding model predictions.<br>
</li>
<li>Introduce GradCAM as a method to visualize the important features
used by a model.<br>
</li>
<li>Understand the concept of probing classifiers and how they assess
the representations learned by models.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="a-deep-dive-into-methods-for-understanding-model-behaviour">A Deep Dive into Methods for Understanding Model Behaviour<a class="anchor" aria-label="anchor" href="#a-deep-dive-into-methods-for-understanding-model-behaviour"></a>
</h2>
<hr class="half-width">
<p>In the previous section, we scratched the surface of explainability
methods, introducing you to the broad classes of methods designed to
understand different aspects of a model’s behavior.</p>
<p>Now, we will dive deeper into two widely used methods, each one which
answers one key question:</p>
</section><section><h2 class="section-heading" id="what-part-of-my-input-causes-this-prediction">What part of my input causes this prediction?<a class="anchor" aria-label="anchor" href="#what-part-of-my-input-causes-this-prediction"></a>
</h2>
<hr class="half-width">
<p>When a model makes a prediction, we often want to know which parts of
the input were most important in generating that prediction. This helps
confirm if the model is making its predictions for the right reasons.
Sometimes, models use features totally unrelated to the task for their
prediction - these are known as ‘spurious correlations’. For example, a
model might predict that a picture contains a dog because it was taken
in a park, and not because there is actually a dog in the picture.</p>
<p><strong><a href="https://arxiv.org/abs/1312.6034" class="external-link">Saliency
Maps</a></strong> are among the most simple and popular methods used
towards this end. We will be working with a more sophisticated version
of this method, known as <strong><a href="https://arxiv.org/abs/1610.02391" class="external-link">GradCAM</a></strong>.</p>
<div class="section level4">
<h4 id="method-and-examples">Method and Examples<a class="anchor" aria-label="anchor" href="#method-and-examples"></a>
</h4>
<p>A saliency map is a kind of visualization - it is a heatmap across
the input that shows which parts of the input are most important in
generating the model’s prediction. They can be calculated using the
gradients of a neural network, or by perturbing the input to any ML
model and observing how the model reacts to these perturbations. The key
intuition is that if a small change in a part of the input causes a
large change in the model’s prediction, then that part of the input is
important for the prediction. Gradients are useful in this because they
provide a signal towards how much the model’s prediction would change if
the input was changed slightly.</p>
<p>For example, in an image classification task, a saliency map can be
used to highlight the parts of the image that the model is focusing on
to make its prediction. In a text classification task, a saliency map
can be used to highlight the words or phrases that are most important
for the model’s prediction.</p>
<p>GradCAM is an extension of this idea, which uses the gradients of the
final layer of a convolutional neural network to generate a heatmap that
highlights the important regions of an image. This heatmap can be
overlaid on the original image to visualize which parts of the image are
most important for the model’s prediction.</p>
<p>Other variants of this method include <a href="https://arxiv.org/abs/1703.01365" class="external-link">Integrated Gradients</a>, <a href="https://arxiv.org/pdf/1806.03000" class="external-link">SmoothGrad</a>, and others,
which are designed to provide more robust and reliable explanations for
model predictions. However, GradCAM is a good starting point for
understanding how saliency maps work, and is a popularly used
approach.</p>
<p>Alternative approaches, which may not directly generate heatmaps,
include <a href="https://arxiv.org/abs/1602.04938" class="external-link">LIME</a> and <a href="https://arxiv.org/abs/1705.07874" class="external-link">SHAP</a>, which are also popular
and recommended for further reading.</p>
</div>
<div class="section level4">
<h4 id="limitations-and-extensions">Limitations and Extensions<a class="anchor" aria-label="anchor" href="#limitations-and-extensions"></a>
</h4>
<p>Gradient based saliency methods like GradCam are fast to compute,
requiring only a handful of backpropagation steps on the model to
generate the heatmap. The method is also model-agnostic, meaning it can
be applied to any model that can be trained using gradient descent.
Additionally, the results obtained from these methods are intuitive and
easy to understand, making them useful for explaining model predictions
to non-experts.</p>
<p>However, their use is limited to models that can be trained using
gradient descent, and have white-box access. It is also difficult to
apply these methods to tasks beyond classification, making their
application limited with many recent generative models (think LLMs).</p>
<p>Another limitation is that the insights gained from these methods are
not actionable - knowing which part of the input caused the prediction
does not highlight why that part caused it. On finding issues in the
prediction process, it is also hard to pick up on if there is an
underlying issue in the model, or just the specific inputs tested
on.</p>
</div>
</section><section><h2 class="section-heading" id="what-part-of-my-model-causes-this-prediction">What part of my model causes this prediction?<a class="anchor" aria-label="anchor" href="#what-part-of-my-model-causes-this-prediction"></a>
</h2>
<hr class="half-width">
<p>When a model makes a correct prediction on a task it has been trained
on (known as a ‘downstream task’), <strong><a href="https://direct.mit.edu/coli/article/48/1/207/107571/Probing-Classifiers-Promises-Shortcomings-and" class="external-link">Probing
classifiers</a></strong> can be used to identify if the model actually
contains the relevant information or knowledge required to make that
prediction, or if it is just making a lucky guess. Furthermore, probes
can be used to identify the specific components of the model that
contain this relevant information, providing crucial insights for
developing better models over time.</p>
<div class="section level4">
<h4 id="method-and-examples-1">Method and Examples<a class="anchor" aria-label="anchor" href="#method-and-examples-1"></a>
</h4>
<p>A neural network takes its input as a series of vectors, or
representations, and transforms them through a series of layers to
produce an output. The job of the main body of the neural network is to
develop representations that are as useful for the downstream task as
possible, so that the final few layers of the network can make a good
prediction.</p>
<p>This essentially means that a good quality representation is one that
<em>already</em> contains all the information required to make a good
prediction. In other words, the features or representations from the
model are easily separable by a simple classifier. And that classifier
is what we call a ‘probe’. A probe is a simple model that uses the
representations of the model as input, and tries to learn the downstream
task from them. The probe itself is designed to be too easy to learn the
task on its own. This means, that the only way the probe get perform
well on this task is if the representations it is given are already good
enough to make the prediction.</p>
<p>These representations can be taken from any part of the model.
Generally, using representations from the last layer of a neural network
help identify if the model even contains the information to make
predictions for the downstream task. However, this can be extended
further: probing the representations from different layers of the model
can help identify where in the model the information is stored, and how
it is transformed through the model.</p>
<p>Probes have been frequently used in the domain of NLP, where they
have been used to check if language models contain certain kinds of
linguistic information. These probes can be designed with varying levels
of complexity. For example, simple probes have shown language models to
contain information about simple syntactical features like <a href="https://aclanthology.org/D15-1246.pdf" class="external-link">Part of Speech tags</a>,
and more complex probes have shown models to contain entire <a href="https://aclanthology.org/N19-1419.pdf" class="external-link">Parse trees</a> of
sentences.</p>
</div>
<div class="section level4">
<h4 id="limitations-and-extensions-1">Limitations and Extensions<a class="anchor" aria-label="anchor" href="#limitations-and-extensions-1"></a>
</h4>
<p>One large challenge in using probes is identifying the correct
architectural design of the probe. Too simple, and it may not be able to
learn the downstream task at all. Too complex, and it may be able to
learn the task even if the model does not contain the information
required to make the prediction.</p>
<p>Another large limitation is that even if a probe is able to learn the
downstream task, it does not mean that the model is actually using the
information contained in the representations to make the prediction. So
essentially, a probe can only tell us if a part of the model
<em>can</em> make the prediction, not if it <em>does</em> make the
prediction.</p>
<p>A new approach known as <strong><a href="https://proceedings.neurips.cc/paper/2020/hash/92650b2e92217715fe312e6fa7b90d82-Abstract.html" class="external-link">Causal
Tracing</a></strong> addresses this limitation. The objective of this
approach is similar to probes: attempting to understand which part of a
model contains information relevant to a downstream task. The approach
involves iterating through all parts of the model being examined
(e.g. all layers of a model), and disrupting the information flow
through that part of the model. (This could be as easy as adding some
kind of noise on top of the weights of that model component). If the
model performance on the downstream task suddenly drops on disrupting a
specific model component, we know for sure that that component not only
contains the information required to make the prediction, but that the
model is actually using that information to make the prediction.</p>
<div id="discussion1" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Now, it’s time to try implementing these methods yourself! Pick one
of the following problems to work on:</p>
<ul>
<li><a href="https://carpentries-incubator.github.io/fair-explainable-ml/5c-probes.html" class="external-link">Train
your own linear probe to check if BERT stores the required knowledge for
sentiment analysis.</a></li>
<li><a href="https://carpentries-incubator.github.io/fair-explainable-ml/5d-gradcam.html" class="external-link">Use
GradCAM on a trained model to check if the model is using the right
features to make predictions.</a></li>
</ul>
<p>It’s time to get your hands dirty now. Good luck, and have fun!</p>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-5c-probes"><p>Content from <a href="5c-probes.html">Explainability methods: linear probe</a></p>
<hr>
<p>Last updated on 2024-07-03 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/5c-probes.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># Let's start by importing the necessary libraries.</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="im">import</span> logging</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Tuple</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="im">from</span> sklearn.manifold <span class="im">import</span> TSNE</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="im">from</span> datasets <span class="im">import</span> load_dataset, Dataset</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> AutoModel, AutoTokenizer, AutoConfig</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>logging.basicConfig(level<span class="op">=</span>logging.INFO)</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>os.environ[<span class="st">'TOKENIZERS_PARALLELISM'</span>] <span class="op">=</span> <span class="st">'false'</span>  <span class="co"># This is needed to avoid a warning from huggingface</span></span></code></pre>
</div>
<p>Now, let’s set the random seed to ensure reproducibility. Setting
random seeds is like setting a starting point for your machine learning
adventure. It ensures that every time you train your model, it starts
from the same place, using the same random numbers, making your results
consistent and comparable.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Set random seeds for reproducibility - pick any number of your choice to set the seed. We use 42, since that is the answer to everything, after all.</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>torch.manual_seed(<span class="dv">42</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># Set the GPU to use</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>os.environ[<span class="st">'CUDA_VISIBLE_DEVICES'</span>] <span class="op">=</span> <span class="st">'0'</span>  </span></code></pre>
</div>
<div class="section level5">
<h5 id="loading-the-dataset">Loading the Dataset<a class="anchor" aria-label="anchor" href="#loading-the-dataset"></a>
</h5>
<p>Let’s load our data: the IMDB Movie Review dataset. The dataset
contains text reviews and their corresponding sentiment labels (positive
or negative). The label 1 corresponds to a positive review, and 0
corresponds to a negative review.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="kw">def</span> load_imdb_dataset(keep_samples: <span class="bu">int</span> <span class="op">=</span> <span class="dv">100</span>) <span class="op">-&gt;</span> Tuple[Dataset, Dataset, Dataset]:</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co">    Load the IMDB dataset from huggingface.</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="co">    The dataset contains text reviews and their corresponding sentiment labels (positive or negative).</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="co">    The label 1 corresponds to a positive review, and 0 corresponds to a negative review.</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="co">    :param keep_samples: Number of samples to keep, for faster training.</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="co">    :return: train, dev, test datasets. Each can be treated as a dictionary with keys 'text' and 'label'.</span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>    dataset <span class="op">=</span> load_dataset(<span class="st">'imdb'</span>)</span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a>    <span class="co"># Keep only a subset of the data for faster training</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a>    train_dataset <span class="op">=</span> Dataset.from_dict(dataset[<span class="st">'train'</span>].shuffle(seed<span class="op">=</span><span class="dv">42</span>)[:keep_samples])</span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a>    dev_dataset <span class="op">=</span> Dataset.from_dict(dataset[<span class="st">'test'</span>].shuffle(seed<span class="op">=</span><span class="dv">42</span>)[:keep_samples])</span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a>    test_dataset <span class="op">=</span> Dataset.from_dict(dataset[<span class="st">'test'</span>].shuffle(seed<span class="op">=</span><span class="dv">42</span>)[keep_samples:<span class="dv">2</span><span class="op">*</span>keep_samples])</span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a>    <span class="co"># train_dataset[0] will return {'text': ...., 'label': 0}</span></span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a>    logging.info(<span class="ss">f'Loaded IMDB dataset: </span><span class="sc">{</span><span class="bu">len</span>(train_dataset)<span class="sc">}</span><span class="ss"> training samples, </span><span class="sc">{</span><span class="bu">len</span>(dev_dataset)<span class="sc">}</span><span class="ss"> dev samples, </span><span class="sc">{</span><span class="bu">len</span>(test_dataset)<span class="sc">}</span><span class="ss"> test samples.'</span>)</span>
<span id="cb4-18"><a href="#cb4-18" tabindex="-1"></a>    <span class="cf">return</span> train_dataset, dev_dataset, test_dataset</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>train_dataset, dev_dataset, test_dataset <span class="op">=</span> load_imdb_dataset(keep_samples<span class="op">=</span><span class="dv">50</span>)</span></code></pre>
</div>
</div>
<div class="section level5">
<h5 id="loading-the-model">Loading the Model<a class="anchor" aria-label="anchor" href="#loading-the-model"></a>
</h5>
<p>We will load a model from huggingface, and use this model to get the
embeddings for the probe. We use BERT for this example, but feel free to
explore other models from huggingface after the exercise.</p>
<p>BERT is a transformer-based model, and is known to perform well on a
variety of NLP tasks. The model is pre-trained on a large corpus of
text, and can be fine-tuned for specific tasks.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="kw">def</span> load_model(model_name: <span class="bu">str</span>) <span class="op">-&gt;</span> Tuple[AutoModel, AutoTokenizer]:</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co">    Load a model from huggingface.</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co">    :param model_name: Check huggingface for acceptable model names.</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="co">    :return: Model and tokenizer.</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>    tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(model_name)</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>    config <span class="op">=</span> AutoConfig.from_pretrained(model_name)</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>    model <span class="op">=</span> AutoModel.from_pretrained(model_name, config<span class="op">=</span>config)</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>    model.config.max_position_embeddings <span class="op">=</span> <span class="dv">128</span>  <span class="co"># Reducing from default 512 to 128 for computational efficiency</span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>    logging.info(<span class="ss">f'Loaded model and tokenizer: </span><span class="sc">{</span>model_name<span class="sc">}</span><span class="ss"> with </span><span class="sc">{</span>model<span class="sc">.</span>config<span class="sc">.</span>num_hidden_layers<span class="sc">}</span><span class="ss"> layers, '</span></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>                 <span class="ss">f'hidden size </span><span class="sc">{</span>model<span class="sc">.</span>config<span class="sc">.</span>hidden_size<span class="sc">}</span><span class="ss"> and sequence length </span><span class="sc">{</span>model<span class="sc">.</span>config<span class="sc">.</span>max_position_embeddings<span class="sc">}</span><span class="ss">.'</span>)</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>    <span class="cf">return</span> model, tokenizer</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># To play around with other models, find a list of models and their model_ids at: https://huggingface.co/models</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>model, tokenizer <span class="op">=</span> load_model(<span class="st">'bert-base-uncased'</span>)</span></code></pre>
</div>
<p>Let’s see what the model’s architecture looks like. How many layers
does it have?</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="bu">print</span>(model)</span></code></pre>
</div>
<p>Let’s see if your answer matches the actual number of layers in the
model.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>num_layers <span class="op">=</span> model.config.num_hidden_layers</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'The model has </span><span class="sc">{</span>num_layers<span class="sc">}</span><span class="ss"> layers.'</span>)</span></code></pre>
</div>
</div>
<div class="section level5">
<h5 id="setting-up-the-probe">Setting up the Probe<a class="anchor" aria-label="anchor" href="#setting-up-the-probe"></a>
</h5>
<p>Before we define the probing classifier or probe, let’s set up some
utility functions the probe will use. The probe will be trained from
hidden representations from a specific layer of the BERT model. The
<code>get_embeddings_from_model</code> function will retrieve the
intermediate layer representations (also known as embeddings) from a
user defined layer number.</p>
<p>The <code>visualize_embeddings</code> method can be used to see what
these high dimensional hidden embeddings would look like when converted
into a 2D view. The visualization is not intended to be informative in
itself, and is only an additional tool used to get a sense of what the
inputs to the probing classifier may look like.</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="kw">def</span> get_embeddings_from_model(model: AutoModel, tokenizer: AutoTokenizer, layer_num: <span class="bu">int</span>, data: <span class="bu">list</span>[<span class="bu">str</span>]) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a><span class="co">    Get the embeddings from a model.</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="co">    :param model: The model to use. This is needed to get the embeddings.</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="co">    :param tokenizer: The tokenizer to use. This is needed to convert the data to input IDs.</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="co">    :param layer_num: The layer to get embeddings from. 0 is the input embeddings, and the last layer is the output embeddings.</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="co">    :param data: The data to get embeddings for. A list of strings.</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="co">    :return: The embeddings. Shape is N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a>    logging.info(<span class="ss">f'Getting embeddings from layer </span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss"> for </span><span class="sc">{</span><span class="bu">len</span>(data)<span class="sc">}</span><span class="ss"> samples...'</span>)</span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>    <span class="co"># Batch the data for computational efficiency</span></span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a>    batch_size <span class="op">=</span> <span class="dv">32</span></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a>    batch_num <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(data), batch_size):</span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a>        batch <span class="op">=</span> data[i:i<span class="op">+</span>batch_size]</span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a>        logging.info(<span class="ss">f'Getting embeddings for batch </span><span class="sc">{</span>batch_num<span class="sc">}</span><span class="ss">...'</span>)</span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a>        batch_num <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a>        <span class="co"># Tokenize the batch of data</span></span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a>        inputs <span class="op">=</span> tokenizer(batch, return_tensors<span class="op">=</span><span class="st">'pt'</span>, padding<span class="op">=</span><span class="va">True</span>, truncation<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a>        <span class="co"># Get the embeddings from the model</span></span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a>        outputs <span class="op">=</span> model(<span class="op">**</span>inputs, output_hidden_states<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a></span>
<span id="cb10-26"><a href="#cb10-26" tabindex="-1"></a>        <span class="co"># Get the embeddings for the specific the layer</span></span>
<span id="cb10-27"><a href="#cb10-27" tabindex="-1"></a>        embeddings <span class="op">=</span> outputs.hidden_states[layer_num]</span>
<span id="cb10-28"><a href="#cb10-28" tabindex="-1"></a></span>
<span id="cb10-29"><a href="#cb10-29" tabindex="-1"></a>        <span class="co"># Concatenate the embeddings from each batch</span></span>
<span id="cb10-30"><a href="#cb10-30" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb10-31"><a href="#cb10-31" tabindex="-1"></a>            all_embeddings <span class="op">=</span> embeddings</span>
<span id="cb10-32"><a href="#cb10-32" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb10-33"><a href="#cb10-33" tabindex="-1"></a>            all_embeddings <span class="op">=</span> torch.cat([all_embeddings, embeddings], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb10-34"><a href="#cb10-34" tabindex="-1"></a></span>
<span id="cb10-35"><a href="#cb10-35" tabindex="-1"></a>    logging.info(<span class="ss">f'Got embeddings for </span><span class="sc">{</span><span class="bu">len</span>(data)<span class="sc">}</span><span class="ss"> samples from layer </span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss">. Shape: </span><span class="sc">{</span>all_embeddings<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb10-36"><a href="#cb10-36" tabindex="-1"></a>    <span class="cf">return</span> all_embeddings</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="kw">def</span> visualize_embeddings(embeddings: torch.Tensor, labels: <span class="bu">list</span>, layer_num: <span class="bu">int</span>, save_plot: <span class="bu">bool</span> <span class="op">=</span> <span class="va">False</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="co">    Visualize the embeddings using t-SNE.</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="co">    :param embeddings: The embeddings to visualize. Shape is N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a><span class="co">    :param labels: The labels for the embeddings. A list of integers.</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="co">    :return: None</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>    <span class="co"># Since we are working with sentiment analysis, which is sentence based task, we can use sentence embeddings.</span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>    <span class="co"># The sentence embeddings are simply the mean of the token embeddings of that sentence.</span></span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>    sentence_embeddings <span class="op">=</span> torch.mean(embeddings, dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># N, D</span></span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a>    <span class="co"># Convert to numpy</span></span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a>    sentence_embeddings <span class="op">=</span> sentence_embeddings.detach().numpy()</span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a>    labels <span class="op">=</span> np.array(labels)</span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a>    <span class="co"># Visualize the embeddings using t-SNE</span></span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a>    tsne <span class="op">=</span> TSNE(n_components<span class="op">=</span><span class="dv">2</span>, random_state<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb11-19"><a href="#cb11-19" tabindex="-1"></a>    embeddings_2d <span class="op">=</span> tsne.fit_transform(sentence_embeddings)</span>
<span id="cb11-20"><a href="#cb11-20" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" tabindex="-1"></a>    negative_points <span class="op">=</span> embeddings_2d[labels <span class="op">==</span> <span class="dv">0</span>]</span>
<span id="cb11-22"><a href="#cb11-22" tabindex="-1"></a>    positive_points <span class="op">=</span> embeddings_2d[labels <span class="op">==</span> <span class="dv">1</span>]</span>
<span id="cb11-23"><a href="#cb11-23" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" tabindex="-1"></a>    <span class="co"># Plot the embeddings. We want to colour the datapoints by label.</span></span>
<span id="cb11-25"><a href="#cb11-25" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb11-26"><a href="#cb11-26" tabindex="-1"></a>    ax.scatter(negative_points[:, <span class="dv">0</span>], negative_points[:, <span class="dv">1</span>], label<span class="op">=</span><span class="st">'Negative'</span>, color<span class="op">=</span><span class="st">'red'</span>, marker<span class="op">=</span><span class="st">'o'</span>, s<span class="op">=</span><span class="dv">10</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb11-27"><a href="#cb11-27" tabindex="-1"></a>    ax.scatter(positive_points[:, <span class="dv">0</span>], positive_points[:, <span class="dv">1</span>], label<span class="op">=</span><span class="st">'Positive'</span>, color<span class="op">=</span><span class="st">'blue'</span>, marker<span class="op">=</span><span class="st">'o'</span>, s<span class="op">=</span><span class="dv">10</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb11-28"><a href="#cb11-28" tabindex="-1"></a>    plt.xlabel(<span class="st">'t-SNE dimension 1'</span>)</span>
<span id="cb11-29"><a href="#cb11-29" tabindex="-1"></a>    plt.ylabel(<span class="st">'t-SNE dimension 2'</span>)</span>
<span id="cb11-30"><a href="#cb11-30" tabindex="-1"></a>    plt.title(<span class="ss">f't-SNE of Sentence Embeddings - Layer</span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb11-31"><a href="#cb11-31" tabindex="-1"></a>    plt.legend()</span>
<span id="cb11-32"><a href="#cb11-32" tabindex="-1"></a></span>
<span id="cb11-33"><a href="#cb11-33" tabindex="-1"></a>    <span class="co"># Save the plot if needed, then display it</span></span>
<span id="cb11-34"><a href="#cb11-34" tabindex="-1"></a>    <span class="cf">if</span> save_plot:</span>
<span id="cb11-35"><a href="#cb11-35" tabindex="-1"></a>        plt.savefig(<span class="ss">f'tsne_layer_</span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss">.png'</span>)</span>
<span id="cb11-36"><a href="#cb11-36" tabindex="-1"></a>    plt.show()</span>
<span id="cb11-37"><a href="#cb11-37" tabindex="-1"></a></span>
<span id="cb11-38"><a href="#cb11-38" tabindex="-1"></a>    logging.info(<span class="st">'Visualized embeddings using t-SNE.'</span>)</span></code></pre>
</div>
<p>Now, it’s finally time to define our probe! We set this up as a
class, where the probe itself is an object of this class. The class also
contains methods used to train and evaluate the probe.</p>
<p>Read through this code block in a bit more detail - from this whole
exercise, this part provides you with the most useful takeaways on ways
to define and train neural networks!</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="kw">class</span> Probe():</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, hidden_dim: <span class="bu">int</span> <span class="op">=</span> <span class="dv">768</span>, class_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">2</span>)  <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="co">        Initialize the probe.</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a><span class="co">        :param hidden_dim: The dimensionality of the hidden layer of the probe.</span></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a><span class="co">        :param num_layers: The number of layers in the probe.</span></span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a><span class="co">        :return: None</span></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>        <span class="co"># The probe is a simple linear classifier, with a hidden layer and an output layer.</span></span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a>        <span class="co"># The input to the probe is the embeddings from the model, and the output is the predicted class.</span></span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a>        <span class="co"># Exercise: Try playing around with the hidden_dim and num_layers to see how it affects the probe's performance.</span></span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a>        <span class="co"># But watch out: if a complex probe performs well on the task, we don't know if the performance</span></span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a>        <span class="co"># is because of the model embeddings, or the probe itself learning the task!</span></span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a>        <span class="va">self</span>.probe <span class="op">=</span> torch.nn.Sequential(</span>
<span id="cb12-18"><a href="#cb12-18" tabindex="-1"></a>            torch.nn.Linear(hidden_dim, hidden_dim),</span>
<span id="cb12-19"><a href="#cb12-19" tabindex="-1"></a>            torch.nn.ReLU(),</span>
<span id="cb12-20"><a href="#cb12-20" tabindex="-1"></a>            torch.nn.Linear(hidden_dim, class_size),</span>
<span id="cb12-21"><a href="#cb12-21" tabindex="-1"></a></span>
<span id="cb12-22"><a href="#cb12-22" tabindex="-1"></a>            <span class="co"># Add more layers here if needed</span></span>
<span id="cb12-23"><a href="#cb12-23" tabindex="-1"></a></span>
<span id="cb12-24"><a href="#cb12-24" tabindex="-1"></a>            <span class="co"># Sigmoid is used to convert the hidden states into a probability distribution over the classes</span></span>
<span id="cb12-25"><a href="#cb12-25" tabindex="-1"></a>            torch.nn.Sigmoid()</span>
<span id="cb12-26"><a href="#cb12-26" tabindex="-1"></a>        )</span>
<span id="cb12-27"><a href="#cb12-27" tabindex="-1"></a></span>
<span id="cb12-28"><a href="#cb12-28" tabindex="-1"></a></span>
<span id="cb12-29"><a href="#cb12-29" tabindex="-1"></a>    <span class="kw">def</span> train(<span class="va">self</span>, data_embeddings: torch.Tensor, labels: torch.Tensor, num_epochs: <span class="bu">int</span> <span class="op">=</span> <span class="dv">10</span>,</span>
<span id="cb12-30"><a href="#cb12-30" tabindex="-1"></a>              learning_rate: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.001</span>, batch_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">32</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb12-31"><a href="#cb12-31" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb12-32"><a href="#cb12-32" tabindex="-1"></a><span class="co">        Train the probe on the embeddings of data from the model.</span></span>
<span id="cb12-33"><a href="#cb12-33" tabindex="-1"></a><span class="co">        :param data_embeddings: A tensor of shape N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb12-34"><a href="#cb12-34" tabindex="-1"></a><span class="co">        :param labels: A tensor of shape N, where N is the number of samples. Each element is the label for the corresponding sample.</span></span>
<span id="cb12-35"><a href="#cb12-35" tabindex="-1"></a><span class="co">        :param num_epochs: The number of epochs to train the probe for. An epoch is one pass through the entire dataset.</span></span>
<span id="cb12-36"><a href="#cb12-36" tabindex="-1"></a><span class="co">        :param learning_rate: How fast the probe learns. A hyperparameter.</span></span>
<span id="cb12-37"><a href="#cb12-37" tabindex="-1"></a><span class="co">        :param batch_size: Used to batch the data for computational efficiency. A hyperparameter.</span></span>
<span id="cb12-38"><a href="#cb12-38" tabindex="-1"></a><span class="co">        :return:</span></span>
<span id="cb12-39"><a href="#cb12-39" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb12-40"><a href="#cb12-40" tabindex="-1"></a></span>
<span id="cb12-41"><a href="#cb12-41" tabindex="-1"></a>        <span class="co"># Setup the loss function (training objective) for the training process.</span></span>
<span id="cb12-42"><a href="#cb12-42" tabindex="-1"></a>        <span class="co"># The cross-entropy loss is used for multi-class classification, and represents the negative log likelihood of the true class.</span></span>
<span id="cb12-43"><a href="#cb12-43" tabindex="-1"></a>        criterion <span class="op">=</span> torch.nn.CrossEntropyLoss()</span>
<span id="cb12-44"><a href="#cb12-44" tabindex="-1"></a></span>
<span id="cb12-45"><a href="#cb12-45" tabindex="-1"></a>        <span class="co"># Setup the optimization algorithm to update the probe's parameters during training.</span></span>
<span id="cb12-46"><a href="#cb12-46" tabindex="-1"></a>        <span class="co"># The Adam optimizer is an extension to stochastic gradient descent, and is a popular choice.</span></span>
<span id="cb12-47"><a href="#cb12-47" tabindex="-1"></a>        optimizer <span class="op">=</span> torch.optim.Adam(<span class="va">self</span>.probe.parameters(), lr<span class="op">=</span>learning_rate)</span>
<span id="cb12-48"><a href="#cb12-48" tabindex="-1"></a></span>
<span id="cb12-49"><a href="#cb12-49" tabindex="-1"></a>        <span class="co"># Train the probe</span></span>
<span id="cb12-50"><a href="#cb12-50" tabindex="-1"></a>        logging.info(<span class="st">'Training the probe...'</span>)</span>
<span id="cb12-51"><a href="#cb12-51" tabindex="-1"></a>        <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(num_epochs):  <span class="co"># Pass over the data num_epochs times</span></span>
<span id="cb12-52"><a href="#cb12-52" tabindex="-1"></a></span>
<span id="cb12-53"><a href="#cb12-53" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(data_embeddings), batch_size):</span>
<span id="cb12-54"><a href="#cb12-54" tabindex="-1"></a></span>
<span id="cb12-55"><a href="#cb12-55" tabindex="-1"></a>                <span class="co"># Iterate through one batch of data at a time</span></span>
<span id="cb12-56"><a href="#cb12-56" tabindex="-1"></a>                batch_embeddings <span class="op">=</span> data_embeddings[i:i<span class="op">+</span>batch_size].detach()</span>
<span id="cb12-57"><a href="#cb12-57" tabindex="-1"></a>                batch_labels <span class="op">=</span> labels[i:i<span class="op">+</span>batch_size]</span>
<span id="cb12-58"><a href="#cb12-58" tabindex="-1"></a></span>
<span id="cb12-59"><a href="#cb12-59" tabindex="-1"></a>                <span class="co"># Convert to sentence embeddings, since we are performing a sentence classification task</span></span>
<span id="cb12-60"><a href="#cb12-60" tabindex="-1"></a>                batch_embeddings <span class="op">=</span> torch.mean(batch_embeddings, dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># N, D</span></span>
<span id="cb12-61"><a href="#cb12-61" tabindex="-1"></a></span>
<span id="cb12-62"><a href="#cb12-62" tabindex="-1"></a>                <span class="co"># Get the probe's predictions, given the embeddings from the model</span></span>
<span id="cb12-63"><a href="#cb12-63" tabindex="-1"></a>                outputs <span class="op">=</span> <span class="va">self</span>.probe(batch_embeddings)</span>
<span id="cb12-64"><a href="#cb12-64" tabindex="-1"></a></span>
<span id="cb12-65"><a href="#cb12-65" tabindex="-1"></a>                <span class="co"># Calculate the loss of the predictions, against the true labels</span></span>
<span id="cb12-66"><a href="#cb12-66" tabindex="-1"></a>                loss <span class="op">=</span> criterion(outputs, batch_labels)</span>
<span id="cb12-67"><a href="#cb12-67" tabindex="-1"></a></span>
<span id="cb12-68"><a href="#cb12-68" tabindex="-1"></a>                <span class="co"># Backward pass - update the probe's parameters</span></span>
<span id="cb12-69"><a href="#cb12-69" tabindex="-1"></a>                optimizer.zero_grad()</span>
<span id="cb12-70"><a href="#cb12-70" tabindex="-1"></a>                loss.backward()</span>
<span id="cb12-71"><a href="#cb12-71" tabindex="-1"></a>                optimizer.step()</span>
<span id="cb12-72"><a href="#cb12-72" tabindex="-1"></a></span>
<span id="cb12-73"><a href="#cb12-73" tabindex="-1"></a>        logging.info(<span class="st">'Trained the probe.'</span>)</span>
<span id="cb12-74"><a href="#cb12-74" tabindex="-1"></a></span>
<span id="cb12-75"><a href="#cb12-75" tabindex="-1"></a></span>
<span id="cb12-76"><a href="#cb12-76" tabindex="-1"></a>    <span class="kw">def</span> predict(<span class="va">self</span>, data_embeddings: torch.Tensor, batch_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">32</span>) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb12-77"><a href="#cb12-77" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb12-78"><a href="#cb12-78" tabindex="-1"></a><span class="co">        Get the probe's predictions on the embeddings from the model, for unseen data.</span></span>
<span id="cb12-79"><a href="#cb12-79" tabindex="-1"></a><span class="co">        :param data_embeddings: A tensor of shape N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb12-80"><a href="#cb12-80" tabindex="-1"></a><span class="co">        :param batch_size: Used to batch the data for computational efficiency.</span></span>
<span id="cb12-81"><a href="#cb12-81" tabindex="-1"></a><span class="co">        :return: A tensor of shape N, where N is the number of samples. Each element is the predicted class for the corresponding sample.</span></span>
<span id="cb12-82"><a href="#cb12-82" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb12-83"><a href="#cb12-83" tabindex="-1"></a></span>
<span id="cb12-84"><a href="#cb12-84" tabindex="-1"></a>        <span class="co"># Iterate through batches</span></span>
<span id="cb12-85"><a href="#cb12-85" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(data_embeddings), batch_size):</span>
<span id="cb12-86"><a href="#cb12-86" tabindex="-1"></a></span>
<span id="cb12-87"><a href="#cb12-87" tabindex="-1"></a>            <span class="co"># Iterate through one batch of data at a time</span></span>
<span id="cb12-88"><a href="#cb12-88" tabindex="-1"></a>            batch_embeddings <span class="op">=</span> data_embeddings[i:i<span class="op">+</span>batch_size]</span>
<span id="cb12-89"><a href="#cb12-89" tabindex="-1"></a></span>
<span id="cb12-90"><a href="#cb12-90" tabindex="-1"></a>            <span class="co"># Get the probe's predictions</span></span>
<span id="cb12-91"><a href="#cb12-91" tabindex="-1"></a>            outputs <span class="op">=</span> <span class="va">self</span>.probe(batch_embeddings)</span>
<span id="cb12-92"><a href="#cb12-92" tabindex="-1"></a></span>
<span id="cb12-93"><a href="#cb12-93" tabindex="-1"></a>            <span class="co"># Get the predicted class for each sample</span></span>
<span id="cb12-94"><a href="#cb12-94" tabindex="-1"></a>            _, predicted <span class="op">=</span> torch.<span class="bu">max</span>(outputs, <span class="dv">1</span>)</span>
<span id="cb12-95"><a href="#cb12-95" tabindex="-1"></a></span>
<span id="cb12-96"><a href="#cb12-96" tabindex="-1"></a>            <span class="co"># Concatenate the predictions from each batch</span></span>
<span id="cb12-97"><a href="#cb12-97" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb12-98"><a href="#cb12-98" tabindex="-1"></a>                all_predicted <span class="op">=</span> predicted</span>
<span id="cb12-99"><a href="#cb12-99" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb12-100"><a href="#cb12-100" tabindex="-1"></a>                all_predicted <span class="op">=</span> torch.cat([all_predicted, predicted], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-101"><a href="#cb12-101" tabindex="-1"></a></span>
<span id="cb12-102"><a href="#cb12-102" tabindex="-1"></a>        <span class="cf">return</span> all_predicted</span>
<span id="cb12-103"><a href="#cb12-103" tabindex="-1"></a></span>
<span id="cb12-104"><a href="#cb12-104" tabindex="-1"></a></span>
<span id="cb12-105"><a href="#cb12-105" tabindex="-1"></a>    <span class="kw">def</span> evaluate(<span class="va">self</span>, data_embeddings: torch.tensor, labels: torch.tensor, batch_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">32</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb12-106"><a href="#cb12-106" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb12-107"><a href="#cb12-107" tabindex="-1"></a><span class="co">        Evaluate the probe's performance by testing it on unseen data.</span></span>
<span id="cb12-108"><a href="#cb12-108" tabindex="-1"></a><span class="co">        :param data_embeddings: A tensor of shape N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb12-109"><a href="#cb12-109" tabindex="-1"></a><span class="co">        :param labels: A tensor of shape N, where N is the number of samples. Each element is the label for the corresponding sample.</span></span>
<span id="cb12-110"><a href="#cb12-110" tabindex="-1"></a><span class="co">        :return: The accuracy of the probe on the unseen data.</span></span>
<span id="cb12-111"><a href="#cb12-111" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb12-112"><a href="#cb12-112" tabindex="-1"></a></span>
<span id="cb12-113"><a href="#cb12-113" tabindex="-1"></a>        <span class="co"># Iterate through batches</span></span>
<span id="cb12-114"><a href="#cb12-114" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(data_embeddings), batch_size):</span>
<span id="cb12-115"><a href="#cb12-115" tabindex="-1"></a></span>
<span id="cb12-116"><a href="#cb12-116" tabindex="-1"></a>            <span class="co"># Iterate through one batch of data at a time</span></span>
<span id="cb12-117"><a href="#cb12-117" tabindex="-1"></a>            batch_embeddings <span class="op">=</span> data_embeddings[i:i<span class="op">+</span>batch_size]</span>
<span id="cb12-118"><a href="#cb12-118" tabindex="-1"></a>            batch_labels <span class="op">=</span> labels[i:i<span class="op">+</span>batch_size]</span>
<span id="cb12-119"><a href="#cb12-119" tabindex="-1"></a></span>
<span id="cb12-120"><a href="#cb12-120" tabindex="-1"></a>            <span class="co"># Convert to sentence embeddings, since we are performing a sentence classification task</span></span>
<span id="cb12-121"><a href="#cb12-121" tabindex="-1"></a>            batch_embeddings <span class="op">=</span> torch.mean(batch_embeddings, dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># N, D</span></span>
<span id="cb12-122"><a href="#cb12-122" tabindex="-1"></a></span>
<span id="cb12-123"><a href="#cb12-123" tabindex="-1"></a>            <span class="co"># Get the probe's predictions</span></span>
<span id="cb12-124"><a href="#cb12-124" tabindex="-1"></a>            <span class="cf">with</span> torch.no_grad():</span>
<span id="cb12-125"><a href="#cb12-125" tabindex="-1"></a>                outputs <span class="op">=</span> <span class="va">self</span>.probe(batch_embeddings)</span>
<span id="cb12-126"><a href="#cb12-126" tabindex="-1"></a></span>
<span id="cb12-127"><a href="#cb12-127" tabindex="-1"></a>            <span class="co"># Get the predicted class for each sample</span></span>
<span id="cb12-128"><a href="#cb12-128" tabindex="-1"></a>            _, predicted <span class="op">=</span> torch.<span class="bu">max</span>(outputs, dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb12-129"><a href="#cb12-129" tabindex="-1"></a></span>
<span id="cb12-130"><a href="#cb12-130" tabindex="-1"></a>            <span class="co"># Concatenate the predictions from each batch</span></span>
<span id="cb12-131"><a href="#cb12-131" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb12-132"><a href="#cb12-132" tabindex="-1"></a>                all_predicted <span class="op">=</span> predicted</span>
<span id="cb12-133"><a href="#cb12-133" tabindex="-1"></a>                all_labels <span class="op">=</span> batch_labels</span>
<span id="cb12-134"><a href="#cb12-134" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb12-135"><a href="#cb12-135" tabindex="-1"></a>                all_predicted <span class="op">=</span> torch.cat([all_predicted, predicted], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-136"><a href="#cb12-136" tabindex="-1"></a>                all_labels <span class="op">=</span> torch.cat([all_labels, batch_labels], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-137"><a href="#cb12-137" tabindex="-1"></a></span>
<span id="cb12-138"><a href="#cb12-138" tabindex="-1"></a>        <span class="co"># Calculate the accuracy of the probe</span></span>
<span id="cb12-139"><a href="#cb12-139" tabindex="-1"></a>        correct <span class="op">=</span> (all_predicted <span class="op">==</span> all_labels).<span class="bu">sum</span>().item()</span>
<span id="cb12-140"><a href="#cb12-140" tabindex="-1"></a>        accuracy <span class="op">=</span> correct <span class="op">/</span> all_labels.shape[<span class="dv">0</span>]</span>
<span id="cb12-141"><a href="#cb12-141" tabindex="-1"></a>        logging.info(<span class="ss">f'Probe accuracy: </span><span class="sc">{</span>accuracy<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb12-142"><a href="#cb12-142" tabindex="-1"></a></span>
<span id="cb12-143"><a href="#cb12-143" tabindex="-1"></a>        <span class="cf">return</span> accuracy</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="co"># Initialize the probing classifier (or probe)</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>probe <span class="op">=</span> Probe()</span></code></pre>
</div>
</div>
<div class="section level5">
<h5 id="analysing-the-model-using-probes">Analysing the model using Probes<a class="anchor" aria-label="anchor" href="#analysing-the-model-using-probes"></a>
</h5>
<p>Time to start evaluating the model using our probing tool! Let’s see
which layer has most information about sentiment analysis on IMDB. For
this, we will train the probe on embeddings from each layer of the
model, and see which layer performs the best on the dev set.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>layer_wise_accuracies <span class="op">=</span> []</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>best_probe, best_layer, best_accuracy <span class="op">=</span> <span class="va">None</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="cf">for</span> layer_num <span class="kw">in</span> <span class="bu">range</span>(num_layers):</span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>    logging.info(<span class="ss">f'</span><span class="ch">\n\n</span><span class="ss">Evaluating representations of layer </span><span class="sc">{</span>layer_num<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">...'</span>)</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>    train_embeddings <span class="op">=</span> get_embeddings_from_model(model, tokenizer, layer_num<span class="op">=</span>layer_num, data<span class="op">=</span>train_dataset[<span class="st">'text'</span>])</span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a>    dev_embeddings <span class="op">=</span> get_embeddings_from_model(model, tokenizer, layer_num<span class="op">=</span>layer_num, data<span class="op">=</span>dev_dataset[<span class="st">'text'</span>])</span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>    train_labels, dev_labels <span class="op">=</span> torch.tensor(train_dataset[<span class="st">'label'</span>],  dtype<span class="op">=</span>torch.<span class="bu">long</span>), torch.tensor(dev_dataset[<span class="st">'label'</span>],  dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a>    <span class="co"># Before training the probe, let's visualize the embeddings using t-SNE.</span></span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a>    <span class="co"># If the layer has information about sentiment analysis, would we see some structure in the embeddings?</span></span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a>    <span class="co"># Compare plots from layers where the probe does poorly, with ones where it does well. What do you notice?</span></span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a>    visualize_embeddings(embeddings<span class="op">=</span>train_embeddings, labels<span class="op">=</span>train_dataset[<span class="st">'label'</span>], layer_num<span class="op">=</span>layer_num, save_plot<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb14-15"><a href="#cb14-15" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" tabindex="-1"></a>    <span class="co"># Now, let's train the probe on the embeddings from the model.</span></span>
<span id="cb14-17"><a href="#cb14-17" tabindex="-1"></a>    <span class="co"># Feel free to play around with the training hyperparameters, and see what works best for your probe.</span></span>
<span id="cb14-18"><a href="#cb14-18" tabindex="-1"></a>    probe <span class="op">=</span> Probe()</span>
<span id="cb14-19"><a href="#cb14-19" tabindex="-1"></a>    probe.train(data_embeddings<span class="op">=</span>train_embeddings, labels<span class="op">=</span>train_labels,</span>
<span id="cb14-20"><a href="#cb14-20" tabindex="-1"></a>                num_epochs<span class="op">=</span><span class="dv">5</span>, learning_rate<span class="op">=</span><span class="fl">0.001</span>, batch_size<span class="op">=</span><span class="dv">32</span>)</span>
<span id="cb14-21"><a href="#cb14-21" tabindex="-1"></a></span>
<span id="cb14-22"><a href="#cb14-22" tabindex="-1"></a>    <span class="co"># Let's see how well our probe does on a held out dev set</span></span>
<span id="cb14-23"><a href="#cb14-23" tabindex="-1"></a>    accuracy <span class="op">=</span> probe.evaluate(data_embeddings<span class="op">=</span>dev_embeddings, labels<span class="op">=</span>dev_labels)</span>
<span id="cb14-24"><a href="#cb14-24" tabindex="-1"></a>    layer_wise_accuracies.append(accuracy)</span>
<span id="cb14-25"><a href="#cb14-25" tabindex="-1"></a></span>
<span id="cb14-26"><a href="#cb14-26" tabindex="-1"></a>    <span class="co"># Keep track of the best probe</span></span>
<span id="cb14-27"><a href="#cb14-27" tabindex="-1"></a>    <span class="cf">if</span> accuracy <span class="op">&gt;</span> best_accuracy:</span>
<span id="cb14-28"><a href="#cb14-28" tabindex="-1"></a>        best_probe, best_layer, best_accuracy <span class="op">=</span> probe, layer_num, accuracy</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="co"># Seeing a list of accuracies can be hard to interpret. Let's plot the layer-wise accuracies to see which layer is best.</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>plt.plot(layer_wise_accuracies)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>plt.xlabel(<span class="st">'Layer'</span>)</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>plt.ylabel(<span class="st">'Accuracy'</span>)</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>plt.title(<span class="st">'Probe Accuracy by Layer'</span>)</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>plt.grid(alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p>Which layer has the best accuracy? What does this tell us about the
model?</p>
<p>Let’s go ahead and stress test this. Is the best layer able to
predict sentiment for sentences outside the IMDB dataset?</p>
<p>For answering this question, you are the test set! Try to think of
challenging sequences for which the model may not be able to predict
sentiment.</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>test_sequences <span class="op">=</span> [<span class="st">'Your sentence here'</span>, <span class="st">'Here is another sentence'</span>]</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>embeddings <span class="op">=</span> get_embeddings_from_model(model<span class="op">=</span>model, tokenizer<span class="op">=</span>tokenizer, layer_num<span class="op">=</span>best_layer, data<span class="op">=</span>test_sequences)</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>preds <span class="op">=</span> probe.predict(data_embeddings<span class="op">=</span>embeddings)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>predictions <span class="op">=</span> [<span class="st">'Positive'</span> <span class="cf">if</span> pred <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="st">'Negative'</span> <span class="cf">for</span> pred <span class="kw">in</span> preds]</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Predictions for test sequences: </span><span class="sc">{</span>predictions<span class="sc">}</span><span class="ss">'</span>)</span></code></pre>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div></section><section id="aio-5d-gradcam"><p>Content from <a href="5d-gradcam.html">Explainability methods: GradCAM</a></p>
<hr>
<p>Last updated on 2024-07-03 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/5d-gradcam.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># Let's begin by installing the grad-cam package - this will significantly simplify our implementation</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="op">!</span>pip install grad<span class="op">-</span>cam</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Packages to download test images</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="im">import</span> requests</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="co"># Packages to view and process images</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="im">import</span> cv2</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="im">from</span> google.colab.patches <span class="im">import</span> cv2_imshow</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a><span class="co"># Packages to load the model</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a><span class="im">from</span> torchvision.models <span class="im">import</span> resnet50</span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a><span class="co"># GradCAM Packaes</span></span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a><span class="im">from</span> pytorch_grad_cam <span class="im">import</span> GradCAM</span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a><span class="im">from</span> pytorch_grad_cam.utils.model_targets <span class="im">import</span> ClassifierOutputTarget</span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a><span class="im">from</span> pytorch_grad_cam.utils.image <span class="im">import</span> show_cam_on_image, preprocess_image</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>device <span class="op">=</span> <span class="st">'gpu'</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">'cpu'</span></span></code></pre>
</div>
<div class="section level5">
<h5 id="load-model">Load Model<a class="anchor" aria-label="anchor" href="#load-model"></a>
</h5>
<p>We’ll load the ResNet-50 model from torchvision. This model is
pre-trained on the ImageNet dataset, which contains 1.2 million images
across 1000 classes. ResNet-50 is popular model that is a type of
convolutional neural network. You can learn more about it here: <a href="https://pytorch.org/hub/pytorch_vision_resnet/" class="external-link uri">https://pytorch.org/hub/pytorch_vision_resnet/</a></p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>model <span class="op">=</span> resnet50(pretrained<span class="op">=</span><span class="va">True</span>).to(device).<span class="bu">eval</span>()</span></code></pre>
</div>
</div>
<div class="section level5">
<h5 id="load-test-image">Load Test Image<a class="anchor" aria-label="anchor" href="#load-test-image"></a>
</h5>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># Let's first take a look at the image, which we source from the GradCAM package</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/jacobgil/pytorch-grad-cam/master/examples/both.png"</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>Image.<span class="bu">open</span>(requests.get(url, stream<span class="op">=</span><span class="va">True</span>).raw)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># Cute, isn't it? Do you prefer dogs or cats?</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co"># We will need to convert the image into a tensor to feed it into the model.</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co"># Let's create a function to do this for us.</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="kw">def</span> load_image(url):</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>    rgb_img <span class="op">=</span> np.array(Image.<span class="bu">open</span>(requests.get(url, stream<span class="op">=</span><span class="va">True</span>).raw))</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>    rgb_img <span class="op">=</span> np.float32(rgb_img) <span class="op">/</span> <span class="dv">255</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>    input_tensor <span class="op">=</span> preprocess_image(rgb_img).to(device)</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>    <span class="cf">return</span> input_tensor, rgb_img</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>input_tensor, rgb_image <span class="op">=</span> load_image(url)</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="grad-cam-time">Grad-CAM Time!<a class="anchor" aria-label="anchor" href="#grad-cam-time"></a>
</h3>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co"># Let's start by selecting which layers of the model we want to use to generate the CAM.</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="co"># For that, we will need to inspect the model architecture.</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="co"># We can do that by simply printing the model object.</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="bu">print</span>(model)</span></code></pre>
</div>
<p>Here we want to interpret what the model as a whole is doing (not
what a specific layer is doing). That means that we want to use the
embeddings of the last layer before the final classification layer. This
is the layer that contains the information about the image encoded by
the model as a whole.</p>
<p>Looking at the model, we can see that the last layer before the final
classification layer is <code>layer4</code>.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>target_layers <span class="op">=</span> [model.layer4]</span></code></pre>
</div>
<p>We also want to pick a label for the CAM - this is the class we want
to visualize the activation for. Essentially, we want to see what the
model is looking at when it is predicting a certain class.</p>
<p>Since ResNet was trained on the ImageNet dataset with 1000 classes,
let’s get an indexed list of those classes. We can then pick the index
of the class we want to visualize.</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>imagenet_categories_url <span class="op">=</span> <span class="op">\</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>     <span class="st">"https://gist.githubusercontent.com/yrevar/942d3a0ac09ec9e5eb3a/raw/238f720ff059c1f82f368259d1ca4ffa5dd8f9f5/imagenet1000_clsidx_to_labels.txt"</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>labels <span class="op">=</span> <span class="bu">eval</span>(requests.get(imagenet_categories_url).text)</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>labels</span></code></pre>
</div>
<p>Well, that’s a lot! To simplify things, we have already picked out
the indices of a few interesting classes.</p>
<ul>
<li>157: Siberian Husky</li>
<li>162: Beagle</li>
<li>245: French Bulldog</li>
<li>281: Tabby Cat</li>
<li>285: Egyptian cat</li>
<li>360: Otter</li>
<li>537: Dog Sleigh</li>
<li>799: Sliding Door</li>
<li>918: Street Sign</li>
</ul>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="co"># Specify the target class for visualization here. If you set this to None, the class with the highest score from the model will automatically be used.</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>visualized_class_id <span class="op">=</span> <span class="dv">245</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="kw">def</span> viz_gradcam(model, target_layers, class_id):</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>  <span class="cf">if</span> class_id <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>    targets <span class="op">=</span> <span class="va">None</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>    targets <span class="op">=</span> [ClassifierOutputTarget(class_id)]</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>  cam_algorithm <span class="op">=</span> GradCAM</span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>  <span class="cf">with</span> cam_algorithm(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers) <span class="im">as</span> cam:</span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>      grayscale_cam <span class="op">=</span> cam(input_tensor<span class="op">=</span>input_tensor,</span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a>                          targets<span class="op">=</span>targets)</span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a>      grayscale_cam <span class="op">=</span> grayscale_cam[<span class="dv">0</span>, :]</span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a></span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a>      cam_image <span class="op">=</span> show_cam_on_image(rgb_image, grayscale_cam, use_rgb<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a>      cam_image <span class="op">=</span> cv2.cvtColor(cam_image, cv2.COLOR_RGB2BGR)</span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a></span>
<span id="cb12-18"><a href="#cb12-18" tabindex="-1"></a>  cv2_imshow(cam_image)</span></code></pre>
</div>
<p>Finally, we can start visualizing! Let’s begin by seeing what parts
of the image the model looks at to make its most confident
prediction.</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="va">None</span>)</span></code></pre>
</div>
<p>Interesting, it looks like the model totally ignores the cat and
makes a prediction based on the dog. If we set the output class to
“French Bulldog” (<code>class_id=245</code>), we see the same
visualization - meaning that the model is indeed looking at the correct
part of the image to make the correct prediction.</p>
<p>Let’s see what the heatmap looks like when we force the model to look
at the cat.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">281</span>)</span></code></pre>
</div>
<p>The model is indeed looking at the cat when asked to predict the
class “Tabby Cat” (<code>class_id=281</code>)! But why is it still
predicting the dog? Well, the model was trained on the ImageNet dataset,
which contains a lot of images of dogs and cats. The model has learned
that the dog is a better indicator of the class “Tabby Cat” than the cat
itself.</p>
<p>Let’s see another example of this. The image has not only a dog and a
cat, but also a items in the background. Can the model correctly
identify the door?</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">799</span>)</span></code></pre>
</div>
<p>It can! However, it seems to also think of the shelf behind the dog
as a door.</p>
<p>Let’s try an unrelated object now. Where in the image does the model
see a street sign?</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">918</span>)</span></code></pre>
</div>
<p>Looks like our analysis has revealed a shortcoming of the model! It
seems to percieve cats and street signs similarly.</p>
<p>Ideally, when the target class is some unrelated object, a good model
will look at no significant part of the image. For example, the model
does a good job with the class for Dog Sleigh.</p>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">537</span>)</span></code></pre>
</div>
<p>Explaining model predictions though visualization techniques like
this can be very subjective and prone to error. However, this still
provides some degree of insight a completely black box model would not
provide.</p>
<p>Spend some time playing around with different classes and seeing
which part of the image the model looks at. Feel free to play around
with other base images as well. Have fun! <!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 --></p>
</div></section><section id="aio-6-confidence-intervals"><p>Content from <a href="6-confidence-intervals.html">Estimating model uncertainty: overview</a></p>
<hr>
<p>Last updated on 2024-11-15 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/6-confidence-intervals.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 15 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What is model uncertainty, and how can it be categorized?<br>
</li>
<li>How do uncertainty estimation methods intersect with OOD detection
methods?<br>
</li>
<li>What are the computational challenges of estimating model
uncertainty?<br>
</li>
<li>When is uncertainty estimation useful, and what are its
limitations?<br>
</li>
<li>Why is OOD detection often preferred over traditional uncertainty
estimation techniques in modern applications?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Define and distinguish between aleatoric and epistemic uncertainty
in machine learning models.<br>
</li>
<li>Explore common techniques for estimating aleatoric and epistemic
uncertainty.<br>
</li>
<li>Understand why OOD detection has become a widely adopted approach in
many real-world applications.<br>
</li>
<li>Compare and contrast the goals and computational costs of
uncertainty estimation and OOD detection.<br>
</li>
<li>Summarize when and where different uncertainty estimation methods
are most useful.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="estimating-model-uncertainty">Estimating model uncertainty<a class="anchor" aria-label="anchor" href="#estimating-model-uncertainty"></a>
</h3>
<p>Understanding how confident a model is in its predictions is a
valuable tool for building trustworthy AI systems, especially in
high-stakes settings like healthcare or autonomous vehicles. Model
uncertainty estimation focuses on quantifying the model’s confidence and
is often used to identify predictions that require further review or
caution.</p>
<p>Model uncertainty can be divided into two categories:</p>
<ul>
<li>
<strong>Aleatoric uncertainty</strong>: Inherent noise in the data
(e.g., overlapping classes) that cannot be reduced, even with more
data.</li>
<li>
<strong>Epistemic uncertainty</strong>: Gaps in the model’s
knowledge about the data distribution, which can be reduced by using
more data or improved models.</li>
</ul>
<div class="section level4">
<h4 id="common-techniques-for-estimating-aleatoric-uncertainty">Common techniques for estimating aleatoric uncertainty<a class="anchor" aria-label="anchor" href="#common-techniques-for-estimating-aleatoric-uncertainty"></a>
</h4>
<p>Aleatoric uncertainty arises from the data itself. Methods to
estimate it include:</p>
<ul>
<li>
<strong>Predictive variance in regression models</strong>: Outputs
the variance of the predicted value, reflecting the noise in the data.
For instance, in a regression task predicting house prices, predictive
variance highlights how much randomness exists in the relationship
between input features (like square footage) and price.<br>
</li>
<li>
<strong>Heteroscedastic models</strong>: Use specialized loss
functions that allow the model to predict the noise level in the data
directly. These models are particularly critical in fields like
<strong>robotics</strong>, where sensor noise varies significantly
depending on environmental conditions. For example, a robot navigating
in bright daylight versus dim lighting conditions may experience vastly
different levels of noise in its sensor inputs, and heteroscedastic
models can help account for this variability.<br>
</li>
<li>
<strong>Data augmentation and perturbation analysis</strong>: Assess
variability in predictions by adding noise to the input data and
observing how much the model’s outputs change. A highly sensitive change
in predictions may indicate underlying noise or instability in the data.
For instance, in image classification, augmenting training data with
synthetic noise can help the model better handle real-world
imperfections like motion blur or occlusions.</li>
</ul>
</div>
<div class="section level4">
<h4 id="common-techniques-for-estimating-epistemic-uncertainty">Common techniques for estimating epistemic uncertainty<a class="anchor" aria-label="anchor" href="#common-techniques-for-estimating-epistemic-uncertainty"></a>
</h4>
<p>Epistemic uncertainty arises from the model’s lack of knowledge about
certain regions of the data space. Techniques to estimate it
include:</p>
<ul>
<li>
<strong>Monte Carlo dropout</strong>: In this method, dropout (a
regularization technique that randomly disables some neurons) is applied
during inference, and multiple forward passes are performed for the same
input. The variability in the outputs across these passes gives an
estimate of uncertainty. Intuitively, each forward pass simulates a
slightly different version of the model, akin to an ensemble. If the
model consistently predicts similar outputs despite dropout, it is
confident; if predictions vary widely, the model is uncertain about that
input.</li>
<li>
<strong>Bayesian neural networks</strong>: These networks
incorporate probabilistic layers to model uncertainty directly in the
weights of the network. Instead of assigning a single deterministic
weight to each connection, Bayesian neural networks assign distributions
to these weights, reflecting the uncertainty about their true values.
During inference, these distributions are sampled multiple times to
generate predictions, which naturally include uncertainty estimates.
While Bayesian neural networks are theoretically rigorous and align well
with the goal of epistemic uncertainty estimation, they are
computationally expensive and challenging to scale for large datasets or
deep architectures. This is because calculating or approximating
posterior distributions over all parameters becomes intractable as model
size grows. To address this, methods like variational inference or Monte
Carlo sampling are often used, but these approximations can introduce
inaccuracies, making Bayesian approaches less practical for many modern
applications. Despite these challenges, Bayesian neural networks remain
valuable for research contexts where precise uncertainty quantification
is needed or in domains where computational resources are less of a
concern.</li>
<li>
<strong>Ensemble models</strong>: These involve training multiple
models on the same data, each starting with different initializations or
random seeds. The ensemble’s predictions are aggregated, and the
variance in their outputs reflects uncertainty. This approach works well
because different models often capture different aspects of the data.
For example, if all models agree, the prediction is confident; if they
disagree, there is uncertainty. Ensembles are effective but
computationally expensive, as they require training and evaluating
multiple models.</li>
<li>
<strong>Out-of-distribution detection</strong>: Identifies inputs
that fall significantly outside the training distribution, flagging
areas where the model’s predictions are unreliable. Many OOD methods
produce continuous scores, such as Mahalanobis distance or energy-based
scores, which measure how novel or dissimilar an input is from the
training data. These scores can be interpreted as a form of epistemic
uncertainty, providing insight into how unfamiliar an input is. However,
OOD detection focuses on distinguishing ID from OOD inputs rather than
offering confidence estimates for predictions on ID inputs.</li>
</ul>
</div>
</div>
<div class="section level3">
<h3 id="method-selection-summary-table">Method selection summary table<a class="anchor" aria-label="anchor" href="#method-selection-summary-table"></a>
</h3>
<div class="section level4">
<h4 id="understanding-size-categories-in-table">Understanding size categories in table<a class="anchor" aria-label="anchor" href="#understanding-size-categories-in-table"></a>
</h4>
<p>To help guide method selection, here are rough definitions for
<strong>model size</strong>, <strong>data size</strong>, and
<strong>compute requirements</strong> used in the table:</p>
<p><strong>Model size</strong></p>
<ul>
<li>
<strong>Small</strong>: Fewer than 10M parameters (e.g., logistic
regression, LeNet).</li>
<li>
<strong>Medium</strong>: 10M–100M parameters (e.g., ResNet-50,
BERT-base).</li>
<li>
<strong>Large</strong>: More than 100M parameters (e.g., GPT-3,
Vision Transformers).</li>
</ul>
<p><strong>Data size</strong></p>
<ul>
<li>
<strong>Small</strong>: Fewer than 10,000 samples (e.g., materials
science datasets).</li>
<li>
<strong>Medium</strong>: 10,000–1M samples (e.g., ImageNet).</li>
<li>
<strong>Large</strong>: More than 1M samples (e.g., Common Crawl,
LAION-5B).</li>
</ul>
<p><strong>Compute time</strong> (approximate)</p>
<ul>
<li>
<strong>Low</strong>: Suitable for standard CPU or single GPU,
training/inference in minutes to an hour.</li>
<li>
<strong>Medium</strong>: Requires a modern GPU, training/inference
in hours to a day.</li>
<li>
<strong>High</strong>: Requires multiple GPUs/TPUs or distributed
setups, training/inference in days to weeks.</li>
</ul>
<table class="table">
<colgroup>
<col width="6%">
<col width="6%">
<col width="15%">
<col width="14%">
<col width="27%">
<col width="10%">
<col width="10%">
<col width="9%">
</colgroup>
<thead><tr class="header">
<th><strong>Method</strong></th>
<th><strong>Type of uncertainty</strong></th>
<th><strong>Key strengths</strong></th>
<th><strong>Key limitations</strong></th>
<th><strong>Common use cases/domains</strong></th>
<th><strong>Model size restrictions</strong></th>
<th><strong>Data size restrictions</strong></th>
<th><strong>Compute time (approx.)</strong></th>
</tr></thead>
<tbody>
<tr class="odd">
<td><strong>Predictive variance</strong></td>
<td>Aleatoric</td>
<td>Simple, intuitive for regression tasks</td>
<td>Limited to regression problems; doesn’t address epistemic
uncertainty</td>
<td>Regression tasks like house price prediction, energy consumption
modeling.</td>
<td>Small to medium</td>
<td>Small to medium</td>
<td>Very low (single pass)</td>
</tr>
<tr class="even">
<td><strong>Heteroscedastic models</strong></td>
<td>Aleatoric</td>
<td>Models variable noise across inputs</td>
<td>Requires specialized architectures or loss functions</td>
<td>Robotics (handling sensor noise), object detection in noisy
environments.</td>
<td>Medium to large (depends on task)</td>
<td>Medium</td>
<td>Medium (depends on task complexity)</td>
</tr>
<tr class="odd">
<td><strong>Monte Carlo dropout</strong></td>
<td>Epistemic</td>
<td>Easy to implement in existing neural networks</td>
<td>Computationally expensive due to multiple forward passes</td>
<td>Medical diagnosis models, small-scale deep learning tasks requiring
uncertainty estimates.</td>
<td>Medium</td>
<td>Medium to large</td>
<td>High (scales with forward passes)</td>
</tr>
<tr class="even">
<td><strong>Bayesian neural nets</strong></td>
<td>Epistemic</td>
<td>Rigorous probabilistic foundation</td>
<td>Computationally prohibitive for large models/datasets</td>
<td>Research-intensive applications like materials science, drug
discovery.</td>
<td>Small to medium (challenging to scale)</td>
<td>Small to medium</td>
<td>Very high (depends on sampling)</td>
</tr>
<tr class="odd">
<td><strong>Ensemble models</strong></td>
<td>Epistemic</td>
<td>Effective and robust; captures diverse uncertainties</td>
<td>Resource-intensive; requires training multiple models</td>
<td>Financial risk assessment, autonomous systems, and materials
property prediction.</td>
<td>Medium to large</td>
<td>Medium to large</td>
<td>Very high (training multiple models)</td>
</tr>
<tr class="even">
<td><strong>OOD detection</strong></td>
<td>Epistemic</td>
<td>Efficient, scalable, excels at rejecting anomalous inputs</td>
<td>Limited to identifying OOD inputs, not fine-grained uncertainty</td>
<td>NLP (e.g., chatbot queries), computer vision (e.g., detecting novel
objects in autonomous driving).</td>
<td>Medium to large</td>
<td>Small to large</td>
<td>Low to medium (scales efficiently)</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="why-is-ood-detection-widely-adopted">Why is OOD detection widely adopted?<a class="anchor" aria-label="anchor" href="#why-is-ood-detection-widely-adopted"></a>
</h4>
<p>Among epistemic uncertainty methods, OOD detection has become a
widely adopted approach in real-world applications due to its ability to
efficiently identify inputs that fall outside the training data
distribution, where predictions are inherently unreliable. Many OOD
detection techniques produce continuous scores that quantify the novelty
or dissimilarity of inputs, which can be interpreted as a form of
uncertainty. This makes OOD detection not only effective at rejecting
anomalous inputs but also useful for prioritizing inputs based on their
predicted risk.</p>
<p>For example, in autonomous vehicles, OOD detection can help flag
unexpected scenarios (e.g., unusual objects on the road) in near
real-time, enabling safer decision-making. Similarly, in NLP, OOD
methods are used to identify queries or statements that deviate from a
model’s training corpus, such as out-of-context questions in a chatbot
system. In the next couple of episodes, we’ll see how to implement
various OOD strategies.</p>
</div>
<div class="section level4">
<h4 id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h4>
<p>While uncertainty estimation provides a broad framework for
understanding model confidence, different methods are suited for
specific types of uncertainty and use cases. OOD detection stands out as
the most practical approach for handling epistemic uncertainty in modern
applications, thanks to its efficiency and ability to reject anomalous
inputs. Together, these methods form a complementary toolkit for
building trustworthy AI systems.</p>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div></section><section id="aio-7a-OOD-detection-overview"><p>Content from <a href="7a-OOD-detection-overview.html">OOD detection: overview</a></p>
<hr>
<p>Last updated on 2024-11-15 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/7a-OOD-detection-overview.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are out-of-distribution (OOD) data and why is detecting them
important in machine learning models?</li>
<li>What are the two broad classes of OOD detection methods:
threshold-based and training-time regularization?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand the concept of out-of-distribution data and its
significance in building trustworthy machine learning models.</li>
<li>Learn the two main approaches to OOD detection: threshold-based
methods and training-time regularization.</li>
<li>Identify the strengths and limitations of these approaches at a high
level.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="introduction-to-out-of-distribution-ood-data">Introduction to Out-of-Distribution (OOD) Data<a class="anchor" aria-label="anchor" href="#introduction-to-out-of-distribution-ood-data"></a>
</h1>
<div class="section level2">
<h2 id="what-is-ood-data">What is OOD data?<a class="anchor" aria-label="anchor" href="#what-is-ood-data"></a>
</h2>
<p>Out-of-distribution (OOD) data refers to data that significantly
differs from the training data on which a machine learning model was
built, i.e., the in-distribution (ID). For example, the image below
compares the training data distribution of CIFAR-10, a popular dataset
used for image classification, with the vastly broader and more diverse
distribution of images found on the internet:</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-internet-vs-CIFAR10.jpg" alt="OpenAI: CIFAR-10 training distribution vs. internet" class="figure mx-auto d-block"><div class="figcaption">OpenAI: CIFAR-10 training distribution
vs. internet</div>
</figure><p>CIFAR-10 contains 60,000 images across 10 distinct classes (e.g.,
airplanes, dogs, trucks), with carefully curated examples for each
class. However, the internet features an essentially infinite variety of
images, many of which fall outside these predefined classes or include
unseen variations (e.g., new breeds of dogs or novel vehicle designs).
This contrast highlights the challenges models face when they encounter
data that significantly differs from their training distribution.</p>
</div>
<div class="section level2">
<h2 id="how-ood-data-manifests-in-ml-pipelines">How OOD data manifests in ML pipelines<a class="anchor" aria-label="anchor" href="#how-ood-data-manifests-in-ml-pipelines"></a>
</h2>
<p>The difference between in-distribution (ID) and OOD data can arise
from:</p>
<ul>
<li>
<strong>Semantic shift</strong>: The OOD sample belongs to a class
that was not present during training.</li>
<li>
<strong>Covariate shift</strong>: The OOD sample comes from a domain
where the input feature distribution is drastically different from the
training data.</li>
</ul>
</div>
<div class="section level2">
<h2 id="why-does-ood-data-matter">Why does OOD data matter?<a class="anchor" aria-label="anchor" href="#why-does-ood-data-matter"></a>
</h2>
<p>Models trained on a specific distribution might make incorrect
predictions on OOD data, leading to unreliable outputs. In critical
applications (e.g., healthcare, autonomous driving), encountering OOD
data without proper handling can have severe consequences.</p>
<div class="section level3">
<h3 id="ex1-tesla-crashes-into-jet">Ex1: Tesla crashes into jet<a class="anchor" aria-label="anchor" href="#ex1-tesla-crashes-into-jet"></a>
</h3>
<p>In April 2022, a <a href="https://www.newsweek.com/video-tesla-smart-summon-mode-ramming-3m-jet-viewed-34m-times-1700310" class="external-link">Tesla
Model Y crashed into a $3.5 million private jet</a> at an aviation trade
show in Spokane, Washington, while operating on the “Smart Summon”
feature. The feature allows Tesla vehicles to autonomously navigate
parking lots to their owners, but in this case, it resulted in a
significant mishap. - The Tesla was summoned by its owner using the
Tesla app, which requires holding down a button to keep the car moving.
The car continued to move forward even after making contact with the
jet, pushing the expensive aircraft and causing notable damage. - The
crash highlighted several issues with Tesla’s Smart Summon feature,
particularly its object detection capabilities. The system failed to
recognize and appropriately react to the presence of the jet, a problem
that has been observed in other scenarios where the car’s sensors
struggle with objects that are lifted off the ground or have unusual
shapes.</p>
</div>
<div class="section level3">
<h3 id="ex2-ibm-watson-for-oncology">Ex2: IBM Watson for Oncology<a class="anchor" aria-label="anchor" href="#ex2-ibm-watson-for-oncology"></a>
</h3>
<p>Around a decade ago, the excitement surrounding AI in healthcare
often exceeded its actual capabilities. In 2016, IBM launched Watson for
Oncology, an AI-powered platform for treatment recommendations, to much
public enthusiasm. However, it soon became apparent that the system was
both costly and unreliable, frequently generating flawed advice while
operating as an opaque “black box. IBM Watson for Oncology faced several
issues due to OOD data. The system was primarily trained on data from
Memorial Sloan Kettering Cancer Center (MSK), which did not generalize
well to other healthcare settings. This led to the following
problems:</p>
<ol style="list-style-type: decimal">
<li>Unsafe Recommendations: Watson for Oncology provided treatment
recommendations that were not safe or aligned with standard care
guidelines in many cases outside of MSK. This happened because the
training data was not representative of the diverse medical practices
and patient populations in different regions</li>
<li>Bias in Training Data: The system’s recommendations were biased
towards the practices at MSK, failing to account for different treatment
protocols and patient needs elsewhere. This bias is a classic example of
an OOD issue, where the model encounters data (patients and treatments)
during deployment that significantly differ from its training data</li>
</ol>
<p>By 2022, IBM had taken Watson for Oncology offline, marking the end
of its commercial use.</p>
</div>
<div class="section level3">
<h3 id="ex3-doctors-using-gpt3">Ex3: Doctors using GPT3<a class="anchor" aria-label="anchor" href="#ex3-doctors-using-gpt3"></a>
</h3>
<div class="section level4">
<h4 id="misdiagnosis-and-inaccurate-medical-advice">Misdiagnosis and inaccurate medical advice<a class="anchor" aria-label="anchor" href="#misdiagnosis-and-inaccurate-medical-advice"></a>
</h4>
<p>In various studies and real-world applications, GPT-3 has been shown
to generate inaccurate medical advice when faced with OOD data. This can
be attributed to the fact that the training data, while extensive, does
not cover all possible medical scenarios and nuances, leading to
hallucinations or incorrect responses when encountering unfamiliar
input.</p>
<p>A <a href="https://hai.stanford.edu/news/generating-medical-errors-genai-and-erroneous-medical-references" class="external-link">study
published by researchers at Stanford</a> found that GPT-3, even when
using retrieval-augmented generation, provided unsupported medical
advice in about 30% of its statements. For example, it suggested the use
of a specific dosage for a defibrillator based on monophasic technology,
while the cited source only discussed biphasic technology, which
operates differently.</p>
</div>
<div class="section level4">
<h4 id="fake-medical-literature-references">Fake medical literature references<a class="anchor" aria-label="anchor" href="#fake-medical-literature-references"></a>
</h4>
<p>Another critical OOD issue is the generation of fake or non-existent
medical references by LLMs. When LLMs are prompted to provide citations
for their responses, they sometimes generate references that sound
plausible but do not actually exist. This can be particularly
problematic in academic and medical contexts where accurate sourcing is
crucial.</p>
<p>In <a href="https://hai.stanford.edu/news/generating-medical-errors-genai-and-erroneous-medical-references" class="external-link">evaluations
of GPT-3’s ability to generate medical literature references</a> , it
was found that a significant portion of the references were either
entirely fabricated or did not support the claims being made. This was
especially true for complex medical inquiries that the model had not
seen in its training data.</p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="detecting-and-handling-ood-data">Detecting and handling OOD data<a class="anchor" aria-label="anchor" href="#detecting-and-handling-ood-data"></a>
</h2>
<p>Given the problems posed by OOD data, a reliable model should
identify such instances, and then:</p>
<ol style="list-style-type: decimal">
<li>Reject them during inference</li>
<li>Ideally, hand these OOD instances to a model trained on a more
similar distribution (an in-distribution).</li>
</ol>
<p>The second step is much more complicated/involved since it requires
matching OOD data to essentially an infinite number of possible classes.
For the current scope of this workshop, we will focus on just the first
step.</p>
<p>How can we determine whether a given instance is OOD or ID? Over the
past several years, there have been a wide assortment of new methods
developed to tackle this task. In this episode, we will cover a few of
the most common approaches and discuss advantages/disadvantages of each.
These methods can be grouped under two broad categores:
<strong>threshold-based</strong> and and <strong>training-time
regularization</strong>.</p>
<div class="section level3">
<h3 id="threshold-based-methods">1) Threshold-based methods<a class="anchor" aria-label="anchor" href="#threshold-based-methods"></a>
</h3>
<p>Threshold-based methods are one of the simplest and most intuitive
approaches for detecting out-of-distribution (OOD) data. The central
idea is to define a threshold on a certain score or confidence measure,
beyond which the data point is considered out-of-distribution.
Typically, these scores are derived from the model’s output
probabilities or other statistical measures of uncertainty. There are
two general classes of threshold-based methods:
<strong>output-based</strong> and <strong>distance-based</strong>.</p>
<div class="section level4">
<h4 id="a-output-based-thresholds">1a) Output-based thresholds<a class="anchor" aria-label="anchor" href="#a-output-based-thresholds"></a>
</h4>
<p>Output-based Out-of-Distribution (OOD) detection refers to methods
that determine whether a given input is out-of-distribution based on the
output of a trained model. These methods typically analyze the model’s
confidence scores, energy scores, or other output metrics to identify
data points that are unlikely to belong to the distribution the model
was trained on. The main approaches within output-based OOD detection
include:</p>
<ul>
<li>
<strong>Softmax scores</strong>: The softmax output of a neural
network represents the predicted probabilities for each class. A common
threshold-based method involves setting a confidence threshold, and if
the maximum softmax score of an instance falls below this threshold, it
is flagged as OOD.</li>
<li>
<strong>Energy</strong>: The energy-based method also uses the
network’s output but measures the uncertainty in a more nuanced way by
calculating an energy score. The energy score typically captures the
confidence more robustly, especially in high-dimensional spaces, and can
be considered a more general and reliable approach than just using
softmax probabilities.</li>
</ul>
</div>
<div class="section level4">
<h4 id="b-distance-based-thresholds">1b) Distance-based thresholds<a class="anchor" aria-label="anchor" href="#b-distance-based-thresholds"></a>
</h4>
<p>Distance-based methods calculate the distance of an instance from the
distribution of training data features learned by the model. If the
distance is beyond a certain threshold, the instance is considered OOD.
Common distance-based approaches include:</p>
<ul>
<li>
<strong>Mahalanobis distance:</strong> This method calculates the
Mahalanobis distance of a data point from the mean of the training data
distribution. A high Mahalanobis distance indicates that the instance is
likely OOD.</li>
<li>
<strong>K-nearest neighbors (KNN):</strong> This method involves
computing the distance to the k-nearest neighbors in the training data.
If the average distance to these neighbors is high, the instance is
considered OOD.</li>
</ul>
<p>We will focus on output-based methods (softmax and energy) in the
next episode and then do a deep dive into distance-based methods in a
later next episode.</p>
</div>
</div>
<div class="section level3">
<h3 id="training-time-regularization-methods">2) Training-time regularization methods<a class="anchor" aria-label="anchor" href="#training-time-regularization-methods"></a>
</h3>
<p>Training-time regularization methods improve OOD detection by
incorporating penalties into the training process. These penalties
encourage the model to handle OOD data effectively, either by:</p>
<ul>
<li>Penalizing high confidence on OOD samples,</li>
<li>Optimizing feature representations to separate ID and OOD data,</li>
<li>Or enhancing robustness to adversarial or ambiguous inputs.</li>
</ul>
<p>The following methods apply these penalties in different ways:
outlier exposure, contrastive learning, confidence penalties, and
adversarial training.</p>
<div class="section level4">
<h4 id="a-outlier-exposure">2a) Outlier exposure<a class="anchor" aria-label="anchor" href="#a-outlier-exposure"></a>
</h4>
<p>Outlier Exposure (OE) penalizes high confidence on OOD samples by
introducing auxiliary datasets during training. This method teaches the
model to differentiate OOD data from ID data.</p>
<p><strong>How it works</strong>:</p>
<ul>
<li>Use a curated auxiliary dataset of OOD samples that differ from the
training distribution.</li>
<li>Augment the training loss function to penalize high confidence on
these auxiliary samples.</li>
<li>Resulting models are less likely to misclassify OOD inputs as
ID.</li>
</ul>
<table class="table">
<colgroup>
<col width="33%">
<col width="66%">
</colgroup>
<thead><tr class="header">
<th><strong>Advantages</strong></th>
<th><strong>Limitations</strong></th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Simple to implement when auxiliary datasets are available.</td>
<td>Requires access to high-quality, diverse OOD datasets during
training.</td>
</tr>
<tr class="even">
<td>Improves OOD detection performance without significant computational
cost.</td>
<td>Performance may degrade for OOD samples dissimilar to the auxiliary
dataset.</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="b-contrastive-learning">2b) Contrastive learning<a class="anchor" aria-label="anchor" href="#b-contrastive-learning"></a>
</h4>
<p>Contrastive learning optimizes feature representations by applying
penalties that control the similarity of embeddings. Positive pairs
(similar samples) are brought closer together, while negative pairs
(dissimilar samples) are pushed apart. This results in a feature space
where OOD data is less likely to overlap with ID data.</p>
<p><strong>How it works</strong>:</p>
<ul>
<li>Define a contrastive loss that minimizes the distance between
embeddings of similar samples (e.g., belonging to the same class).</li>
<li>Simultaneously maximize the distance between embeddings of
dissimilar samples (e.g., ID vs. synthetic or auxiliary OOD
samples).</li>
<li>Often uses data augmentation or self-supervised techniques to
generate “positive” and “negative” pairs.</li>
</ul>
<table class="table">
<colgroup>
<col width="33%">
<col width="66%">
</colgroup>
<thead><tr class="header">
<th><strong>Advantages</strong></th>
<th><strong>Limitations</strong></th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Does not require labeled auxiliary OOD data, as augmentations or
unsupervised data can be used.</td>
<td>Computationally expensive, especially with large datasets.</td>
</tr>
<tr class="even">
<td>Improves the quality of learned representations, benefiting other
tasks.</td>
<td>Requires careful tuning of the contrastive loss and data
augmentation strategy.</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="c-other-regularization-based-techniques">2c) Other regularization-based techniques<a class="anchor" aria-label="anchor" href="#c-other-regularization-based-techniques"></a>
</h4>
<p>Other methods incorporate penalties directly into the training
process to improve robustness to OOD data:</p>
<ul>
<li>
<strong>Confidence penalties</strong>: Penalize overconfidence in
predictions, especially on ambiguous samples.</li>
<li>
<strong>Adversarial training</strong>: Generate adversarial examples
(slightly perturbed ID samples) to penalize high confidence on these
perturbed examples, improving robustness.</li>
</ul>
<table class="table">
<colgroup>
<col width="33%">
<col width="66%">
</colgroup>
<thead><tr class="header">
<th><strong>Advantages</strong></th>
<th><strong>Limitations</strong></th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Enhances OOD detection performance by integrating it into the
training process.</td>
<td>Requires careful design of the training procedure and loss
function.</td>
</tr>
<tr class="even">
<td>Leads to better generalization for both ID and OOD scenarios.</td>
<td>Computationally intensive and may need access to additional
datasets.</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="summary-of-training-time-regularization-methods">Summary of Training-Time Regularization Methods<a class="anchor" aria-label="anchor" href="#summary-of-training-time-regularization-methods"></a>
</h4>
<table class="table">
<colgroup>
<col width="14%">
<col width="32%">
<col width="20%">
<col width="33%">
</colgroup>
<thead><tr class="header">
<th><strong>Method</strong></th>
<th><strong>Penalty Applied</strong></th>
<th><strong>Advantages</strong></th>
<th><strong>Limitations</strong></th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Outlier Exposure</td>
<td>High confidence on auxiliary OOD data.</td>
<td>Simple to implement, improves performance.</td>
<td>Requires high-quality auxiliary datasets, may not generalize to
unseen OOD data.</td>
</tr>
<tr class="even">
<td>Contrastive Learning</td>
<td>Embedding similarity for dissimilar samples (and vice versa)</td>
<td>Improves feature space quality, versatile.</td>
<td>Computationally expensive, requires careful tuning.</td>
</tr>
<tr class="odd">
<td>Confidence Penalties</td>
<td>Overconfidence on ambiguous inputs.</td>
<td>Improves robustness, generalizes well.</td>
<td>Requires careful design, computationally intensive.</td>
</tr>
<tr class="even">
<td>Adversarial Training</td>
<td>High confidence on adversarial examples.</td>
<td>Enhances robustness to perturbed inputs.</td>
<td>Computationally intensive, challenging to implement.</td>
</tr>
</tbody>
</table>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Out-of-distribution (OOD) data significantly differs from training
data and can lead to unreliable model predictions.</li>
<li>Threshold-based methods use model outputs or distances in feature
space to detect OOD instances by defining a score threshold.</li>
<li>Training-time regularization enhances OOD detection by incorporating
techniques like Outlier Exposure and Contrastive Learning during model
training.</li>
<li>Each method has trade-offs: threshold-based methods are simpler,
while training-time regularization often improves robustness at higher
computational cost.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div>
</div>
</div></section><section id="aio-7b-OOD-detection-output-based"><p>Content from <a href="7b-OOD-detection-output-based.html">OOD detection: output-based methods</a></p>
<hr>
<p>Last updated on 2024-11-15 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/7b-OOD-detection-output-based.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are out-of-distribution (OOD) data and why is detecting them
important in machine learning models?</li>
<li>What are the two broad classes of OOD detection methods:
threshold-based and training-time regularization?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand the concept of out-of-distribution data and its
significance in building trustworthy machine learning models.</li>
<li>Learn the two main approaches to OOD detection: threshold-based
methods and training-time regularization.</li>
<li>Identify the strengths and limitations of these approaches at a high
level.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="example-1-softmax-scores">Example 1: Softmax scores<a class="anchor" aria-label="anchor" href="#example-1-softmax-scores"></a>
</h1>
<p>Softmax-based out-of-distribution (OOD) detection methods are a
fundamental aspect of understanding how models differentiate between
in-distribution and OOD data. Even though energy-based methods are
becoming more popular, grasping softmax OOD detection methods provides
essential scaffolding for learning more advanced techniques.
Furthermore, softmax thresholding is still in use throughout ML
literature, and learning more about this method will help you better
assess results from others.</p>
<p>In this first example, we will train a simple logistic regression
model to classify images as T-shirts or pants. We will then evaluate how
our model reacts to data outside of these two classes (“semantic
shift”).</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># some settings I'm playing around with when designing this lesson</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>verbose <span class="op">=</span> <span class="va">False</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>alpha<span class="op">=</span><span class="fl">0.2</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>max_iter <span class="op">=</span> <span class="dv">10</span> <span class="co"># increase after testing phase</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>n_epochs <span class="op">=</span> <span class="dv">10</span> <span class="co"># increase after testing phase</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="prepare-the-id-train-and-test-and-ood-data">Prepare the ID (train and test) and OOD data<a class="anchor" aria-label="anchor" href="#prepare-the-id-train-and-test-and-ood-data"></a>
</h3>
<ul>
<li>ID = T-shirts/Blouses, Pants</li>
<li>OOD = any other class. For Illustrative purposes, we’ll focus on
images of sandals as the OOD class.</li>
</ul>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> accuracy_score</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="im">from</span> keras.datasets <span class="im">import</span> fashion_mnist</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="kw">def</span> prep_ID_OOD_datasests(ID_class_labels, OOD_class_labels):</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>    <span class="co"># Load Fashion MNIST dataset</span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>    (train_images, train_labels), (test_images, test_labels) <span class="op">=</span> fashion_mnist.load_data()</span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>    </span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>    <span class="co"># Prepare OOD data: Sandals = 5</span></span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a>    ood_filter <span class="op">=</span> np.isin(test_labels, OOD_class_labels)</span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a>    ood_data <span class="op">=</span> test_images[ood_filter]</span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a>    ood_labels <span class="op">=</span> test_labels[ood_filter]</span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'ood_data.shape=</span><span class="sc">{</span>ood_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a>    </span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a>    <span class="co"># Filter data for T-shirts (0) and Trousers (1) as in-distribution</span></span>
<span id="cb2-18"><a href="#cb2-18" tabindex="-1"></a>    train_filter <span class="op">=</span> np.isin(train_labels, ID_class_labels)</span>
<span id="cb2-19"><a href="#cb2-19" tabindex="-1"></a>    test_filter <span class="op">=</span> np.isin(test_labels, ID_class_labels)</span>
<span id="cb2-20"><a href="#cb2-20" tabindex="-1"></a>    </span>
<span id="cb2-21"><a href="#cb2-21" tabindex="-1"></a>    train_data <span class="op">=</span> train_images[train_filter]</span>
<span id="cb2-22"><a href="#cb2-22" tabindex="-1"></a>    train_labels <span class="op">=</span> train_labels[train_filter]</span>
<span id="cb2-23"><a href="#cb2-23" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'train_data.shape=</span><span class="sc">{</span>train_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb2-24"><a href="#cb2-24" tabindex="-1"></a>    </span>
<span id="cb2-25"><a href="#cb2-25" tabindex="-1"></a>    test_data <span class="op">=</span> test_images[test_filter]</span>
<span id="cb2-26"><a href="#cb2-26" tabindex="-1"></a>    test_labels <span class="op">=</span> test_labels[test_filter]</span>
<span id="cb2-27"><a href="#cb2-27" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'test_data.shape=</span><span class="sc">{</span>test_data<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb2-28"><a href="#cb2-28" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" tabindex="-1"></a>    <span class="cf">return</span> train_data, test_data, ood_data, train_labels, test_labels, ood_labels</span>
<span id="cb2-30"><a href="#cb2-30" tabindex="-1"></a></span>
<span id="cb2-31"><a href="#cb2-31" tabindex="-1"></a></span>
<span id="cb2-32"><a href="#cb2-32" tabindex="-1"></a><span class="kw">def</span> plot_data_sample(train_data, ood_data):</span>
<span id="cb2-33"><a href="#cb2-33" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-34"><a href="#cb2-34" tabindex="-1"></a><span class="co">    Plots a sample of in-distribution and OOD data.</span></span>
<span id="cb2-35"><a href="#cb2-35" tabindex="-1"></a></span>
<span id="cb2-36"><a href="#cb2-36" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb2-37"><a href="#cb2-37" tabindex="-1"></a><span class="co">    - train_data: np.array, array of in-distribution data images</span></span>
<span id="cb2-38"><a href="#cb2-38" tabindex="-1"></a><span class="co">    - ood_data: np.array, array of out-of-distribution data images</span></span>
<span id="cb2-39"><a href="#cb2-39" tabindex="-1"></a></span>
<span id="cb2-40"><a href="#cb2-40" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb2-41"><a href="#cb2-41" tabindex="-1"></a><span class="co">    - fig: matplotlib.figure.Figure, the figure object containing the plots</span></span>
<span id="cb2-42"><a href="#cb2-42" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-43"><a href="#cb2-43" tabindex="-1"></a>    fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb2-44"><a href="#cb2-44" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb2-45"><a href="#cb2-45" tabindex="-1"></a>        plt.subplot(<span class="dv">2</span>, <span class="dv">5</span>, i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-46"><a href="#cb2-46" tabindex="-1"></a>        plt.imshow(train_data[i], cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb2-47"><a href="#cb2-47" tabindex="-1"></a>        plt.title(<span class="st">"In-Dist"</span>)</span>
<span id="cb2-48"><a href="#cb2-48" tabindex="-1"></a>        plt.axis(<span class="st">'off'</span>)</span>
<span id="cb2-49"><a href="#cb2-49" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb2-50"><a href="#cb2-50" tabindex="-1"></a>        plt.subplot(<span class="dv">2</span>, <span class="dv">5</span>, i <span class="op">+</span> <span class="dv">6</span>)</span>
<span id="cb2-51"><a href="#cb2-51" tabindex="-1"></a>        plt.imshow(ood_data[i], cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb2-52"><a href="#cb2-52" tabindex="-1"></a>        plt.title(<span class="st">"OOD"</span>)</span>
<span id="cb2-53"><a href="#cb2-53" tabindex="-1"></a>        plt.axis(<span class="st">'off'</span>)</span>
<span id="cb2-54"><a href="#cb2-54" tabindex="-1"></a>    </span>
<span id="cb2-55"><a href="#cb2-55" tabindex="-1"></a>    <span class="cf">return</span> fig</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>train_data, test_data, ood_data, train_labels, test_labels, ood_labels <span class="op">=</span> prep_ID_OOD_datasests([<span class="dv">0</span>,<span class="dv">1</span>], [<span class="dv">5</span>])</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>fig <span class="op">=</span> plot_data_sample(train_data, ood_data)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>fig.savefig(<span class="st">'../images/OOD-detection_image-data-preview.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>plt.show()</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a></span></code></pre>
</div>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-detection_image-data-preview.png" alt="Preview of image dataset" class="figure mx-auto d-block"><div class="figcaption">Preview of image dataset</div>
</figure>
</div>
<div class="section level2">
<h2 id="visualizing-ood-and-id-data">Visualizing OOD and ID data<a class="anchor" aria-label="anchor" href="#visualizing-ood-and-id-data"></a>
</h2>
<div class="section level3">
<h3 id="pca">PCA<a class="anchor" aria-label="anchor" href="#pca"></a>
</h3>
<p>PCA visualization can provide insights into how well a model is
separating ID and OOD data. If the OOD data overlaps significantly with
ID data in the PCA space, it might indicate that the model could
struggle to correctly identify OOD samples.</p>
<p><strong>Focus on Linear Relationships</strong>: PCA is a linear
dimensionality reduction technique. It assumes that the directions of
maximum variance in the data can be captured by linear combinations of
the original features. This can be a limitation when the data has
complex, non-linear relationships, as PCA may not capture the true
structure of the data. However, if you’re using a linear model (as we
are here), PCA can be more appropriate for visualizing in-distribution
(ID) and out-of-distribution (OOD) data because both PCA and linear
models operate under linear assumptions. PCA will effectively capture
the main variance in the data as seen by the linear model, making it
easier to understand the decision boundaries and how OOD data deviates
from the ID data within those boundaries.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Flatten images for PCA and logistic regression</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>train_data_flat <span class="op">=</span> train_data.reshape((train_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>test_data_flat <span class="op">=</span> test_data.reshape((test_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>ood_data_flat <span class="op">=</span> ood_data.reshape((ood_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'train_data_flat.shape=</span><span class="sc">{</span>train_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'test_data_flat.shape=</span><span class="sc">{</span>test_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'ood_data_flat.shape=</span><span class="sc">{</span>ood_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># Perform PCA to visualize the first two principal components</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>pca <span class="op">=</span> PCA(n_components<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>train_data_pca <span class="op">=</span> pca.fit_transform(train_data_flat)</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>test_data_pca <span class="op">=</span> pca.transform(test_data_flat)</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>ood_data_pca <span class="op">=</span> pca.transform(ood_data_flat)</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co"># Plotting PCA components</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a>scatter1 <span class="op">=</span> plt.scatter(train_data_pca[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">0</span>], train_data_pca[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'blue'</span>, label<span class="op">=</span><span class="st">'T-shirt/top (ID)'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a>scatter2 <span class="op">=</span> plt.scatter(train_data_pca[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">0</span>], train_data_pca[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'red'</span>, label<span class="op">=</span><span class="st">'Pants (ID)'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a>scatter3 <span class="op">=</span> plt.scatter(ood_data_pca[:, <span class="dv">0</span>], ood_data_pca[:, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'green'</span>, label<span class="op">=</span><span class="st">'Sandals (OOD)'</span>, edgecolor<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a><span class="co"># Create a single legend for all classes</span></span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[scatter1, scatter2, scatter3], loc<span class="op">=</span><span class="st">"upper right"</span>)</span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a>plt.xlabel(<span class="st">'First Principal Component'</span>)</span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a>plt.ylabel(<span class="st">'Second Principal Component'</span>)</span>
<span id="cb5-19"><a href="#cb5-19" tabindex="-1"></a>plt.title(<span class="st">'PCA of In-Distribution and OOD Data'</span>)</span>
<span id="cb5-20"><a href="#cb5-20" tabindex="-1"></a>plt.savefig(<span class="st">'../images/OOD-detection_PCA-image-dataset.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb5-21"><a href="#cb5-21" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-detection_PCA-image-dataset.png" alt="PCA visualization" class="figure"> From this plot, we see that sandals are more
likely to be confused as T-shirts than pants. It also may be surprising
to see that these data clouds overlap so much given their semantic
differences. Why might this be?</p>
<ul>
<li>
<strong>Over-reliance on linear relationships</strong>: Part of this
has to do with the fact that we’re only looking at linear relationships
and treating each pixel as its own input feature, which is usually never
a great idea when working with image data. In our next example, we’ll
switch to the more modern approach of CNNs.</li>
<li>
<strong>Semantic gap != feature gap</strong>: Another factor of note
is that images that have a wide semantic gap may not necessarily
translate to a wide gap in terms of the data’s visual features (e.g.,
ankle boots and bags might both be small, have leather, and have
zippers). Part of an effective OOD detection scheme involves thinking
carefully about what sorts of data contanimations may be observed by the
model, and assessing how similar these contaminations may be to your
desired class labels. ## Train and evaluate model on ID data</li>
</ul>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># Train a logistic regression classifier</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>model <span class="op">=</span> LogisticRegression(max_iter<span class="op">=</span>max_iter, solver<span class="op">=</span><span class="st">'lbfgs'</span>, multi_class<span class="op">=</span><span class="st">'multinomial'</span>).fit(train_data_flat, train_labels)</span></code></pre>
</div>
<p>Before we worry about the impact of OOD data, let’s first verify that
we have a reasonably accurate model for the ID data.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># Evaluate the model on in-distribution data</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>in_dist_preds <span class="op">=</span> model.predict(test_data_flat)</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>in_dist_accuracy <span class="op">=</span> accuracy_score(test_labels, in_dist_preds)</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'In-Distribution Accuracy: </span><span class="sc">{</span>in_dist_accuracy<span class="sc">:.2f}</span><span class="ss">'</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> accuracy_score, confusion_matrix, ConfusionMatrixDisplay</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="co"># Generate and display confusion matrix</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>cm <span class="op">=</span> confusion_matrix(test_labels, in_dist_preds, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>cm, display_labels<span class="op">=</span>[<span class="st">'T-shirt/top'</span>, <span class="st">'Pants'</span>])</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>disp.plot(cmap<span class="op">=</span>plt.cm.Blues)</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>plt.savefig(<span class="st">'../images/OOD-detection_ID-confusion-matrix.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-detection_ID-confusion-matrix.png" alt="ID confusion matrix" class="figure mx-auto d-block"><div class="figcaption">ID confusion matrix</div>
</figure>
</div>
</div>
<div class="section level2">
<h2 id="how-does-our-model-view-ood-data">How does our model view OOD data?<a class="anchor" aria-label="anchor" href="#how-does-our-model-view-ood-data"></a>
</h2>
<p>A basic question we can start with is to ask, on average, how are OOD
samples classified? Are they more likely to be Tshirts or pants? For
this kind of question, we can calculate the probability scores for the
OOD data, and compare this to the ID data.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># Predict probabilities using the model on OOD data (Sandals)</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>ood_probs <span class="op">=</span> model.predict_proba(ood_data_flat)</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>avg_ood_prob <span class="op">=</span> np.mean(ood_probs, <span class="dv">0</span>)</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Avg. probability of sandal being T-shirt: </span><span class="sc">{</span>avg_ood_prob[<span class="dv">0</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Avg. probability of sandal being pants: </span><span class="sc">{</span>avg_ood_prob[<span class="dv">1</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>id_probs <span class="op">=</span> model.predict_proba(train_data_flat)</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>id_probs_shirts <span class="op">=</span> id_probs[train_labels<span class="op">==</span><span class="dv">0</span>,:]</span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a>id_probs_pants <span class="op">=</span> id_probs[train_labels<span class="op">==</span><span class="dv">1</span>,:]</span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a>avg_tshirt_prob <span class="op">=</span> np.mean(id_probs_shirts, <span class="dv">0</span>)</span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a>avg_pants_prob <span class="op">=</span> np.mean(id_probs_pants, <span class="dv">0</span>)</span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Avg. probability of T-shirt being T-shirt: </span><span class="sc">{</span>avg_tshirt_prob[<span class="dv">0</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Avg. probability of pants being pants: </span><span class="sc">{</span>avg_pants_prob[<span class="dv">1</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code></pre>
</div>
<p>Based on the difference in averages here, it looks like softmax may
provide at least a somewhat useful signal in separating ID and OOD data.
Let’s take a closer look by plotting histograms of all probability
scores across our classes of interest (ID-Tshirt, ID-Pants, and
OOD).</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co"># Creating the figure and subplots</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">4</span>), sharey<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>bins<span class="op">=</span><span class="dv">60</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="co"># Plotting the histogram of probabilities for OOD data (Sandals)</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>axes[<span class="dv">0</span>].hist(ood_probs[:, <span class="dv">0</span>], bins<span class="op">=</span>bins, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'T-shirt probability'</span>)</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>axes[<span class="dv">0</span>].set_xlabel(<span class="st">'Probability'</span>)</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>axes[<span class="dv">0</span>].set_ylabel(<span class="st">'Frequency'</span>)</span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'OOD Data (Sandals)'</span>)</span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>axes[<span class="dv">0</span>].legend()</span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a><span class="co"># Plotting the histogram of probabilities for ID data (T-shirt)</span></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>axes[<span class="dv">1</span>].hist(id_probs_shirts[:, <span class="dv">0</span>], bins<span class="op">=</span>bins, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'T-shirt probability'</span>, color<span class="op">=</span><span class="st">'orange'</span>)</span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a>axes[<span class="dv">1</span>].set_xlabel(<span class="st">'Probability'</span>)</span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'ID Data (T-shirt/top)'</span>)</span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a>axes[<span class="dv">1</span>].legend()</span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a><span class="co"># Plotting the histogram of probabilities for ID data (Pants)</span></span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a>axes[<span class="dv">2</span>].hist(id_probs_pants[:, <span class="dv">1</span>], bins<span class="op">=</span>bins, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Pants probability'</span>, color<span class="op">=</span><span class="st">'green'</span>)</span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a>axes[<span class="dv">2</span>].set_xlabel(<span class="st">'Probability'</span>)</span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a>axes[<span class="dv">2</span>].set_title(<span class="st">'ID Data (Pants)'</span>)</span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a>axes[<span class="dv">2</span>].legend()</span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a><span class="co"># Adjusting layout</span></span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a>plt.savefig(<span class="st">'../images/OOD-detection_histograms.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb10-26"><a href="#cb10-26" tabindex="-1"></a><span class="co"># Displaying the plot</span></span>
<span id="cb10-27"><a href="#cb10-27" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-detection_histograms.png" alt="Histograms of ID oand OOD data" class="figure"> Alternatively, for a better
comparison across all three classes, we can use a probability density
plot. This will allow for an easier comparison when the counts across
classes lie on vastly different sclaes (i.e., max of 35 vs max of
5000).</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> gaussian_kde</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="co"># Create figure</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="co"># Define bins</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">0.4</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a><span class="co"># Plot PDF for ID T-shirt (T-shirt probability)</span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>density_id_shirts <span class="op">=</span> gaussian_kde(id_probs_shirts[:, <span class="dv">0</span>])</span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>x_id_shirts <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1000</span>)</span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a>plt.plot(x_id_shirts, density_id_shirts(x_id_shirts), label<span class="op">=</span><span class="st">'ID T-shirt (T-shirt probability)'</span>, color<span class="op">=</span><span class="st">'orange'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a><span class="co"># Plot PDF for ID Pants (Pants probability)</span></span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a>density_id_pants <span class="op">=</span> gaussian_kde(id_probs_pants[:, <span class="dv">0</span>])</span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a>x_id_pants <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1000</span>)</span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a>plt.plot(x_id_pants, density_id_pants(x_id_pants), label<span class="op">=</span><span class="st">'ID Pants (T-shirt probability)'</span>, color<span class="op">=</span><span class="st">'green'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" tabindex="-1"></a><span class="co"># Plot PDF for OOD (T-shirt probability)</span></span>
<span id="cb11-20"><a href="#cb11-20" tabindex="-1"></a>density_ood <span class="op">=</span> gaussian_kde(ood_probs[:, <span class="dv">0</span>])</span>
<span id="cb11-21"><a href="#cb11-21" tabindex="-1"></a>x_ood <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1000</span>)</span>
<span id="cb11-22"><a href="#cb11-22" tabindex="-1"></a>plt.plot(x_ood, density_ood(x_ood), label<span class="op">=</span><span class="st">'OOD (T-shirt probability)'</span>, color<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb11-23"><a href="#cb11-23" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" tabindex="-1"></a><span class="co"># Adding labels and title</span></span>
<span id="cb11-25"><a href="#cb11-25" tabindex="-1"></a>plt.xlabel(<span class="st">'Probability'</span>)</span>
<span id="cb11-26"><a href="#cb11-26" tabindex="-1"></a>plt.ylabel(<span class="st">'Density'</span>)</span>
<span id="cb11-27"><a href="#cb11-27" tabindex="-1"></a>plt.title(<span class="st">'Probability Density Distributions for OOD and ID Data'</span>)</span>
<span id="cb11-28"><a href="#cb11-28" tabindex="-1"></a>plt.legend()</span>
<span id="cb11-29"><a href="#cb11-29" tabindex="-1"></a></span>
<span id="cb11-30"><a href="#cb11-30" tabindex="-1"></a>plt.savefig(<span class="st">'../images/OOD-detection_PSDs.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb11-31"><a href="#cb11-31" tabindex="-1"></a></span>
<span id="cb11-32"><a href="#cb11-32" tabindex="-1"></a><span class="co"># Displaying the plot</span></span>
<span id="cb11-33"><a href="#cb11-33" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-detection_PSDs.png" alt="Probability densities" class="figure"> Unfortunately, we observe a significant
amount of overlap between OOD data and high T-shirt probability.
Furthermore, the blue line doesn’t seem to decrease much as you move
from 0.9 to 1, suggesting that even a very high threshold is likely to
lead to OOD contamination (while also tossing out a significant portion
of ID data).</p>
<p>For pants, the problem is much less severe. It looks like a low
threshold (on this T-shirt probability scale) can separate nearly all
OOD samples from being pants.</p>
<div class="section level3">
<h3 id="setting-a-threshold">Setting a threshold<a class="anchor" aria-label="anchor" href="#setting-a-threshold"></a>
</h3>
<p>Let’s put our observations to the test and produce a confusion matrix
that includes ID-pants, ID-Tshirts, and OOD class labels. We’ll start
with a high threshold of 0.9 to see how that performs.</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="kw">def</span> softmax_thresh_classifications(probs, threshold):</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>    classifications <span class="op">=</span> np.where(probs[:, <span class="dv">1</span>] <span class="op">&gt;=</span> threshold, <span class="dv">1</span>,  <span class="co"># classified as pants</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>                               np.where(probs[:, <span class="dv">0</span>] <span class="op">&gt;=</span> threshold, <span class="dv">0</span>,  <span class="co"># classified as shirts</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>                                        <span class="op">-</span><span class="dv">1</span>))  <span class="co"># classified as OOD</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>    <span class="cf">return</span> classifications</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> precision_recall_fscore_support</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="co"># Assuming ood_probs, id_probs, and train_labels are defined</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="co"># Threshold values</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>upper_threshold <span class="op">=</span> <span class="fl">0.9</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="co"># Classifying OOD examples (sandals)</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a>ood_classifications <span class="op">=</span> softmax_thresh_classifications(ood_probs, upper_threshold)</span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="co"># Classifying ID examples (T-shirts and pants)</span></span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a>id_classifications <span class="op">=</span> softmax_thresh_classifications(id_probs, upper_threshold)</span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a><span class="co"># Combine OOD and ID classifications and true labels</span></span>
<span id="cb13-14"><a href="#cb13-14" tabindex="-1"></a>all_predictions <span class="op">=</span> np.concatenate([ood_classifications, id_classifications])</span>
<span id="cb13-15"><a href="#cb13-15" tabindex="-1"></a>all_true_labels <span class="op">=</span> np.concatenate([<span class="op">-</span><span class="dv">1</span> <span class="op">*</span> np.ones(ood_classifications.shape), train_labels])</span>
<span id="cb13-16"><a href="#cb13-16" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" tabindex="-1"></a><span class="co"># Confusion matrix</span></span>
<span id="cb13-18"><a href="#cb13-18" tabindex="-1"></a>cm <span class="op">=</span> confusion_matrix(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb13-19"><a href="#cb13-19" tabindex="-1"></a></span>
<span id="cb13-20"><a href="#cb13-20" tabindex="-1"></a><span class="co"># Plotting the confusion matrix</span></span>
<span id="cb13-21"><a href="#cb13-21" tabindex="-1"></a>disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>cm, display_labels<span class="op">=</span>[<span class="st">"Shirt"</span>, <span class="st">"Pants"</span>, <span class="st">"OOD"</span>])</span>
<span id="cb13-22"><a href="#cb13-22" tabindex="-1"></a>disp.plot(cmap<span class="op">=</span>plt.cm.Blues)</span>
<span id="cb13-23"><a href="#cb13-23" tabindex="-1"></a>plt.title(<span class="st">'Confusion Matrix for OOD and ID Classification'</span>)</span>
<span id="cb13-24"><a href="#cb13-24" tabindex="-1"></a></span>
<span id="cb13-25"><a href="#cb13-25" tabindex="-1"></a>plt.savefig(<span class="st">'../images/OOD-detection_ID-OOD-confusion-matrix1.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb13-26"><a href="#cb13-26" tabindex="-1"></a></span>
<span id="cb13-27"><a href="#cb13-27" tabindex="-1"></a>plt.show()</span>
<span id="cb13-28"><a href="#cb13-28" tabindex="-1"></a></span>
<span id="cb13-29"><a href="#cb13-29" tabindex="-1"></a><span class="co"># Looking at F1, precision, and recall</span></span>
<span id="cb13-30"><a href="#cb13-30" tabindex="-1"></a>precision, recall, f1, _ <span class="op">=</span> precision_recall_fscore_support(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>], average<span class="op">=</span><span class="st">'macro'</span>) <span class="co"># discuss macro vs micro .</span></span>
<span id="cb13-31"><a href="#cb13-31" tabindex="-1"></a></span>
<span id="cb13-32"><a href="#cb13-32" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"F1: </span><span class="sc">{</span>f1<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb13-33"><a href="#cb13-33" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Precision: </span><span class="sc">{</span>precision<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb13-34"><a href="#cb13-34" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Recall: </span><span class="sc">{</span>recall<span class="sc">}</span><span class="ss">"</span>)</span></code></pre>
</div>
<p><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-detection_ID-OOD-confusion-matrix1.png" alt="Probability densities" class="figure"> Even with a high threshold of 0.9, we end
up with nearly a couple hundred OOD samples classified as ID. In
addition, over 800 ID samples had to be tossed out due to
uncertainty.</p>
</div>
<div class="section level3">
<h3 id="quick-exercise">Quick exercise<a class="anchor" aria-label="anchor" href="#quick-exercise"></a>
</h3>
<p>What threhsold is required to ensure that no OOD samples are
incorrectly considered as IID? What percentage of ID samples are
mistaken as OOD at this threshold? Answer: 0.9999,
(3826+2414)/(3826+2414+2174+3586)=52%</p>
<p>With a very conservative threshold, we can make sure very few OOD
samples are incorrectly classified as ID. However, the flip side is that
conservative thresholds tend to incorrectly classify many ID samples as
being OOD. In this case, we incorrectly assume almost 20% of shirts are
OOD samples.</p>
</div>
</div>
<div class="section level2">
<h2 id="iterative-threshold-determination">Iterative Threshold Determination<a class="anchor" aria-label="anchor" href="#iterative-threshold-determination"></a>
</h2>
<p>In practice, selecting an appropriate threshold is an iterative
process that balances the trade-off between correctly identifying
in-distribution (ID) data and accurately flagging out-of-distribution
(OOD) data. Here’s how you can iteratively determine the threshold:</p>
<ul>
<li><p><strong>Define Evaluation Metrics</strong>: While confusion
matrices are an excellent tool when you’re ready to more closely examine
the data, we need a single metric that can summarize threshold
performance so we can easily compare across threshold. Common metrics
include accuracy, precision, recall, or the F1 score for both ID and OOD
detection.</p></li>
<li><p><strong>Evaluate Over a Range of Thresholds</strong>: Test
different threshold values and evaluate the performance on a validation
set containing both ID and OOD data.</p></li>
<li><p><strong>Select the Optimal Threshold</strong>: Choose the
threshold that provides the best balance according to your chosen
metrics.</p></li>
</ul>
<p>Use the below code to determine what threshold should be set to
ensure precision = 100%. What threshold is required for recall to be
100%? What threshold gives the highest F1 score?</p>
<div class="section level3">
<h3 id="callout-on-averaging-schemes">Callout on averaging schemes<a class="anchor" aria-label="anchor" href="#callout-on-averaging-schemes"></a>
</h3>
<p>F1 scores can be calculated per class, and then averaged in different
ways (macro, micro, or weighted) when dealing with multiclass or
multilabel classification problems. Here are the key types of averaging
methods:</p>
<ul>
<li><p>Macro-Averaging: Calculates the F1 score for each class
independently and then takes the average of these scores. This treats
all classes equally, regardless of their support (number of true
instances for each class).</p></li>
<li><p>Micro-Averaging: Aggregates the contributions of all classes to
compute the average F1 score. This is typically used for imbalanced
datasets as it gives more weight to classes with more
instances.</p></li>
<li><p>Weighted-Averaging: Calculates the F1 score for each class
independently and then takes the average, weighted by the number of true
instances for each class. This accounts for class imbalance by giving
more weight to classes with more instances.</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="callout-on-including-ood-data-in-f1-calculation">Callout on including OOD data in F1 calculation<a class="anchor" aria-label="anchor" href="#callout-on-including-ood-data-in-f1-calculation"></a>
</h3>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="co"># from sklearn.metrics import precision_recall_fscore_support, accuracy_score</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a><span class="kw">def</span> eval_softmax_thresholds(thresholds, ood_probs, id_probs):</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>    <span class="co"># Store evaluation metrics for each threshold</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>    precisions <span class="op">=</span> []</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a>    recalls <span class="op">=</span> []</span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>    f1_scores <span class="op">=</span> []</span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a>    </span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>    <span class="cf">for</span> threshold <span class="kw">in</span> thresholds:</span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a>        <span class="co"># Classifying OOD examples (sandals)</span></span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a>        ood_classifications <span class="op">=</span> softmax_thresh_classifications(ood_probs, threshold)</span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a>        </span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a>        <span class="co"># Classifying ID examples (T-shirts and pants)</span></span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a>        id_classifications <span class="op">=</span> softmax_thresh_classifications(id_probs, threshold)</span>
<span id="cb14-15"><a href="#cb14-15" tabindex="-1"></a>        </span>
<span id="cb14-16"><a href="#cb14-16" tabindex="-1"></a>        <span class="co"># Combine OOD and ID classifications and true labels</span></span>
<span id="cb14-17"><a href="#cb14-17" tabindex="-1"></a>        all_predictions <span class="op">=</span> np.concatenate([ood_classifications, id_classifications])</span>
<span id="cb14-18"><a href="#cb14-18" tabindex="-1"></a>        all_true_labels <span class="op">=</span> np.concatenate([<span class="op">-</span><span class="dv">1</span> <span class="op">*</span> np.ones(ood_classifications.shape), train_labels])</span>
<span id="cb14-19"><a href="#cb14-19" tabindex="-1"></a>        </span>
<span id="cb14-20"><a href="#cb14-20" tabindex="-1"></a>        <span class="co"># Evaluate metrics</span></span>
<span id="cb14-21"><a href="#cb14-21" tabindex="-1"></a>        precision, recall, f1, _ <span class="op">=</span> precision_recall_fscore_support(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>], average<span class="op">=</span><span class="st">'macro'</span>) <span class="co"># discuss macro vs micro .</span></span>
<span id="cb14-22"><a href="#cb14-22" tabindex="-1"></a>        precisions.append(precision)</span>
<span id="cb14-23"><a href="#cb14-23" tabindex="-1"></a>        recalls.append(recall)</span>
<span id="cb14-24"><a href="#cb14-24" tabindex="-1"></a>        f1_scores.append(f1)</span>
<span id="cb14-25"><a href="#cb14-25" tabindex="-1"></a>        </span>
<span id="cb14-26"><a href="#cb14-26" tabindex="-1"></a>    <span class="cf">return</span> precisions, recalls, f1_scores</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="co"># Define thresholds to evaluate</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>thresholds <span class="op">=</span> np.linspace(<span class="fl">.5</span>, <span class="dv">1</span>, <span class="dv">50</span>)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="co"># Evaluate on all thresholds</span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>precisions, recalls, f1_scores <span class="op">=</span> eval_softmax_thresholds(thresholds, ood_probs, id_probs)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="kw">def</span> plot_metrics_vs_thresholds(thresholds, f1_scores, precisions, recalls, OOD_signal):</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>    <span class="co"># Find the best thresholds for each metric</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>    best_f1_index <span class="op">=</span> np.argmax(f1_scores)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>    best_f1_threshold <span class="op">=</span> thresholds[best_f1_index]</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>    </span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a>    best_precision_index <span class="op">=</span> np.argmax(precisions)</span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a>    best_precision_threshold <span class="op">=</span> thresholds[best_precision_index]</span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a>    </span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a>    best_recall_index <span class="op">=</span> np.argmax(recalls)</span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a>    best_recall_threshold <span class="op">=</span> thresholds[best_recall_index]</span>
<span id="cb16-11"><a href="#cb16-11" tabindex="-1"></a>    </span>
<span id="cb16-12"><a href="#cb16-12" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best F1 threshold: </span><span class="sc">{</span>best_f1_threshold<span class="sc">}</span><span class="ss">, F1 Score: </span><span class="sc">{</span>f1_scores[best_f1_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-13"><a href="#cb16-13" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Precision threshold: </span><span class="sc">{</span>best_precision_threshold<span class="sc">}</span><span class="ss">, Precision: </span><span class="sc">{</span>precisions[best_precision_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-14"><a href="#cb16-14" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Recall threshold: </span><span class="sc">{</span>best_recall_threshold<span class="sc">}</span><span class="ss">, Recall: </span><span class="sc">{</span>recalls[best_recall_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-15"><a href="#cb16-15" tabindex="-1"></a></span>
<span id="cb16-16"><a href="#cb16-16" tabindex="-1"></a>    <span class="co"># Create a new figure</span></span>
<span id="cb16-17"><a href="#cb16-17" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb16-18"><a href="#cb16-18" tabindex="-1"></a></span>
<span id="cb16-19"><a href="#cb16-19" tabindex="-1"></a>    <span class="co"># Plot metrics as functions of the threshold</span></span>
<span id="cb16-20"><a href="#cb16-20" tabindex="-1"></a>    ax.plot(thresholds, precisions, label<span class="op">=</span><span class="st">'Precision'</span>, color<span class="op">=</span><span class="st">'g'</span>)</span>
<span id="cb16-21"><a href="#cb16-21" tabindex="-1"></a>    ax.plot(thresholds, recalls, label<span class="op">=</span><span class="st">'Recall'</span>, color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb16-22"><a href="#cb16-22" tabindex="-1"></a>    ax.plot(thresholds, f1_scores, label<span class="op">=</span><span class="st">'F1 Score'</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb16-23"><a href="#cb16-23" tabindex="-1"></a>    </span>
<span id="cb16-24"><a href="#cb16-24" tabindex="-1"></a>    <span class="co"># Add best threshold indicators</span></span>
<span id="cb16-25"><a href="#cb16-25" tabindex="-1"></a>    ax.axvline(x<span class="op">=</span>best_f1_threshold, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best F1 Threshold: </span><span class="sc">{</span>best_f1_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb16-26"><a href="#cb16-26" tabindex="-1"></a>    ax.axvline(x<span class="op">=</span>best_precision_threshold, color<span class="op">=</span><span class="st">'g'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best Precision Threshold: </span><span class="sc">{</span>best_precision_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb16-27"><a href="#cb16-27" tabindex="-1"></a>    ax.axvline(x<span class="op">=</span>best_recall_threshold, color<span class="op">=</span><span class="st">'b'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best Recall Threshold: </span><span class="sc">{</span>best_recall_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb16-28"><a href="#cb16-28" tabindex="-1"></a>    ax.set_xlabel(<span class="ss">f'</span><span class="sc">{</span>OOD_signal<span class="sc">}</span><span class="ss"> Threshold'</span>)</span>
<span id="cb16-29"><a href="#cb16-29" tabindex="-1"></a>    ax.set_ylabel(<span class="st">'Metric Value'</span>)</span>
<span id="cb16-30"><a href="#cb16-30" tabindex="-1"></a>    ax.set_title(<span class="st">'Evaluation Metrics as Functions of Threshold'</span>)</span>
<span id="cb16-31"><a href="#cb16-31" tabindex="-1"></a>    ax.legend()</span>
<span id="cb16-32"><a href="#cb16-32" tabindex="-1"></a></span>
<span id="cb16-33"><a href="#cb16-33" tabindex="-1"></a>    <span class="cf">return</span> fig, best_f1_threshold, best_precision_threshold, best_recall_threshold</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>fig, best_f1_threshold, best_precision_threshold, best_recall_threshold <span class="op">=</span> plot_metrics_vs_thresholds(thresholds, f1_scores, precisions, recalls, <span class="st">'Softmax'</span>)</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>fig.savefig(<span class="st">'../images/OOD-detection_metrics_vs_softmax-thresholds.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span></code></pre>
</div>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-detection_metrics_vs_softmax-thresholds.png" alt="OOD-detection_metrics_vs_softmax-thresholds" class="figure mx-auto d-block"><div class="figcaption">OOD-detection_metrics_vs_softmax-thresholds</div>
</figure><div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="co"># Threshold values</span></span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>upper_threshold <span class="op">=</span> best_f1_threshold</span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a><span class="co"># upper_threshold = best_precision_threshold</span></span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a><span class="co"># Classifying OOD examples (sandals)</span></span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a>ood_classifications <span class="op">=</span> softmax_thresh_classifications(ood_probs, upper_threshold)</span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a><span class="co"># Classifying ID examples (T-shirts and pants)</span></span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a>id_classifications <span class="op">=</span> softmax_thresh_classifications(id_probs, upper_threshold)</span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" tabindex="-1"></a><span class="co"># Combine OOD and ID classifications and true labels</span></span>
<span id="cb18-12"><a href="#cb18-12" tabindex="-1"></a>all_predictions <span class="op">=</span> np.concatenate([ood_classifications, id_classifications])</span>
<span id="cb18-13"><a href="#cb18-13" tabindex="-1"></a>all_true_labels <span class="op">=</span> np.concatenate([<span class="op">-</span><span class="dv">1</span> <span class="op">*</span> np.ones(ood_classifications.shape), train_labels])</span>
<span id="cb18-14"><a href="#cb18-14" tabindex="-1"></a></span>
<span id="cb18-15"><a href="#cb18-15" tabindex="-1"></a><span class="co"># Confusion matrix</span></span>
<span id="cb18-16"><a href="#cb18-16" tabindex="-1"></a>cm <span class="op">=</span> confusion_matrix(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb18-17"><a href="#cb18-17" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" tabindex="-1"></a><span class="co"># Plotting the confusion matrix</span></span>
<span id="cb18-19"><a href="#cb18-19" tabindex="-1"></a>disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>cm, display_labels<span class="op">=</span>[<span class="st">"Shirt"</span>, <span class="st">"Pants"</span>, <span class="st">"OOD"</span>])</span>
<span id="cb18-20"><a href="#cb18-20" tabindex="-1"></a>disp.plot(cmap<span class="op">=</span>plt.cm.Blues)</span>
<span id="cb18-21"><a href="#cb18-21" tabindex="-1"></a>plt.title(<span class="st">'Confusion Matrix for OOD and ID Classification'</span>)</span>
<span id="cb18-22"><a href="#cb18-22" tabindex="-1"></a>plt.savefig(<span class="st">'../images/OOD-detection_ID-OOD-confusion-matrix2.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb18-23"><a href="#cb18-23" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/OOD-detection_ID-OOD-confusion-matrix2.png" alt="Optimized threshold confusion matrix" class="figure mx-auto d-block"><div class="figcaption">Optimized threshold confusion matrix</div>
</figure>
</div>
</div>
</div>
<div class="section level1">
<h1 id="example-2-energy-based-ood-detection">Example 2: Energy-Based OOD Detection<a class="anchor" aria-label="anchor" href="#example-2-energy-based-ood-detection"></a>
</h1>
<p><strong>TODO</strong>: Provide background and intuiiton surrounding
energy-based measure. Some notes below:</p>
<p>Liu et al., Energy-based Out-of-distribution Detection, NeurIPS 2020;
<a href="https://arxiv.org/pdf/2010.03759" class="external-link uri">https://arxiv.org/pdf/2010.03759</a></p>
<ul>
<li><p>E(x, y) = energy value</p></li>
<li><p>if x and y are “compatitble”, lower energy</p></li>
<li>
<p>Energy can be turned into probability through Gibbs
distribution</p>
<ul>
<li>looks at integral over all possible y’s</li>
</ul>
</li>
<li><p>With energy scores, ID and OOD distributions become much more
separable</p></li>
<li><p>Another “output-based” method like softmax</p></li>
<li><p>I believe this measure is explicitly designed to work with neural
nets, but may (?) work with other models</p></li>
</ul>
<div class="section level2">
<h2 id="introducing-pytorch-ood">Introducing PyTorch OOD<a class="anchor" aria-label="anchor" href="#introducing-pytorch-ood"></a>
</h2>
<p>The PyTorch-OOD library provides methods for OOD detection and other
closely related fields, such as anomoly detection or novelty detection.
Visit the docs to learn more: <a href="https://pytorch-ood.readthedocs.io/en/latest/info.html" class="external-link">pytorch-ood.readthedocs.io/en/latest/info.html</a></p>
<p>This library will provide a streamlined way to calculate both energy
and softmax scores from a trained model. ### Setup example In this
example, we will train a CNN model on the FashionMNIST dataset. We will
then repeat a similar process as we did with softmax scores to evaluate
how well the energy metric can separate ID and OOD data.</p>
<p>We’ll start by fresh by loading our data again. This time, let’s
treat all remaining classes in the MNIST fashion dataset as OOD. This
should yield a more robust model that is more reliable when presented
with all kinds of data.</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>train_data, test_data, ood_data, train_labels, test_labels, ood_labels <span class="op">=</span> prep_ID_OOD_datasests([<span class="dv">0</span>,<span class="dv">1</span>], <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">2</span>,<span class="dv">10</span>))) <span class="co"># use remaining 8 classes in dataset as OOD</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>fig <span class="op">=</span> plot_data_sample(train_data, ood_data)</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a>fig.savefig(<span class="st">'../images/OOD-detection_image-data-preview.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
</div>
<div class="section level2">
<h2 id="visualizing-ood-and-id-data-1">Visualizing OOD and ID data<a class="anchor" aria-label="anchor" href="#visualizing-ood-and-id-data-1"></a>
</h2>
<div class="section level3">
<h3 id="umap-or-similar">UMAP (or similar)<a class="anchor" aria-label="anchor" href="#umap-or-similar"></a>
</h3>
<p>Recall in our previous example, we used PCA to visualize the ID and
OOD data distributions. This was appropriate given that we were
evaluating OOD/ID data in the context of a linear model. However, when
working with nonlinear models such as CNNs, it makes more sense to
investigate how the data is represented in a nonlinear space. Nonlinear
embedding methods, such as Uniform Manifold Approximation and Projection
(UMAP), are more suitable in such scenarios.</p>
<p>UMAP is a non-linear dimensionality reduction technique that
preserves both the global structure and the local neighborhood
relationships in the data. UMAP is often better at maintaining the
continuity of data points that lie on non-linear manifolds. It can
reveal nonlinear patterns and structures that PCA might miss, making it
a valuable tool for analyzing ID and OOD distributions.</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>plot_umap <span class="op">=</span> <span class="va">True</span> <span class="co"># leave off for now to save time testing downstream materials</span></span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a><span class="cf">if</span> plot_umap:</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a>    <span class="im">import</span> umap</span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>    <span class="co"># Flatten images for PCA and logistic regression</span></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a>    train_data_flat <span class="op">=</span> train_data.reshape((train_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a>    test_data_flat <span class="op">=</span> test_data.reshape((test_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a>    ood_data_flat <span class="op">=</span> ood_data.reshape((ood_data.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a>    </span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'train_data_flat.shape=</span><span class="sc">{</span>train_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'test_data_flat.shape=</span><span class="sc">{</span>test_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'ood_data_flat.shape=</span><span class="sc">{</span>ood_data_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a>    </span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a>    <span class="co"># Perform UMAP to visualize the data</span></span>
<span id="cb20-14"><a href="#cb20-14" tabindex="-1"></a>    umap_reducer <span class="op">=</span> umap.UMAP(n_components<span class="op">=</span><span class="dv">2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb20-15"><a href="#cb20-15" tabindex="-1"></a>    combined_data <span class="op">=</span> np.vstack([train_data_flat, ood_data_flat])</span>
<span id="cb20-16"><a href="#cb20-16" tabindex="-1"></a>    combined_labels <span class="op">=</span> np.hstack([train_labels, np.full(ood_data_flat.shape[<span class="dv">0</span>], <span class="dv">2</span>)])  <span class="co"># Use 2 for OOD class</span></span>
<span id="cb20-17"><a href="#cb20-17" tabindex="-1"></a>    </span>
<span id="cb20-18"><a href="#cb20-18" tabindex="-1"></a>    umap_results <span class="op">=</span> umap_reducer.fit_transform(combined_data)</span>
<span id="cb20-19"><a href="#cb20-19" tabindex="-1"></a>    </span>
<span id="cb20-20"><a href="#cb20-20" tabindex="-1"></a>    <span class="co"># Split the results back into in-distribution and OOD data</span></span>
<span id="cb20-21"><a href="#cb20-21" tabindex="-1"></a>    umap_in_dist <span class="op">=</span> umap_results[:<span class="bu">len</span>(train_data_flat)]</span>
<span id="cb20-22"><a href="#cb20-22" tabindex="-1"></a>    umap_ood <span class="op">=</span> umap_results[<span class="bu">len</span>(train_data_flat):]</span></code></pre>
</div>
<p>The warning message indicates that UMAP has overridden the n_jobs
parameter to 1 due to the random_state being set. This behavior ensures
reproducibility by using a single job. If you want to avoid the warning
and still use parallelism, you can remove the random_state parameter.
However, removing random_state will mean that the results might not be
reproducible.</p>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="cf">if</span> plot_umap:</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>    umap_alpha <span class="op">=</span> <span class="fl">.02</span></span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>    <span class="co"># Plotting UMAP components</span></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a>    </span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a>    <span class="co"># Plot in-distribution data</span></span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a>    scatter1 <span class="op">=</span> plt.scatter(umap_in_dist[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">0</span>], umap_in_dist[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'blue'</span>, label<span class="op">=</span><span class="st">'T-shirts (ID)'</span>, alpha<span class="op">=</span>umap_alpha)</span>
<span id="cb21-9"><a href="#cb21-9" tabindex="-1"></a>    scatter2 <span class="op">=</span> plt.scatter(umap_in_dist[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">0</span>], umap_in_dist[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'red'</span>, label<span class="op">=</span><span class="st">'Trousers (ID)'</span>, alpha<span class="op">=</span>umap_alpha)</span>
<span id="cb21-10"><a href="#cb21-10" tabindex="-1"></a>    </span>
<span id="cb21-11"><a href="#cb21-11" tabindex="-1"></a>    <span class="co"># Plot OOD data</span></span>
<span id="cb21-12"><a href="#cb21-12" tabindex="-1"></a>    scatter3 <span class="op">=</span> plt.scatter(umap_ood[:, <span class="dv">0</span>], umap_ood[:, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'green'</span>, label<span class="op">=</span><span class="st">'OOD'</span>, edgecolor<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb21-13"><a href="#cb21-13" tabindex="-1"></a>    </span>
<span id="cb21-14"><a href="#cb21-14" tabindex="-1"></a>    <span class="co"># Create a single legend for all classes</span></span>
<span id="cb21-15"><a href="#cb21-15" tabindex="-1"></a>    plt.legend(handles<span class="op">=</span>[scatter1, scatter2, scatter3], loc<span class="op">=</span><span class="st">"upper right"</span>)</span>
<span id="cb21-16"><a href="#cb21-16" tabindex="-1"></a>    plt.xlabel(<span class="st">'First UMAP Component'</span>)</span>
<span id="cb21-17"><a href="#cb21-17" tabindex="-1"></a>    plt.ylabel(<span class="st">'Second UMAP Component'</span>)</span>
<span id="cb21-18"><a href="#cb21-18" tabindex="-1"></a>    plt.title(<span class="st">'UMAP of In-Distribution and OOD Data'</span>)</span>
<span id="cb21-19"><a href="#cb21-19" tabindex="-1"></a>    plt.show()</span></code></pre>
</div>
</div>
</div>
<div class="section level2">
<h2 id="train-cnn">Train CNN<a class="anchor" aria-label="anchor" href="#train-cnn"></a>
</h2>
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim</span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a><span class="im">import</span> torchvision.transforms <span class="im">as</span> transforms</span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" tabindex="-1"></a><span class="co"># Convert to PyTorch tensors and normalize</span></span>
<span id="cb22-8"><a href="#cb22-8" tabindex="-1"></a>train_data_tensor <span class="op">=</span> torch.tensor(train_data, dtype<span class="op">=</span>torch.float32).unsqueeze(<span class="dv">1</span>) <span class="op">/</span> <span class="fl">255.0</span></span>
<span id="cb22-9"><a href="#cb22-9" tabindex="-1"></a>test_data_tensor <span class="op">=</span> torch.tensor(test_data, dtype<span class="op">=</span>torch.float32).unsqueeze(<span class="dv">1</span>) <span class="op">/</span> <span class="fl">255.0</span></span>
<span id="cb22-10"><a href="#cb22-10" tabindex="-1"></a>ood_data_tensor <span class="op">=</span> torch.tensor(ood_data, dtype<span class="op">=</span>torch.float32).unsqueeze(<span class="dv">1</span>) <span class="op">/</span> <span class="fl">255.0</span></span>
<span id="cb22-11"><a href="#cb22-11" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" tabindex="-1"></a>train_labels_tensor <span class="op">=</span> torch.tensor(train_labels, dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb22-13"><a href="#cb22-13" tabindex="-1"></a>test_labels_tensor <span class="op">=</span> torch.tensor(test_labels, dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb22-14"><a href="#cb22-14" tabindex="-1"></a></span>
<span id="cb22-15"><a href="#cb22-15" tabindex="-1"></a>train_dataset <span class="op">=</span> torch.utils.data.TensorDataset(train_data_tensor, train_labels_tensor)</span>
<span id="cb22-16"><a href="#cb22-16" tabindex="-1"></a>test_dataset <span class="op">=</span> torch.utils.data.TensorDataset(test_data_tensor, test_labels_tensor)</span>
<span id="cb22-17"><a href="#cb22-17" tabindex="-1"></a>ood_dataset <span class="op">=</span> torch.utils.data.TensorDataset(ood_data_tensor, torch.zeros(ood_data_tensor.shape[<span class="dv">0</span>], dtype<span class="op">=</span>torch.<span class="bu">long</span>))</span>
<span id="cb22-18"><a href="#cb22-18" tabindex="-1"></a></span>
<span id="cb22-19"><a href="#cb22-19" tabindex="-1"></a>train_loader <span class="op">=</span> torch.utils.data.DataLoader(train_dataset, batch_size<span class="op">=</span><span class="dv">64</span>, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb22-20"><a href="#cb22-20" tabindex="-1"></a>test_loader <span class="op">=</span> torch.utils.data.DataLoader(test_dataset, batch_size<span class="op">=</span><span class="dv">64</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb22-21"><a href="#cb22-21" tabindex="-1"></a>ood_loader <span class="op">=</span> torch.utils.data.DataLoader(ood_dataset, batch_size<span class="op">=</span><span class="dv">64</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb22-22"><a href="#cb22-22" tabindex="-1"></a></span>
<span id="cb22-23"><a href="#cb22-23" tabindex="-1"></a><span class="co"># Define a simple CNN model</span></span>
<span id="cb22-24"><a href="#cb22-24" tabindex="-1"></a><span class="kw">class</span> SimpleCNN(nn.Module):</span>
<span id="cb22-25"><a href="#cb22-25" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb22-26"><a href="#cb22-26" tabindex="-1"></a>        <span class="bu">super</span>(SimpleCNN, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb22-27"><a href="#cb22-27" tabindex="-1"></a>        <span class="va">self</span>.conv1 <span class="op">=</span> nn.Conv2d(<span class="dv">1</span>, <span class="dv">32</span>, kernel_size<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb22-28"><a href="#cb22-28" tabindex="-1"></a>        <span class="va">self</span>.conv2 <span class="op">=</span> nn.Conv2d(<span class="dv">32</span>, <span class="dv">64</span>, kernel_size<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb22-29"><a href="#cb22-29" tabindex="-1"></a>        <span class="va">self</span>.fc1 <span class="op">=</span> nn.Linear(<span class="dv">64</span><span class="op">*</span><span class="dv">5</span><span class="op">*</span><span class="dv">5</span>, <span class="dv">128</span>)  <span class="co"># Updated this line</span></span>
<span id="cb22-30"><a href="#cb22-30" tabindex="-1"></a>        <span class="va">self</span>.fc2 <span class="op">=</span> nn.Linear(<span class="dv">128</span>, <span class="dv">2</span>)</span>
<span id="cb22-31"><a href="#cb22-31" tabindex="-1"></a></span>
<span id="cb22-32"><a href="#cb22-32" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb22-33"><a href="#cb22-33" tabindex="-1"></a>        x <span class="op">=</span> F.relu(F.max_pool2d(<span class="va">self</span>.conv1(x), <span class="dv">2</span>))</span>
<span id="cb22-34"><a href="#cb22-34" tabindex="-1"></a>        x <span class="op">=</span> F.relu(F.max_pool2d(<span class="va">self</span>.conv2(x), <span class="dv">2</span>))</span>
<span id="cb22-35"><a href="#cb22-35" tabindex="-1"></a>        x <span class="op">=</span> x.view(<span class="op">-</span><span class="dv">1</span>, <span class="dv">64</span><span class="op">*</span><span class="dv">5</span><span class="op">*</span><span class="dv">5</span>)  <span class="co"># Updated this line</span></span>
<span id="cb22-36"><a href="#cb22-36" tabindex="-1"></a>        x <span class="op">=</span> F.relu(<span class="va">self</span>.fc1(x))</span>
<span id="cb22-37"><a href="#cb22-37" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.fc2(x)</span>
<span id="cb22-38"><a href="#cb22-38" tabindex="-1"></a>        <span class="cf">return</span> x</span>
<span id="cb22-39"><a href="#cb22-39" tabindex="-1"></a></span>
<span id="cb22-40"><a href="#cb22-40" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">'cuda'</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">'cpu'</span>)</span>
<span id="cb22-41"><a href="#cb22-41" tabindex="-1"></a>model <span class="op">=</span> SimpleCNN().to(device)</span>
<span id="cb22-42"><a href="#cb22-42" tabindex="-1"></a>criterion <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb22-43"><a href="#cb22-43" tabindex="-1"></a>optimizer <span class="op">=</span> optim.Adam(model.parameters(), lr<span class="op">=</span><span class="fl">0.001</span>)</span>
<span id="cb22-44"><a href="#cb22-44" tabindex="-1"></a></span>
<span id="cb22-45"><a href="#cb22-45" tabindex="-1"></a><span class="kw">def</span> train_model(model, train_loader, criterion, optimizer, epochs<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb22-46"><a href="#cb22-46" tabindex="-1"></a>    model.train()</span>
<span id="cb22-47"><a href="#cb22-47" tabindex="-1"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(epochs):</span>
<span id="cb22-48"><a href="#cb22-48" tabindex="-1"></a>        running_loss <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb22-49"><a href="#cb22-49" tabindex="-1"></a>        <span class="cf">for</span> inputs, labels <span class="kw">in</span> train_loader:</span>
<span id="cb22-50"><a href="#cb22-50" tabindex="-1"></a>            inputs, labels <span class="op">=</span> inputs.to(device), labels.to(device)</span>
<span id="cb22-51"><a href="#cb22-51" tabindex="-1"></a>            optimizer.zero_grad()</span>
<span id="cb22-52"><a href="#cb22-52" tabindex="-1"></a>            outputs <span class="op">=</span> model(inputs)</span>
<span id="cb22-53"><a href="#cb22-53" tabindex="-1"></a>            loss <span class="op">=</span> criterion(outputs, labels)</span>
<span id="cb22-54"><a href="#cb22-54" tabindex="-1"></a>            loss.backward()</span>
<span id="cb22-55"><a href="#cb22-55" tabindex="-1"></a>            optimizer.step()</span>
<span id="cb22-56"><a href="#cb22-56" tabindex="-1"></a>            running_loss <span class="op">+=</span> loss.item()</span>
<span id="cb22-57"><a href="#cb22-57" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f'Epoch </span><span class="sc">{</span>epoch<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">, Loss: </span><span class="sc">{</span>running_loss<span class="op">/</span><span class="bu">len</span>(train_loader)<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb22-58"><a href="#cb22-58" tabindex="-1"></a></span>
<span id="cb22-59"><a href="#cb22-59" tabindex="-1"></a>train_model(model, train_loader, criterion, optimizer)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> confusion_matrix, ConfusionMatrixDisplay</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a><span class="co"># Function to plot confusion matrix</span></span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a><span class="kw">def</span> plot_confusion_matrix(labels, predictions, title):</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a>    cm <span class="op">=</span> confusion_matrix(labels, predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>    disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>cm, display_labels<span class="op">=</span>[<span class="st">"T-shirt/top"</span>, <span class="st">"Trouser"</span>])</span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a>    disp.plot(cmap<span class="op">=</span>plt.cm.Blues)</span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a>    plt.title(title)</span>
<span id="cb23-9"><a href="#cb23-9" tabindex="-1"></a>    plt.show()</span>
<span id="cb23-10"><a href="#cb23-10" tabindex="-1"></a></span>
<span id="cb23-11"><a href="#cb23-11" tabindex="-1"></a><span class="co"># Function to evaluate model on a dataset</span></span>
<span id="cb23-12"><a href="#cb23-12" tabindex="-1"></a><span class="kw">def</span> evaluate_model(model, dataloader, device):</span>
<span id="cb23-13"><a href="#cb23-13" tabindex="-1"></a>    model.<span class="bu">eval</span>()</span>
<span id="cb23-14"><a href="#cb23-14" tabindex="-1"></a>    all_labels <span class="op">=</span> []</span>
<span id="cb23-15"><a href="#cb23-15" tabindex="-1"></a>    all_predictions <span class="op">=</span> []</span>
<span id="cb23-16"><a href="#cb23-16" tabindex="-1"></a>    <span class="cf">with</span> torch.no_grad():</span>
<span id="cb23-17"><a href="#cb23-17" tabindex="-1"></a>        <span class="cf">for</span> inputs, labels <span class="kw">in</span> dataloader:</span>
<span id="cb23-18"><a href="#cb23-18" tabindex="-1"></a>            inputs, labels <span class="op">=</span> inputs.to(device), labels.to(device)</span>
<span id="cb23-19"><a href="#cb23-19" tabindex="-1"></a>            outputs <span class="op">=</span> model(inputs)</span>
<span id="cb23-20"><a href="#cb23-20" tabindex="-1"></a>            _, preds <span class="op">=</span> torch.<span class="bu">max</span>(outputs, <span class="dv">1</span>)</span>
<span id="cb23-21"><a href="#cb23-21" tabindex="-1"></a>            all_labels.extend(labels.cpu().numpy())</span>
<span id="cb23-22"><a href="#cb23-22" tabindex="-1"></a>            all_predictions.extend(preds.cpu().numpy())</span>
<span id="cb23-23"><a href="#cb23-23" tabindex="-1"></a>    <span class="cf">return</span> np.array(all_labels), np.array(all_predictions)</span>
<span id="cb23-24"><a href="#cb23-24" tabindex="-1"></a></span>
<span id="cb23-25"><a href="#cb23-25" tabindex="-1"></a><span class="co"># Evaluate on train data</span></span>
<span id="cb23-26"><a href="#cb23-26" tabindex="-1"></a>train_labels, train_predictions <span class="op">=</span> evaluate_model(model, train_loader, device)</span>
<span id="cb23-27"><a href="#cb23-27" tabindex="-1"></a>plot_confusion_matrix(train_labels, train_predictions, <span class="st">"Confusion Matrix for Train Data"</span>)</span>
<span id="cb23-28"><a href="#cb23-28" tabindex="-1"></a></span>
<span id="cb23-29"><a href="#cb23-29" tabindex="-1"></a><span class="co"># Evaluate on test data</span></span>
<span id="cb23-30"><a href="#cb23-30" tabindex="-1"></a>test_labels, test_predictions <span class="op">=</span> evaluate_model(model, test_loader, device)</span>
<span id="cb23-31"><a href="#cb23-31" tabindex="-1"></a>plot_confusion_matrix(test_labels, test_predictions, <span class="st">"Confusion Matrix for Test Data"</span>)</span>
<span id="cb23-32"><a href="#cb23-32" tabindex="-1"></a></span>
<span id="cb23-33"><a href="#cb23-33" tabindex="-1"></a><span class="co"># Evaluate on OOD data</span></span>
<span id="cb23-34"><a href="#cb23-34" tabindex="-1"></a>ood_labels, ood_predictions <span class="op">=</span> evaluate_model(model, ood_loader, device)</span>
<span id="cb23-35"><a href="#cb23-35" tabindex="-1"></a>plot_confusion_matrix(ood_labels, ood_predictions, <span class="st">"Confusion Matrix for OOD Data"</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb24">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> gaussian_kde</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a><span class="im">from</span> pytorch_ood.detector <span class="im">import</span> EnergyBased</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> precision_recall_fscore_support, accuracy_score</span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a><span class="co"># Compute softmax scores</span></span>
<span id="cb24-6"><a href="#cb24-6" tabindex="-1"></a><span class="kw">def</span> get_softmax_scores(model, dataloader):</span>
<span id="cb24-7"><a href="#cb24-7" tabindex="-1"></a>    model.<span class="bu">eval</span>()</span>
<span id="cb24-8"><a href="#cb24-8" tabindex="-1"></a>    softmax_scores <span class="op">=</span> []</span>
<span id="cb24-9"><a href="#cb24-9" tabindex="-1"></a>    <span class="cf">with</span> torch.no_grad():</span>
<span id="cb24-10"><a href="#cb24-10" tabindex="-1"></a>        <span class="cf">for</span> inputs, _ <span class="kw">in</span> dataloader:</span>
<span id="cb24-11"><a href="#cb24-11" tabindex="-1"></a>            inputs <span class="op">=</span> inputs.to(device)</span>
<span id="cb24-12"><a href="#cb24-12" tabindex="-1"></a>            outputs <span class="op">=</span> model(inputs)</span>
<span id="cb24-13"><a href="#cb24-13" tabindex="-1"></a>            softmax <span class="op">=</span> torch.nn.functional.softmax(outputs, dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb24-14"><a href="#cb24-14" tabindex="-1"></a>            softmax_scores.extend(softmax.cpu().numpy())</span>
<span id="cb24-15"><a href="#cb24-15" tabindex="-1"></a>    <span class="cf">return</span> np.array(softmax_scores)</span>
<span id="cb24-16"><a href="#cb24-16" tabindex="-1"></a></span>
<span id="cb24-17"><a href="#cb24-17" tabindex="-1"></a>id_softmax_scores <span class="op">=</span> get_softmax_scores(model, test_loader)</span>
<span id="cb24-18"><a href="#cb24-18" tabindex="-1"></a>ood_softmax_scores <span class="op">=</span> get_softmax_scores(model, ood_loader)</span>
<span id="cb24-19"><a href="#cb24-19" tabindex="-1"></a></span>
<span id="cb24-20"><a href="#cb24-20" tabindex="-1"></a><span class="co"># Initialize the energy-based OOD detector</span></span>
<span id="cb24-21"><a href="#cb24-21" tabindex="-1"></a>energy_detector <span class="op">=</span> EnergyBased(model, t<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb24-22"><a href="#cb24-22" tabindex="-1"></a></span>
<span id="cb24-23"><a href="#cb24-23" tabindex="-1"></a><span class="co"># Compute energy scores</span></span>
<span id="cb24-24"><a href="#cb24-24" tabindex="-1"></a><span class="kw">def</span> get_energy_scores(detector, dataloader):</span>
<span id="cb24-25"><a href="#cb24-25" tabindex="-1"></a>    scores <span class="op">=</span> []</span>
<span id="cb24-26"><a href="#cb24-26" tabindex="-1"></a>    detector.model.<span class="bu">eval</span>()</span>
<span id="cb24-27"><a href="#cb24-27" tabindex="-1"></a>    <span class="cf">with</span> torch.no_grad():</span>
<span id="cb24-28"><a href="#cb24-28" tabindex="-1"></a>        <span class="cf">for</span> inputs, _ <span class="kw">in</span> dataloader:</span>
<span id="cb24-29"><a href="#cb24-29" tabindex="-1"></a>            inputs <span class="op">=</span> inputs.to(device)</span>
<span id="cb24-30"><a href="#cb24-30" tabindex="-1"></a>            score <span class="op">=</span> detector.predict(inputs)</span>
<span id="cb24-31"><a href="#cb24-31" tabindex="-1"></a>            scores.extend(score.cpu().numpy())</span>
<span id="cb24-32"><a href="#cb24-32" tabindex="-1"></a>    <span class="cf">return</span> np.array(scores)</span>
<span id="cb24-33"><a href="#cb24-33" tabindex="-1"></a></span>
<span id="cb24-34"><a href="#cb24-34" tabindex="-1"></a>id_energy_scores <span class="op">=</span> get_energy_scores(energy_detector, test_loader)</span>
<span id="cb24-35"><a href="#cb24-35" tabindex="-1"></a>ood_energy_scores <span class="op">=</span> get_energy_scores(energy_detector, ood_loader)</span>
<span id="cb24-36"><a href="#cb24-36" tabindex="-1"></a></span>
<span id="cb24-37"><a href="#cb24-37" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb24-38"><a href="#cb24-38" tabindex="-1"></a></span>
<span id="cb24-39"><a href="#cb24-39" tabindex="-1"></a></span>
<span id="cb24-40"><a href="#cb24-40" tabindex="-1"></a><span class="co"># Plot PSDs</span></span>
<span id="cb24-41"><a href="#cb24-41" tabindex="-1"></a></span>
<span id="cb24-42"><a href="#cb24-42" tabindex="-1"></a><span class="co"># Function to plot PSD</span></span>
<span id="cb24-43"><a href="#cb24-43" tabindex="-1"></a><span class="kw">def</span> plot_psd(id_scores, ood_scores, method_name):</span>
<span id="cb24-44"><a href="#cb24-44" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb24-45"><a href="#cb24-45" tabindex="-1"></a>    alpha <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="cb24-46"><a href="#cb24-46" tabindex="-1"></a></span>
<span id="cb24-47"><a href="#cb24-47" tabindex="-1"></a>    <span class="co"># Plot PSD for ID scores</span></span>
<span id="cb24-48"><a href="#cb24-48" tabindex="-1"></a>    id_density <span class="op">=</span> gaussian_kde(id_scores)</span>
<span id="cb24-49"><a href="#cb24-49" tabindex="-1"></a>    x_id <span class="op">=</span> np.linspace(id_scores.<span class="bu">min</span>(), id_scores.<span class="bu">max</span>(), <span class="dv">1000</span>)</span>
<span id="cb24-50"><a href="#cb24-50" tabindex="-1"></a>    plt.plot(x_id, id_density(x_id), label<span class="op">=</span><span class="ss">f'ID (</span><span class="sc">{</span>method_name<span class="sc">}</span><span class="ss">)'</span>, color<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb24-51"><a href="#cb24-51" tabindex="-1"></a></span>
<span id="cb24-52"><a href="#cb24-52" tabindex="-1"></a>    <span class="co"># Plot PSD for OOD scores</span></span>
<span id="cb24-53"><a href="#cb24-53" tabindex="-1"></a>    ood_density <span class="op">=</span> gaussian_kde(ood_scores)</span>
<span id="cb24-54"><a href="#cb24-54" tabindex="-1"></a>    x_ood <span class="op">=</span> np.linspace(ood_scores.<span class="bu">min</span>(), ood_scores.<span class="bu">max</span>(), <span class="dv">1000</span>)</span>
<span id="cb24-55"><a href="#cb24-55" tabindex="-1"></a>    plt.plot(x_ood, ood_density(x_ood), label<span class="op">=</span><span class="ss">f'OOD (</span><span class="sc">{</span>method_name<span class="sc">}</span><span class="ss">)'</span>, color<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span>alpha)</span>
<span id="cb24-56"><a href="#cb24-56" tabindex="-1"></a></span>
<span id="cb24-57"><a href="#cb24-57" tabindex="-1"></a>    plt.xlabel(<span class="st">'Score'</span>)</span>
<span id="cb24-58"><a href="#cb24-58" tabindex="-1"></a>    plt.ylabel(<span class="st">'Density'</span>)</span>
<span id="cb24-59"><a href="#cb24-59" tabindex="-1"></a>    plt.title(<span class="ss">f'Probability Density Distributions for </span><span class="sc">{</span>method_name<span class="sc">}</span><span class="ss"> Scores'</span>)</span>
<span id="cb24-60"><a href="#cb24-60" tabindex="-1"></a>    plt.legend()</span>
<span id="cb24-61"><a href="#cb24-61" tabindex="-1"></a>    plt.show()</span>
<span id="cb24-62"><a href="#cb24-62" tabindex="-1"></a></span>
<span id="cb24-63"><a href="#cb24-63" tabindex="-1"></a><span class="co"># Plot PSD for softmax scores</span></span>
<span id="cb24-64"><a href="#cb24-64" tabindex="-1"></a>plot_psd(id_softmax_scores[:, <span class="dv">1</span>], ood_softmax_scores[:, <span class="dv">1</span>], <span class="st">'Softmax'</span>)</span>
<span id="cb24-65"><a href="#cb24-65" tabindex="-1"></a></span>
<span id="cb24-66"><a href="#cb24-66" tabindex="-1"></a><span class="co"># Plot PSD for energy scores</span></span>
<span id="cb24-67"><a href="#cb24-67" tabindex="-1"></a>plot_psd(id_energy_scores, ood_energy_scores, <span class="st">'Energy'</span>)</span>
<span id="cb24-68"><a href="#cb24-68" tabindex="-1"></a></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> precision_recall_fscore_support, accuracy_score, confusion_matrix, ConfusionMatrixDisplay</span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a><span class="co"># Define thresholds to evaluate</span></span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a>thresholds <span class="op">=</span> np.linspace(id_energy_scores.<span class="bu">min</span>(), id_energy_scores.<span class="bu">max</span>(), <span class="dv">50</span>)</span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" tabindex="-1"></a><span class="co"># Store evaluation metrics for each threshold</span></span>
<span id="cb25-9"><a href="#cb25-9" tabindex="-1"></a>accuracies <span class="op">=</span> []</span>
<span id="cb25-10"><a href="#cb25-10" tabindex="-1"></a>precisions <span class="op">=</span> []</span>
<span id="cb25-11"><a href="#cb25-11" tabindex="-1"></a>recalls <span class="op">=</span> []</span>
<span id="cb25-12"><a href="#cb25-12" tabindex="-1"></a>f1_scores <span class="op">=</span> []</span>
<span id="cb25-13"><a href="#cb25-13" tabindex="-1"></a></span>
<span id="cb25-14"><a href="#cb25-14" tabindex="-1"></a><span class="co"># True labels for OOD data (since they are not part of the original labels)</span></span>
<span id="cb25-15"><a href="#cb25-15" tabindex="-1"></a>ood_true_labels <span class="op">=</span> np.full(<span class="bu">len</span>(ood_energy_scores), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb25-16"><a href="#cb25-16" tabindex="-1"></a></span>
<span id="cb25-17"><a href="#cb25-17" tabindex="-1"></a><span class="co"># We need the test_labels to be aligned with the ID data</span></span>
<span id="cb25-18"><a href="#cb25-18" tabindex="-1"></a>id_true_labels <span class="op">=</span> test_labels[:<span class="bu">len</span>(id_energy_scores)]</span>
<span id="cb25-19"><a href="#cb25-19" tabindex="-1"></a></span>
<span id="cb25-20"><a href="#cb25-20" tabindex="-1"></a><span class="cf">for</span> threshold <span class="kw">in</span> thresholds:</span>
<span id="cb25-21"><a href="#cb25-21" tabindex="-1"></a>    <span class="co"># Classify OOD examples based on energy scores</span></span>
<span id="cb25-22"><a href="#cb25-22" tabindex="-1"></a>    ood_classifications <span class="op">=</span> np.where(ood_energy_scores <span class="op">&gt;=</span> threshold, <span class="op">-</span><span class="dv">1</span>,  <span class="co"># classified as OOD</span></span>
<span id="cb25-23"><a href="#cb25-23" tabindex="-1"></a>                                   np.where(ood_energy_scores <span class="op">&lt;</span> threshold, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>))  <span class="co"># classified as ID</span></span>
<span id="cb25-24"><a href="#cb25-24" tabindex="-1"></a></span>
<span id="cb25-25"><a href="#cb25-25" tabindex="-1"></a>    <span class="co"># Classify ID examples based on energy scores</span></span>
<span id="cb25-26"><a href="#cb25-26" tabindex="-1"></a>    id_classifications <span class="op">=</span> np.where(id_energy_scores <span class="op">&gt;=</span> threshold, <span class="op">-</span><span class="dv">1</span>,  <span class="co"># classified as OOD</span></span>
<span id="cb25-27"><a href="#cb25-27" tabindex="-1"></a>                                  np.where(id_energy_scores <span class="op">&lt;</span> threshold, id_true_labels, <span class="op">-</span><span class="dv">1</span>))  <span class="co"># classified as ID</span></span>
<span id="cb25-28"><a href="#cb25-28" tabindex="-1"></a></span>
<span id="cb25-29"><a href="#cb25-29" tabindex="-1"></a>    <span class="co"># Combine OOD and ID classifications and true labels</span></span>
<span id="cb25-30"><a href="#cb25-30" tabindex="-1"></a>    all_predictions <span class="op">=</span> np.concatenate([ood_classifications, id_classifications])</span>
<span id="cb25-31"><a href="#cb25-31" tabindex="-1"></a>    all_true_labels <span class="op">=</span> np.concatenate([ood_true_labels, id_true_labels])</span>
<span id="cb25-32"><a href="#cb25-32" tabindex="-1"></a></span>
<span id="cb25-33"><a href="#cb25-33" tabindex="-1"></a>    <span class="co"># Evaluate metrics</span></span>
<span id="cb25-34"><a href="#cb25-34" tabindex="-1"></a>    precision, recall, f1, _ <span class="op">=</span> precision_recall_fscore_support(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>], average<span class="op">=</span><span class="st">'macro'</span>)<span class="co">#, zero_division=0)</span></span>
<span id="cb25-35"><a href="#cb25-35" tabindex="-1"></a>    accuracy <span class="op">=</span> accuracy_score(all_true_labels, all_predictions)</span>
<span id="cb25-36"><a href="#cb25-36" tabindex="-1"></a></span>
<span id="cb25-37"><a href="#cb25-37" tabindex="-1"></a>    accuracies.append(accuracy)</span>
<span id="cb25-38"><a href="#cb25-38" tabindex="-1"></a>    precisions.append(precision)</span>
<span id="cb25-39"><a href="#cb25-39" tabindex="-1"></a>    recalls.append(recall)</span>
<span id="cb25-40"><a href="#cb25-40" tabindex="-1"></a>    f1_scores.append(f1)</span>
<span id="cb25-41"><a href="#cb25-41" tabindex="-1"></a></span>
<span id="cb25-42"><a href="#cb25-42" tabindex="-1"></a><span class="co"># Find the best thresholds for each metric</span></span>
<span id="cb25-43"><a href="#cb25-43" tabindex="-1"></a>best_f1_index <span class="op">=</span> np.argmax(f1_scores)</span>
<span id="cb25-44"><a href="#cb25-44" tabindex="-1"></a>best_f1_threshold <span class="op">=</span> thresholds[best_f1_index]</span>
<span id="cb25-45"><a href="#cb25-45" tabindex="-1"></a></span>
<span id="cb25-46"><a href="#cb25-46" tabindex="-1"></a>best_precision_index <span class="op">=</span> np.argmax(precisions)</span>
<span id="cb25-47"><a href="#cb25-47" tabindex="-1"></a>best_precision_threshold <span class="op">=</span> thresholds[best_precision_index]</span>
<span id="cb25-48"><a href="#cb25-48" tabindex="-1"></a></span>
<span id="cb25-49"><a href="#cb25-49" tabindex="-1"></a>best_recall_index <span class="op">=</span> np.argmax(recalls)</span>
<span id="cb25-50"><a href="#cb25-50" tabindex="-1"></a>best_recall_threshold <span class="op">=</span> thresholds[best_recall_index]</span>
<span id="cb25-51"><a href="#cb25-51" tabindex="-1"></a></span>
<span id="cb25-52"><a href="#cb25-52" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Best F1 threshold: </span><span class="sc">{</span>best_f1_threshold<span class="sc">}</span><span class="ss">, F1 Score: </span><span class="sc">{</span>f1_scores[best_f1_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-53"><a href="#cb25-53" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Best Precision threshold: </span><span class="sc">{</span>best_precision_threshold<span class="sc">}</span><span class="ss">, Precision: </span><span class="sc">{</span>precisions[best_precision_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-54"><a href="#cb25-54" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Best Recall threshold: </span><span class="sc">{</span>best_recall_threshold<span class="sc">}</span><span class="ss">, Recall: </span><span class="sc">{</span>recalls[best_recall_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-55"><a href="#cb25-55" tabindex="-1"></a></span>
<span id="cb25-56"><a href="#cb25-56" tabindex="-1"></a><span class="co"># Plot metrics as functions of the threshold</span></span>
<span id="cb25-57"><a href="#cb25-57" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb25-58"><a href="#cb25-58" tabindex="-1"></a>plt.plot(thresholds, precisions, label<span class="op">=</span><span class="st">'Precision'</span>, color<span class="op">=</span><span class="st">'g'</span>)</span>
<span id="cb25-59"><a href="#cb25-59" tabindex="-1"></a>plt.plot(thresholds, recalls, label<span class="op">=</span><span class="st">'Recall'</span>, color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb25-60"><a href="#cb25-60" tabindex="-1"></a>plt.plot(thresholds, f1_scores, label<span class="op">=</span><span class="st">'F1 Score'</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb25-61"><a href="#cb25-61" tabindex="-1"></a></span>
<span id="cb25-62"><a href="#cb25-62" tabindex="-1"></a><span class="co"># Add best threshold indicators</span></span>
<span id="cb25-63"><a href="#cb25-63" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>best_f1_threshold, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best F1 Threshold: </span><span class="sc">{</span>best_f1_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb25-64"><a href="#cb25-64" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>best_precision_threshold, color<span class="op">=</span><span class="st">'g'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best Precision Threshold: </span><span class="sc">{</span>best_precision_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb25-65"><a href="#cb25-65" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>best_recall_threshold, color<span class="op">=</span><span class="st">'b'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best Recall Threshold: </span><span class="sc">{</span>best_recall_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb25-66"><a href="#cb25-66" tabindex="-1"></a></span>
<span id="cb25-67"><a href="#cb25-67" tabindex="-1"></a>plt.xlabel(<span class="st">'Threshold'</span>)</span>
<span id="cb25-68"><a href="#cb25-68" tabindex="-1"></a>plt.ylabel(<span class="st">'Metric Value'</span>)</span>
<span id="cb25-69"><a href="#cb25-69" tabindex="-1"></a>plt.title(<span class="st">'Evaluation Metrics as Functions of Threshold (Energy-Based OOD Detection)'</span>)</span>
<span id="cb25-70"><a href="#cb25-70" tabindex="-1"></a>plt.legend()</span>
<span id="cb25-71"><a href="#cb25-71" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb26">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a></span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> precision_recall_fscore_support, accuracy_score, confusion_matrix, ConfusionMatrixDisplay</span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb26-7"><a href="#cb26-7" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb26-8"><a href="#cb26-8" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> precision_recall_fscore_support, accuracy_score</span>
<span id="cb26-9"><a href="#cb26-9" tabindex="-1"></a></span>
<span id="cb26-10"><a href="#cb26-10" tabindex="-1"></a><span class="kw">def</span> evaluate_ood_detection(id_scores, ood_scores, id_true_labels, id_predictions, ood_predictions, score_type<span class="op">=</span><span class="st">'energy'</span>):</span>
<span id="cb26-11"><a href="#cb26-11" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb26-12"><a href="#cb26-12" tabindex="-1"></a><span class="co">    Evaluate OOD detection based on either energy scores or softmax scores.</span></span>
<span id="cb26-13"><a href="#cb26-13" tabindex="-1"></a></span>
<span id="cb26-14"><a href="#cb26-14" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb26-15"><a href="#cb26-15" tabindex="-1"></a><span class="co">    - id_scores: np.array, scores for in-distribution (ID) data</span></span>
<span id="cb26-16"><a href="#cb26-16" tabindex="-1"></a><span class="co">    - ood_scores: np.array, scores for out-of-distribution (OOD) data</span></span>
<span id="cb26-17"><a href="#cb26-17" tabindex="-1"></a><span class="co">    - id_true_labels: np.array, true labels for ID data</span></span>
<span id="cb26-18"><a href="#cb26-18" tabindex="-1"></a><span class="co">    - id_predictions: np.array, predicted labels for ID data</span></span>
<span id="cb26-19"><a href="#cb26-19" tabindex="-1"></a><span class="co">    - ood_predictions: np.array, predicted labels for OOD data</span></span>
<span id="cb26-20"><a href="#cb26-20" tabindex="-1"></a><span class="co">    - score_type: str, type of score used ('energy' or 'softmax')</span></span>
<span id="cb26-21"><a href="#cb26-21" tabindex="-1"></a></span>
<span id="cb26-22"><a href="#cb26-22" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb26-23"><a href="#cb26-23" tabindex="-1"></a><span class="co">    - Best thresholds for F1, Precision, and Recall</span></span>
<span id="cb26-24"><a href="#cb26-24" tabindex="-1"></a><span class="co">    - Plots of Precision, Recall, and F1 Score as functions of the threshold</span></span>
<span id="cb26-25"><a href="#cb26-25" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb26-26"><a href="#cb26-26" tabindex="-1"></a>    <span class="co"># Define thresholds to evaluate</span></span>
<span id="cb26-27"><a href="#cb26-27" tabindex="-1"></a>    <span class="cf">if</span> score_type <span class="op">==</span> <span class="st">'softmax'</span>:</span>
<span id="cb26-28"><a href="#cb26-28" tabindex="-1"></a>        thresholds <span class="op">=</span> np.linspace(<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="dv">200</span>)</span>
<span id="cb26-29"><a href="#cb26-29" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb26-30"><a href="#cb26-30" tabindex="-1"></a>        thresholds <span class="op">=</span> np.linspace(id_scores.<span class="bu">min</span>(), id_scores.<span class="bu">max</span>(), <span class="dv">50</span>)</span>
<span id="cb26-31"><a href="#cb26-31" tabindex="-1"></a></span>
<span id="cb26-32"><a href="#cb26-32" tabindex="-1"></a>    <span class="co"># Store evaluation metrics for each threshold</span></span>
<span id="cb26-33"><a href="#cb26-33" tabindex="-1"></a>    accuracies <span class="op">=</span> []</span>
<span id="cb26-34"><a href="#cb26-34" tabindex="-1"></a>    precisions <span class="op">=</span> []</span>
<span id="cb26-35"><a href="#cb26-35" tabindex="-1"></a>    recalls <span class="op">=</span> []</span>
<span id="cb26-36"><a href="#cb26-36" tabindex="-1"></a>    f1_scores <span class="op">=</span> []</span>
<span id="cb26-37"><a href="#cb26-37" tabindex="-1"></a></span>
<span id="cb26-38"><a href="#cb26-38" tabindex="-1"></a>    <span class="co"># True labels for OOD data (since they are not part of the original labels)</span></span>
<span id="cb26-39"><a href="#cb26-39" tabindex="-1"></a>    <span class="cf">if</span> score_type <span class="op">==</span> <span class="st">"energy"</span>:</span>
<span id="cb26-40"><a href="#cb26-40" tabindex="-1"></a>        ood_true_labels <span class="op">=</span> np.full(<span class="bu">len</span>(ood_scores), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb26-41"><a href="#cb26-41" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb26-42"><a href="#cb26-42" tabindex="-1"></a>        ood_true_labels <span class="op">=</span> np.full(<span class="bu">len</span>(ood_scores[:,<span class="dv">0</span>]), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb26-43"><a href="#cb26-43" tabindex="-1"></a></span>
<span id="cb26-44"><a href="#cb26-44" tabindex="-1"></a>    <span class="cf">for</span> threshold <span class="kw">in</span> thresholds:</span>
<span id="cb26-45"><a href="#cb26-45" tabindex="-1"></a>        <span class="co"># Classify OOD examples based on scores</span></span>
<span id="cb26-46"><a href="#cb26-46" tabindex="-1"></a>        <span class="cf">if</span> score_type <span class="op">==</span> <span class="st">'energy'</span>:</span>
<span id="cb26-47"><a href="#cb26-47" tabindex="-1"></a>            ood_classifications <span class="op">=</span> np.where(ood_scores <span class="op">&gt;=</span> threshold, <span class="op">-</span><span class="dv">1</span>, ood_predictions)</span>
<span id="cb26-48"><a href="#cb26-48" tabindex="-1"></a>            id_classifications <span class="op">=</span> np.where(id_scores <span class="op">&gt;=</span> threshold, <span class="op">-</span><span class="dv">1</span>, id_predictions)</span>
<span id="cb26-49"><a href="#cb26-49" tabindex="-1"></a>        <span class="cf">elif</span> score_type <span class="op">==</span> <span class="st">'softmax'</span>:</span>
<span id="cb26-50"><a href="#cb26-50" tabindex="-1"></a>            ood_classifications <span class="op">=</span> np.where(ood_scores[:,<span class="dv">0</span>] <span class="op">&lt;=</span> threshold, <span class="op">-</span><span class="dv">1</span>, ood_predictions)</span>
<span id="cb26-51"><a href="#cb26-51" tabindex="-1"></a>            id_classifications <span class="op">=</span> np.where(id_scores[:,<span class="dv">0</span>] <span class="op">&lt;=</span> threshold, <span class="op">-</span><span class="dv">1</span>, id_predictions)</span>
<span id="cb26-52"><a href="#cb26-52" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb26-53"><a href="#cb26-53" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Invalid score_type. Use 'energy' or 'softmax'."</span>)</span>
<span id="cb26-54"><a href="#cb26-54" tabindex="-1"></a></span>
<span id="cb26-55"><a href="#cb26-55" tabindex="-1"></a>        <span class="co"># Combine OOD and ID classifications and true labels</span></span>
<span id="cb26-56"><a href="#cb26-56" tabindex="-1"></a>        all_predictions <span class="op">=</span> np.concatenate([ood_classifications, id_classifications])</span>
<span id="cb26-57"><a href="#cb26-57" tabindex="-1"></a>        all_true_labels <span class="op">=</span> np.concatenate([ood_true_labels, id_true_labels])</span>
<span id="cb26-58"><a href="#cb26-58" tabindex="-1"></a></span>
<span id="cb26-59"><a href="#cb26-59" tabindex="-1"></a>        <span class="co"># Evaluate metrics</span></span>
<span id="cb26-60"><a href="#cb26-60" tabindex="-1"></a>        precision, recall, f1, _ <span class="op">=</span> precision_recall_fscore_support(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>], average<span class="op">=</span><span class="st">'macro'</span>, zero_division<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb26-61"><a href="#cb26-61" tabindex="-1"></a>        accuracy <span class="op">=</span> accuracy_score(all_true_labels, all_predictions)</span>
<span id="cb26-62"><a href="#cb26-62" tabindex="-1"></a></span>
<span id="cb26-63"><a href="#cb26-63" tabindex="-1"></a>        accuracies.append(accuracy)</span>
<span id="cb26-64"><a href="#cb26-64" tabindex="-1"></a>        precisions.append(precision)</span>
<span id="cb26-65"><a href="#cb26-65" tabindex="-1"></a>        recalls.append(recall)</span>
<span id="cb26-66"><a href="#cb26-66" tabindex="-1"></a>        f1_scores.append(f1)</span>
<span id="cb26-67"><a href="#cb26-67" tabindex="-1"></a></span>
<span id="cb26-68"><a href="#cb26-68" tabindex="-1"></a>    <span class="co"># Find the best thresholds for each metric</span></span>
<span id="cb26-69"><a href="#cb26-69" tabindex="-1"></a>    best_f1_index <span class="op">=</span> np.argmax(f1_scores)</span>
<span id="cb26-70"><a href="#cb26-70" tabindex="-1"></a>    best_f1_threshold <span class="op">=</span> thresholds[best_f1_index]</span>
<span id="cb26-71"><a href="#cb26-71" tabindex="-1"></a></span>
<span id="cb26-72"><a href="#cb26-72" tabindex="-1"></a>    best_precision_index <span class="op">=</span> np.argmax(precisions)</span>
<span id="cb26-73"><a href="#cb26-73" tabindex="-1"></a>    best_precision_threshold <span class="op">=</span> thresholds[best_precision_index]</span>
<span id="cb26-74"><a href="#cb26-74" tabindex="-1"></a></span>
<span id="cb26-75"><a href="#cb26-75" tabindex="-1"></a>    best_recall_index <span class="op">=</span> np.argmax(recalls)</span>
<span id="cb26-76"><a href="#cb26-76" tabindex="-1"></a>    best_recall_threshold <span class="op">=</span> thresholds[best_recall_index]</span>
<span id="cb26-77"><a href="#cb26-77" tabindex="-1"></a></span>
<span id="cb26-78"><a href="#cb26-78" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best F1 threshold: </span><span class="sc">{</span>best_f1_threshold<span class="sc">}</span><span class="ss">, F1 Score: </span><span class="sc">{</span>f1_scores[best_f1_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-79"><a href="#cb26-79" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Precision threshold: </span><span class="sc">{</span>best_precision_threshold<span class="sc">}</span><span class="ss">, Precision: </span><span class="sc">{</span>precisions[best_precision_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-80"><a href="#cb26-80" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Best Recall threshold: </span><span class="sc">{</span>best_recall_threshold<span class="sc">}</span><span class="ss">, Recall: </span><span class="sc">{</span>recalls[best_recall_index]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-81"><a href="#cb26-81" tabindex="-1"></a></span>
<span id="cb26-82"><a href="#cb26-82" tabindex="-1"></a>    <span class="co"># Plot metrics as functions of the threshold</span></span>
<span id="cb26-83"><a href="#cb26-83" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb26-84"><a href="#cb26-84" tabindex="-1"></a>    plt.plot(thresholds, precisions, label<span class="op">=</span><span class="st">'Precision'</span>, color<span class="op">=</span><span class="st">'g'</span>)</span>
<span id="cb26-85"><a href="#cb26-85" tabindex="-1"></a>    plt.plot(thresholds, recalls, label<span class="op">=</span><span class="st">'Recall'</span>, color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb26-86"><a href="#cb26-86" tabindex="-1"></a>    plt.plot(thresholds, f1_scores, label<span class="op">=</span><span class="st">'F1 Score'</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb26-87"><a href="#cb26-87" tabindex="-1"></a></span>
<span id="cb26-88"><a href="#cb26-88" tabindex="-1"></a>    <span class="co"># Add best threshold indicators</span></span>
<span id="cb26-89"><a href="#cb26-89" tabindex="-1"></a>    plt.axvline(x<span class="op">=</span>best_f1_threshold, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best F1 Threshold: </span><span class="sc">{</span>best_f1_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb26-90"><a href="#cb26-90" tabindex="-1"></a>    plt.axvline(x<span class="op">=</span>best_precision_threshold, color<span class="op">=</span><span class="st">'g'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best Precision Threshold: </span><span class="sc">{</span>best_precision_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb26-91"><a href="#cb26-91" tabindex="-1"></a>    plt.axvline(x<span class="op">=</span>best_recall_threshold, color<span class="op">=</span><span class="st">'b'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Best Recall Threshold: </span><span class="sc">{</span>best_recall_threshold<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb26-92"><a href="#cb26-92" tabindex="-1"></a></span>
<span id="cb26-93"><a href="#cb26-93" tabindex="-1"></a>    plt.xlabel(<span class="st">'Threshold'</span>)</span>
<span id="cb26-94"><a href="#cb26-94" tabindex="-1"></a>    plt.ylabel(<span class="st">'Metric Value'</span>)</span>
<span id="cb26-95"><a href="#cb26-95" tabindex="-1"></a>    plt.title(<span class="ss">f'Evaluation Metrics as Functions of Threshold (</span><span class="sc">{</span>score_type<span class="sc">.</span>capitalize()<span class="sc">}</span><span class="ss">-Based OOD Detection)'</span>)</span>
<span id="cb26-96"><a href="#cb26-96" tabindex="-1"></a>    plt.legend()</span>
<span id="cb26-97"><a href="#cb26-97" tabindex="-1"></a>    plt.show()</span>
<span id="cb26-98"><a href="#cb26-98" tabindex="-1"></a></span>
<span id="cb26-99"><a href="#cb26-99" tabindex="-1"></a>    <span class="co"># plot confusion matrix</span></span>
<span id="cb26-100"><a href="#cb26-100" tabindex="-1"></a>    <span class="co"># Threshold value for the energy score</span></span>
<span id="cb26-101"><a href="#cb26-101" tabindex="-1"></a>    upper_threshold <span class="op">=</span> best_f1_threshold  <span class="co"># Using the best F1 threshold from the previous calculation</span></span>
<span id="cb26-102"><a href="#cb26-102" tabindex="-1"></a>    <span class="cf">if</span> score_type <span class="op">==</span> <span class="st">'energy'</span>:</span>
<span id="cb26-103"><a href="#cb26-103" tabindex="-1"></a>        <span class="co"># Classifying OOD examples based on energy scores</span></span>
<span id="cb26-104"><a href="#cb26-104" tabindex="-1"></a>        ood_classifications <span class="op">=</span> np.where(ood_energy_scores <span class="op">&gt;=</span> upper_threshold, <span class="op">-</span><span class="dv">1</span>,  <span class="co"># classified as OOD</span></span>
<span id="cb26-105"><a href="#cb26-105" tabindex="-1"></a>                                  np.where(ood_energy_scores <span class="op">&lt;</span> upper_threshold, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>))  <span class="co"># classified as ID</span></span>
<span id="cb26-106"><a href="#cb26-106" tabindex="-1"></a>        <span class="co"># Classifying ID examples based on energy scores</span></span>
<span id="cb26-107"><a href="#cb26-107" tabindex="-1"></a>        id_classifications <span class="op">=</span> np.where(id_energy_scores <span class="op">&gt;=</span> upper_threshold, <span class="op">-</span><span class="dv">1</span>,  <span class="co"># classified as OOD</span></span>
<span id="cb26-108"><a href="#cb26-108" tabindex="-1"></a>                                  np.where(id_energy_scores <span class="op">&lt;</span> upper_threshold, id_true_labels, <span class="op">-</span><span class="dv">1</span>))  <span class="co"># classified as ID</span></span>
<span id="cb26-109"><a href="#cb26-109" tabindex="-1"></a>    <span class="cf">elif</span> score_type <span class="op">==</span> <span class="st">'softmax'</span>:</span>
<span id="cb26-110"><a href="#cb26-110" tabindex="-1"></a>        <span class="co"># Classifying OOD examples based on softmax scores</span></span>
<span id="cb26-111"><a href="#cb26-111" tabindex="-1"></a>        ood_classifications <span class="op">=</span> softmax_thresh_classifications(ood_scores, upper_threshold)</span>
<span id="cb26-112"><a href="#cb26-112" tabindex="-1"></a></span>
<span id="cb26-113"><a href="#cb26-113" tabindex="-1"></a>        <span class="co"># Classifying ID examples based on softmax scores</span></span>
<span id="cb26-114"><a href="#cb26-114" tabindex="-1"></a>        id_classifications <span class="op">=</span> softmax_thresh_classifications(id_scores, upper_threshold)</span>
<span id="cb26-115"><a href="#cb26-115" tabindex="-1"></a>    <span class="co"># Combine OOD and ID classifications and true labels</span></span>
<span id="cb26-116"><a href="#cb26-116" tabindex="-1"></a>    all_predictions <span class="op">=</span> np.concatenate([ood_classifications, id_classifications])</span>
<span id="cb26-117"><a href="#cb26-117" tabindex="-1"></a>    all_true_labels <span class="op">=</span> np.concatenate([ood_true_labels, id_true_labels])</span>
<span id="cb26-118"><a href="#cb26-118" tabindex="-1"></a>    <span class="co"># Confusion matrix</span></span>
<span id="cb26-119"><a href="#cb26-119" tabindex="-1"></a>    cm <span class="op">=</span> confusion_matrix(all_true_labels, all_predictions, labels<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb26-120"><a href="#cb26-120" tabindex="-1"></a></span>
<span id="cb26-121"><a href="#cb26-121" tabindex="-1"></a>    <span class="co"># Plotting the confusion matrix</span></span>
<span id="cb26-122"><a href="#cb26-122" tabindex="-1"></a>    disp <span class="op">=</span> ConfusionMatrixDisplay(confusion_matrix<span class="op">=</span>cm, display_labels<span class="op">=</span>[<span class="st">"Shirt"</span>, <span class="st">"Pants"</span>, <span class="st">"OOD"</span>])</span>
<span id="cb26-123"><a href="#cb26-123" tabindex="-1"></a>    disp.plot(cmap<span class="op">=</span>plt.cm.Blues)</span>
<span id="cb26-124"><a href="#cb26-124" tabindex="-1"></a>    plt.title(<span class="ss">f'Confusion Matrix for OOD and ID Classification (</span><span class="sc">{</span>score_type<span class="sc">.</span>capitalize()<span class="sc">}</span><span class="ss">-Based)'</span>)</span>
<span id="cb26-125"><a href="#cb26-125" tabindex="-1"></a>    plt.show()</span>
<span id="cb26-126"><a href="#cb26-126" tabindex="-1"></a></span>
<span id="cb26-127"><a href="#cb26-127" tabindex="-1"></a></span>
<span id="cb26-128"><a href="#cb26-128" tabindex="-1"></a>    <span class="cf">return</span> best_f1_threshold, best_precision_threshold, best_recall_threshold</span>
<span id="cb26-129"><a href="#cb26-129" tabindex="-1"></a></span>
<span id="cb26-130"><a href="#cb26-130" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb26-131"><a href="#cb26-131" tabindex="-1"></a><span class="co"># Assuming id_energy_scores, ood_energy_scores, id_true_labels, and test_labels are already defined</span></span>
<span id="cb26-132"><a href="#cb26-132" tabindex="-1"></a>best_f1_threshold, best_precision_threshold, best_recall_threshold <span class="op">=</span> evaluate_ood_detection(id_energy_scores, ood_energy_scores, test_labels, test_predictions, ood_predictions, score_type<span class="op">=</span><span class="st">'energy'</span>)</span>
<span id="cb26-133"><a href="#cb26-133" tabindex="-1"></a>best_f1_threshold, best_precision_threshold, best_recall_threshold <span class="op">=</span> evaluate_ood_detection(id_softmax_scores, ood_softmax_scores, test_labels, test_predictions, ood_predictions, score_type<span class="op">=</span><span class="st">'softmax'</span>)</span></code></pre>
</div>
</div>
</div>
<div class="section level1">
<h1 id="limitations-of-our-approach-thus-far">Limitations of our approach thus far<a class="anchor" aria-label="anchor" href="#limitations-of-our-approach-thus-far"></a>
</h1>
<ul>
<li>Focus on single OOD class: More reliable/accurate thresholds
can/should be obtained using a wider variety (more classes) and larger
sample of OOD data. This is part of the challenge of OOD detection which
is that space of OOD data is vast. <strong>Possible exercise</strong>:
Redo thresholding using all remaining classes in dataset.</li>
</ul>
<div class="section level2">
<h2 id="references-and-supplemental-resources">References and supplemental resources<a class="anchor" aria-label="anchor" href="#references-and-supplemental-resources"></a>
</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=hgLC9_9ZCJI" class="external-link uri">https://www.youtube.com/watch?v=hgLC9_9ZCJI</a></li>
<li>Generalized Out-of-Distribution Detection: A Survey: <a href="https://arxiv.org/abs/2110.11334" class="external-link uri">https://arxiv.org/abs/2110.11334</a>
</li>
</ul>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div></section><section id="aio-7c-OOD-detection-distance-based"><p>Content from <a href="7c-OOD-detection-distance-based.html">OOD detection: distance-based</a></p>
<hr>
<p>Last updated on 2024-11-15 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/7c-OOD-detection-distance-based.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How do distance-based methods like Mahalanobis distance and KNN work
for OOD detection?</li>
<li>What is contrastive learning and how does it improve feature
representations?</li>
<li>How does contrastive learning enhance the effectiveness of
distance-based OOD detection methods?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Gain a thorough understanding of distance-based OOD detection
methods, including Mahalanobis distance and KNN.</li>
<li>Learn the principles of contrastive learning and its role in
improving feature representations.</li>
<li>Explore the synergy between contrastive learning and distance-based
OOD detection methods to enhance detection performance.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="example-3-distance-based-methods">Example 3: Distance-Based Methods<a class="anchor" aria-label="anchor" href="#example-3-distance-based-methods"></a>
</h1>
<p><em>Lee et al., A simple unified framework for detecting
out-of-distribution samples and adversarial attacks. NeurIPS
2018.</em></p>
<p>With softmax and energy-based methods, we focus on the models outputs
to determine a threshold that defines ID and OOD data. With
distance-based methods, we focus on the feature representations learned
by the model.</p>
<p>In the case of neural networks, a common approach is to use the
penultimate layer as a feature representation that can define an ID
clusters for each class. You can then use distance to the closesent
centroid as a proxy for OOD measure.</p>
<div class="section level2">
<h2 id="mahalanobis-distance-parametric">Mahalanobis distance (parametric)<a class="anchor" aria-label="anchor" href="#mahalanobis-distance-parametric"></a>
</h2>
<p>Model the feature space as a mixture of multivariate Gaussian
distribution, one for each class. use distance to the closest centroid
as proxy for OOD measure</p>
<div class="section level3">
<h3 id="limiations-of-parametric-approach">Limiations of parametric approach<a class="anchor" aria-label="anchor" href="#limiations-of-parametric-approach"></a>
</h3>
<ul>
<li>Strong distributional assumption (features may not necessarily be
Gassian-distributed)</li>
<li>Suboptimal embedding</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="nearest-neighbor-distance-non-parametric">Nearest Neighbor Distance (non-parametric)<a class="anchor" aria-label="anchor" href="#nearest-neighbor-distance-non-parametric"></a>
</h2>
<p><em>Sun et al., Out-of-distribution Detection with Deep Nearest
Neighbors, ICML 2022</em></p>
<ul>
<li>Sample considered OOD if it has a large KNN distrance w.r.t.
training data (and vice versa)</li>
<li>No distributional assumptions about underlying embedding space.
Stronger generality and flexibility than mahalanobis distancew</li>
</ul>
</div>
<div class="section level2">
<h2 id="cider">CIDER<a class="anchor" aria-label="anchor" href="#cider"></a>
</h2>
<p>This one might be out of scope…</p>
<p>Ming et al., How to Exploit Hyperspherical Embeddings for
Out-of-Distribution Detection # Contrastive Learning</p>
<ul>
<li>Explain the basic idea of contrastive learning: learning
representations by contrasting positive and negative pairs.</li>
<li>Highlight the role of contrastive learning in learning
discriminative features that can separate in-distribution (ID) from OOD
data more effectively.</li>
<li>Illustrate how contrastive learning improves the feature space,
making distance-based methods (like Mahalanobis and KNN) more
effective.</li>
<li>Provide examples or case studies where contrastive learning has been
applied to enhance OOD detection. # Example X: Comparing feature
representations with and without contrastive learning</li>
</ul>
</div>
<div class="section level2">
<h2 id="returning-to-umap">Returning to UMAP<a class="anchor" aria-label="anchor" href="#returning-to-umap"></a>
</h2>
<p>Notice how in our UMAP visualization, we say three distinct clusters
representing each class. However, our model still confidently rated many
sandals as being tshirts. The crux of this issue is that models do not
know what they don’t know. They simply draw classifcation boundaries
between the classes available to them during training.</p>
<p>One way to get around this problem is to train models to learn
discriminative features…</p>
</div>
<div class="section level2">
<h2 id="contrastive-learning">Contrastive learning<a class="anchor" aria-label="anchor" href="#contrastive-learning"></a>
</h2>
<p>In this experiment, we use both a traditional neural network and a
contrastive learning model to classify images from the Fashion MNIST
dataset, focusing on T-shirts (class 0) and Trousers (class 1).
Additionally, we evaluate the models on out-of-distribution (OOD) data,
specifically Sandals (class 5). To visualize the models’ learned
features, we extract features from specific layers of the neural
networks and reduce their dimensionality using UMAP.</p>
</div>
<div class="section level2">
<h2 id="overview-of-steps">Overview of steps<a class="anchor" aria-label="anchor" href="#overview-of-steps"></a>
</h2>
<div class="section level4">
<h4 id="train-model">1) Train model<a class="anchor" aria-label="anchor" href="#train-model"></a>
</h4>
<ul>
<li>With or without contrastive learning</li>
<li>Focusing on T-shirts (class 0) and Trousers (class 1)</li>
<li>Additionally, we evaluate the models on out-of-distribution (OOD)
data, specifically Sandals (class 5)</li>
</ul>
</div>
<div class="section level4">
<h4 id="feature-extraction">2) Feature Extraction:<a class="anchor" aria-label="anchor" href="#feature-extraction"></a>
</h4>
<ul>
<li>After training, we set the models to evaluation mode to prevent
updates to the model parameters.</li>
<li>For each subset of the data (training, validation, and OOD), we pass
the images through the entire network up to the first fully connected
layer.</li>
<li>The output of this layer, which captures high-level features and
abstractions, is then used as a 1D feature vector.</li>
<li>These feature vectors are detached from the computational graph and
converted to NumPy arrays for further processing.</li>
</ul>
</div>
<div class="section level4">
<h4 id="dimensionality-reduction-and-visualization">3) Dimensionality Reduction and Visualization:<a class="anchor" aria-label="anchor" href="#dimensionality-reduction-and-visualization"></a>
</h4>
<ul>
<li>We combine the feature vectors from the training, validation, and
OOD data into a single dataset.</li>
<li>UMAP (Uniform Manifold Approximation and Projection) is used to
reduce the dimensionality of the feature vectors from the
high-dimensional space to 2D, making it possible to visualize the
relationships between different data points.</li>
<li>The reduced features are then plotted, with different colors
representing the training data (T-shirts and Trousers), validation data
(T-shirts and Trousers), and OOD data (Sandals).</li>
</ul>
<p>By visualizing the features generated from different subsets of the
data, we can observe how well the models have learned to distinguish
between in-distribution classes (T-shirts and Trousers) and handle OOD
data (Sandals). This approach allows us to evaluate the robustness and
generalization capabilities of the models in dealing with data that may
not have been seen during training. ## Standard neural network w/out
contrastive learning</p>
</div>
<div class="section level3">
<h3 id="train-model-1">1) Train model<a class="anchor" aria-label="anchor" href="#train-model-1"></a>
</h3>
<p>We’ll first train our vanilla CNN w/out contrastive learning.</p>
<ul>
<li>Focusing on T-shirts (class 0) and Trousers (class 1)</li>
<li>Additionally, we evaluate the models on out-of-distribution (OOD)
data, specifically Sandals (class 5)</li>
</ul>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> accuracy_score</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="im">from</span> torchvision <span class="im">import</span> datasets, transforms</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> DataLoader, Subset, Dataset</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="co"># Check if GPU is available and set device</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Using device: </span><span class="sc">{</span>device<span class="sc">}</span><span class="ss">'</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Define a simple CNN model for classification</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="kw">class</span> ClassificationModel(nn.Module):</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>        <span class="bu">super</span>(ClassificationModel, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>        <span class="va">self</span>.conv1 <span class="op">=</span> nn.Conv2d(<span class="dv">1</span>, <span class="dv">32</span>, kernel_size<span class="op">=</span><span class="dv">3</span>, stride<span class="op">=</span><span class="dv">1</span>, padding<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>        <span class="va">self</span>.relu <span class="op">=</span> nn.ReLU()</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>        <span class="va">self</span>.flatten <span class="op">=</span> nn.Flatten()</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>        <span class="va">self</span>.fc1 <span class="op">=</span> nn.Linear(<span class="dv">32</span> <span class="op">*</span> <span class="dv">28</span> <span class="op">*</span> <span class="dv">28</span>, <span class="dv">128</span>)</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>        <span class="va">self</span>.fc2 <span class="op">=</span> nn.Linear(<span class="dv">128</span>, <span class="dv">2</span>)  <span class="co"># 2 classes for T-shirts and Trousers</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.conv1(x)</span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.relu(x)</span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.flatten(x)</span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.fc1(x)</span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.relu(x)</span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.fc2(x)</span>
<span id="cb2-18"><a href="#cb2-18" tabindex="-1"></a>        <span class="cf">return</span> x</span>
<span id="cb2-19"><a href="#cb2-19" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" tabindex="-1"></a><span class="co"># Load Fashion MNIST dataset and filter for T-shirts and Trousers</span></span>
<span id="cb2-21"><a href="#cb2-21" tabindex="-1"></a>transform <span class="op">=</span> transforms.Compose([transforms.ToTensor()])</span>
<span id="cb2-22"><a href="#cb2-22" tabindex="-1"></a>train_dataset <span class="op">=</span> datasets.FashionMNIST(root<span class="op">=</span><span class="st">'./data'</span>, train<span class="op">=</span><span class="va">True</span>, download<span class="op">=</span><span class="va">True</span>, transform<span class="op">=</span>transform)</span>
<span id="cb2-23"><a href="#cb2-23" tabindex="-1"></a>test_dataset <span class="op">=</span> datasets.FashionMNIST(root<span class="op">=</span><span class="st">'./data'</span>, train<span class="op">=</span><span class="va">False</span>, download<span class="op">=</span><span class="va">True</span>, transform<span class="op">=</span>transform)</span>
<span id="cb2-24"><a href="#cb2-24" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" tabindex="-1"></a>train_indices <span class="op">=</span> np.where((train_dataset.targets <span class="op">==</span> <span class="dv">0</span>) <span class="op">|</span> (train_dataset.targets <span class="op">==</span> <span class="dv">1</span>))[<span class="dv">0</span>]</span>
<span id="cb2-26"><a href="#cb2-26" tabindex="-1"></a>val_indices <span class="op">=</span> np.where((test_dataset.targets <span class="op">==</span> <span class="dv">0</span>) <span class="op">|</span> (test_dataset.targets <span class="op">==</span> <span class="dv">1</span>))[<span class="dv">0</span>]</span>
<span id="cb2-27"><a href="#cb2-27" tabindex="-1"></a>ood_indices <span class="op">=</span> np.where(test_dataset.targets <span class="op">==</span> <span class="dv">5</span>)[<span class="dv">0</span>]</span>
<span id="cb2-28"><a href="#cb2-28" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" tabindex="-1"></a><span class="co"># Use a subset of the data for quicker training</span></span>
<span id="cb2-30"><a href="#cb2-30" tabindex="-1"></a>train_subset <span class="op">=</span> Subset(train_dataset, np.random.choice(train_indices, size<span class="op">=</span><span class="dv">5000</span>, replace<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb2-31"><a href="#cb2-31" tabindex="-1"></a>val_subset <span class="op">=</span> Subset(test_dataset, np.random.choice(val_indices, size<span class="op">=</span><span class="dv">1000</span>, replace<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb2-32"><a href="#cb2-32" tabindex="-1"></a>ood_subset <span class="op">=</span> Subset(test_dataset, np.random.choice(ood_indices, size<span class="op">=</span><span class="dv">1000</span>, replace<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb2-33"><a href="#cb2-33" tabindex="-1"></a></span>
<span id="cb2-34"><a href="#cb2-34" tabindex="-1"></a>train_loader <span class="op">=</span> DataLoader(train_subset, batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-35"><a href="#cb2-35" tabindex="-1"></a>val_loader <span class="op">=</span> DataLoader(val_subset, batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-36"><a href="#cb2-36" tabindex="-1"></a>ood_loader <span class="op">=</span> DataLoader(ood_subset, batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-37"><a href="#cb2-37" tabindex="-1"></a></span>
<span id="cb2-38"><a href="#cb2-38" tabindex="-1"></a><span class="co"># Initialize the model and move it to the device</span></span>
<span id="cb2-39"><a href="#cb2-39" tabindex="-1"></a>classification_model <span class="op">=</span> ClassificationModel().to(device)</span>
<span id="cb2-40"><a href="#cb2-40" tabindex="-1"></a></span>
<span id="cb2-41"><a href="#cb2-41" tabindex="-1"></a><span class="co"># Loss function and optimizer</span></span>
<span id="cb2-42"><a href="#cb2-42" tabindex="-1"></a>criterion <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb2-43"><a href="#cb2-43" tabindex="-1"></a>optimizer <span class="op">=</span> optim.Adam(classification_model.parameters(), lr<span class="op">=</span><span class="fl">0.001</span>)</span>
<span id="cb2-44"><a href="#cb2-44" tabindex="-1"></a></span>
<span id="cb2-45"><a href="#cb2-45" tabindex="-1"></a><span class="co"># Training loop for standard neural network</span></span>
<span id="cb2-46"><a href="#cb2-46" tabindex="-1"></a>train_losses <span class="op">=</span> []</span>
<span id="cb2-47"><a href="#cb2-47" tabindex="-1"></a>val_losses <span class="op">=</span> []</span>
<span id="cb2-48"><a href="#cb2-48" tabindex="-1"></a></span>
<span id="cb2-49"><a href="#cb2-49" tabindex="-1"></a><span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(n_epochs):</span>
<span id="cb2-50"><a href="#cb2-50" tabindex="-1"></a>    total_train_loss <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-51"><a href="#cb2-51" tabindex="-1"></a>    classification_model.train()</span>
<span id="cb2-52"><a href="#cb2-52" tabindex="-1"></a>    <span class="cf">for</span> batch_images, batch_labels <span class="kw">in</span> train_loader:</span>
<span id="cb2-53"><a href="#cb2-53" tabindex="-1"></a>        batch_images, batch_labels <span class="op">=</span> batch_images.to(device), batch_labels.to(device)</span>
<span id="cb2-54"><a href="#cb2-54" tabindex="-1"></a></span>
<span id="cb2-55"><a href="#cb2-55" tabindex="-1"></a>        optimizer.zero_grad()</span>
<span id="cb2-56"><a href="#cb2-56" tabindex="-1"></a>        outputs <span class="op">=</span> classification_model(batch_images)</span>
<span id="cb2-57"><a href="#cb2-57" tabindex="-1"></a>        loss <span class="op">=</span> criterion(outputs, batch_labels)</span>
<span id="cb2-58"><a href="#cb2-58" tabindex="-1"></a></span>
<span id="cb2-59"><a href="#cb2-59" tabindex="-1"></a>        loss.backward()</span>
<span id="cb2-60"><a href="#cb2-60" tabindex="-1"></a>        optimizer.step()</span>
<span id="cb2-61"><a href="#cb2-61" tabindex="-1"></a></span>
<span id="cb2-62"><a href="#cb2-62" tabindex="-1"></a>        total_train_loss <span class="op">+=</span> loss.item()</span>
<span id="cb2-63"><a href="#cb2-63" tabindex="-1"></a></span>
<span id="cb2-64"><a href="#cb2-64" tabindex="-1"></a>    total_val_loss <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-65"><a href="#cb2-65" tabindex="-1"></a>    classification_model.<span class="bu">eval</span>()</span>
<span id="cb2-66"><a href="#cb2-66" tabindex="-1"></a>    <span class="cf">with</span> torch.no_grad():</span>
<span id="cb2-67"><a href="#cb2-67" tabindex="-1"></a>        <span class="cf">for</span> batch_images, batch_labels <span class="kw">in</span> val_loader:</span>
<span id="cb2-68"><a href="#cb2-68" tabindex="-1"></a>            batch_images, batch_labels <span class="op">=</span> batch_images.to(device), batch_labels.to(device)</span>
<span id="cb2-69"><a href="#cb2-69" tabindex="-1"></a>            outputs <span class="op">=</span> classification_model(batch_images)</span>
<span id="cb2-70"><a href="#cb2-70" tabindex="-1"></a>            loss <span class="op">=</span> criterion(outputs, batch_labels)</span>
<span id="cb2-71"><a href="#cb2-71" tabindex="-1"></a>            total_val_loss <span class="op">+=</span> loss.item()</span>
<span id="cb2-72"><a href="#cb2-72" tabindex="-1"></a></span>
<span id="cb2-73"><a href="#cb2-73" tabindex="-1"></a>    avg_train_loss <span class="op">=</span> total_train_loss <span class="op">/</span> <span class="bu">len</span>(train_loader)</span>
<span id="cb2-74"><a href="#cb2-74" tabindex="-1"></a>    avg_val_loss <span class="op">=</span> total_val_loss <span class="op">/</span> <span class="bu">len</span>(val_loader)</span>
<span id="cb2-75"><a href="#cb2-75" tabindex="-1"></a>    train_losses.append(avg_train_loss)</span>
<span id="cb2-76"><a href="#cb2-76" tabindex="-1"></a>    val_losses.append(avg_val_loss)</span>
<span id="cb2-77"><a href="#cb2-77" tabindex="-1"></a></span>
<span id="cb2-78"><a href="#cb2-78" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'Epoch </span><span class="sc">{</span>epoch <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">, Train Loss: </span><span class="sc">{</span>avg_train_loss<span class="sc">:.4f}</span><span class="ss">, Val Loss: </span><span class="sc">{</span>avg_val_loss<span class="sc">:.4f}</span><span class="ss">'</span>)</span>
<span id="cb2-79"><a href="#cb2-79" tabindex="-1"></a></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># Plot training and validation loss</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">1</span>, n_epochs <span class="op">+</span> <span class="dv">1</span>), train_losses, label<span class="op">=</span><span class="st">'Train Loss'</span>)</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">1</span>, n_epochs <span class="op">+</span> <span class="dv">1</span>), val_losses, label<span class="op">=</span><span class="st">'Validation Loss'</span>)</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>plt.xlabel(<span class="st">'Epoch'</span>)</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>plt.ylabel(<span class="st">'Loss'</span>)</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>plt.title(<span class="st">'Training and Validation Loss - Classification Model'</span>)</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>plt.legend()</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="extracting-learned-features">2) Extracting learned features<a class="anchor" aria-label="anchor" href="#extracting-learned-features"></a>
</h3>
<ul>
<li>After training, we set the models to evaluation mode to prevent
updates to the model parameters.</li>
<li>For each subset of the data (training, validation, and OOD), we pass
the images through the entire network up to the first fully connected
layer.</li>
<li>The output of this layer, which captures high-level features and
abstractions, is then used as a 1D feature vector.</li>
<li>These feature vectors are detached from the computational graph and
converted to NumPy arrays for further processing.</li>
</ul>
<div class="section level4">
<h4 id="why-later-layer-features-are-better">Why later layer features are better<a class="anchor" aria-label="anchor" href="#why-later-layer-features-are-better"></a>
</h4>
<p>In both the traditional neural network and the contrastive learning
model, we will extract features from the first fully connected layer
(fc1) before the final classification layer. Here’s why this layer is
particularly suitable for feature extraction:</p>
<ul>
<li><p><strong>Hierarchical feature representation</strong>: In neural
networks, the initial layers typically capture low-level features such
as edges, textures, and simple shapes (e.g., with CNNs). As you move
deeper into the network, the layers capture higher-level, more abstract
features that are more relevant for the final classification task. These
high-level features are combinations of the low-level features and are
typically more discriminative.</p></li>
<li><p><strong>Better separation of classes</strong>: Features from
later layers have been transformed through several layers of non-linear
activations and pooling operations, making them more suitable for
distinguishing between classes. These features are usually more compact
and have a better separation in the feature space, which helps in
visualization and understanding the model’s decision-making
process.</p></li>
</ul>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Extract features using the trained classification model</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>classification_model.<span class="bu">eval</span>()</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>train_features <span class="op">=</span> []</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>train_labels_list <span class="op">=</span> []</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="cf">for</span> batch_images, batch_labels <span class="kw">in</span> train_loader:</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>    batch_images <span class="op">=</span> batch_images.to(device)</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>    features <span class="op">=</span> classification_model.fc1(classification_model.flatten(classification_model.conv1(batch_images)))</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>    train_features.append(features.detach().cpu().numpy())</span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>    train_labels_list.append(batch_labels.numpy())</span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a>val_features <span class="op">=</span> []</span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a>val_labels_list <span class="op">=</span> []</span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a><span class="cf">for</span> batch_images, batch_labels <span class="kw">in</span> val_loader:</span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a>    batch_images <span class="op">=</span> batch_images.to(device)</span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a>    features <span class="op">=</span> classification_model.fc1(classification_model.flatten(classification_model.conv1(batch_images)))</span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a>    val_features.append(features.detach().cpu().numpy())</span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a>    val_labels_list.append(batch_labels.numpy())</span>
<span id="cb4-18"><a href="#cb4-18" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" tabindex="-1"></a>ood_features <span class="op">=</span> []</span>
<span id="cb4-20"><a href="#cb4-20" tabindex="-1"></a>ood_labels_list <span class="op">=</span> []</span>
<span id="cb4-21"><a href="#cb4-21" tabindex="-1"></a><span class="cf">for</span> batch_images, batch_labels <span class="kw">in</span> ood_loader:</span>
<span id="cb4-22"><a href="#cb4-22" tabindex="-1"></a>    batch_images <span class="op">=</span> batch_images.to(device)</span>
<span id="cb4-23"><a href="#cb4-23" tabindex="-1"></a>    features <span class="op">=</span> classification_model.fc1(classification_model.flatten(classification_model.conv1(batch_images)))</span>
<span id="cb4-24"><a href="#cb4-24" tabindex="-1"></a>    ood_features.append(features.detach().cpu().numpy())</span>
<span id="cb4-25"><a href="#cb4-25" tabindex="-1"></a>    ood_labels_list.append(batch_labels.numpy())</span></code></pre>
</div>
</div>
</div>
<div class="section level3">
<h3 id="dimensionality-reduction-and-visualization-1">3) Dimensionality Reduction and Visualization:<a class="anchor" aria-label="anchor" href="#dimensionality-reduction-and-visualization-1"></a>
</h3>
<ul>
<li>We combine the feature vectors from the training, validation, and
OOD data into a single dataset.</li>
<li>UMAP (Uniform Manifold Approximation and Projection) is used to
reduce the dimensionality of the feature vectors from the
high-dimensional space to 2D, making it possible to visualize the
relationships between different data points.</li>
<li>The reduced features are then plotted, with different colors
representing the training data (T-shirts and Trousers), validation data
(T-shirts and Trousers), and OOD data (Sandals).</li>
</ul>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>train_features <span class="op">=</span> np.concatenate(train_features)</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>train_labels <span class="op">=</span> np.concatenate(train_labels_list)</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>val_features <span class="op">=</span> np.concatenate(val_features)</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>val_labels <span class="op">=</span> np.concatenate(val_labels_list)</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>ood_features <span class="op">=</span> np.concatenate(ood_features)</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>ood_labels <span class="op">=</span> np.concatenate(ood_labels_list)</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co"># Perform UMAP to visualize the classification model features</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>combined_features <span class="op">=</span> np.vstack([train_features, val_features, ood_features])</span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>combined_labels <span class="op">=</span> np.hstack([train_labels, val_labels, np.full(<span class="bu">len</span>(ood_labels), <span class="dv">2</span>)])  <span class="co"># Use 2 for OOD class</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a>umap_reducer <span class="op">=</span> umap.UMAP(n_components<span class="op">=</span><span class="dv">2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a>umap_results <span class="op">=</span> umap_reducer.fit_transform(combined_features)</span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a><span class="co"># Split the results back into train, val, and OOD data</span></span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a>umap_train_features <span class="op">=</span> umap_results[:<span class="bu">len</span>(train_features)]</span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a>umap_val_features <span class="op">=</span> umap_results[<span class="bu">len</span>(train_features):<span class="bu">len</span>(train_features) <span class="op">+</span> <span class="bu">len</span>(val_features)]</span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a>umap_ood_features <span class="op">=</span> umap_results[<span class="bu">len</span>(train_features) <span class="op">+</span> <span class="bu">len</span>(val_features):]</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># Plotting UMAP components for classification model</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">.2</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co"># Plot train T-shirts</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>scatter1 <span class="op">=</span> plt.scatter(umap_train_features[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">0</span>], umap_train_features[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span>alpha, label<span class="op">=</span><span class="st">'Train T-shirts (ID)'</span>)</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co"># Plot train Trousers</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>scatter2 <span class="op">=</span> plt.scatter(umap_train_features[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">0</span>], umap_train_features[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span>alpha, label<span class="op">=</span><span class="st">'Train Trousers (ID)'</span>)</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a><span class="co"># Plot val T-shirts</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>scatter3 <span class="op">=</span> plt.scatter(umap_val_features[val_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">0</span>], umap_val_features[val_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span>alpha, marker<span class="op">=</span><span class="st">'x'</span>, label<span class="op">=</span><span class="st">'Val T-shirts (ID)'</span>)</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a><span class="co"># Plot val Trousers</span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>scatter4 <span class="op">=</span> plt.scatter(umap_val_features[val_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">0</span>], umap_val_features[val_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span>alpha, marker<span class="op">=</span><span class="st">'x'</span>, label<span class="op">=</span><span class="st">'Val Trousers (ID)'</span>)</span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a><span class="co"># Plot OOD Sandals</span></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>scatter5 <span class="op">=</span> plt.scatter(umap_ood_features[:, <span class="dv">0</span>], umap_ood_features[:, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'green'</span>, alpha<span class="op">=</span>alpha, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">'OOD Sandals'</span>)</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[scatter1, scatter2, scatter3, scatter4, scatter5])</span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a>plt.xlabel(<span class="st">'First UMAP Component'</span>)</span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a>plt.ylabel(<span class="st">'Second UMAP Component'</span>)</span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a>plt.title(<span class="st">'UMAP of Classification Model Features'</span>)</span>
<span id="cb6-18"><a href="#cb6-18" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
</div>
</div>
<div class="section level2">
<h2 id="neural-network-trained-with-contrastive-learning">Neural network trained with contrastive learning<a class="anchor" aria-label="anchor" href="#neural-network-trained-with-contrastive-learning"></a>
</h2>
<div class="section level3">
<h3 id="what-is-contrastive-learning">What is Contrastive Learning?<a class="anchor" aria-label="anchor" href="#what-is-contrastive-learning"></a>
</h3>
<p>Contrastive learning is a technique where the model learns to
distinguish between similar and dissimilar pairs of data. This can be
achieved through different types of learning: supervised, unsupervised,
and self-supervised.</p>
<ul>
<li><p>Supervised Contrastive Learning: Uses labeled data to create
pairs or groups of similar and dissimilar data points based on their
labels.</p></li>
<li><p>Unsupervised Contrastive Learning: Does not use any labels.
Instead, it relies on inherent patterns in the data to create pairs. For
example, random pairs of data points might be assumed to be dissimilar,
while augmented versions of the same data point might be assumed to be
similar.</p></li>
<li><p>Self-Supervised Contrastive Learning: A form of unsupervised
learning where the model generates its own supervisory signal from the
data. This typically involves data augmentation techniques where
positive pairs are created by augmenting the same image (e.g., cropping,
rotating), and negative pairs are formed from different images.</p></li>
</ul>
<p>In contrastive learning, the model learns to bring similar pairs
closer in the embedding space while pushing dissimilar pairs further
apart. This approach is particularly useful for tasks like image
retrieval, clustering, and representation learning.</p>
<p>Certainly! Let’s expand on how we are treating the T-shirt, Trouser,
and Sandals classes in the context of our supervised contrastive
learning framework.</p>
</div>
<div class="section level3">
<h3 id="key-concepts-in-our-code">Key Concepts in Our Code<a class="anchor" aria-label="anchor" href="#key-concepts-in-our-code"></a>
</h3>
</div>
<div class="section level3">
<h3 id="data-preparation">Data Preparation<a class="anchor" aria-label="anchor" href="#data-preparation"></a>
</h3>
<ul>
<li>
<strong>Dataset</strong>: We use the Fashion MNIST dataset, which
contains images of various clothing items, each labeled with a specific
class.</li>
<li>
<strong>Class Filtering</strong>: For this exercise, we are focusing
on three classes from the Fashion MNIST dataset:
<ul>
<li>
<strong>T-shirts</strong> (class label 0)</li>
<li>
<strong>Trousers</strong> (class label 1)</li>
<li>
<strong>Sandals</strong> (class label 5)</li>
</ul>
</li>
<li>
<strong>In-Distribution (ID) Data</strong>: We treat T-shirts and
Trousers as our primary classes for training. These are considered
“in-distribution” data.</li>
<li>
<strong>Out-of-Distribution (OOD) Data</strong>: Sandals are treated
as a different class for testing the robustness of our learned
embeddings, making them “out-of-distribution” data.</li>
</ul>
</div>
<div class="section level3">
<h3 id="pairs-creation">Pairs Creation<a class="anchor" aria-label="anchor" href="#pairs-creation"></a>
</h3>
<p>For each image in our training set: - <strong>Positive Pair</strong>:
We find another image of the same class (either T-shirt or Trouser).
These pairs are labeled as similar. - <strong>Negative Pair</strong>: We
randomly choose an image from a different class (T-shirt paired with
Trouser or vice versa). These pairs are labeled as dissimilar.</p>
<p>By creating these pairs, the model learns to produce embeddings where
similar images (same class) are close together, and dissimilar images
(different classes) are farther apart.</p>
</div>
<div class="section level3">
<h3 id="model-architecture">Model Architecture<a class="anchor" aria-label="anchor" href="#model-architecture"></a>
</h3>
<p>The model is a simple Convolutional Neural Network (CNN) designed to
output embeddings. It consists of: - Two convolutional layers to extract
features from the images. - Fully connected layers to map these features
to a 50-dimensional embedding space.</p>
</div>
<div class="section level3">
<h3 id="training-process">Training Process<a class="anchor" aria-label="anchor" href="#training-process"></a>
</h3>
<ul>
<li>
<strong>Forward Pass</strong>: The model processes pairs of images
and outputs their embeddings.</li>
<li>
<strong>Contrastive Loss</strong>: We use a contrastive loss
function to train the model. This loss encourages embeddings of similar
pairs to be close and embeddings of dissimilar pairs to be far apart.
Specifically, we:
<ul>
<li>Normalize the embeddings.</li>
<li>Calculate similarity scores.</li>
<li>Compute the contrastive loss, which penalizes similar pairs if they
are not close enough and dissimilar pairs if they are too close.</li>
</ul>
</li>
</ul>
</div>
<div class="section level3">
<h3 id="differences-from-standard-neural-network-training">Differences from Standard Neural Network Training<a class="anchor" aria-label="anchor" href="#differences-from-standard-neural-network-training"></a>
</h3>
<ul>
<li>
<strong>Data Pairing</strong>: In contrastive learning, we create
pairs of data points. Standard neural network training typically
involves individual data points with corresponding labels.</li>
<li>
<strong>Loss Function</strong>: We use a contrastive loss function
instead of the typical cross-entropy loss used in classification tasks.
The contrastive loss is designed to optimize the relative distances
between pairs of embeddings.</li>
<li>
<strong>Supervised Learning</strong>: Our approach uses labeled data
to form similar and dissimilar pairs, making it supervised contrastive
learning. This contrasts with self-supervised or unsupervised methods
where labels are not used.</li>
</ul>
</div>
<div class="section level3">
<h3 id="specific-type-of-contrastive-learning">Specific Type of Contrastive Learning<a class="anchor" aria-label="anchor" href="#specific-type-of-contrastive-learning"></a>
</h3>
<p>The specific contrastive learning technique we are using here is a
form of <strong>supervised contrastive learning</strong>. This involves
using labeled data to create similar and dissimilar pairs of images. The
model is trained to output embeddings where a contrastive loss function
is applied to these pairs. By doing so, the model learns to map images
into an embedding space where similar images are close together, and
dissimilar images are farther apart.</p>
<p>By training with this method, the model learns robust feature
representations that are useful for various downstream tasks, even with
limited labeled data. This is powerful because it allows leveraging
labeled data to improve the model’s performance and
generalizability.</p>
</div>
<div class="section level3">
<h3 id="application-of-the-framework">Application of the Framework<a class="anchor" aria-label="anchor" href="#application-of-the-framework"></a>
</h3>
<ol style="list-style-type: decimal">
<li>
<strong>Training with In-Distribution Data</strong>:
<ul>
<li>
<strong>T-shirts and Trousers</strong>: These classes are used to
train the model. Positive and negative pairs are created within this
subset to teach the model to distinguish between the two classes.</li>
</ul>
</li>
<li>
<strong>Testing with Out-of-Distribution Data</strong>:
<ul>
<li>
<strong>Sandals</strong>: This class is used to test the robustness
of the embeddings learned by the model. By introducing a completely
different class during testing, we can evaluate how well the model
generalizes to new, unseen data.</li>
</ul>
</li>
</ol>
<p>This framework demonstrates how supervised contrastive learning can
be effectively applied to learn discriminative embeddings that can
generalize well to both in-distribution and out-of-distribution
data.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> Dataset, DataLoader, Subset</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="im">from</span> torchvision <span class="im">import</span> datasets, transforms</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="im">import</span> umap</span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim</span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="kw">class</span> PairDataset(Dataset):</span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, images, labels):</span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a>        <span class="va">self</span>.images <span class="op">=</span> images</span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a>        <span class="va">self</span>.labels <span class="op">=</span> labels</span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__len__</span>(<span class="va">self</span>):</span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(<span class="va">self</span>.images)</span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__getitem__</span>(<span class="va">self</span>, idx):</span>
<span id="cb7-19"><a href="#cb7-19" tabindex="-1"></a>        img1 <span class="op">=</span> <span class="va">self</span>.images[idx]</span>
<span id="cb7-20"><a href="#cb7-20" tabindex="-1"></a>        label1 <span class="op">=</span> <span class="va">self</span>.labels[idx]</span>
<span id="cb7-21"><a href="#cb7-21" tabindex="-1"></a>        idx2 <span class="op">=</span> np.random.choice(np.where(<span class="va">self</span>.labels <span class="op">==</span> label1)[<span class="dv">0</span>])</span>
<span id="cb7-22"><a href="#cb7-22" tabindex="-1"></a>        img2 <span class="op">=</span> <span class="va">self</span>.images[idx2]</span>
<span id="cb7-23"><a href="#cb7-23" tabindex="-1"></a>        <span class="cf">return</span> img1, img2, label1</span>
<span id="cb7-24"><a href="#cb7-24" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" tabindex="-1"></a><span class="co"># Load Fashion MNIST dataset and filter for T-shirts and Trousers</span></span>
<span id="cb7-26"><a href="#cb7-26" tabindex="-1"></a>transform <span class="op">=</span> transforms.Compose([transforms.ToTensor()])</span>
<span id="cb7-27"><a href="#cb7-27" tabindex="-1"></a>train_dataset <span class="op">=</span> datasets.FashionMNIST(root<span class="op">=</span><span class="st">'./data'</span>, train<span class="op">=</span><span class="va">True</span>, download<span class="op">=</span><span class="va">True</span>, transform<span class="op">=</span>transform)</span>
<span id="cb7-28"><a href="#cb7-28" tabindex="-1"></a>test_dataset <span class="op">=</span> datasets.FashionMNIST(root<span class="op">=</span><span class="st">'./data'</span>, train<span class="op">=</span><span class="va">False</span>, download<span class="op">=</span><span class="va">True</span>, transform<span class="op">=</span>transform)</span>
<span id="cb7-29"><a href="#cb7-29" tabindex="-1"></a></span>
<span id="cb7-30"><a href="#cb7-30" tabindex="-1"></a>train_indices <span class="op">=</span> np.where((train_dataset.targets <span class="op">==</span> <span class="dv">0</span>) <span class="op">|</span> (train_dataset.targets <span class="op">==</span> <span class="dv">1</span>))[<span class="dv">0</span>]</span>
<span id="cb7-31"><a href="#cb7-31" tabindex="-1"></a>val_indices <span class="op">=</span> np.where((test_dataset.targets <span class="op">==</span> <span class="dv">0</span>) <span class="op">|</span> (test_dataset.targets <span class="op">==</span> <span class="dv">1</span>))[<span class="dv">0</span>]</span>
<span id="cb7-32"><a href="#cb7-32" tabindex="-1"></a>ood_indices <span class="op">=</span> np.where(test_dataset.targets <span class="op">==</span> <span class="dv">5</span>)[<span class="dv">0</span>]</span>
<span id="cb7-33"><a href="#cb7-33" tabindex="-1"></a></span>
<span id="cb7-34"><a href="#cb7-34" tabindex="-1"></a><span class="co"># Use a subset of the data for quicker training</span></span>
<span id="cb7-35"><a href="#cb7-35" tabindex="-1"></a>train_subset <span class="op">=</span> Subset(train_dataset, np.random.choice(train_indices, size<span class="op">=</span><span class="dv">5000</span>, replace<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb7-36"><a href="#cb7-36" tabindex="-1"></a>val_subset <span class="op">=</span> Subset(test_dataset, np.random.choice(val_indices, size<span class="op">=</span><span class="dv">1000</span>, replace<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb7-37"><a href="#cb7-37" tabindex="-1"></a>ood_subset <span class="op">=</span> Subset(test_dataset, np.random.choice(ood_indices, size<span class="op">=</span><span class="dv">1000</span>, replace<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb7-38"><a href="#cb7-38" tabindex="-1"></a></span>
<span id="cb7-39"><a href="#cb7-39" tabindex="-1"></a><span class="co"># Create DataLoaders for the subsets</span></span>
<span id="cb7-40"><a href="#cb7-40" tabindex="-1"></a>train_images <span class="op">=</span> np.array([train_dataset[i][<span class="dv">0</span>].numpy() <span class="cf">for</span> i <span class="kw">in</span> train_indices])</span>
<span id="cb7-41"><a href="#cb7-41" tabindex="-1"></a>train_labels <span class="op">=</span> np.array([train_dataset[i][<span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> train_indices])</span>
<span id="cb7-42"><a href="#cb7-42" tabindex="-1"></a>val_images <span class="op">=</span> np.array([test_dataset[i][<span class="dv">0</span>].numpy() <span class="cf">for</span> i <span class="kw">in</span> val_indices])</span>
<span id="cb7-43"><a href="#cb7-43" tabindex="-1"></a>val_labels <span class="op">=</span> np.array([test_dataset[i][<span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> val_indices])</span>
<span id="cb7-44"><a href="#cb7-44" tabindex="-1"></a>ood_images <span class="op">=</span> np.array([test_dataset[i][<span class="dv">0</span>].numpy() <span class="cf">for</span> i <span class="kw">in</span> ood_indices])</span>
<span id="cb7-45"><a href="#cb7-45" tabindex="-1"></a>ood_labels <span class="op">=</span> np.array([test_dataset[i][<span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> ood_indices])</span>
<span id="cb7-46"><a href="#cb7-46" tabindex="-1"></a></span>
<span id="cb7-47"><a href="#cb7-47" tabindex="-1"></a>train_loader <span class="op">=</span> DataLoader(PairDataset(train_images, train_labels), batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-48"><a href="#cb7-48" tabindex="-1"></a>val_loader <span class="op">=</span> DataLoader(PairDataset(val_images, val_labels), batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb7-49"><a href="#cb7-49" tabindex="-1"></a>ood_loader <span class="op">=</span> DataLoader(PairDataset(ood_images, ood_labels), batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb7-50"><a href="#cb7-50" tabindex="-1"></a></span>
<span id="cb7-51"><a href="#cb7-51" tabindex="-1"></a><span class="co"># Inspect the data loaders</span></span>
<span id="cb7-52"><a href="#cb7-52" tabindex="-1"></a><span class="cf">for</span> batch_images1, batch_images2, batch_labels <span class="kw">in</span> train_loader:</span>
<span id="cb7-53"><a href="#cb7-53" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"train_loader batch_images1 shape: </span><span class="sc">{</span>batch_images1<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-54"><a href="#cb7-54" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"train_loader batch_images2 shape: </span><span class="sc">{</span>batch_images2<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-55"><a href="#cb7-55" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"train_loader batch_labels shape: </span><span class="sc">{</span>batch_labels<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-56"><a href="#cb7-56" tabindex="-1"></a>    <span class="cf">break</span></span>
<span id="cb7-57"><a href="#cb7-57" tabindex="-1"></a></span>
<span id="cb7-58"><a href="#cb7-58" tabindex="-1"></a><span class="cf">for</span> batch_images1, batch_images2, batch_labels <span class="kw">in</span> val_loader:</span>
<span id="cb7-59"><a href="#cb7-59" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"val_loader batch_images1 shape: </span><span class="sc">{</span>batch_images1<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-60"><a href="#cb7-60" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"val_loader batch_images2 shape: </span><span class="sc">{</span>batch_images2<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-61"><a href="#cb7-61" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"val_loader batch_labels shape: </span><span class="sc">{</span>batch_labels<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-62"><a href="#cb7-62" tabindex="-1"></a>    <span class="cf">break</span></span>
<span id="cb7-63"><a href="#cb7-63" tabindex="-1"></a></span>
<span id="cb7-64"><a href="#cb7-64" tabindex="-1"></a><span class="cf">for</span> batch_images1, batch_images2, batch_labels <span class="kw">in</span> ood_loader:</span>
<span id="cb7-65"><a href="#cb7-65" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"ood_loader batch_images1 shape: </span><span class="sc">{</span>batch_images1<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-66"><a href="#cb7-66" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"ood_loader batch_images2 shape: </span><span class="sc">{</span>batch_images2<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-67"><a href="#cb7-67" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"ood_loader batch_labels shape: </span><span class="sc">{</span>batch_labels<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-68"><a href="#cb7-68" tabindex="-1"></a>    <span class="cf">break</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co"># Define a simple CNN model for contrastive learning</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="kw">class</span> ContrastiveModel(nn.Module):</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>        <span class="bu">super</span>(ContrastiveModel, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>        <span class="va">self</span>.conv1 <span class="op">=</span> nn.Conv2d(<span class="dv">1</span>, <span class="dv">32</span>, kernel_size<span class="op">=</span><span class="dv">3</span>, stride<span class="op">=</span><span class="dv">1</span>, padding<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>        <span class="va">self</span>.relu <span class="op">=</span> nn.ReLU()</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>        <span class="va">self</span>.flatten <span class="op">=</span> nn.Flatten()</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>        <span class="va">self</span>.fc1 <span class="op">=</span> nn.Linear(<span class="dv">32</span> <span class="op">*</span> <span class="dv">28</span> <span class="op">*</span> <span class="dv">28</span>, <span class="dv">128</span>)</span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>        <span class="va">self</span>.fc2 <span class="op">=</span> nn.Linear(<span class="dv">128</span>, <span class="dv">50</span>)  <span class="co"># Embedding size</span></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.conv1(x)</span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.relu(x)</span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.flatten(x)</span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.fc1(x)</span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.relu(x)</span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.fc2(x)</span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a>        <span class="cf">return</span> x</span>
<span id="cb8-19"><a href="#cb8-19" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" tabindex="-1"></a><span class="co"># Define contrastive loss function</span></span>
<span id="cb8-21"><a href="#cb8-21" tabindex="-1"></a><span class="kw">def</span> contrastive_loss(z_i, z_j, temperature<span class="op">=</span><span class="fl">0.5</span>):</span>
<span id="cb8-22"><a href="#cb8-22" tabindex="-1"></a>    z_i <span class="op">=</span> nn.functional.normalize(z_i, dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb8-23"><a href="#cb8-23" tabindex="-1"></a>    z_j <span class="op">=</span> nn.functional.normalize(z_j, dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb8-24"><a href="#cb8-24" tabindex="-1"></a>    batch_size <span class="op">=</span> z_i.size(<span class="dv">0</span>)</span>
<span id="cb8-25"><a href="#cb8-25" tabindex="-1"></a>    z <span class="op">=</span> torch.cat([z_i, z_j], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb8-26"><a href="#cb8-26" tabindex="-1"></a></span>
<span id="cb8-27"><a href="#cb8-27" tabindex="-1"></a>    sim <span class="op">=</span> torch.mm(z, z.t()) <span class="op">/</span> temperature</span>
<span id="cb8-28"><a href="#cb8-28" tabindex="-1"></a>    sim_i_j <span class="op">=</span> torch.diag(sim, batch_size)</span>
<span id="cb8-29"><a href="#cb8-29" tabindex="-1"></a>    sim_j_i <span class="op">=</span> torch.diag(sim, <span class="op">-</span>batch_size)</span>
<span id="cb8-30"><a href="#cb8-30" tabindex="-1"></a></span>
<span id="cb8-31"><a href="#cb8-31" tabindex="-1"></a>    positives <span class="op">=</span> torch.cat([sim_i_j, sim_j_i], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb8-32"><a href="#cb8-32" tabindex="-1"></a>    negatives_mask <span class="op">=</span> <span class="op">~</span>torch.eye(<span class="dv">2</span> <span class="op">*</span> batch_size, dtype<span class="op">=</span>torch.<span class="bu">bool</span>, device<span class="op">=</span>z.device)</span>
<span id="cb8-33"><a href="#cb8-33" tabindex="-1"></a>    negatives <span class="op">=</span> sim[negatives_mask].view(<span class="dv">2</span> <span class="op">*</span> batch_size, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb8-34"><a href="#cb8-34" tabindex="-1"></a></span>
<span id="cb8-35"><a href="#cb8-35" tabindex="-1"></a>    loss <span class="op">=</span> <span class="op">-</span>torch.mean(positives) <span class="op">+</span> torch.mean(negatives)</span>
<span id="cb8-36"><a href="#cb8-36" tabindex="-1"></a>    <span class="cf">return</span> loss</span>
<span id="cb8-37"><a href="#cb8-37" tabindex="-1"></a></span>
<span id="cb8-38"><a href="#cb8-38" tabindex="-1"></a><span class="co"># Training loop for contrastive learning</span></span>
<span id="cb8-39"><a href="#cb8-39" tabindex="-1"></a><span class="kw">def</span> train_contrastive_model(model, train_loader, optimizer, num_epochs<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb8-40"><a href="#cb8-40" tabindex="-1"></a>    model.train()</span>
<span id="cb8-41"><a href="#cb8-41" tabindex="-1"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(num_epochs):</span>
<span id="cb8-42"><a href="#cb8-42" tabindex="-1"></a>        total_loss <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-43"><a href="#cb8-43" tabindex="-1"></a>        <span class="cf">for</span> img1, img2, _ <span class="kw">in</span> train_loader:</span>
<span id="cb8-44"><a href="#cb8-44" tabindex="-1"></a>            img1, img2 <span class="op">=</span> img1.to(device), img2.to(device)</span>
<span id="cb8-45"><a href="#cb8-45" tabindex="-1"></a></span>
<span id="cb8-46"><a href="#cb8-46" tabindex="-1"></a>            optimizer.zero_grad()</span>
<span id="cb8-47"><a href="#cb8-47" tabindex="-1"></a></span>
<span id="cb8-48"><a href="#cb8-48" tabindex="-1"></a>            z_i <span class="op">=</span> model(img1)</span>
<span id="cb8-49"><a href="#cb8-49" tabindex="-1"></a>            z_j <span class="op">=</span> model(img2)</span>
<span id="cb8-50"><a href="#cb8-50" tabindex="-1"></a></span>
<span id="cb8-51"><a href="#cb8-51" tabindex="-1"></a>            loss <span class="op">=</span> contrastive_loss(z_i, z_j)</span>
<span id="cb8-52"><a href="#cb8-52" tabindex="-1"></a>            loss.backward()</span>
<span id="cb8-53"><a href="#cb8-53" tabindex="-1"></a>            optimizer.step()</span>
<span id="cb8-54"><a href="#cb8-54" tabindex="-1"></a></span>
<span id="cb8-55"><a href="#cb8-55" tabindex="-1"></a>            total_loss <span class="op">+=</span> loss.item()</span>
<span id="cb8-56"><a href="#cb8-56" tabindex="-1"></a></span>
<span id="cb8-57"><a href="#cb8-57" tabindex="-1"></a>        avg_loss <span class="op">=</span> total_loss <span class="op">/</span> <span class="bu">len</span>(train_loader)</span>
<span id="cb8-58"><a href="#cb8-58" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Epoch [</span><span class="sc">{</span>epoch <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>num_epochs<span class="sc">}</span><span class="ss">], Loss: </span><span class="sc">{</span>avg_loss<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb8-59"><a href="#cb8-59" tabindex="-1"></a></span>
<span id="cb8-60"><a href="#cb8-60" tabindex="-1"></a><span class="co"># Instantiate the model, optimizer, and start training</span></span>
<span id="cb8-61"><a href="#cb8-61" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">'cuda'</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">'cpu'</span>)</span>
<span id="cb8-62"><a href="#cb8-62" tabindex="-1"></a>contrastive_model <span class="op">=</span> ContrastiveModel().to(device)</span>
<span id="cb8-63"><a href="#cb8-63" tabindex="-1"></a>optimizer <span class="op">=</span> optim.Adam(contrastive_model.parameters(), lr<span class="op">=</span><span class="fl">0.001</span>)</span>
<span id="cb8-64"><a href="#cb8-64" tabindex="-1"></a></span>
<span id="cb8-65"><a href="#cb8-65" tabindex="-1"></a>train_contrastive_model(contrastive_model, train_loader, optimizer, num_epochs<span class="op">=</span>n_epochs)</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="extracting-learned-features-1">2) Extracting learned features<a class="anchor" aria-label="anchor" href="#extracting-learned-features-1"></a>
</h3>
<ul>
<li>After training, we set the models to evaluation mode to prevent
updates to the model parameters.</li>
<li>For each subset of the data (training, validation, and OOD), we pass
the images through the entire network up to the first fully connected
layer.</li>
<li>The output of this layer, which captures high-level features and
abstractions, is then used as a 1D feature vector.</li>
<li>These feature vectors are detached from the computational graph and
converted to NumPy arrays for further processing.</li>
</ul>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># Extract features using the trained contrastive model</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>contrastive_model.<span class="bu">eval</span>()</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>train_features <span class="op">=</span> []</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>train_labels_list <span class="op">=</span> []</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a><span class="cf">for</span> img1, _, label1 <span class="kw">in</span> train_loader:</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>    img1 <span class="op">=</span> img1.to(device)</span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>    features <span class="op">=</span> contrastive_model.fc1(contrastive_model.flatten(contrastive_model.conv1(img1)))</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>    train_features.append(features.detach().cpu().numpy())</span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a>    train_labels_list.append(label1.numpy())</span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a>val_features <span class="op">=</span> []</span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a>val_labels_list <span class="op">=</span> []</span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a><span class="cf">for</span> img1, _, label1 <span class="kw">in</span> val_loader:</span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a>    img1 <span class="op">=</span> img1.to(device)</span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a>    features <span class="op">=</span> contrastive_model.fc1(contrastive_model.flatten(contrastive_model.conv1(img1)))</span>
<span id="cb9-16"><a href="#cb9-16" tabindex="-1"></a>    val_features.append(features.detach().cpu().numpy())</span>
<span id="cb9-17"><a href="#cb9-17" tabindex="-1"></a>    val_labels_list.append(label1.numpy())</span>
<span id="cb9-18"><a href="#cb9-18" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" tabindex="-1"></a>ood_features <span class="op">=</span> []</span>
<span id="cb9-20"><a href="#cb9-20" tabindex="-1"></a>ood_labels_list <span class="op">=</span> []</span>
<span id="cb9-21"><a href="#cb9-21" tabindex="-1"></a><span class="cf">for</span> img1, _, label1 <span class="kw">in</span> ood_loader:</span>
<span id="cb9-22"><a href="#cb9-22" tabindex="-1"></a>    img1 <span class="op">=</span> img1.to(device)</span>
<span id="cb9-23"><a href="#cb9-23" tabindex="-1"></a>    features <span class="op">=</span> contrastive_model.fc1(contrastive_model.flatten(contrastive_model.conv1(img1)))</span>
<span id="cb9-24"><a href="#cb9-24" tabindex="-1"></a>    ood_features.append(features.detach().cpu().numpy())</span>
<span id="cb9-25"><a href="#cb9-25" tabindex="-1"></a>    ood_labels_list.append(label1.numpy())</span>
<span id="cb9-26"><a href="#cb9-26" tabindex="-1"></a></span>
<span id="cb9-27"><a href="#cb9-27" tabindex="-1"></a>train_features <span class="op">=</span> np.concatenate(train_features)</span>
<span id="cb9-28"><a href="#cb9-28" tabindex="-1"></a>train_labels <span class="op">=</span> np.concatenate(train_labels_list)</span>
<span id="cb9-29"><a href="#cb9-29" tabindex="-1"></a>val_features <span class="op">=</span> np.concatenate(val_features)</span>
<span id="cb9-30"><a href="#cb9-30" tabindex="-1"></a>val_labels <span class="op">=</span> np.concatenate(val_labels_list)</span>
<span id="cb9-31"><a href="#cb9-31" tabindex="-1"></a>ood_features <span class="op">=</span> np.concatenate(ood_features)</span>
<span id="cb9-32"><a href="#cb9-32" tabindex="-1"></a>ood_labels <span class="op">=</span> np.concatenate(ood_labels_list)</span>
<span id="cb9-33"><a href="#cb9-33" tabindex="-1"></a></span>
<span id="cb9-34"><a href="#cb9-34" tabindex="-1"></a><span class="co"># Diagnostic print statements</span></span>
<span id="cb9-35"><a href="#cb9-35" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"train_features shape: </span><span class="sc">{</span>train_features<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-36"><a href="#cb9-36" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"train_labels shape: </span><span class="sc">{</span>train_labels<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-37"><a href="#cb9-37" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"val_features shape: </span><span class="sc">{</span>val_features<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-38"><a href="#cb9-38" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"val_labels shape: </span><span class="sc">{</span>val_labels<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-39"><a href="#cb9-39" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"ood_features shape: </span><span class="sc">{</span>ood_features<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-40"><a href="#cb9-40" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"ood_labels shape: </span><span class="sc">{</span>ood_labels<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="dimensionality-reduction-and-visualization-2">3) Dimensionality Reduction and Visualization:<a class="anchor" aria-label="anchor" href="#dimensionality-reduction-and-visualization-2"></a>
</h3>
<ul>
<li>We combine the feature vectors from the training, validation, and
OOD data into a single dataset.</li>
<li>UMAP (Uniform Manifold Approximation and Projection) is used to
reduce the dimensionality of the feature vectors from the
high-dimensional space to 2D, making it possible to visualize the
relationships between different data points.</li>
<li>The reduced features are then plotted, with different colors
representing the training data (T-shirts and Trousers), validation data
(T-shirts and Trousers), and OOD data (Sandals).</li>
</ul>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co"># Ensure the labels array for OOD matches the feature array length</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>combined_features <span class="op">=</span> np.vstack([train_features, val_features, ood_features])</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>combined_labels <span class="op">=</span> np.hstack([train_labels, val_labels, np.full(<span class="bu">len</span>(ood_features), <span class="dv">2</span>)])  <span class="co"># Use 2 for OOD class</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>umap_reducer <span class="op">=</span> umap.UMAP(n_components<span class="op">=</span><span class="dv">2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>umap_results <span class="op">=</span> umap_reducer.fit_transform(combined_features)</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="co"># Split the results back into train, val, and OOD data</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>umap_train_features <span class="op">=</span> umap_results[:<span class="bu">len</span>(train_features)]</span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a>umap_val_features <span class="op">=</span> umap_results[<span class="bu">len</span>(train_features):<span class="bu">len</span>(train_features) <span class="op">+</span> <span class="bu">len</span>(val_features)]</span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a>umap_ood_features <span class="op">=</span> umap_results[<span class="bu">len</span>(train_features) <span class="op">+</span> <span class="bu">len</span>(val_features):]</span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a><span class="co"># Plotting UMAP components for contrastive learning model</span></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a><span class="co"># Plot train T-shirts</span></span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a>scatter1 <span class="op">=</span> plt.scatter(umap_train_features[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">0</span>], umap_train_features[train_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Train T-shirts (ID)'</span>)</span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a><span class="co"># Plot train Trousers</span></span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a>scatter2 <span class="op">=</span> plt.scatter(umap_train_features[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">0</span>], umap_train_features[train_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Train Trousers (ID)'</span>)</span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a><span class="co"># Plot val T-shirts</span></span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a>scatter3 <span class="op">=</span> plt.scatter(umap_val_features[val_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">0</span>], umap_val_features[val_labels <span class="op">==</span> <span class="dv">0</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'blue'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, marker<span class="op">=</span><span class="st">'x'</span>, label<span class="op">=</span><span class="st">'Val T-shirts (ID)'</span>)</span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a><span class="co"># Plot val Trousers</span></span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a>scatter4 <span class="op">=</span> plt.scatter(umap_val_features[val_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">0</span>], umap_val_features[val_labels <span class="op">==</span> <span class="dv">1</span>, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, marker<span class="op">=</span><span class="st">'x'</span>, label<span class="op">=</span><span class="st">'Val Trousers (ID)'</span>)</span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a><span class="co"># Plot OOD Sandals</span></span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a>scatter5 <span class="op">=</span> plt.scatter(umap_ood_features[:, <span class="dv">0</span>], umap_ood_features[:, <span class="dv">1</span>], c<span class="op">=</span><span class="st">'green'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">'OOD Sandals'</span>)</span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a>plt.legend(handles<span class="op">=</span>[scatter1, scatter2, scatter3, scatter4, scatter5])</span>
<span id="cb10-26"><a href="#cb10-26" tabindex="-1"></a>plt.xlabel(<span class="st">'First UMAP Component'</span>)</span>
<span id="cb10-27"><a href="#cb10-27" tabindex="-1"></a>plt.ylabel(<span class="st">'Second UMAP Component'</span>)</span>
<span id="cb10-28"><a href="#cb10-28" tabindex="-1"></a>plt.title(<span class="st">'UMAP of Contrastive Model Features'</span>)</span>
<span id="cb10-29"><a href="#cb10-29" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="limitations-of-threshold-based-ood-detection-methods">Limitations of Threshold-Based OOD Detection Methods<a class="anchor" aria-label="anchor" href="#limitations-of-threshold-based-ood-detection-methods"></a>
</h1>
<p>Threshold-based out-of-distribution (OOD) detection methods are
widely used due to their simplicity and intuitive nature. However, they
come with several significant limitations that need to be
considered:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Dependence on OOD Data Choice</strong>:
<ul>
<li>
<strong>Variety and Representation</strong>: The effectiveness of
threshold-based methods heavily relies on the variety and
representativeness of the OOD data used during threshold selection. If
the chosen OOD samples do not adequately cover the possible range of OOD
scenarios, the threshold may not generalize well to unseen OOD
data.</li>
<li>
<strong>Threshold Determination</strong>: To determine a robust
threshold, it is essential to include a diverse set of OOD samples. This
helps in setting a threshold that can effectively distinguish between
in-distribution and out-of-distribution data across various scenarios.
Without a comprehensive OOD dataset, the threshold might either be too
conservative, causing many ID samples to be misclassified as OOD, or too
lenient, failing to detect OOD samples accurately.</li>
</ul>
</li>
<li>
<strong>Impact of High Thresholds</strong>:
<ul>
<li>
<strong>False OOD Classification</strong>: High thresholds can lead
to a significant number of ID samples being incorrectly classified as
OOD. This false OOD classification results in the loss of potentially
valuable data, reducing the efficiency and performance of the
model.</li>
<li>
<strong>Data Efficiency</strong>: In applications where retaining as
much ID data as possible is crucial, high thresholds can be particularly
detrimental. It’s important to strike a balance between detecting OOD
samples and retaining ID samples to ensure the model’s overall
performance and data efficiency.</li>
</ul>
</li>
<li>
<strong>Sensitivity to Model Confidence</strong>:
<ul>
<li>
<strong>Model Calibration</strong>: Threshold-based methods rely on
the model’s confidence scores, which can be misleading if the model is
poorly calibrated. Overconfident predictions for ID samples or
underconfident predictions for OOD samples can result in suboptimal
threshold settings.</li>
<li>
<strong>Confidence Variability</strong>: The variability in
confidence scores across different models and architectures can make it
challenging to set a universal threshold. Each model might require
different threshold settings, complicating the deployment and
maintenance of threshold-based OOD detection systems.</li>
</ul>
</li>
<li>
<strong>Lack of Discriminative Features</strong>:
<ul>
<li>
<strong>Boundary-Based Detection</strong>: Threshold-based methods
focus on class boundaries rather than learning discriminative features
that can effectively separate ID and OOD samples. This approach can be
less robust, particularly in complex or high-dimensional data spaces
where class boundaries might be less clear.</li>
<li>
<strong>Feature Learning</strong>: By relying solely on confidence
scores, these methods miss the opportunity to learn and leverage
features that are inherently more discriminative. This limitation
highlights the need for advanced techniques like contrastive learning,
which focuses on learning features that distinguish between ID and OOD
samples more effectively.</li>
</ul>
</li>
</ol>
<div class="section level3">
<h3 id="conclusion">Conclusion<a class="anchor" aria-label="anchor" href="#conclusion"></a>
</h3>
<p>While threshold-based OOD detection methods offer a straightforward
approach, their limitations underscore the importance of considering
additional OOD samples for robust threshold determination and the
potential pitfalls of high thresholds. Transitioning to methods that
learn discriminative features rather than relying solely on class
boundaries can address these limitations, paving the way for more
effective OOD detection. This sets the stage for discussing contrastive
learning, which provides a powerful framework for learning such
discriminative features.</p>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div></section><section id="aio-7d-OOD-detection-algo-design"><p>Content from <a href="7d-OOD-detection-algo-design.html">OOD detection: training-time regularization</a></p>
<hr>
<p>Last updated on 2024-11-15 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/7d-OOD-detection-algo-design.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are the key considerations when designing algorithms for OOD
detection?</li>
<li>How can OOD detection be incorporated into the loss functions of
models?</li>
<li>What are the challenges and best practices for training models with
OOD detection capabilities?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand the critical design considerations for creating effective
OOD detection algorithms.</li>
<li>Learn how to integrate OOD detection into the loss functions of
machine learning models.</li>
<li>Identify the challenges in training models with OOD detection and
explore best practices to overcome these challenges.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="training-time-regularization-for-ood-detection">Training-time regularization for OOD detection<a class="anchor" aria-label="anchor" href="#training-time-regularization-for-ood-detection"></a>
</h1>
<p>Training-time regularization methods improve OOD detection by
incorporating penalties into the training process. These penalties
encourage the model to handle OOD data effectively, either by:</p>
<ul>
<li>Penalizing high confidence on OOD samples,</li>
<li>Optimizing feature representations to separate ID and OOD data,</li>
<li>Or enhancing robustness to adversarial or ambiguous inputs.</li>
</ul>
<p>The following methods apply these penalties in different ways:
outlier exposure, contrastive learning, confidence penalties, and
adversarial training.</p>
<div class="section level4">
<h4 id="a-outlier-exposure">2a) Outlier exposure<a class="anchor" aria-label="anchor" href="#a-outlier-exposure"></a>
</h4>
<p>Outlier Exposure (OE) penalizes high confidence on OOD samples by
introducing auxiliary datasets during training. This method teaches the
model to differentiate OOD data from ID data.</p>
<p><strong>How it works</strong>:</p>
<ul>
<li>Use a curated auxiliary dataset of OOD samples that differ from the
training distribution.</li>
<li>Augment the training loss function to penalize high confidence on
these auxiliary samples.</li>
<li>Resulting models are less likely to misclassify OOD inputs as
ID.</li>
</ul>
<table class="table">
<colgroup>
<col width="33%">
<col width="66%">
</colgroup>
<thead><tr class="header">
<th><strong>Advantages</strong></th>
<th><strong>Limitations</strong></th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Simple to implement when auxiliary datasets are available.</td>
<td>Requires access to high-quality, diverse OOD datasets during
training.</td>
</tr>
<tr class="even">
<td>Improves OOD detection performance without significant computational
cost.</td>
<td>Performance may degrade for OOD samples dissimilar to the auxiliary
dataset.</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="b-contrastive-learning">2b) Contrastive learning<a class="anchor" aria-label="anchor" href="#b-contrastive-learning"></a>
</h4>
<p>Contrastive learning optimizes feature representations by applying
penalties that control the similarity of embeddings. Positive pairs
(similar samples) are brought closer together, while negative pairs
(dissimilar samples) are pushed apart. This results in a feature space
where OOD data is less likely to overlap with ID data.</p>
<p><strong>How it works</strong>:</p>
<ul>
<li>Define a contrastive loss that minimizes the distance between
embeddings of similar samples (e.g., belonging to the same class).</li>
<li>Simultaneously maximize the distance between embeddings of
dissimilar samples (e.g., ID vs. synthetic or auxiliary OOD
samples).</li>
<li>Often uses data augmentation or self-supervised techniques to
generate “positive” and “negative” pairs.</li>
</ul>
<table class="table">
<colgroup>
<col width="33%">
<col width="66%">
</colgroup>
<thead><tr class="header">
<th><strong>Advantages</strong></th>
<th><strong>Limitations</strong></th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Does not require labeled auxiliary OOD data, as augmentations or
unsupervised data can be used.</td>
<td>Computationally expensive, especially with large datasets.</td>
</tr>
<tr class="even">
<td>Improves the quality of learned representations, benefiting other
tasks.</td>
<td>Requires careful tuning of the contrastive loss and data
augmentation strategy.</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="c-other-regularization-based-techniques">2c) Other regularization-based techniques<a class="anchor" aria-label="anchor" href="#c-other-regularization-based-techniques"></a>
</h4>
<p>Other methods incorporate penalties directly into the training
process to improve robustness to OOD data:</p>
<ul>
<li>
<strong>Confidence penalties</strong>: Penalize overconfidence in
predictions, especially on ambiguous samples.</li>
<li>
<strong>Adversarial training</strong>: Generate adversarial examples
(slightly perturbed ID samples) to penalize high confidence on these
perturbed examples, improving robustness.</li>
</ul>
<table class="table">
<colgroup>
<col width="33%">
<col width="66%">
</colgroup>
<thead><tr class="header">
<th><strong>Advantages</strong></th>
<th><strong>Limitations</strong></th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Enhances OOD detection performance by integrating it into the
training process.</td>
<td>Requires careful design of the training procedure and loss
function.</td>
</tr>
<tr class="even">
<td>Leads to better generalization for both ID and OOD scenarios.</td>
<td>Computationally intensive and may need access to additional
datasets.</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="summary-of-training-time-regularization-methods">Summary of Training-Time Regularization Methods<a class="anchor" aria-label="anchor" href="#summary-of-training-time-regularization-methods"></a>
</h4>
<table class="table">
<colgroup>
<col width="14%">
<col width="32%">
<col width="20%">
<col width="33%">
</colgroup>
<thead><tr class="header">
<th><strong>Method</strong></th>
<th><strong>Penalty Applied</strong></th>
<th><strong>Advantages</strong></th>
<th><strong>Limitations</strong></th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Outlier Exposure</td>
<td>High confidence on auxiliary OOD data.</td>
<td>Simple to implement, improves performance.</td>
<td>Requires high-quality auxiliary datasets, may not generalize to
unseen OOD data.</td>
</tr>
<tr class="even">
<td>Contrastive Learning</td>
<td>Embedding similarity for dissimilar samples (and vice versa)</td>
<td>Improves feature space quality, versatile.</td>
<td>Computationally expensive, requires careful tuning.</td>
</tr>
<tr class="odd">
<td>Confidence Penalties</td>
<td>Overconfidence on ambiguous inputs.</td>
<td>Improves robustness, generalizes well.</td>
<td>Requires careful design, computationally intensive.</td>
</tr>
<tr class="even">
<td>Adversarial Training</td>
<td>High confidence on adversarial examples.</td>
<td>Enhances robustness to perturbed inputs.</td>
<td>Computationally intensive, challenging to implement.</td>
</tr>
</tbody>
</table>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Training-time regularization enhances OOD detection by incorporating
techniques like Outlier Exposure and Contrastive Learning during model
training.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div></section><section id="aio-8-releasing-a-model"><p>Content from <a href="8-releasing-a-model.html">Documenting and releasing a model</a></p>
<hr>
<p>Last updated on 2024-09-25 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/8-releasing-a-model.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 0 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Why is model sharing important in the context of reproducibility and
responsible use?</li>
<li>What are the challenges, risks, and ethical considerations related
to sharing models?</li>
<li>How can model-sharing best practices be applied using tools like
model cards and the Hugging Face platform?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand the importance of model sharing and best practices to
ensure reproducibility and responsible use of models.</li>
<li>Understand the challenges, risks, and ethical concerns associated
with model sharing.</li>
<li>Apply model-sharing best practices through using model cards and the
Hugging Face platform.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Model cards are the standard technique for communicating information
about how machine learning systems were trained and how they should and
should not be used.</li>
<li>Models can be shared and reused via the Hugging Face platform.</li>
</ul>
</div>
</div>
</div>
<div id="why-should-we-share-trained-models" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="why-should-we-share-trained-models" class="callout-inner">
<h3 class="callout-title">Why should we share trained models?</h3>
<div class="callout-content">
<p>Discuss in small groups and report out: <em>Why do you believe it is
or isn’t important to share ML models? How has model-sharing contributed
to your experiences or projects?</em></p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<ul>
<li>
<strong>Accelerating research</strong>: Sharing models allows
researchers and practitioners to build upon existing work, accelerating
the pace of innovation in the field.</li>
<li>
<strong>Knowledge exchange</strong>: Model sharing promotes
knowledge exchange and collaboration within the machine learning
community, fostering a culture of open science.</li>
<li>
<strong>Reproducibility</strong>: Sharing models, along with
associated code and data, enhances reproducibility, enabling others to
validate and verify the results reported in research papers.</li>
<li>
<strong>Benchmarking</strong>: Shared models serve as benchmarks for
comparing new models and algorithms, facilitating the evaluation and
improvement of state-of-the-art techniques.</li>
<li>
<strong>Education / Accessibility to state-of-the-art
architectures</strong>: Shared models provide valuable resources for
educational purposes, allowing students and learners to explore and
experiment with advanced machine learning techniques.</li>
<li>
<strong>Repurpose (transfer learning and finetuning)</strong>: Some
models (i.e., foundation models) can be repurposed for a wide variety of
tasks. This is especially useful when working with limited data. Data
scarcity</li>
<li>
<strong>Resource efficiency</strong>: Instead of training a model
from the ground up, practitioners can use existing models as a starting
point, saving time, computational resources, and energy.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="challenges-and-risks-of-model-sharing" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="challenges-and-risks-of-model-sharing" class="callout-inner">
<h3 class="callout-title">Challenges and risks of model sharing</h3>
<div class="callout-content">
<p>Discuss in small groups and report out: <em>What are some potential
challenges, risks, or ethical concerns associated with model sharing and
reproducing ML workflows?</em></p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<ul>
<li>
<strong>Privacy concerns</strong>: Sharing models that were trained
on sensitive or private data raises privacy concerns. The potential
disclosure of personal information through the model poses a risk to
individuals and can lead to unintended consequences.</li>
<li>
<strong>Informed consent</strong>: If models involve user data,
ensuring informed consent is crucial. Sharing models trained on
user-generated content without clear consent may violate privacy norms
and regulations.</li>
<li>
<strong>Intellectual property</strong>: Models may be developed
within organizations with proprietary data and methodologies. Sharing
such models without proper consent or authorization may lead to
intellectual property disputes and legal consequences.</li>
<li>
<strong>Model robustness and generalization</strong>: Reproduced
models may not generalize well to new datasets or real-world scenarios.
Failure to account for the limitations of the original model can result
in reduced performance and reliability in diverse settings.</li>
<li>
<strong>Lack of reproducibility</strong>: Incomplete documentation,
missing details, or changes in dependencies over time can hinder the
reproducibility of ML workflows. This lack of reproducibility can impede
scientific progress and validation of research findings.</li>
<li>
<strong>Unintended use and misuse</strong>: Shared models may be
used in unintended ways, leading to ethical concerns. Developers should
consider the potential consequences of misuse, particularly in
applications with societal impact, such as healthcare or law
enforcement.</li>
<li>
<strong>Responsible AI considerations</strong>: Ethical
considerations, such as fairness, accountability, and transparency,
should be addressed during model sharing. Failing to consider these
aspects can result in models that inadvertently discriminate or lack
interpretability. Models used for decision-making, especially in
critical areas like healthcare or finance, should be ethically deployed.
Transparent documentation and disclosure of how decisions are made are
essential for responsible AI adoption.</li>
</ul>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="saving-the-model-locally">Saving the model locally<a class="anchor" aria-label="anchor" href="#saving-the-model-locally"></a>
</h2>
<hr class="half-width">
<p>Let’s review the simplest method for sharing a model first — saving
the model locally. When working with PyTorch, it’s important to know how
to save and load models efficiently. This process ensures that you can
pause your work, share your models, or deploy them for inference without
having to retrain them from scratch each time.</p>
<div class="section level3">
<h3 id="defining-the-model">Defining the model<a class="anchor" aria-label="anchor" href="#defining-the-model"></a>
</h3>
<p>As an example, we’ll configure a simple perceptron (single hidden
layer) in PyTorch. We’ll define a bare bones class for this just so we
can initialize the model.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Dict, Any</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="kw">class</span> MyModel(nn.Module):</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, config: Dict[<span class="bu">str</span>, <span class="bu">int</span>]):</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>        <span class="co"># Parameter is a trainable tensor initialized with random values</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>        <span class="va">self</span>.param <span class="op">=</span> nn.Parameter(torch.rand(config[<span class="st">"num_channels"</span>], config[<span class="st">"hidden_size"</span>]))</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>        <span class="co"># Linear layer (fully connected layer) for the output</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>        <span class="va">self</span>.linear <span class="op">=</span> nn.Linear(config[<span class="st">"hidden_size"</span>], config[<span class="st">"num_classes"</span>])</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>        <span class="co"># Store the configuration</span></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>        <span class="va">self</span>.config <span class="op">=</span> config</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x: torch.Tensor) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>        <span class="co"># Forward pass: Add the input to the param tensor, then pass through the linear layer</span></span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.linear(x <span class="op">+</span> <span class="va">self</span>.param)</span></code></pre>
</div>
<p>Initialize model by calling the class with configuration
settings.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Create model instance with specific configuration</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>config <span class="op">=</span> {<span class="st">"num_channels"</span>: <span class="dv">3</span>, <span class="st">"hidden_size"</span>: <span class="dv">32</span>, <span class="st">"num_classes"</span>: <span class="dv">10</span>}</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>model <span class="op">=</span> MyModel(config<span class="op">=</span>config)</span></code></pre>
</div>
<p>We can then write a function to save out the model. We’ll need both
the model weights and the model’s configuration (hyperparameter
settings). We’ll save the configurations as a json since a key/value
format is convenient here.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="im">import</span> json</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="co"># Function to save model and config locally</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="kw">def</span> save_model(model: nn.Module, model_path: <span class="bu">str</span>, config_path: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>    <span class="co"># Save model state dict (weights and biases) as a .pth file</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>    torch.save(model.state_dict(), model_path) <span class="co">#</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>    <span class="co"># Save config</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(config_path, <span class="st">'w'</span>) <span class="im">as</span> f:</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>        json.dump(model.config, f)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Save the model and config locally</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>save_model(model, <span class="st">"my_awesome_model.pth"</span>, <span class="st">"my_awesome_model_config.json"</span>)</span></code></pre>
</div>
<p>To load the model back in, we can write another function</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># Function to load model and config locally</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="kw">def</span> load_model(model_class: Any, model_path: <span class="bu">str</span>, config_path: <span class="bu">str</span>) <span class="op">-&gt;</span> nn.Module:</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>    <span class="co"># Load config</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(config_path, <span class="st">'r'</span>) <span class="im">as</span> f:</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>        config <span class="op">=</span> json.load(f)</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>    <span class="co"># Create model instance with config</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>    model <span class="op">=</span> model_class(config<span class="op">=</span>config)</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>    <span class="co"># Load model state dict</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>    model.load_state_dict(torch.load(model_path))</span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>    <span class="cf">return</span> model</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># Load the model and config locally</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>loaded_model <span class="op">=</span> load_model(MyModel, <span class="st">"my_awesome_model.pth"</span>, <span class="st">"my_awesome_model_config.json"</span>)</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co"># Verify the loaded model</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="bu">print</span>(loaded_model)</span></code></pre>
</div>
</div>
</section><section><h2 class="section-heading" id="saving-a-model-to-hugging-face">Saving a model to Hugging Face<a class="anchor" aria-label="anchor" href="#saving-a-model-to-hugging-face"></a>
</h2>
<hr class="half-width">
<p>To share your model with a wider audience, we recommend uploading
your model to Hugging Face. Hugging Face is a very popular machine
learning (ML) platform and community that helps users build, deploy,
share, and train machine learning models. It has quickly become the
go-to option for sharing models with the public.</p>
<div class="section level3">
<h3 id="create-a-hugging-face-account-and-access-token">Create a Hugging Face account and access Token<a class="anchor" aria-label="anchor" href="#create-a-hugging-face-account-and-access-token"></a>
</h3>
<p>If you haven’t completed these steps from the setup, make sure to do
this now.</p>
<p><strong>Create account</strong>: To create an account on Hugging
Face, visit: <a href="https://huggingface.co/join" class="external-link">huggingface.co/join</a>. Enter an
email address and password, and follow the instructions provided via
Hugging Face (you may need to verify your email address) to complete the
process.</p>
<p><strong>Setup access token</strong>: Once you have your account
created, you’ll need to generate an access token so that you can
upload/share models to your Hugging Face account during the workshop. To
generate a token, visit the <a href="https://huggingface.co/settings/tokens" class="external-link">Access Tokens setting
page</a> after logging in.</p>
</div>
<div class="section level3">
<h3 id="login-to-hugging-face-account">Login to Hugging Face account<a class="anchor" aria-label="anchor" href="#login-to-hugging-face-account"></a>
</h3>
<p>To login, you will need to retrieve your access token from the <a href="https://huggingface.co/settings/tokens" class="external-link">Access Tokens setting
page</a></p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="op">!</span>huggingface<span class="op">-</span>cli login</span></code></pre>
</div>
<p>You might get a message saying you cannot authenticate through
git-credential as no helper is defined on your machine. This warning
message should not stop you from being able to complete this episode,
but it may mean that the token won’t be stored on your machine for
future use.</p>
<p>Once logged in, we will need to edit our model class definition to
include Hugging Face’s “push_to_hub” attribute. To enable the
push_to_hub functionality, you’ll need to include the
PyTorchModelHubMixin “mixin class” provided by the huggingface_hub
library. A mixin class is a type of class used in object-oriented
programming to “mix in” additional properties and methods into a class.
The PyTorchModelHubMixin class adds methods to your PyTorch model to
enable easy saving and loading from the Hugging Face Model Hub.</p>
<p>Here’s how you can adjust the code to incorporate both saving/loading
locally and pushing the model to the Hugging Face Hub.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="im">from</span> huggingface_hub <span class="im">import</span> PyTorchModelHubMixin <span class="co"># NEW</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="kw">class</span> MyModel(nn.Module, PyTorchModelHubMixin): <span class="co"># PyTorchModelHubMixin is new</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, config: Dict[<span class="bu">str</span>, Any]):</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>        <span class="co"># Initialize layers and parameters</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>        <span class="va">self</span>.param <span class="op">=</span> nn.Parameter(torch.rand(config[<span class="st">"num_channels"</span>], config[<span class="st">"hidden_size"</span>]))</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>        <span class="va">self</span>.linear <span class="op">=</span> nn.Linear(config[<span class="st">"hidden_size"</span>], config[<span class="st">"num_classes"</span>])</span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>        <span class="va">self</span>.config <span class="op">=</span> config</span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x: torch.Tensor) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.linear(x <span class="op">+</span> <span class="va">self</span>.param)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># Create model instance with specific configuration</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>config <span class="op">=</span> {<span class="st">"num_channels"</span>: <span class="dv">3</span>, <span class="st">"hidden_size"</span>: <span class="dv">32</span>, <span class="st">"num_classes"</span>: <span class="dv">10</span>}</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>model <span class="op">=</span> MyModel(config<span class="op">=</span>config)</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="bu">print</span>(model)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co"># push to the hub</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>model.push_to_hub(<span class="st">"my-awesome-model"</span>, config<span class="op">=</span>config)</span></code></pre>
</div>
<p><strong>Verifying</strong>: To check your work, head back over to
your Hugging Face account and click your profile icon in the top-right
of the website. Click “Profile” from there to view all of your uploaded
models. Alternatively, you can search for your username (or model name)
from the <a href="https://huggingface.co/models" class="external-link">Model Hub</a>.</p>
<div class="section level4">
<h4 id="loading-the-model-from-hugging-face">Loading the model from Hugging Face<a class="anchor" aria-label="anchor" href="#loading-the-model-from-hugging-face"></a>
</h4>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="co"># reload</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>model <span class="op">=</span> MyModel.from_pretrained(<span class="st">"your-username/my-awesome-model"</span>)</span></code></pre>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="uploading-transformer-models-to-hugging-face">Uploading transformer models to Hugging Face<a class="anchor" aria-label="anchor" href="#uploading-transformer-models-to-hugging-face"></a>
</h2>
<hr class="half-width">
<p>Key Differences</p>
<ul>
<li>
<strong>Saving and Loading the Tokenizer</strong>: Transformer
models require a tokenizer that needs to be saved and loaded with the
model. This is not necessary for custom PyTorch models that typically do
not require a separate tokenizer.</li>
<li>
<strong>Using Pre-trained Classes</strong>: Transformer models use
classes like AutoModelForSequenceClassification and AutoTokenizer from
the transformers library, which are pre-built and designed for specific
tasks (e.g., sequence classification).</li>
<li>
<strong>Methods for Saving and Loading</strong>: The transformers
library provides save_pretrained and from_pretrained methods for both
models and tokenizers, which handle the serialization and
deserialization processes seamlessly.</li>
</ul>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> AutoModelForSequenceClassification, AutoTokenizer</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="co"># Load a pre-trained model and tokenizer</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>model_name <span class="op">=</span> <span class="st">"bert-base-uncased"</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>model <span class="op">=</span> AutoModelForSequenceClassification.from_pretrained(model_name, num_labels<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(model_name)</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a><span class="co"># Save the model and tokenizer locally</span></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>model.save_pretrained(<span class="st">"my_transformer_model"</span>)</span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>tokenizer.save_pretrained(<span class="st">"my_transformer_model"</span>)</span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a><span class="co"># Load the model and tokenizer from the saved directory</span></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a>loaded_model <span class="op">=</span> AutoModelForSequenceClassification.from_pretrained(<span class="st">"my_transformer_model"</span>)</span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a>loaded_tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(<span class="st">"my_transformer_model"</span>)</span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a><span class="co"># Verify the loaded model and tokenizer</span></span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a><span class="bu">print</span>(loaded_model)</span>
<span id="cb12-18"><a href="#cb12-18" tabindex="-1"></a><span class="bu">print</span>(loaded_tokenizer)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="co"># Push the model and tokenizer to Hugging Face Hub</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>model.push_to_hub(<span class="st">"my-awesome-transformer-model"</span>)</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>tokenizer.push_to_hub(<span class="st">"my-awesome-transformer-model"</span>)</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a><span class="co"># Load the model and tokenizer from the Hugging Face Hub</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>hub_model <span class="op">=</span> AutoModelForSequenceClassification.from_pretrained(<span class="st">"user-name/my-awesome-transformer-model"</span>)</span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a>hub_tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(<span class="st">"user-name/my-awesome-transformer-model"</span>)</span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a><span class="co"># Verify the model and tokenizer loaded from the hub</span></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="bu">print</span>(hub_model)</span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a><span class="bu">print</span>(hub_tokenizer)</span></code></pre>
</div>
<div id="what-pieces-must-be-well-documented-to-ensure-reproducible-and-responsible-model-sharing" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="what-pieces-must-be-well-documented-to-ensure-reproducible-and-responsible-model-sharing" class="callout-inner">
<h3 class="callout-title">What pieces must be well-documented to ensure reproducible and responsible model sharing?</h3>
<div class="callout-content">
<p>Discuss in small groups and report out: <em>What type of information
needs to be included in the documentation when sharing a model?</em></p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" data-bs-parent="#accordionSolution3" aria-labelledby="headingSolution3">
<div class="accordion-body">
<ul>
<li>Environment setup</li>
<li>Training data
<ul>
<li>How the data was collected</li>
<li>Who owns the data: data license and usage terms</li>
<li>Basic descriptive statistics: number of samples, features, classes,
etc.</li>
<li>Note any class imbalance or general bias issues</li>
<li>Description of data distribution to help prevent out-of-distribution
failures.</li>
</ul>
</li>
<li>Preprocessing steps.
<ul>
<li>Data splitting</li>
<li>Standardization method</li>
<li>Feature selection</li>
<li>Outlier detection and other filters</li>
</ul>
</li>
<li>Model architecture, hyperparameters and, training procedure (e.g.,
dropout or early stopping)</li>
<li>Model weights</li>
<li>Evaluation metrics. Results and performance. The more tasks/datasets
you can evaluate on, the better.</li>
<li>Ethical considerations: Include investigations of bias/fairness when
applicable (i.e., if your model involves human data or affects
decision-making involving humans)</li>
<li>Contact info</li>
<li>Acknowledgments</li>
<li>Examples and demos (highly recommended)</li>
</ul>
</div>
</div>
</div>
</div>
<div id="document-your-model" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="document-your-model" class="callout-inner">
<h3 class="callout-title">Document your model</h3>
<div class="callout-content">
<p>For this challenge, you have two options:</p>
<ol style="list-style-type: decimal">
<li><p>Start writing a model card for a model you have created for your
research. The solution from the previous challenge or this <a href="https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/templates/modelcard_template.md" class="external-link">template</a>
from Hugging Face are good places to start, but note that not all fields
may be relevant, depending on what your model does.</p></li>
<li><p>Find a model on <a href="https://huggingface.co/" class="external-link">HuggingFace</a>
that has a model card, for example, you could search for models using
terms like “sentiment classification” or “medical”. Read the model card
and evaluate whether the information is clear and complete. Would you be
able to recreate the model based on the information presented? Do you
feel that there is enough information to be able to evaluate you would
be able to adapt this model for your purposes? You can refer to the
previous challenge’s solution for ideas of what information should be
included, but note that not all sections are relevant to all
models.</p></li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" data-bs-parent="#accordionSolution4" aria-labelledby="headingSolution4">
<div class="accordion-body">
<p>Pair up with a classmate and discuss what you wrote/read. Do model
cards seem like a useful tool for you moving forwards?</p>
</div>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section>
</div>
    </main>
</div>
<!-- END  : inst/pkgdown/templates/content-extra.html -->

      </div>
<!--/div.row-->
      		<footer class="row footer mx-md-3"><hr>
<div class="col-md-6">
        <p>This lesson is subject to the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a></p>
        <p>

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/README.md" class="external-link">Edit on GitHub</a>

	
        | <a href="https://github.com/carpentries-incubator/fair-explainable-ml/blob/main/CONTRIBUTING.md" class="external-link">Contributing</a>
        | <a href="https://github.com/carpentries-incubator/fair-explainable-ml/" class="external-link">Source</a></p>
				<p><a href="https://github.com/carpentries-incubator/fair-explainable-ml/blob/main/CITATION" class="external-link">Cite</a> | <a href="mailto:apmeyer4@wisc.edu">Contact</a> | <a href="https://carpentries.org/about/" class="external-link">About</a></p>
			</div>
			<div class="col-md-6">

        <p>Materials licensed under <a href="LICENSE.html">CC-BY 4.0</a> by the authors</p>

        <p>Template licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/" class="external-link">CC-BY 4.0</a> by <a href="https://carpentries.org/" class="external-link">The Carpentries</a></p>
        <p>Built with <a href="https://github.com/carpentries/sandpaper/tree/0.16.10" class="external-link">sandpaper (0.16.10)</a>, <a href="https://github.com/carpentries/pegboard/tree/0.7.7" class="external-link">pegboard (0.7.7)</a>, and <a href="https://github.com/carpentries/varnish/tree/1.0.5" class="external-link">varnish (1.0.5)</a></p>
			</div>
		</footer>
</div> <!-- / div.container -->
	<div id="to-top">
		<a href="#top">
      <i class="search-icon" data-feather="arrow-up" role="img" aria-label="Back To Top"></i><br><!-- <span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top --><span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top
		</a>
	</div>
  <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "TrainingMaterial",
  "@id": "https://carpentries-incubator.github.io/fair-explainable-ml/instructor/aio.html",
  "inLanguage": "en",
  "dct:conformsTo": "https://bioschemas.org/profiles/TrainingMaterial/1.0-RELEASE",
  "description": "A Carpentries Lesson teaching foundational data and coding skills to researchers worldwide",
  "keywords": "fairness, explainability, fair machine learning, interpretable machine learning, xai, lesson, The Carpentries",
  "name": "All in One View",
  "creativeWorkStatus": "active",
  "url": "https://carpentries-incubator.github.io/fair-explainable-ml/instructor/aio.html",
  "identifier": "https://carpentries-incubator.github.io/fair-explainable-ml/instructor/aio.html",
  "dateCreated": "2023-12-05",
  "dateModified": "2024-11-15",
  "datePublished": "2024-11-15"
}

  </script><script>
		feather.replace();
	</script>
</body>
</html><!-- END:   inst/pkgdown/templates/layout.html-->

