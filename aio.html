<!DOCTYPE html>
<!-- START: inst/pkgdown/templates/layout.html --><!-- Generated by pkgdown: do not edit by hand --><html lang="en" data-bs-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Trustworthy AI: Explainability, Bias, and Fairness: All in One View</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="assets/themetoggle.js"></script><link rel="stylesheet" type="text/css" href="assets/styles.css">
<script src="assets/scripts.js" type="text/javascript"></script><!-- mathjax --><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      config: ["MMLorHTML.js"],
      jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [['\\(', '\\)']],
        displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
        processEscapes: true
      }
    });
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><!-- Responsive Favicon for The Carpentries --><link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="manifest" href="site.webmanifest">
<link rel="mask-icon" href="safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="white">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="black">
</head>
<body>
    <header id="top" class="navbar navbar-expand-md top-nav incubator"><svg xmlns="http://www.w3.org/2000/svg" class="d-none"><symbol id="check2" viewbox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path></symbol><symbol id="circle-half" viewbox="0 0 16 16"><path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path></symbol><symbol id="moon-stars-fill" viewbox="0 0 16 16"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path><path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"></path></symbol><symbol id="sun-fill" viewbox="0 0 16 16"><path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></symbol></svg><a class="visually-hidden-focusable skip-link" href="#main-content">Skip to main content</a>
  <div class="container-fluid top-nav-container">
    <div class="col-md-8">
      <div class="large-logo">
        <img id="incubator-logo" alt="Carpentries Incubator" src="assets/images/incubator-logo.svg"><span class="badge text-bg-danger">
          <abbr title="This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.">
            <a href="https://cdh.carpentries.org/the-lesson-life-cycle.html#early-development-pre-alpha-through-alpha" class="external-link alert-link">
              <i aria-hidden="true" class="icon" data-feather="alert-octagon" style="border-radius: 5px"></i>
              Pre-Alpha
            </a>
            <span class="visually-hidden">This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.</span>
          </abbr>
        </span>

      </div>
    </div>
    <div class="selector-container">
      <div id="theme-selector">
        <li class="nav-item dropdown" id="theme-button-list">
          <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
            <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="bd-theme-text">
<li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                Light
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                Dark
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                Auto
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
          </ul>
</li>
      </div>

      <div class="dropdown" id="instructor-dropdown">
        <button class="btn btn-secondary dropdown-toggle bordered-button" type="button" id="dropdownMenu1" data-bs-toggle="dropdown" aria-expanded="false">
          <i aria-hidden="true" class="icon" data-feather="eye"></i> Learner View <i data-feather="chevron-down"></i>
        </button>
        <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
<li><button class="dropdown-item" type="button" onclick="window.location.href='instructor/aio.html';">Instructor View</button></li>
        </ul>
</div>
    </div>
  </div>
  <hr></header><nav class="navbar navbar-expand-xl bottom-nav incubator" aria-label="Main Navigation"><div class="container-fluid nav-container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle Navigation">
      <span class="navbar-toggler-icon"></span>
      <span class="menu-title">Menu</span>
    </button>
    <div class="nav-logo">
      <img class="small-logo" alt="Carpentries Incubator" src="assets/images/incubator-logo-sm.svg">
</div>
    <div class="lesson-title-md">
      Trustworthy AI: Explainability, Bias, and Fairness
    </div>
    <div class="search-icon-sm">
      <!-- TODO: do not show until we have search
        <i role="img" aria-label="Search the All In One page" data-feather="search"></i>
      -->
    </div>
    <div class="desktop-nav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
<li class="nav-item">
          <span class="lesson-title">
            Trustworthy AI: Explainability, Bias, and Fairness
          </span>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="key-points.html">Key Points</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="reference.html#glossary">Glossary</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="profiles.html">Learner Profiles</a>
        </li>
        <li class="nav-item dropdown">
          <button class="nav-link dropdown-toggle" id="navbarDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            More <i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
<li><a class="dropdown-item" href="reference.html">Reference</a></li>
          </ul>
</li>
      </ul>
</div>
    <!--
    <form class="d-flex col-md-2 search-form">
      <fieldset disabled>
      <input class="form-control me-2 searchbox" type="search" placeholder="" aria-label="">
        <button class="btn btn-outline-success tablet-search-button"  type="submit">
          <i class="search-icon" data-feather="search" role="img" aria-label="Search the All In One page"></i>
        </button>
      </fieldset>
    </form>
    -->
    <a id="search-button" class="btn btn-primary" href="aio.html" role="button" aria-label="Search the All In One page">Search the All In One page</a>
  </div>
<!--/div.container-fluid -->
</nav><div class="col-md-12 mobile-title">
  Trustworthy AI: Explainability, Bias, and Fairness
</div>

<aside class="col-md-12 lesson-progress"><div style="width: %" class="percentage">
    %
  </div>
  <div class="progress incubator">
    <div class="progress-bar incubator" role="progressbar" style="width: %" aria-valuenow="" aria-label="Lesson Progress" aria-valuemin="0" aria-valuemax="100">
    </div>
  </div>
</aside><div class="container">
      <div class="row">
        <!-- START: inst/pkgdown/templates/navbar.html -->
<div id="sidebar-col" class="col-lg-4">
  <div id="sidebar" class="sidebar">
      <nav aria-labelledby="flush-headingEleven"><button role="button" aria-label="close menu" alt="close menu" aria-expanded="true" aria-controls="sidebar" class="collapse-toggle" data-collapse="Collapse " data-episodes="Episodes ">
          <i class="search-icon" data-feather="x" role="img"></i>
        </button>
        <div class="sidebar-inner">
          <div class="row mobile-row" id="theme-row-mobile">
            <div class="col" id="theme-selector">
              <li class="nav-item dropdown" id="theme-button-list">
                <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
                  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><span class="d-lg-none ms-1" id="bd-theme-text">Toggle Theme</span>
                </button>
                <ul class="dropdown-menu dropdown-menu-right" aria-labelledby="bd-theme-text">
<li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                      Light
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                      Dark
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                      <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                      Auto
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                </ul>
</li>
            </div>
          </div>
          <div class="row mobile-row">
            <div class="col">
              <div class="sidenav-view-selector">
                <div class="accordion accordion-flush" id="accordionFlush9">
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingNine">
                      <button class="accordion-button collapsed" id="instructor" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <i id="eye" aria-hidden="true" class="icon" data-feather="eye"></i> Learner View
                      </button>
                    </h2>
                    <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlush2">
                      <div class="accordion-body">
                        <a href="instructor/aio.html">Instructor View</a>
                      </div>
                    </div>
                  </div>
<!--/div.accordion-item-->
                </div>
<!--/div.accordion-flush-->
              </div>
<!--div.sidenav-view-selector -->
            </div>
<!--/div.col -->

            <hr>
</div>
<!--/div.mobile-row -->

          <div class="accordion accordion-flush" id="accordionFlush11">
            <div class="accordion-item">

              <button id="chapters" class="accordion-button show" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                <h2 class="accordion-header chapters" id="flush-headingEleven">
                  EPISODES
                </h2>
              </button>
              <div id="flush-collapseEleven" class="accordion-collapse show collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlush11">

                <div class="accordion-body">
                  <div class="accordion accordion-flush" id="accordionFlush1">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading1">
        <a href="index.html">Summary and Setup</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush2">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading2">
        <a href="0-introduction.html">1. Overview</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush3">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading3">
        <a href="1-preparing-to-train.html">2. Preparing to train a model</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush4">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading4">
        <a href="2-model-fitting.html">3. Scientific validity in the modeling process</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush5">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading5">
        <a href="3-model-eval-and-fairness.html">4. Model evaluation and fairness</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush6">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading6">
        <a href="4-explainability-vs-interpretability.html">5. Interpretablility versus explainability</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush7">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading7">
        <a href="5a-explainable-AI-method-overview.html">6. Explainability methods overview</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush8">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading8">
        <a href="5b-deep-dive-into-methods.html">7. Explainability methods: deep dive</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush9">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading9">
        <a href="5c-probes.html">8. Explainability methods: linear probe</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush10">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading10">
        <a href="5d-gradcam.html">9. Explainability methods: GradCAM</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush11">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading11">
        <a href="6-confidence-intervals.html">10. Estimating model uncertainty</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush12">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading12">
        <a href="7-distribution-shift-OOD-detection.html">11. Distribution shift and OOD detection</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush13">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading13">
        <a href="8-releasing-a-model.html">12. Documenting and releasing a model</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

                </div>
              </div>
            </div>

            <hr class="half-width">
<div class="accordion accordion-flush resources" id="accordionFlush12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingTwelve">
                  <button class="accordion-button collapsed" id="resources" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                    RESOURCES
                  </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlush12">
                  <div class="accordion-body">
                    <ul>
<li>
                        <a href="key-points.html">Key Points</a>
                      </li>
                      <li>
                        <a href="reference.html#glossary">Glossary</a>
                      </li>
                      <li>
                        <a href="profiles.html">Learner Profiles</a>
                      </li>
                      <li><a href="reference.html">Reference</a></li>
                    </ul>
</div>
                </div>
              </div>
            </div>
            <hr class="half-width resources">
<a href="aio.html">See all in one page</a>


            <hr class="d-none d-sm-block d-md-none">
<div class="d-grid gap-1">

            </div>
          </div>
<!-- /div.accordion -->
        </div>
<!-- /div.sidebar-inner -->
      </nav>
</div>
<!-- /div.sidebar -->
  </div>
<!-- /div.sidebar-col -->
<!-- END:   inst/pkgdown/templates/navbar.html-->

        <!-- START: inst/pkgdown/templates/content-extra.html -->
  <div class="col-xl-8 col-lg-12 primary-content">
    <main id="main-content" class="main-content"><div class="container lesson-content">
        
        
<section id="aio-0-introduction"><p>Content from <a href="0-introduction.html">Overview</a></p>
<hr>
<p>Last updated on 2024-06-19 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/0-introduction.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 --></section></section><section id="aio-1-preparing-to-train"><p>Content from <a href="1-preparing-to-train.html">Preparing to train a model</a></p>
<hr>
<p>Last updated on 2024-07-31 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/1-preparing-to-train.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>For what prediction tasks is machine learning an appropriate
tool?</li>
<li>How can inappropriate target variable choice lead to suboptimal
outcomes in a machine learning pipeline?</li>
<li>What forms of “bias” can occur in machine learning, and where do
these biases come from?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Judge what tasks are appropriate for machine learning</li>
<li>Understand why the choice of prediction task / target variable is
important.</li>
<li>Describe how bias can appear in training data and algorithms.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="choosing-appropriate-tasks">Choosing appropriate tasks<a class="anchor" aria-label="anchor" href="#choosing-appropriate-tasks"></a>
<a class="anchor" aria-label="anchor" href="#choosing-appropriate-tasks"></a>
</h2>
<hr class="half-width">
<p>Machine learning is a rapidly advancing, powerful technology that is
helping to drive innovation. Before embarking on a machine learning
project, we need to consider the task carefully. Many machine learning
efforts are not solving problems that need to be solved. Or, the problem
may be valid, but the machine learning approach makes incorrect
assumptions and fails to solve the problem effectively. Worse, many
applications of machine learning are not for the public good.</p>
<p>We will start by considering the <a href="https://www.nih.gov/health-information/nih-clinical-research-trials-you/guiding-principles-ethical-research" class="external-link">NIH
Guiding Principles for Ethical Research</a>, which provide a useful set
of considerations for any project.</p>
<div id="discussion1" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge<a class="anchor" aria-label="anchor" href="#discussion1"></a>
</h3>
<div class="callout-content">
<p>Take a look at the <a href="https://www.nih.gov/health-information/nih-clinical-research-trials-you/guiding-principles-ethical-research" class="external-link">NIH
Guiding Principles for Ethical Research</a>.</p>
<p>What are the main principles?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<p>A summary of the principles is listed below:</p>
<ul>
<li>Social and clinical value: Does the social or clinical value of
developing and implementing the model outweigh the risk and burden of
the people involved?</li>
<li>Scientific validity: Once created, will the model provide valid,
meaningful outputs?</li>
<li>Fair subject selection: Are the people who contribute and benefit
from the model selected fairly, and not through vulnerability,
privilege, or other unrelated factors?</li>
<li>Favorable risk-benefit ratio: Do the potential benefits of of
developing and implementing the model outweigh the risks?</li>
<li>Independent review: Has the project been reviewed by someone
independent of the project, and has an Institutional Review Board (IRB)
been approached where appropriate?</li>
<li>Informed consent: Are participants whose data contributes to
development and implementation of the model, as well as downstream
recipients of the model, kept informed?</li>
<li>Respect for potential and enrolled subjects: Is the privacy of
participants respected and are steps taken to continuously monitor the
effect of the model on downstream participants?</li>
</ul>
</div>
</div>
</div>
</div>
<p>AI tasks are often most controversial when they involve human
subjects, and especially visual representations of people. We’ll discuss
two case studies that use people’s faces as a prediction tool, and
discuss whether these uses of AI are appropriate.</p>
<div class="section level3">
<h3 id="case-study-1-physiognomy">Case study 1: Physiognomy<a class="anchor" aria-label="anchor" href="#case-study-1-physiognomy"></a>
</h3>
<p>In 2019, Nature Medicine <a href="https://www.nature.com/articles/s41591-018-0279-0.epdf" class="external-link">published
a paper</a> that describes a model that can identify genetic disorders
from a photograph of a patient’s face. The abstract of the paper is
copied below:</p>
<blockquote>
<p>Syndromic genetic conditions, in aggregate, affect 8% of the
population. Many syndromes have recognizable facial features that are
highly informative to clinical geneticists. Recent studies show that
facial analysis technologies measured up to the capabilities of expert
clinicians in syndrome identification. However, these technologies
identified only a few disease phenotypes, limiting their role in
clinical settings, where hundreds of diagnoses must be considered. Here
we present a facial image analysis framework, DeepGestalt, using
computer vision and deep-learning algorithms, that quantifies
similarities to hundreds of syndromes.</p>
<p>DeepGestalt outperformed clinicians in three initial experiments, two
with the goal of distinguishing subjects with a target syndrome from
other syndromes, and one of separating different genetic sub-types in
Noonan syndrome. On the final experiment reflecting a real clinical
setting problem, DeepGestalt achieved 91% top-10 accuracy in identifying
the correct syndrome on 502 different images. The model was trained on a
dataset of over 17,000 images representing more than 200 syndromes,
curated through a community-driven phenotyping platform. DeepGestalt
potentially adds considerable value to phenotypic evaluations in
clinical genetics, genetic testing, research and precision medicine.</p>
</blockquote>
<ul>
<li>What is the proposed value of the algorithm?</li>
<li>What are the potential risks?</li>
<li>Are you supportive of this kind of research?</li>
<li>What safeguards, if any, would you want to be used when developing
and using this algorithm?</li>
</ul>
<p>Media reports about this paper were largely positive, e.g., <a href="https://www.genengnews.com/insights/a-i-gets-in-the-face-of-rare-genetic-diseases/" class="external-link">reporting
that clinicians are excited about the new technology</a>.</p>
</div>
<div class="section level3">
<h3 id="case-study-2">Case study 2:<a class="anchor" aria-label="anchor" href="#case-study-2"></a>
</h3>
<p>There is a long history of physiognomy, the “science” of trying to
read someone’s character from their face. With the advent of machine
learning, this discredited area of research has made a comeback. There
have been numerous studies attempting to guess characteristics such as
trustworthness, criminality, and political and sexual orientation.</p>
<p>In 2018, for example, researchers suggested that neural networks
could be used to detect sexual orientation from facial images. The
abstract is copied below:</p>
<blockquote>
<p>We show that faces contain much more information about sexual
orientation than can be perceived and interpreted by the human brain. We
used deep neural networks to extract features from 35,326 facial images.
These features were entered into a logistic regression aimed at
classifying sexual orientation. Given a single facial image, a
classifier could correctly distinguish between gay and heterosexual men
in 81% of cases, and in 74% of cases for women. Human judges achieved
much lower accuracy: 61% for men and 54% for women. The accuracy of the
algorithm increased to 91% and 83%, respectively, given five facial
images per person.</p>
<p>Facial features employed by the classifier included both fixed (e.g.,
nose shape) and transient facial features (e.g., grooming style).
Consistent with the prenatal hormone theory of sexual orientation, gay
men and women tended to have gender-atypical facial morphology,
expression, and grooming styles. Prediction models aimed at gender alone
allowed for detecting gay males with 57% accuracy and gay females with
58% accuracy. Those findings advance our understanding of the origins of
sexual orientation and the limits of human perception. Additionally,
given that companies and governments are increasingly using computer
vision algorithms to detect people’s intimate traits, our findings
expose a threat to the privacy and safety of gay men and women.</p>
</blockquote>
<ul>
<li>What is the proposed value of the algorithm?</li>
<li>What are the potential risks?</li>
<li>Are you supportive of this kind of research?</li>
<li>What distinguishes this use of AI from the use of AI described in
Case Study 1?</li>
</ul>
<p>Media reports of this algorithm were largely negative, with a <a href="https://www.scientificamerican.com/blog/observations/can-we-read-a-persons-character-from-facial-images/" class="external-link">Scientific
American article</a> highlighting the connections to physiognomy and
raising concern over government use of these algorithms:</p>
<blockquote>
<p>This is precisely the kind of “scientific” claim that can motivate
repressive governments to apply AI algorithms to images of their
citizens. And what is it to stop them from “reading” intelligence,
political orientation and criminal inclinations from these images?</p>
</blockquote>
</div>
</section><section><h2 class="section-heading" id="choosing-the-outcome-variable">Choosing the outcome variable<a class="anchor" aria-label="anchor" href="#choosing-the-outcome-variable"></a>
<a class="anchor" aria-label="anchor" href="#choosing-the-outcome-variable"></a>
</h2>
<hr class="half-width">
<p>Sometimes, choosing the outcome variable is easy: for instance, when
building a model to predict how warm it will be out tomorrow, the
temperature can be the outcome variable because it’s measurable (i.e.,
you know what temperature it was yesterday and today) and your
predictions won’t cause a feedback loop (e.g., given a set of past
weather data, the weather next Monday won’t change based on what your
model predicts tomorrow’s temperature to be).</p>
<p>By contrast, sometimes it’s not possible to measure the target
prediction subject directly, and sometimes predictions can cause
feedback loops.</p>
<div class="section level3">
<h3 id="case-study-proxy-variables">Case Study: Proxy variables<a class="anchor" aria-label="anchor" href="#case-study-proxy-variables"></a>
</h3>
<p>Consider the scenario described in the challenge below.</p>
<div id="discussion2" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge<a class="anchor" aria-label="anchor" href="#discussion2"></a>
</h3>
<div class="callout-content">
<p>Suppose that you work for a hospital and are asked to build a model
to predict which patients are high-risk and need extra care to prevent
negative health outcomes.</p>
<p>Discuss the following with a partner or small group: 1. What is the
goal target variable? 2. What are challenges in measuring the target
variable in the training data (i.e., former patients)? 3. Are there
other variables that are easier to measure, but can approximate the
target variable, that could serve as proxies? 3. How do social
inequities interplay with the value of the target variable versus the
value of the proxies?</p>
</div>
</div>
</div>
<p>The “challenge” scenario is not hypothetical: A well-known <a href="https://escholarship.org/content/qt6h92v832/qt6h92v832.pdf" class="external-link">study
by Obermeyer et al.</a> analyzed an algorithm that hospitals used to
assign patients risk scores for various conditions. The algorithm had
access to various patient data, such as demographics (e.g., age and
sex), the number of chronic conditions, insurance type, diagnoses, and
medical costs. The algorithm did not have access to the patient’s race.
The patient risk score determined the level of care the patient should
receive, with higher-risk patients receiving additional care.</p>
<p>Ideally, the target variable would be health needs, but this can be
challenging to measure: how do you compare the severity of two different
conditions? Do you count chronic and acute conditions equally? In the
system described by Obermeyer et al., the hospital decided to use
<strong>health-care costs</strong> as a proxy for health needs, perhaps
reasoning that this data is at least standardized across patients and
doctors.</p>
<p>However, Obermeyer et al. reveal that the algorithm is biased against
Black patients. That is, if there are two individuals – one white and
one Black – with equal health, the algorithm tends to assign a higher
risk score to the white patient, thus giving them access to higher care
quality. The authors blame the choice of proxy variable for the racial
disparities.</p>
<p>The authors go on to describe how, due to how health-care access is
structured in the US, richer patients have more healthcare expenses,
even if they are equally (un)healthy to a lower-income patient. The
richer patients are also more likely to be white.</p>
<p>Consider the following: * How could the algorithm developers have
caught this problem earlier? * Is this a technical mistake or a
process-based mistake? Why?</p>
</div>
<div class="section level3">
<h3 id="case-study-feedback-loop">Case study: Feedback loop<a class="anchor" aria-label="anchor" href="#case-study-feedback-loop"></a>
</h3>
<p>Consider social media, like Instagram or TikTok’s “for you page” or
Facebook or Twitter’s newsfeed. The algorithms that determine what to
show are complex (and proprietary!) but a large part of the algorithms’
objective is engagement: the number of clicks, views, or re-posts. For
instance, this focus on engagement can create an “echo chamber” where
individual users solely see content that aligns with their political
ideology, thereby maximizing the positive engagement with each post. But
the impact of social media feedback loops spreads beyond politics: <a href="https://arxiv.org/pdf/2305.11316" class="external-link">researchers have explored</a>
how similar feedback loops exist for mental health conditions such as
eating disorders. If someone finds themselves in this area of social
media, it’s likely because they have, or have risk factors for, an
eating disorder, and seeing pro-eating disorder content can drive
engagement, but ultimately be very bad for mental health.</p>
<p>Consider the following questions: * Why do social media companies
optimize for engagement? * What would be an alternative optimization
target? How would the outcomes differ, both for users and for the
companies’ profits?</p>
</div>
</section><section><h2 class="section-heading" id="understanding-bias">Understanding bias<a class="anchor" aria-label="anchor" href="#understanding-bias"></a>
<a class="anchor" aria-label="anchor" href="#understanding-bias"></a>
</h2>
<hr class="half-width">
<p>The term “bias” is overloaded, and can have the following
definitions:</p>
<ul>
<li>(Statistical) bias: the tendency of an algorithm to produce one
solution over another, even though some alternatives may be just as
good, or better. Statistical bias can have multiple sources, which we’ll
get into below.</li>
<li>(Social) bias: outcomes are unfair to one or more social groups.
Social bias can be the result of statistical bias (i.e., an algorithm
giving preferential treatment to one social group over others), but can
also occur outside of a machine learning context.</li>
</ul>
<div class="section level3">
<h3 id="sources-of-statistical-bias">Sources of statistical bias<a class="anchor" aria-label="anchor" href="#sources-of-statistical-bias"></a>
</h3>
<div class="section level4">
<h4 id="algorithmic-bias">Algorithmic bias<a class="anchor" aria-label="anchor" href="#algorithmic-bias"></a>
</h4>
<p>Algorithmic bias is the tendency of an algorithm to favor one
solution over another. Algorithmic bias is not always bad, and may
sometimes be encoded for by algorithm developers. For instance, linear
regression with L0-regularization displays algorithmic bias towards
sparse classifiers (i.e., classifiers where most weights are 0). This
bias may be desirable in settings where human interpretability is
important.</p>
<p>But algorithmic bias can also occur unintentionally: for instance, if
there is data bias (described below), this may lead algorithm developers
to select an algorithm that is ill-suited to underrepresented groups.
Then, even if the data bias is rectified, sticking with the original
algorithm choice may not fix biased outcomes.</p>
</div>
<div class="section level4">
<h4 id="data-bias">Data bias:<a class="anchor" aria-label="anchor" href="#data-bias"></a>
</h4>
<p>Data bias is when the available training data is not accurate or
representative of the target population. Data bias is extremely common
(it’s often hard to collect perfectly-representative, and
perfectly-accurate data), and care arise in multiple ways:</p>
<ul>
<li>Measurement error - if a tool is not well calibrated, measurements
taken by that tool won’t be accurate. Likewise, human biases can lead to
measurement error, for instance, if people systematically over-report
their height on dating apps, or if doctors do not believe patient’s
self-reports of their pain levels.</li>
<li>Response bias - for instance, when conducting a survey about
customer satisfaction, customers who had very positive or very negative
experiences may be more likely to respond.</li>
<li>Representation bias - the data is not well representative of the
whole population. For instance, doing clinical trials primarily on white
men means that women and other races are not well represented in
data.</li>
</ul>
<p>Through the rest of this lesson, if we use the term “bias” without
any additional context, we will be referring to social bias that stems
from statistical bias.</p>
<div id="case-study" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="case-study" class="callout-inner">
<h3 class="callout-title">Case Study<a class="anchor" aria-label="anchor" href="#case-study"></a>
</h3>
<div class="callout-content">
<p>With a partner or small group, choose one of the three case study
options. Read or watch individually, then discuss as a group how bias
manifested in the training data, and what strategies could correct for
it.</p>
<p>After the discussion, share with the whole workshop what you
discussed.</p>
<ol style="list-style-type: decimal">
<li><a href="https://www.technologyreview.com/2019/02/13/137444/predictive-policing-algorithms-ai-crime-dirty-data/" class="external-link">Predictive
policing</a></li>
<li>
<a href="http://gendershades.org/" class="external-link">Facial recognition</a> (video, 5
min.)</li>
<li><a href="https://www.aclu.org/news/womens-rights/why-amazons-automated-hiring-tool-discriminated-against" class="external-link">Amazon
hiring tool</a></li>
</ol>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>Some tasks are not appropriate for machine learning due to ethical
concerns.</li>
<li>Machine learning tasks should have a valid prediction target that
maps clearly to the real-world goal.</li>
<li>Training data can be biased due to societal inequities, errors in
the data collection process, and lack of attention to careful sampling
practices.</li>
<li>“Bias” also refers to statistical bias, and certain algorithms can
be biased towards some solutions.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div>
</section></section><section id="aio-2-model-fitting"><p>Content from <a href="2-model-fitting.html">Scientific validity in the modeling process</a></p>
<hr>
<p>Last updated on 2024-06-19 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/2-model-fitting.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What impact does overfitting and underfitting have on model
performance?</li>
<li>What is data leakage?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Implement at least two types of machine learning models in
Python.</li>
<li>Describe the risks of, identify, and understand mitigation steps for
overfitting and underfitting.</li>
<li>Understand why data leakage is harmful to scientific validity and
how it can appear in machine learning pipelines.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>Overfitting is characterized by worse performance on the test set
than on the train set and can be fixed by switching to a simpler model
architecture or by adding regularization.</li>
<li>Underfitting is characterized by poor performance on both the
training and test datasets. It can be fixed by collecting more training
data, switching to a more complex model architecture, or improving
feature quality.</li>
<li>Data leakage occurs when the model has access to the test data
during training and results in overconfidence in the model’s
performance.</li>
</ul>
</div>
</div>
</div></section><section id="aio-3-model-eval-and-fairness"><p>Content from <a href="3-model-eval-and-fairness.html">Model evaluation and fairness</a></p>
<hr>
<p>Last updated on 2024-06-19 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/3-model-eval-and-fairness.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How do we define fairness and bias in machine learning
outcomes?</li>
<li>What types of bias and unfairness can occur in generative AI?</li>
<li>How can we improve the fairness of machine learning models?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Reason about model performance through standard evaluation
metrics.</li>
<li>Understand and distinguish between various notions of fairness in
machine learning.</li>
<li>Describe and implement two different ways of modifying the machine
learning modeling process to improve the fairness of a model.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="accuracy-metrics">Accuracy metrics<a class="anchor" aria-label="anchor" href="#accuracy-metrics"></a>
<a class="anchor" aria-label="anchor" href="#accuracy-metrics"></a>
</h2>
<hr class="half-width">
<p>Stakeholders often want to know the accuracy of a machine learning
model – what percent of predictions are correct? Accuracy can be
decomposed into further metrics: e.g., in a binary prediction setting,
recall (the fraction of positive samples that are classified correctly)
and precision (the fraction of samples classified as positive that
actually are positive) are commonly-used metrics.</p>
<p>Suppose we have a model that performs binary classification (+, -) on
a test dataset of 1000 samples (let <span class="math inline">\(n\)</span>=1000). A <em>confusion matrix</em>
defines how many predictions we make in each of four quadrants: true
positive with positive prediction (++), true positive with negative
prediction (+-), true negative with positive prediction (-+), and true
negative with negative prediction (–).</p>
<table class="table">
<thead><tr class="header">
<th></th>
<th>True +</th>
<th>True -</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Predicted +</td>
<td>300</td>
<td>80</td>
</tr>
<tr class="even">
<td>Predicted -</td>
<td>25</td>
<td>595</td>
</tr>
</tbody>
</table>
<p>So, for instance, 80 samples have a true class of + but get predicted
as members of -.</p>
<p>We can compute the following metrics:</p>
<ul>
<li>Accuracy: What fraction of predictions are correct?
<ul>
<li>(300 + 595) / 100 = 0.895</li>
<li>Accuracy is 89.5%</li>
</ul>
</li>
<li>Precision: What fraction of predicted positives are true positives?
<ul>
<li>300 / (300 + 80) = 0.789</li>
<li>Precision is 78.9%</li>
</ul>
</li>
<li>Recall: What fraction of true positives are classified as positive?
<ul>
<li>300 / (300 + 25) = 0.923</li>
<li>Recall is 92.3%</li>
</ul>
</li>
</ul>
<div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout<a class="anchor" aria-label="anchor" href="#callout1"></a>
</h3>
<div class="callout-content">
<p>We’ve discussed binary classification but for other types of tasks
there are different metrics. For example,</p>
<ul>
<li>Multi-class problems often use <a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.top_k_accuracy_score.html" class="external-link">Top-K
accuracy</a>, a metric of how often the true response appears in their
top-K guesses.</li>
<li>Regression tasks often use the <a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" class="external-link">Area
Under the ROC curve (AUC ROC)</a> as a measure of how well the
classifier performs at different thresholds.</li>
</ul>
</div>
</div>
</div>
<div id="what-accuracy-metric-to-use" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="what-accuracy-metric-to-use" class="callout-inner">
<h3 class="callout-title">What accuracy metric to use?<a class="anchor" aria-label="anchor" href="#what-accuracy-metric-to-use"></a>
</h3>
<div class="callout-content">
<p>Different accuracy metrics may be more relevant in different
situations. Discuss with a partner or small groups whether precision,
recall, or some combination of the two is most relevant in the following
prediction tasks:</p>
<ol style="list-style-type: decimal">
<li>Deciding what patients are high risk for a disease and who should
get additional low-cost screening.</li>
<li>Deciding what patients are high risk for a disease and should start
taking medication to lower the disease risk. The medication is expensive
and can have unpleasant side effects.</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li><p>It is best if all patients who need the screening get it, and
there is little downside for doing screenings unnecessarily because the
screening costs are low. Thus, a high recall score is optimal.</p></li>
<li><p>Given the costs and side effects of the medicine, we do not want
patients not at risk for the disease to take the medication. So, a high
precision score is ideal.</p></li>
</ol>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="how-do-we-measure-fairness">How do we measure fairness?<a class="anchor" aria-label="anchor" href="#how-do-we-measure-fairness"></a>
<a class="anchor" aria-label="anchor" href="#how-do-we-measure-fairness"></a>
</h2>
<hr class="half-width">
<p>What does it mean for a machine learning model to be fair or
unbiased? There is no single definition of fairness, and we can talk
about fairness at several levels (ranging from training data, to model
internals, to how a model is deployed in practice). Similarly, bias is
often used as a catch-all term for any behavior that we think is unfair.
Even though there is no tidy definition of unfairness or bias, we can
use aggregate model outputs to gain an overall understanding of how
models behave with respect to different demographic groups – an approach
called group fairness.</p>
<p>In general, if there are no differences between groups in the real
world (e.g., if we lived in a utopia with no racial or gender gaps),
achieving fairness is easy. But, in practice, in many social settings
where prediction tools are used, there are differences between groups,
e.g., due to historical and current discrimination.</p>
<p>For instance, in a loan prediction setting in the United States, the
average white applicant may be better positioned to repay a loan than
the average Black applicant due to differences in generational wealth,
education opportunities, and other factors stemming from anti-Black
racism. Suppose that a bank uses a machine learning model to decide who
gets a loan. Suppose that 50% of white applicants are granted a loan,
with a precision of 90% and a recall of 70% – in other words, 90% of
white people granted loans end up repaying them, and 70% of all people
who would have repaid the loan, if given the opportunity, get the loan.
Consider the following scenarios:</p>
<ul>
<li>(Demographic parity) We give loans to 50% of Black applicants in a
way that maximizes overall accuracy</li>
<li>(Equalized odds) We give loans to X% of Black applicants, where X is
chosen to maximize accuracy subject to keeping precision equal to
90%.</li>
<li>(Group level calibration) We give loans to X% of Black applicants,
where X is chosen to maximize accuracy while keeping recall equal to
70%.</li>
</ul>
<p>There are <em>many</em> notions of statistical group fairness, but
most boil down to one of the three above options: demographic parity,
equalized odds, and group-level calibration. All three are forms of
<em>distributional</em> (or <em>outcome</em>) fairness. Another
dimension, though, is <em>procedural</em> fairness: whether decisions
are made in a just way, regardless of final outcomes. Procedural
fairness contains many facets, but one way to operationalize it is to
consider individual fairness (also called counterfactual fairness),
which was suggested in 2012 by <a href="https://dl.acm.org/doi/abs/10.1145/2090236.2090255" class="external-link">Dwork et
al.</a> as a way to ensure that “similar individuals [are treated]
similarly”. For instance, if two individuals differ only on their race
or gender, they should receive the same outcome from an algorithm that
decides whether to approve a loan application.</p>
<p>In practice, it’s hard to use individual fairness because defining a
complete set of rules about when two individuals are sufficiently
“similar” is challenging.</p>
<div id="matching-fairness-terminology-with-definitions" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="matching-fairness-terminology-with-definitions" class="callout-inner">
<h3 class="callout-title">Matching fairness terminology with definitions<a class="anchor" aria-label="anchor" href="#matching-fairness-terminology-with-definitions"></a>
</h3>
<div class="callout-content">
<p>Match the following types of formal fairness with their definitions.
(A) Individual fairness, (B) Equalized odds, (C) Demographic parity, and
(D) Group-level calibration</p>
<ol style="list-style-type: decimal">
<li>The model is equally accurate across all demographic groups.</li>
<li>Different demographic groups have the same true positive rates and
false positive rates.</li>
<li>Similar people are treated similarly.</li>
<li>People from different demographic groups receive each outcome at the
same rate.</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p>A - 3, B - 2, C - 4, D - 1</p>
</div>
</div>
</div>
</div>
<p>But some types of unfairness cannot be directly measured by
group-level statistical data. In particular, generative AI opens up new
opportunities for bias and unfairness. Bias can occur through
representational harms (e.g., creating content that over-represents one
population subgroup at the expense of another), or through stereotypes
(e.g., creating content that reinforces real-world stereotypes about a
group of people). We’ll discuss some specific examples of bias in
generative models next.</p>
</section><section><h2 class="section-heading" id="fairness-in-generative-ai">Fairness in generative AI<a class="anchor" aria-label="anchor" href="#fairness-in-generative-ai"></a>
<a class="anchor" aria-label="anchor" href="#fairness-in-generative-ai"></a>
</h2>
<hr class="half-width">
<p>Generative models learn from statistical patterns in real-world data.
These statistical patterns reflect instances of bias in real-world data
- what data is available on the internet, what stereotypes does it
reinforce, and what forms of representation are missing?</p>
<div class="section level3">
<h3 id="natural-language">Natural language<a class="anchor" aria-label="anchor" href="#natural-language"></a>
</h3>
<p>One set of social stereotypes that large AI models can learn is
gender based. For instance, certain occupations are associated with men,
and others with women. For instance, in the U.S., doctors are
historically and stereotypically usually men.</p>
<p>In 2016, Caliskan et al. <a href="https://www.fatml.org/schedule/2016/presentation/semantics-derived-automatically-language-corpora" class="external-link">showed
that machine translation systems exhibit gender bias</a>, for instance,
by reverting to stereotypical gendered pronouns in ambiguous
translations, like in Turkish – a language without gendered pronouns –
to English.</p>
<p>In response, Google <a href="https://blog.research.google/2018/12/providing-gender-specific-translations.html" class="external-link">tweaked
their translator algorithms</a> to identify and correct for gender
stereotypes in Turkish and several other widely-spoken languages. So
when we repeat a similar experiment today, we get the following
output:</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e4-turkish-nlp-stereotypes.png" alt='Screenshot of Google Translate output. The English sentence "The doctor is on her lunch break" is translated to Turkish, and then the Turkish output is translated back to English as either "The doctor is on his lunch break" or "The doctor is on his lunch break".' class="figure mx-auto d-block"><div class="figcaption">Turkish Google Translate example (screenshot
from 1/9/2024)</div>
</figure><p>But for other, less widely-spoken languages, the original problem
persists:</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e4-norwegian-nlp-stereotypes.png" alt='Screenshot of Google Translate output. The English sentence "The doctor is on her lunch break" is translated to Norwegian, and then the Norwegian output is translated back to English as "The doctor is on his lunch break".' class="figure mx-auto d-block"><div class="figcaption">Norwegian Google Translate example (screenshot
from 1/9/2024)</div>
</figure><p>We’re not trying to slander Google Translate here – the translation,
without additional context, is ambiguous. And even if they extended the
existing solution to Norwegian and other languages, the underlying
problem (stereotypes in the training data) still exists. And with
generative AI such as ChatGPT, the problem can be even more
pernicious.</p>
<div id="red-teaming-large-language-models" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="red-teaming-large-language-models" class="callout-inner">
<h3 class="callout-title">Red-teaming large language models<a class="anchor" aria-label="anchor" href="#red-teaming-large-language-models"></a>
</h3>
<div class="callout-content">
<p>In cybersecurity, “red-teaming” is when well-intentioned people think
like a hacker in order to make a system safer. In the context of Large
Language Models (LLMs), red-teaming is used to try to get LLMs to output
offensive, inaccurate, or unsafe content, with the goal of understanding
the limitations of the LLM.</p>
<p>Try out red-teaming with ChatGPT or another LLM. Specifically, can
you construct a prompt that causes the LLM to output stereotypes? Here
are some example prompts, but feel free to get creative!</p>
<ul>
<li><p>“Tell me a story about a doctor” (or other profession with
gender)</p></li>
<li><p>If you speak a language other than English, how does are
ambiguous gendered pronouns handled? For instance, try the prompt
“Translate ‘The doctor is here’ to Spanish”. Is a masculine or feminine
pronoun used for the doctor in Spanish?</p></li>
</ul>
<p>If you use LLMs in your research, consider whether any of these
issues are likely to be present for your use cases. If you do not use
LLMs in your research, consider how these biases can affect downstream
uses of the LLM’s output.</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" aria-labelledby="headingSolution3" data-bs-parent="#accordionSolution3">
<div class="accordion-body">
<p>Most publicly-available LLM providers set up guardrails to avoid
propagating biases present in their training data. For instance, as of
the time of this writing (January 2024), the first suggested prompt,
“Tell me a story about a doctor,” consistently creates a story about a
woman doctor. Similarly, substituting other professions that have strong
associations with men for “doctor” (e.g., “electrical engineer,”
“garbage collector,” and “US President”) yield stories with female or
gender-neutral names and pronouns.</p>
</div>
</div>
</div>
</div>
<div id="discussing-other-fairness-issues" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="discussing-other-fairness-issues" class="callout-inner">
<h3 class="callout-title">Discussing other fairness issues<a class="anchor" aria-label="anchor" href="#discussing-other-fairness-issues"></a>
</h3>
<div class="callout-content">
<p>If you use LLMs in your research, consider whether any of these
issues are likely to be present for your use cases. Share your thoughts
in small groups with other workshop participants.</p>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="image-generation">Image generation<a class="anchor" aria-label="anchor" href="#image-generation"></a>
</h3>
<p>The same problems that language modeling face also affect image
generation. Consider, for instance, Melon et al. <a href="https://arxiv.org/pdf/2003.03808.pdf" class="external-link">developed an algorithm
called Pulse</a> that can convert blurry images to higher resolution.
But, biases were quickly unearthed and <a href="https://twitter.com/Chicken3gg/status/1274314622447820801?s=20&amp;t=_oORPJBJRaBW_J0zresFJQ" class="external-link">shared
via social media</a>.</p>
<div id="discussion5" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge<a class="anchor" aria-label="anchor" href="#discussion5"></a>
</h3>
<div class="callout-content">
<p>Who is shown in this blurred picture? <img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e4-obama.png" alt="blurry image of Barack Obama" class="figure"></p>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" aria-labelledby="headingSolution4" data-bs-parent="#accordionSolution4">
<div class="accordion-body">
<p>While the picture is of Barack Obama, the upsampled image shows a
white face. <img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e4-obama-upsampled.png" alt="Unblurred version of the pixelated picture of Obama. Instead of showing Obama, it shows a white man." class="figure"></p>
<p>You can <a href="https://colab.research.google.com/github/tg-bomze/Face-Depixelizer/blob/master/Face_Depixelizer_Eng.ipynb#scrollTo=fU0aGtD4Nl4W" class="external-link">try
the model here</a>.</p>
</div>
</div>
</div>
</div>
<p>Menon and colleagues subsequently updated their paper to discuss this
issue of bias. They assert that the problems inherent in the PULSE model
are largely a result of the <a href="https://arxiv.org/abs/1812.04948" class="external-link">underlying StyleGAN model</a>,
which they had used in their work.</p>
<blockquote>
<p>Overall, it seems that sampling from StyleGAN yields white faces much
more frequently than faces of people of color … This bias extends to any
downstream application of StyleGAN, including the implementation of
PULSE using StyleGAN.</p>
<p>…</p>
<p>Results indicate a racial bias among the generated pictures, with
close to three-fourths (72.6%) of the pictures representing White
people. Asian (13.8%) and Black (10.1%) are considerably less frequent,
while Indians represent only a minor fraction of the pictures
(3.4%).</p>
</blockquote>
<p>These remarks get at a central issue: biases in any building block of
a system (data, base models, etc.) get propagated forwards. In
generative AI, such as text-to-image systems, this can result in
representational harms, <a href="https://arxiv.org/pdf/2211.03759.pdf" class="external-link">as documented by Bianchi et
al.</a> Fixing these issues of bias is still an active area of research.
One important step is to be careful in data collection, and try to get a
balanced dataset that does not contain harmful stereotypes. But large
language models use massive training datasets, so it is not possible to
manually verify data quality. Instead, researchers use heuristic
approaches to improve data quality, and then rely on various techniques
to improve models’ fairness, which we discuss next.</p>
</div>
</section><section><h2 class="section-heading" id="improving-fairness-of-models">Improving fairness of models<a class="anchor" aria-label="anchor" href="#improving-fairness-of-models"></a>
<a class="anchor" aria-label="anchor" href="#improving-fairness-of-models"></a>
</h2>
<hr class="half-width">
<p>Model developers frequently try to improve the fairness of there
model by intervening at one of three stages: pre-processing,
in-processing, or post-processing. We’ll cover techniques within each of
these paradigms in turn.</p>
<p>We start, though, by discussing why removing the sensitive
attribute(s) is not sufficient. Consider the task of deciding which loan
applicants are funded. Suppose we are concerned with racial bias in the
model outputs. If we remove race from the set of attributes available to
the model, the model cannot make <em>overly</em> racist decisions.
However, it could instead make decisions based on zip code, which in the
US is a very good proxy for race.</p>
<p>Can we simply remove all proxy variables? We could likely remove zip
code, if we cannot identify a causal relationship between where someone
lives and whether they will be able to repay a loan. But what about an
attribute like educational achievement? Someone with a college degree
(compared with someone with, say, less than a high school degree) has
better employment opportunities and therefore might reasonably be
expected to be more likely to be able to repay a loan. However,
educational attainment is still a proxy for race in the United States
due to historical (and ongoing) discrimination.</p>
<p><strong>Pre-processing</strong> generally modifies the dataset used
for learning. Techniques in this category include:</p>
<ul>
<li><p>Oversampling/undersampling: instead of training a machine
learning model on all of the data, <em>undersample</em> the majority
class by removing some of the majority class samples from the dataset in
order to have a more balanced dataset. Alternatively,
<em>oversample</em> the minority class by duplicating samples belonging
to this group.</p></li>
<li><p>Data augmentation: the number of samples from minority groups may
be increased by generating synthetic data with a generative adversarial
network (GAN). We won’t cover this method in this workshop (using a GAN
can be more computationally expensive than other techniques). If you’re
interested, you can learn more about this method from the paper <a href="https://link.springer.com/chapter/10.1007/978-3-030-58542-6_23" class="external-link">Inclusive
GAN: Improving Data and Minority Coverage in Generative
Models</a>.</p></li>
<li><p>Changing feature representations: various techniques have been
proposed to increase fairness by removing unfairness from the data
directly. To do so, the data is converted into an alternate
representation so that differences between demographic groups are
minimized, yet enough information is maintained in order to be able to
learn a model that performs well. An advantage of this method is that it
is model-agnostic, however, a challenge is it reduces the
interpretability of interpretable models and makes post-hoc
explainability less meaningful for black-box models.</p></li>
</ul>
<div id="pros-and-cons-of-preprocessing-options" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="pros-and-cons-of-preprocessing-options" class="callout-inner">
<h3 class="callout-title">Pros and cons of preprocessing options<a class="anchor" aria-label="anchor" href="#pros-and-cons-of-preprocessing-options"></a>
</h3>
<div class="callout-content">
<p>Discuss what you think the pros and cons of the different
pre-processing options are. What techniques might work better in
different settings?</p>
</div>
</div>
</div>
<div id="accordionSolution5" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution5" aria-expanded="false" aria-controls="collapseSolution5">
  <h4 class="accordion-header" id="headingSolution5"> Show me the solution </h4>
</button>
<div id="collapseSolution5" class="accordion-collapse collapse" aria-labelledby="headingSolution5" data-bs-parent="#accordionSolution5">
<div class="accordion-body">
<p>A downside of oversampling is that it may violate statistical
assumptions about independence of samples. A downside of undersampling
is that the total amount of data is reduced, potentially resulting in
models that perform less well overall.</p>
<p>A downside of using GANs to generate additional data is that this
process may be expensive and require higher levels of ML expertise.</p>
<p>A challenge with all techniques is that if there is not sufficient
data from minority groups, it may be hard to achieve good performance on
the groups without simply collecting more or higher-quality data.</p>
</div>
</div>
</div>
</div>
<p><strong>In-processing</strong> modifies the learning algorithm. Some
specific in-processing techniques include:</p>
<ul>
<li><p>Reweighting samples: many machine learning models allow for
reweighting individual samples, i.e., indicating that misclassifying
certain, rarer, samples should be penalized more severely in the loss
function. In the code example, we show how to reweight samples using
AIF360’s <a href="https://aif360.readthedocs.io/en/latest/modules/generated/aif360.algorithms.preprocessing.Reweighing.html" class="external-link">Reweighting</a>
function.</p></li>
<li><p>Incorporating fairness into the loss function: reweighting
explicitly instructs the loss function to penalize the misclassification
of certain samples more harshly. However, another option is to add a
term to the loss function corresponding to the fairness metric of
interest.</p></li>
</ul>
<p><strong>Post-processing</strong> modifies an existing model to
increase its fairness. Techniques in this category often compute a
custom <em>threshold</em> for each demographic group in order to satisfy
a specific notion of group fairness. For instance, if a machine learning
model for a binary prediction task uses 0.5 as a cutoff (e.g., raw
scores less than 0.5 get a prediction of 0 and others get a prediction
of 1), fair post-processing techniques may select different thresholds,
e.g., 0.4 or 0.6 for different demographic groups.</p>
<p>In the code, we explore two different bias mitigations strategies
implemented in the <a href="https://aif360.readthedocs.io/en/stable/" class="external-link">AIF360 Fairness
Toolkit</a>.</p>
<hr>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Markdown, display</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> make_pipeline</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a><span class="im">from</span> aif360.metrics <span class="im">import</span> BinaryLabelDatasetMetric</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a><span class="im">from</span> aif360.metrics <span class="im">import</span> ClassificationMetric</span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a><span class="im">from</span> aif360.explainers <span class="im">import</span> MetricTextExplainer</span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a><span class="im">from</span> aif360.algorithms.preprocessing <span class="im">import</span> Reweighing</span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a><span class="im">from</span> aif360.algorithms.preprocessing <span class="im">import</span> OptimPreproc</span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a><span class="im">from</span> aif360.datasets <span class="im">import</span> MEPSDataset19</span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a><span class="im">from</span> fairlearn.postprocessing <span class="im">import</span> ThresholdOptimizer</span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span></code></pre>
</div>
<p>This notebook is adapted from AIF360’s <a href="https://github.com/Trusted-AI/AIF360/blob/master/examples/tutorial_medical_expenditure.ipynb" class="external-link">Medical
Expenditure Tutorial</a>.</p>
<p>The tutorial uses data from the <a href="https://meps.ahrq.gov/mepsweb/" class="external-link">Medical Expenditure Panel
Survey</a>. We include a short description of the data below. For more
details, especially on the preprocessing, please see the AIF360
tutorial. ## Scenario and data</p>
<p>The goal is to develop a healthcare utilization scoring model – i.e.,
to predict which patients will have the highest utilization of
healthcare resources.</p>
<p>The original dataset contains information about various types of
medical visits; the AIF360 preprocessing created a single output feature
‘UTILIZATION’ that combines utilization across all visit types. Then,
this feature is binarized based on whether utilization is high, defined
as &gt;= 10 visits. Around 17% of the dataset has high utilization.</p>
<p>The sensitive feature (that we will base fairness scores on) is
defined as race. Other predictors include demographics, health
assessment data, past diagnoses, and physical/mental limitations.</p>
<p>The data is divided into years (we follow the lead of AIF360’s
tutorial and use 2015), and further divided into Panels. We use Panel 19
(the first half of 2015). ### Loading the data</p>
<p>First, the data needs to be moved into the correct location for the
AIF360 library to find it. If you haven’t yet, run <code>setup.sh</code>
to complete that step. (Then, restart the kernel and re-load the
packages at the top of this file.)</p>
<p>First, we load the data. Next, we create the train/validation/test
splits and setup information about the privileged and unprivileged
groups. (Recall, we focus on race as the sensitive feature.)</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>(dataset_orig_panel19_train,</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a> dataset_orig_panel19_val,</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a> dataset_orig_panel19_test) <span class="op">=</span> MEPSDataset19().split([<span class="fl">0.5</span>, <span class="fl">0.8</span>], shuffle<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>sens_ind <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>sens_attr <span class="op">=</span> dataset_orig_panel19_train.protected_attribute_names[sens_ind]</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>unprivileged_groups <span class="op">=</span> [{sens_attr: v} <span class="cf">for</span> v <span class="kw">in</span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>                       dataset_orig_panel19_train.unprivileged_protected_attributes[sens_ind]]</span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>privileged_groups <span class="op">=</span> [{sens_attr: v} <span class="cf">for</span> v <span class="kw">in</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>                     dataset_orig_panel19_train.privileged_protected_attributes[sens_ind]]</span></code></pre>
</div>
<p>Show details about the data.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="kw">def</span> describe(train<span class="op">=</span><span class="va">None</span>, val<span class="op">=</span><span class="va">None</span>, test<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>    <span class="cf">if</span> train <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>        display(Markdown(<span class="st">"#### Training Dataset shape"</span>))</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>        <span class="bu">print</span>(train.features.shape)</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>    <span class="cf">if</span> val <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>        display(Markdown(<span class="st">"#### Validation Dataset shape"</span>))</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>        <span class="bu">print</span>(val.features.shape)</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Test Dataset shape"</span>))</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>    <span class="bu">print</span>(test.features.shape)</span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Favorable and unfavorable labels"</span>))</span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a>    <span class="bu">print</span>(test.favorable_label, test.unfavorable_label)</span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Protected attribute names"</span>))</span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a>    <span class="bu">print</span>(test.protected_attribute_names)</span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Privileged and unprivileged protected attribute values"</span>))</span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a>    <span class="bu">print</span>(test.privileged_protected_attributes, </span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a>          test.unprivileged_protected_attributes)</span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a>    display(Markdown(<span class="st">"#### Dataset feature names</span><span class="ch">\n</span><span class="st"> See [MEPS documentation](https://meps.ahrq.gov/data_stats/download_data/pufs/h181/h181doc.pdf) for details on the various features"</span>))</span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a>    <span class="bu">print</span>(test.feature_names)</span>
<span id="cb3-19"><a href="#cb3-19" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" tabindex="-1"></a>describe(dataset_orig_panel19_train, dataset_orig_panel19_val, dataset_orig_panel19_test)</span></code></pre>
</div>
<p>Next, we will look at whether the dataset contains bias; i.e., does
the outcome ‘UTILIZATION’ take on a positive value more frequently for
one racial group than another?</p>
<p>The disparate impact score will be between 0 and 1, where 1 indicates
<em>no bias</em>.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>metric_orig_panel19_train <span class="op">=</span> BinaryLabelDatasetMetric(</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>        dataset_orig_panel19_train,</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>        unprivileged_groups<span class="op">=</span>unprivileged_groups,</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>        privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>explainer_orig_panel19_train <span class="op">=</span> MetricTextExplainer(metric_orig_panel19_train)</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="bu">print</span>(explainer_orig_panel19_train.disparate_impact())</span></code></pre>
</div>
<p>We see that the disparate impact is about 0.48, which means the
privileged group has the favorable outcome at about 2x the rate as the
unprivileged group does.</p>
<p>(In this case, the “favorable” outcome is label=1, i.e., high
utilization) ## Train a model</p>
<p>We will train a logistic regression classifier.</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>dataset <span class="op">=</span> dataset_orig_panel19_train</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>model <span class="op">=</span> make_pipeline(StandardScaler(),</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>                      LogisticRegression(solver<span class="op">=</span><span class="st">'liblinear'</span>, random_state<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>fit_params <span class="op">=</span> {<span class="st">'logisticregression__sample_weight'</span>: dataset.instance_weights}</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>lr_orig_panel19 <span class="op">=</span> model.fit(dataset.features, dataset.labels.ravel(), <span class="op">**</span>fit_params)</span></code></pre>
</div>
<div class="section level3">
<h3 id="validate-the-model">Validate the model<a class="anchor" aria-label="anchor" href="#validate-the-model"></a>
</h3>
<p>Recall that a logistic regression model can output probabilities
(i.e., <code>model.predict(dataset).scores</code>) and we can determine
our own threshold for predicting class 0 or 1.</p>
<p>The following function, <code>test</code>, computes performance on
the logistic regression model based on a variety of thresholds, as
indicated by <code>thresh_arr</code>, an array of threshold values. We
will continue to focus on disparate impact, but all other metrics are
described in the <a href="https://aif360.readthedocs.io/en/stable/modules/generated/aif360.metrics.ClassificationMetric.html#aif360.metrics.ClassificationMetric" class="external-link">AIF360
documentation</a>.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="kw">def</span> test(dataset, model, thresh_arr):</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>        <span class="co"># sklearn classifier</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>        y_val_pred_prob <span class="op">=</span> model.predict_proba(dataset.features)</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>        pos_ind <span class="op">=</span> np.where(model.classes_ <span class="op">==</span> dataset.favorable_label)[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">AttributeError</span> <span class="im">as</span> e:</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>        <span class="bu">print</span>(e)</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>        <span class="co"># aif360 inprocessing algorithm</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>        y_val_pred_prob <span class="op">=</span> model.predict(dataset).scores</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>        pos_ind <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>        </span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>    pos_ind <span class="op">=</span> np.where(model.classes_ <span class="op">==</span> dataset.favorable_label)[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>    metric_arrs <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>    </span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a>    <span class="cf">for</span> thresh <span class="kw">in</span> thresh_arr:</span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a>        y_val_pred <span class="op">=</span> (y_val_pred_prob[:, pos_ind] <span class="op">&gt;</span> thresh).astype(np.float64)</span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" tabindex="-1"></a>        dataset_pred <span class="op">=</span> dataset.copy()</span>
<span id="cb6-19"><a href="#cb6-19" tabindex="-1"></a>        dataset_pred.labels <span class="op">=</span> y_val_pred</span>
<span id="cb6-20"><a href="#cb6-20" tabindex="-1"></a>        metric <span class="op">=</span> ClassificationMetric(</span>
<span id="cb6-21"><a href="#cb6-21" tabindex="-1"></a>                dataset, dataset_pred,</span>
<span id="cb6-22"><a href="#cb6-22" tabindex="-1"></a>                unprivileged_groups<span class="op">=</span>unprivileged_groups,</span>
<span id="cb6-23"><a href="#cb6-23" tabindex="-1"></a>                privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb6-24"><a href="#cb6-24" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" tabindex="-1"></a>        <span class="co"># various metrics - can look up what they are on your own</span></span>
<span id="cb6-26"><a href="#cb6-26" tabindex="-1"></a>        metric_arrs[<span class="st">'bal_acc'</span>].append((metric.true_positive_rate()</span>
<span id="cb6-27"><a href="#cb6-27" tabindex="-1"></a>                                     <span class="op">+</span> metric.true_negative_rate()) <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb6-28"><a href="#cb6-28" tabindex="-1"></a>        metric_arrs[<span class="st">'avg_odds_diff'</span>].append(metric.average_odds_difference())</span>
<span id="cb6-29"><a href="#cb6-29" tabindex="-1"></a>        metric_arrs[<span class="st">'disp_imp'</span>].append(metric.disparate_impact())</span>
<span id="cb6-30"><a href="#cb6-30" tabindex="-1"></a>        metric_arrs[<span class="st">'stat_par_diff'</span>].append(metric.statistical_parity_difference())</span>
<span id="cb6-31"><a href="#cb6-31" tabindex="-1"></a>        metric_arrs[<span class="st">'eq_opp_diff'</span>].append(metric.equal_opportunity_difference())</span>
<span id="cb6-32"><a href="#cb6-32" tabindex="-1"></a>        metric_arrs[<span class="st">'theil_ind'</span>].append(metric.theil_index())</span>
<span id="cb6-33"><a href="#cb6-33" tabindex="-1"></a>    </span>
<span id="cb6-34"><a href="#cb6-34" tabindex="-1"></a>    <span class="cf">return</span> metric_arrs</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>thresh_arr <span class="op">=</span> np.linspace(<span class="fl">0.01</span>, <span class="fl">0.5</span>, <span class="dv">50</span>)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>val_metrics <span class="op">=</span> test(dataset<span class="op">=</span>dataset_orig_panel19_val,</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>                   model<span class="op">=</span>lr_orig_panel19,</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>                   thresh_arr<span class="op">=</span>thresh_arr)</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>lr_orig_best_ind <span class="op">=</span> np.argmax(val_metrics[<span class="st">'bal_acc'</span>])</span></code></pre>
</div>
<p>We will plot <code>val_metrics</code>. The x-axis will be the
threshold we use to output the label 1 (i.e., if the raw score is larger
than the threshold, we output 1).</p>
<p>The y-axis will show both balanced accuracy (in blue) and disparate
impact (in red).</p>
<p>Note that we plot 1 - Disparate Impact, so now a score of 0 indicates
no bias.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="kw">def</span> plot(x, x_name, y_left, y_left_name, y_right, y_right_name):</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>    fig, ax1 <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">7</span>))</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>    ax1.plot(x, y_left)</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>    ax1.set_xlabel(x_name, fontsize<span class="op">=</span><span class="dv">16</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>    ax1.set_ylabel(y_left_name, color<span class="op">=</span><span class="st">'b'</span>, fontsize<span class="op">=</span><span class="dv">16</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>    ax1.xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>    ax1.yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>    ax1.set_ylim(<span class="fl">0.5</span>, <span class="fl">0.8</span>)</span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a>    ax2 <span class="op">=</span> ax1.twinx()</span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>    ax2.plot(x, y_right, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a>    ax2.set_ylabel(y_right_name, color<span class="op">=</span><span class="st">'r'</span>, fontsize<span class="op">=</span><span class="dv">16</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'DI'</span> <span class="kw">in</span> y_right_name:</span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a>        ax2.set_ylim(<span class="fl">0.</span>, <span class="fl">0.7</span>)</span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a>        ax2.set_ylim(<span class="op">-</span><span class="fl">0.25</span>, <span class="fl">0.1</span>)</span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a>    best_ind <span class="op">=</span> np.argmax(y_left)</span>
<span id="cb8-19"><a href="#cb8-19" tabindex="-1"></a>    ax2.axvline(np.array(x)[best_ind], color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">':'</span>)</span>
<span id="cb8-20"><a href="#cb8-20" tabindex="-1"></a>    ax2.yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb8-21"><a href="#cb8-21" tabindex="-1"></a>    ax2.grid(<span class="va">True</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>disp_imp <span class="op">=</span> np.array(val_metrics[<span class="st">'disp_imp'</span>])</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>disp_imp_err <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> disp_imp</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>plot(thresh_arr, <span class="st">'Classification Thresholds'</span>,</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>     val_metrics[<span class="st">'bal_acc'</span>], <span class="st">'Balanced Accuracy'</span>,</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>     disp_imp_err, <span class="st">'1 - DI'</span>)</span></code></pre>
</div>
<p>If you like, you can plot other metrics, e.g., average odds
difference.</p>
<p>In the next cell, we write a function to print out a variety of other
metrics. Since we look at 1 - disparate impact, <strong>all of these
metrics have a value of 0 if they are perfectly fair</strong>. Again,
you can learn more details about the various metrics in the <a href="https://aif360.readthedocs.io/en/stable/modules/generated/aif360.metrics.ClassificationMetric.html#aif360.metrics.ClassificationMetric" class="external-link">AIF360
documentation</a>.</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="kw">def</span> describe_metrics(metrics, thresh_arr):</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>    best_ind <span class="op">=</span> np.argmax(metrics[<span class="st">'bal_acc'</span>])</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Threshold corresponding to Best balanced accuracy: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(thresh_arr[best_ind]))</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Best balanced accuracy: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'bal_acc'</span>][best_ind]))</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>    disp_imp_at_best_ind <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> metrics[<span class="st">'disp_imp'</span>][best_ind]</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Corresponding 1-DI value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(disp_imp_at_best_ind))</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Corresponding average odds difference value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'avg_odds_diff'</span>][best_ind]))</span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Corresponding statistical parity difference value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'stat_par_diff'</span>][best_ind]))</span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Corresponding equal opportunity difference value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'eq_opp_diff'</span>][best_ind]))</span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Corresponding Theil index value: </span><span class="sc">{:6.4f}</span><span class="st">"</span>.<span class="bu">format</span>(metrics[<span class="st">'theil_ind'</span>][best_ind]))</span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>describe_metrics(val_metrics, thresh_arr)</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="test-the-model">Test the model<a class="anchor" aria-label="anchor" href="#test-the-model"></a>
</h3>
<p>Now that we have used the validation data to select the best
threshold, we will evaluate the test the model on the test data.</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>lr_metrics <span class="op">=</span> test(dataset<span class="op">=</span>dataset_orig_panel19_test,</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>                       model<span class="op">=</span>lr_orig_panel19,</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>                       thresh_arr<span class="op">=</span>[thresh_arr[lr_orig_best_ind]])</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>describe_metrics(lr_metrics, [thresh_arr[lr_orig_best_ind]])</span></code></pre>
</div>
</div>
</section><section><h2 class="section-heading" id="mitigate-bias-with-in-processing">Mitigate bias with in-processing<a class="anchor" aria-label="anchor" href="#mitigate-bias-with-in-processing"></a>
<a class="anchor" aria-label="anchor" href="#mitigate-bias-with-in-processing"></a>
</h2>
<hr class="half-width">
<p>We will use reweighting as an in-processing step to try to increase
fairness. AIF360 has a function that performs reweighting that we will
use. If you’re interested, you can look at details about how it works in
<a href="https://aif360.readthedocs.io/en/latest/modules/generated/aif360.algorithms.preprocessing.Reweighing.html" class="external-link">the
documentation</a>.</p>
<p>If you look at the documentation, you will see that AIF360 classifies
reweighting as a preprocessing, not an in-processing intervention.
Technically, AIF360’s implementation modifies the dataset, not the
learning algorithm so it is pre-processing. But, it is functionally
equivalent to modifying the learning algorithm’s loss function, so we
follow the convention of the fair ML field and call it
in-processing.</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="co"># Reweighting is a AIF360 class to reweight the data </span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>RW <span class="op">=</span> Reweighing(unprivileged_groups<span class="op">=</span>unprivileged_groups,</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>                privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>dataset_transf_panel19_train <span class="op">=</span> RW.fit_transform(dataset_orig_panel19_train)</span></code></pre>
</div>
<p>We’ll also define metrics for the reweighted data and print out the
disparate impact of the dataset.</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>metric_transf_panel19_train <span class="op">=</span> BinaryLabelDatasetMetric(</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>        dataset_transf_panel19_train,</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>        unprivileged_groups<span class="op">=</span>unprivileged_groups,</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a>        privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>explainer_transf_panel19_train <span class="op">=</span> MetricTextExplainer(metric_transf_panel19_train)</span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="bu">print</span>(explainer_transf_panel19_train.disparate_impact())</span></code></pre>
</div>
<p>Then, we’ll train a model, validate it, and evaluate of the test
data.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="co"># train</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>dataset <span class="op">=</span> dataset_transf_panel19_train</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>model <span class="op">=</span> make_pipeline(StandardScaler(),</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>                      LogisticRegression(solver<span class="op">=</span><span class="st">'liblinear'</span>, random_state<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>fit_params <span class="op">=</span> {<span class="st">'logisticregression__sample_weight'</span>: dataset.instance_weights}</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a>lr_transf_panel19 <span class="op">=</span> model.fit(dataset.features, dataset.labels.ravel(), <span class="op">**</span>fit_params)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="co"># validate</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>thresh_arr <span class="op">=</span> np.linspace(<span class="fl">0.01</span>, <span class="fl">0.5</span>, <span class="dv">50</span>)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>val_metrics <span class="op">=</span> test(dataset<span class="op">=</span>dataset_orig_panel19_val,</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>                   model<span class="op">=</span>lr_transf_panel19,</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>                   thresh_arr<span class="op">=</span>thresh_arr)</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>lr_transf_best_ind <span class="op">=</span> np.argmax(val_metrics[<span class="st">'bal_acc'</span>])</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="co"># plot validation results</span></span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>disp_imp <span class="op">=</span> np.array(val_metrics[<span class="st">'disp_imp'</span>])</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>disp_imp_err <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> np.minimum(disp_imp, <span class="dv">1</span><span class="op">/</span>disp_imp)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>plot(thresh_arr, <span class="st">'Classification Thresholds'</span>,</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>     val_metrics[<span class="st">'bal_acc'</span>], <span class="st">'Balanced Accuracy'</span>,</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a>     disp_imp_err, <span class="st">'1 - min(DI, 1/DI)'</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="co"># describe validation results</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>describe_metrics(val_metrics, thresh_arr)</span></code></pre>
</div>
<div class="section level3">
<h3 id="test">Test<a class="anchor" aria-label="anchor" href="#test"></a>
</h3>
<p>lr_transf_metrics = test(dataset=dataset_orig_panel19_test,
model=lr_transf_panel19, thresh_arr=[thresh_arr[lr_transf_best_ind]])
describe_metrics(lr_transf_metrics, [thresh_arr[lr_transf_best_ind]]) We
see that the disparate impact score on the test data is better after
reweighting than it was originally.</p>
<p>How do the other fairness metrics compare? ## Mitigate bias with
preprocessing We will use a method, <a href="https://fairlearn.org/main/api_reference/generated/fairlearn.postprocessing.ThresholdOptimizer.html#fairlearn.postprocessing.ThresholdOptimizer" class="external-link">ThresholdOptimizer</a>,
that is implemented in the library <a href="https://fairlearn.org/" class="external-link">Fairlearn</a>. ThresholdOptimizer finds
custom thresholds for each demographic group so as to achieve parity in
the desired group fairness metric.</p>
<p>We will focus on demographic parity, but feel free to try other
metrics if you’re curious on how it does.</p>
<p>The first step is creating the ThresholdOptimizer object. We pass in
the demographic parity constraint, and indicate that we would like to
optimize the balanced accuracy score (other options include accuracy,
and true or false positive rate – see <a href="https://fairlearn.org/main/api_reference/generated/fairlearn.postprocessing.ThresholdOptimizer.html#fairlearn.postprocessing.ThresholdOptimizer" class="external-link">the
documentation</a> for more details).</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>to <span class="op">=</span> ThresholdOptimizer(estimator<span class="op">=</span>model, constraints<span class="op">=</span><span class="st">"demographic_parity"</span>, objective<span class="op">=</span><span class="st">"balanced_accuracy_score"</span>, prefit<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<p>Next, we fit the ThresholdOptimizer object to the validation
data.</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>to.fit(dataset_orig_panel19_val.features, dataset_orig_panel19_val.labels, </span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>       sensitive_features<span class="op">=</span>dataset_orig_panel19_val.protected_attributes[:,<span class="dv">0</span>])</span></code></pre>
</div>
<p>Then, we’ll create a helper function, <code>mini_test</code> to allow
us to call the <code>describe_metrics</code> function even though we are
no longer evaluating our method as a variety of thresholds.</p>
<p>After that, we call the ThresholdOptimizer’s predict function on the
validation and test data, and then compute metrics and print the
results.</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="kw">def</span> mini_test(dataset, preds):</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>    metric_arrs <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a>    dataset_pred <span class="op">=</span> dataset.copy()</span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>    dataset_pred.labels <span class="op">=</span> preds</span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a>    metric <span class="op">=</span> ClassificationMetric(</span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a>            dataset, dataset_pred,</span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a>            unprivileged_groups<span class="op">=</span>unprivileged_groups,</span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a>            privileged_groups<span class="op">=</span>privileged_groups)</span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a>    <span class="co"># various metrics - can look up what they are on your own</span></span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a>    metric_arrs[<span class="st">'bal_acc'</span>].append((metric.true_positive_rate()</span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a>                                    <span class="op">+</span> metric.true_negative_rate()) <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a>    metric_arrs[<span class="st">'avg_odds_diff'</span>].append(metric.average_odds_difference())</span>
<span id="cb20-14"><a href="#cb20-14" tabindex="-1"></a>    metric_arrs[<span class="st">'disp_imp'</span>].append(metric.disparate_impact())</span>
<span id="cb20-15"><a href="#cb20-15" tabindex="-1"></a>    metric_arrs[<span class="st">'stat_par_diff'</span>].append(metric.statistical_parity_difference())</span>
<span id="cb20-16"><a href="#cb20-16" tabindex="-1"></a>    metric_arrs[<span class="st">'eq_opp_diff'</span>].append(metric.equal_opportunity_difference())</span>
<span id="cb20-17"><a href="#cb20-17" tabindex="-1"></a>    metric_arrs[<span class="st">'theil_ind'</span>].append(metric.theil_index())</span>
<span id="cb20-18"><a href="#cb20-18" tabindex="-1"></a>    </span>
<span id="cb20-19"><a href="#cb20-19" tabindex="-1"></a>    <span class="cf">return</span> metric_arrs</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>to_val_preds <span class="op">=</span> to.predict(dataset_orig_panel19_val.features, sensitive_features<span class="op">=</span>dataset_orig_panel19_val.protected_attributes[:,<span class="dv">0</span>])</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>to_test_preds <span class="op">=</span> to.predict(dataset_orig_panel19_test.features, sensitive_features<span class="op">=</span>dataset_orig_panel19_test.protected_attributes[:,<span class="dv">0</span>])</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>to_val_metrics <span class="op">=</span> mini_test(dataset_orig_panel19_val, to_val_preds)</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>to_test_metrics <span class="op">=</span> mini_test(dataset_orig_panel19_test, to_test_preds)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Remember, `Threshold corresponding to Best balanced accuracy` is just a placeholder here."</span>)</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>describe_metrics(to_val_metrics, [<span class="dv">0</span>])</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb24">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Remember, `Threshold corresponding to Best balanced accuracy` is just a placeholder here."</span>)</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>describe_metrics(to_test_metrics, [<span class="dv">0</span>])</span></code></pre>
</div>
<p>Scroll up and see how these results compare with the original
classifier and with the in-processing technique.</p>
<p>A major difference is that the accuracy is lower, now. In practice,
it might be better to use an algorithm that allows a custom tradeoff
between the accuracy sacrifice and increased levels of fairness.</p>
<p>We can also see what threshold is being used for each demographic
group by examining the
<code>interpolated_thresholder_.interpretation_dict</code> property of
the ThresholdOptimzer.</p>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>threshold_rules_by_group <span class="op">=</span> to.interpolated_thresholder_.interpolation_dict</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>threshold_rules_by_group</span></code></pre>
</div>
<p>Recall that a value of 1 in the Race column corresponds to White
people, while a value of 0 corresponds to non-White people.</p>
<p>Due to the inherent randomness of the ThresholdOptimizer, you might
get slightly different results than your neighbors. When we ran the
previous cell, the output was</p>
<p><code>{0.0: {'p0': 0.9287205987170348,   'operation0': [&gt;0.5],   'p1': 0.07127940128296517,   'operation1': [&gt;-inf]},  1.0: {'p0': 0.002549618320610717,   'operation0': [&gt;inf],   'p1': 0.9974503816793893,   'operation1': [&gt;0.5]}}</code></p>
<p>This tells us that for non-White individuals:</p>
<ul>
<li><p>If the score is above 0.5, predict 1.</p></li>
<li><p>Otherwise, predict 1 with probability 0.071</p></li>
</ul>
<p>And for White individuals:</p>
<ul>
<li>If the score is above 0.5, predict 1 with probability 0.997</li>
</ul>
<p><strong>Discussion question:</strong> what are the pros and cons of
improving the model fairness by introducing randomization?</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>It’s important to consider many dimensions of model performance: a
single accuracy score is not sufficient.</li>
<li>There is no single definition of “fair machine learning”: different
notions of fairness are appropriate in different contexts.</li>
<li>Representational harms and stereotypes can be perpetuated by
generative AI.</li>
<li>The fairness of a model can be improved by using techniques like
data reweighting and model postprocessing.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-4-explainability-vs-interpretability"><p>Content from <a href="4-explainability-vs-interpretability.html">Interpretablility versus explainability</a></p>
<hr>
<p>Last updated on 2024-07-17 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/4-explainability-vs-interpretability.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are popular machine learning models?</li>
<li>What are model intepretability and model explainability? Why are
they important?</li>
<li>Which should you choose: interpretable models or explainable
models?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Showcase machine learning models that are widely used in
practice.</li>
<li>Understand and distinguish between explainable machine learning
models and interpretable machine learning models.</li>
<li>Describe two reasons when deciding which model to choose.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>
<strong>Model Explainability vs. Model Interpretability:</strong>
<ul>
<li>
<strong>Interpretability:</strong> Refers to the degree to which a
human can understand the cause of a decision made by a model. It is
essential for verifying the correctness of the model, ensuring
compliance with regulations, and enabling effective debugging.</li>
<li>
<strong>Explainability:</strong> Refers to the extent to which the
internal mechanics of a machine learning model can be explained in human
terms. It is crucial for understanding how models make decisions,
ensuring transparency, and building trust with stakeholders.</li>
</ul>
</li>
<li>
<strong>Choosing Between Explainable and Interpretable
Models:</strong>
<ul>
<li>
<strong>When Transparency is Critical:</strong> Opt for
interpretable models (e.g., linear regression, decision trees) when it
is essential to have a clear understanding of how decisions are made,
such as in healthcare or finance.</li>
<li>
<strong>When Performance is a Priority:</strong> Choose explainable
models (e.g., neural networks, gradient boosting machines) when
predictive accuracy is the primary concern, and you can use explanation
methods to understand model behavior.</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="section level3 exercise">
<h3 id="exercise-1-model-selection-for-predicting-covid-19-progression-a-study-by-giotta-et-al-">Exercise 1: Model Selection for Predicting COVID-19 Progression, a
study by <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9602523/" class="external-link">Giotta et
al.</a>
<a class="anchor" aria-label="anchor" href="#exercise-1-model-selection-for-predicting-covid-19-progression-a-study-by-giotta-et-al-"></a>
</h3>
<p><strong>Objective:</strong></p>
<p>To predict bad outcomes (death or transfer to an intensive care unit)
from COVID-19 patients using hematological, biochemical, and
inflammatory biomarkers.</p>
<p><strong>Motivation:</strong></p>
<p>In the early days of the COVID-19 pandemic, healthcare professionals
around the world faced unprecedented challenges. Predicting the
progression of the disease and identifying patients at high risk of
severe outcomes became crucial for effective treatment and resource
allocation. One such study, published on the National Center for
Biotechnology Information (NCBI) website, investigated the
characteristics of patients who either succumbed to the disease or
required intensive care compared to those who recovered.</p>
<p>This study highlighted the critical role of various biomarkers, such
as hematological, biochemical, and inflammatory markers, in
understanding disease progression. However, simply identifying these
markers was not enough. Clinicians needed tools that could not only
predict outcomes with high accuracy but also provide clear,
understandable reasons for their predictions.</p>
<p><strong>Dataset Specification:</strong> Hematological biomarkers
included white blood cells, neutrophils count, lymphocytes count,
monocytes count, eosinophils count, platelet count, cluster of
differentiation (CD)4, CD8 percentages, and hemoglobin. Biochemical
markers were albumin, alanine aminotransferase, aspartate
aminotransferase, total bilirubin, creatinine, creatinine kinase,
lactate dehydrogenase (LDH), cardiac troponin I, myoglobin, and creatine
kinase-MB. The coagulation markers were prothrombin time, activated
partial thromboplastin time (APTT), and D-dimer. The inflammatory
biomarkers were C-reactive protein (CRP), serum ferritin, procalcitonin
(PCT), erythrocyte sedimentation rate, and interleukin and tumor
necrosis factor-alpha (TNFα) levels.</p>
<p><strong>Some statistics from the dataset:</strong></p>
<p><strong>Table 1</strong>: Main characteristics of the patients
included in the study at baseline and results of comparison of
percentage between outcome using chi-square or Fisher exact test.</p>
<table class="table">
<colgroup>
<col width="24%">
<col width="44%">
<col width="23%">
<col width="7%">
</colgroup>
<thead><tr class="header">
<th></th>
<th>Death or Transferred to Intensive Care Unit (n = 32)</th>
<th>Discharged Alive (n = 113)</th>
<th>p-Value</th>
</tr></thead>
<tbody>
<tr class="odd">
<td></td>
<td>N</td>
<td>%</td>
<td>N</td>
</tr>
<tr class="even">
<td><strong>Sex</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Male</td>
<td>18</td>
<td>56.25%</td>
<td>61</td>
</tr>
<tr class="even">
<td>Female</td>
<td>14</td>
<td>43.75%</td>
<td>52</td>
</tr>
<tr class="odd">
<td><strong>Symptoms</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Dyspnea</td>
<td>12</td>
<td>37.50%</td>
<td>52</td>
</tr>
<tr class="odd">
<td>Cough</td>
<td>5</td>
<td>15.63%</td>
<td>35</td>
</tr>
<tr class="even">
<td>Fatigue</td>
<td>7</td>
<td>21.88%</td>
<td>30</td>
</tr>
<tr class="odd">
<td>Headache</td>
<td>2</td>
<td>6.25%</td>
<td>12</td>
</tr>
<tr class="even">
<td>Confusion</td>
<td>1</td>
<td>3.13%</td>
<td>9</td>
</tr>
<tr class="odd">
<td>Nausea</td>
<td>1</td>
<td>3.13%</td>
<td>8</td>
</tr>
<tr class="even">
<td>Sick</td>
<td>1</td>
<td>3.13%</td>
<td>6</td>
</tr>
<tr class="odd">
<td>Pharyngitis</td>
<td>1</td>
<td>3.13%</td>
<td>6</td>
</tr>
<tr class="even">
<td>Nasal congestion</td>
<td>1</td>
<td>3.13%</td>
<td>3</td>
</tr>
<tr class="odd">
<td>Arthralgia</td>
<td>0</td>
<td>0.00%</td>
<td>3</td>
</tr>
<tr class="even">
<td>Myalgia</td>
<td>1</td>
<td>3.13%</td>
<td>2</td>
</tr>
<tr class="odd">
<td>Arrhythmia</td>
<td>3</td>
<td>9.38%</td>
<td>12</td>
</tr>
<tr class="even">
<td><strong>Comorbidity</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Hypertension</td>
<td>12</td>
<td>37.50%</td>
<td>71</td>
</tr>
<tr class="even">
<td>Cardiovascular disease</td>
<td>12</td>
<td>37.50%</td>
<td>43</td>
</tr>
<tr class="odd">
<td>Diabetes</td>
<td>11</td>
<td>34.38%</td>
<td>35</td>
</tr>
<tr class="even">
<td>Cerebrovascular disease</td>
<td>9</td>
<td>28.13%</td>
<td>19</td>
</tr>
<tr class="odd">
<td>Chronic kidney disease</td>
<td>8</td>
<td>25.00%</td>
<td>14</td>
</tr>
<tr class="even">
<td>COPD</td>
<td>5</td>
<td>15.63%</td>
<td>14</td>
</tr>
<tr class="odd">
<td>Tumors</td>
<td>5</td>
<td>15.63%</td>
<td>11</td>
</tr>
<tr class="even">
<td>Hepatitis B</td>
<td>0</td>
<td>0.00%</td>
<td>6</td>
</tr>
<tr class="odd">
<td>Immunopathological disease</td>
<td>1</td>
<td>3.13%</td>
<td>5</td>
</tr>
</tbody>
</table>
<p><strong>Table 2</strong>: Comparison of clinical characteristics and
laboratory findings between patients who died or were transferred to ICU
and those who were discharged alive.</p>
<table class="table">
<colgroup>
<col width="27%">
<col width="42%">
<col width="22%">
<col width="7%">
</colgroup>
<thead><tr class="header">
<th></th>
<th>Patients Deaths or Transferred to ICU (n = 32)</th>
<th>Patients Alive (n = 113)</th>
<th>p-Value</th>
</tr></thead>
<tbody>
<tr class="odd">
<td></td>
<td>Median</td>
<td>Q1</td>
<td>Q3</td>
</tr>
<tr class="even">
<td><strong>Age (years)</strong></td>
<td>78.0</td>
<td>67.0</td>
<td>85.75</td>
</tr>
<tr class="odd">
<td><strong>Temperature (°C)</strong></td>
<td>36.5</td>
<td>36.0</td>
<td>36.9</td>
</tr>
<tr class="even">
<td><strong>Respiratory rate (rpm)</strong></td>
<td>20.0</td>
<td>18.0</td>
<td>20.0</td>
</tr>
<tr class="odd">
<td><strong>Cardiac frequency (rpm)</strong></td>
<td>79.0</td>
<td>70.0</td>
<td>90.0</td>
</tr>
<tr class="even">
<td><strong>Systolic blood pressure (mmHg)</strong></td>
<td>137.5</td>
<td>116.0</td>
<td>150.0</td>
</tr>
<tr class="odd">
<td><strong>Diastolic blood pressure (mmHg)</strong></td>
<td>77.5</td>
<td>65.0</td>
<td>83.0</td>
</tr>
<tr class="even">
<td><strong>Temperature at admission (°C)</strong></td>
<td>36.0</td>
<td>35.7</td>
<td>36.4</td>
</tr>
<tr class="odd">
<td><strong>Percentage of O2 saturation</strong></td>
<td>90.0</td>
<td>87.0</td>
<td>95.0</td>
</tr>
<tr class="even">
<td><strong>FiO2 (%)</strong></td>
<td>100.0</td>
<td>96.0</td>
<td>100.0</td>
</tr>
<tr class="odd">
<td>**Neutrophil count (*10^3/µL)**</td>
<td>7.98</td>
<td>4.75</td>
<td>10.5</td>
</tr>
<tr class="even">
<td>**Lymphocyte count (*10^3/µL)**</td>
<td>1.34</td>
<td>0.85</td>
<td>1.98</td>
</tr>
<tr class="odd">
<td>**Platelet count (*10^3/µL)**</td>
<td>202.00</td>
<td>147.5</td>
<td>272.25</td>
</tr>
<tr class="even">
<td><strong>Hemoglobin level (g/dL)</strong></td>
<td>12.7</td>
<td>11.8</td>
<td>14.5</td>
</tr>
<tr class="odd">
<td><strong>Procalcitonin levels (ng/mL)</strong></td>
<td>0.11</td>
<td>0.07</td>
<td>0.27</td>
</tr>
<tr class="even">
<td><strong>CRP (mg/dL)</strong></td>
<td>8.06</td>
<td>2.9</td>
<td>16.1</td>
</tr>
<tr class="odd">
<td><strong>LDH (mg/dL)</strong></td>
<td>307.0</td>
<td>258.5</td>
<td>386.0</td>
</tr>
<tr class="even">
<td><strong>Albumin (mg/dL)</strong></td>
<td>27.0</td>
<td>24.5</td>
<td>32.5</td>
</tr>
<tr class="odd">
<td><strong>ALT (mg/dL)</strong></td>
<td>23.0</td>
<td>12.0</td>
<td>47.5</td>
</tr>
<tr class="even">
<td><strong>AST (mg/dL)</strong></td>
<td>30.0</td>
<td>22.0</td>
<td>52.5</td>
</tr>
<tr class="odd">
<td><strong>ALP (mg/dL)</strong></td>
<td>70.0</td>
<td>53.5</td>
<td>88.0</td>
</tr>
<tr class="even">
<td><strong>Direct bilirubin (mg/dL)</strong></td>
<td>0.15</td>
<td>0.1</td>
<td>0.27</td>
</tr>
<tr class="odd">
<td><strong>Indirect bilirubin (mg/dL)</strong></td>
<td>0.15</td>
<td>0.012</td>
<td>0.002</td>
</tr>
<tr class="even">
<td><strong>Total bilirubin (mg/dL)</strong></td>
<td>0.3</td>
<td>0.2</td>
<td>0.6</td>
</tr>
<tr class="odd">
<td><strong>Creatinine (mg/dL)</strong></td>
<td>1.03</td>
<td>0.6</td>
<td>1.637</td>
</tr>
<tr class="even">
<td><strong>CPK (mg/dL)</strong></td>
<td>79.0</td>
<td>47.0</td>
<td>194.0</td>
</tr>
<tr class="odd">
<td><strong>Sodium (mg/dL)</strong></td>
<td>140.0</td>
<td>137.0</td>
<td>142.5</td>
</tr>
<tr class="even">
<td><strong>Potassium (mg/dL)</strong></td>
<td>4.4</td>
<td>4.0</td>
<td>5.0</td>
</tr>
<tr class="odd">
<td><strong>INR</strong></td>
<td>1.1</td>
<td>1.0</td>
<td>1.2</td>
</tr>
<tr class="even">
<td><strong>IL-6 (pg/mL)</strong></td>
<td>88.8</td>
<td>13.7</td>
<td>119.7</td>
</tr>
<tr class="odd">
<td><strong>IgM (AU/mL)</strong></td>
<td>3.4</td>
<td>0.0</td>
<td>8.1</td>
</tr>
<tr class="even">
<td><strong>IgG (AU/mL)</strong></td>
<td>12.0</td>
<td>5.7</td>
<td>13.4</td>
</tr>
<tr class="odd">
<td><strong>Length of stay (days)</strong></td>
<td>11.0</td>
<td>5.75</td>
<td>17.0</td>
</tr>
</tbody>
</table>
<p><strong>Real-World Impact:</strong></p>
<p>During the pandemic, numerous studies and models were developed to
aid in predicting COVID-19 outcomes. The study from this paper serves as
an excellent example of how detailed patient data can inform model
development. By designing a suitable machine learning model, researchers
and healthcare providers can not only achieve high predictive accuracy
but also ensure that their findings are actionable and trustworthy.</p>
<p><strong>Discussion Questions:</strong></p>
<ol style="list-style-type: decimal">
<li>
<strong>Compare the Advantages:</strong>
<ul>
<li>What are the advantages of using explainable models such as decision
trees in predicting COVID-19 outcomes?</li>
<li>What are the advantages of using black box models such as neural
networks in this scenario?</li>
</ul>
</li>
<li>
<strong>Assess the Drawbacks:</strong>
<ul>
<li>What are the potential drawbacks of using explainable models like
decision trees?</li>
<li>What are the potential drawbacks of using black box models in
healthcare settings?</li>
</ul>
</li>
<li>
<strong>Decision-Making Criteria:</strong>
<ul>
<li>In what situations might you prioritize an explainable model over a
black box model, and why?</li>
<li>Are there scenarios where the higher accuracy of black box models
justifies their use despite their lack of transparency?</li>
</ul>
</li>
<li>
<strong>Practical Application:</strong>
<ul>
<li>Design a simple decision tree based on the provided biomarkers to
predict bad outcomes.</li>
<li>Evaluate how the decision tree can aid healthcare providers in
making informed decisions.</li>
</ul>
</li>
</ol>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>
<strong>Compare the Advantages:</strong>
<ul>
<li>
<strong>Explainable Models:</strong> Allow healthcare professionals
to understand and trust the model’s decisions, providing clear insights
into which biomarkers contribute most to predicting bad outcomes. This
transparency is crucial in critical fields such as healthcare, where
understanding the decision-making process can inform treatment plans and
improve patient outcomes.</li>
<li>
<strong>Black Box Models:</strong> Often provide higher predictive
accuracy, which can be crucial for identifying patterns in complex
datasets. They can capture non-linear relationships and interactions
that simpler models might miss.</li>
</ul>
</li>
<li>
<strong>Assess the Drawbacks:</strong>
<ul>
<li>
<strong>Explainable Models:</strong> May not capture complex
relationships in the data as effectively as black box models,
potentially leading to lower predictive accuracy in some cases.</li>
<li>
<strong>Black Box Models:</strong> Can be difficult to interpret,
which hinders trust and adoption by medical professionals. Without
understanding the model’s reasoning, it becomes challenging to validate
its correctness, ensure regulatory compliance, and effectively debug or
refine the model.</li>
</ul>
</li>
<li>
<strong>Decision-Making Criteria:</strong>
<ul>
<li>
<strong>Prioritizing Explainable Models:</strong> When transparency,
trust, and regulatory compliance are critical, such as in healthcare
settings where understanding and validating decisions is essential.</li>
<li>
<strong>Using Black Box Models:</strong> When the need for high
predictive accuracy outweighs the need for transparency, and when
supplementary methods for interpreting the model’s output can be
employed.</li>
</ul>
</li>
<li>
<strong>Practical Application:</strong>
<ul>
<li>
<strong>Design a Decision Tree:</strong> Using the given biomarkers,
create a simple decision tree. Identify key split points (e.g., high CRP
levels, elevated LDH) and illustrate how these markers can be used to
predict bad outcomes. Tools like scikit-learn or any decision tree
visualization tool can be used.</li>
<li>
<strong>Example Decision Tree:</strong> Here is a <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9602523/figure/ijerph-19-13016-f003/" class="external-link">Decision
Tree</a> found by Giotta et al.</li>
</ul>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="section level3 exercise">
<h3 id="exercise2-covid-19-diagnosis-using-chest-x-rays-a-study-by-ucar-and-korkmaz">Exercise2: COVID-19 Diagnosis Using Chest X-Rays, a study by <a href="https://www.sciencedirect.com/science/article/pii/S0306987720307702" class="external-link">Ucar
and Korkmaz</a>
<a class="anchor" aria-label="anchor" href="#exercise2-covid-19-diagnosis-using-chest-x-rays-a-study-by-ucar-and-korkmaz"></a>
</h3>
<p><strong>Objective:</strong> Diagnose COVID-19 through chest
X-rays.</p>
<p><strong>Motivation:</strong></p>
<p>The COVID-19 pandemic has had an unprecedented impact on global
health, affecting millions of people worldwide. One of the critical
challenges in managing this pandemic is the rapid and accurate diagnosis
of infected individuals. Traditional methods, such as the Reverse
Transcription Polymerase Chain Reaction (RT-PCR) test, although widely
used, have several drawbacks. These tests are time-consuming, require
specialized equipment and personnel, and often suffer from low detection
rates, necessitating multiple tests to confirm a diagnosis.</p>
<p>In this context, radiological imaging, particularly chest X-rays, has
emerged as a valuable tool for COVID-19 diagnosis. Early studies have
shown that COVID-19 causes specific abnormalities in chest X-rays, such
as ground-glass opacities, which can be used as indicators of the
disease. However, interpreting these images requires expertise and time,
both of which are in short supply during a pandemic.</p>
<p>To address these challenges, researchers have turned to machine
learning techniques…</p>
<p><strong>Dataset Specification:</strong> <a href="https://ars.els-cdn.com/content/image/1-s2.0-S0306987720307702-gr5.jpg" class="external-link">Chest
X-ray images</a></p>
<p><strong>Real-World Impact:</strong></p>
<p>The COVID-19 pandemic highlighted the urgent need for rapid and
accurate diagnostic tools. Traditional methods like RT-PCR tests, while
effective, are often time-consuming and have variable detection rates.
Using chest X-rays for diagnosis offers a quicker and more accessible
alternative. By analyzing chest X-rays, healthcare providers can swiftly
identify COVID-19 cases, enabling timely treatment and isolation
measures. Developing a machine learning method that can quickly and
accurately analyze chest X-rays can significantly enhance the speed and
efficiency of the healthcare response, especially in areas with limited
access to RT-PCR testing.</p>
<p><strong>Discussion Questions:</strong></p>
<ol style="list-style-type: decimal">
<li>
<strong>Compare the Advantages:</strong>
<ul>
<li>What are the advantages of using deep neural networks in diagnosing
COVID-19 from chest X-rays?</li>
<li>What are the advantages of traditional methods, such as genomic data
analysis, for COVID-19 diagnosis?</li>
</ul>
</li>
<li>
<strong>Assess the Drawbacks:</strong>
<ul>
<li>What are the potential drawbacks of using deep neural networks for
COVID-19 diagnosis from chest X-rays?</li>
<li>How do these drawbacks compare to those of traditional methods?</li>
</ul>
</li>
<li>
<strong>Decision-Making Criteria:</strong>
<ul>
<li>In what situations might you prioritize using deep neural networks
over traditional methods, and why?</li>
<li>Are there scenarios where the rapid availability of X-ray results
justifies the use of deep neural networks despite potential
drawbacks?</li>
</ul>
</li>
<li>
<strong>Practical Application:</strong>
<ul>
<li>Design a simple deep neural network architecture for diagnosing
COVID-19 from chest X-rays.</li>
<li>Evaluate how this deep learning model can aid healthcare providers
in making informed decisions quickly.</li>
</ul>
</li>
</ol>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>
<strong>Compare the Advantages:</strong>
<ul>
<li>
<strong>Deep Neural Networks:</strong> Provide high accuracy (e.g.,
98%) in diagnosing COVID-19 from chest X-rays, offering a quick and
non-invasive diagnostic tool. They can handle large amounts of image
data and identify complex patterns that might be missed by human
eyes.</li>
<li>
<strong>Traditional Methods:</strong> Provide detailed and specific
diagnostic information by analyzing genomic data and biomarkers, which
can be crucial for understanding the virus’s behavior and patient
response.</li>
</ul>
</li>
<li>
<strong>Assess the Drawbacks:</strong>
<ul>
<li>
<strong>Deep Neural Networks:</strong> Require large labeled
datasets for training, which may not always be available. The models can
be seen as “black boxes”, making it challenging to interpret their
decisions without additional explainability methods.</li>
<li>
<strong>Traditional Methods:</strong> Time-consuming and may have
lower detection accuracy. They often require specialized equipment and
personnel, leading to delays in diagnosis.</li>
</ul>
</li>
<li>
<strong>Decision-Making Criteria:</strong>
<ul>
<li>
<strong>Prioritizing Deep Neural Networks:</strong> When rapid
diagnosis is critical, and chest X-rays are readily available. Useful in
large-scale screening scenarios where speed is more critical than the
detailed understanding provided by genomic data.</li>
<li>
<strong>Using Traditional Methods:</strong> When detailed and
specific information about the virus is needed for treatment planning,
and when the availability of genomic data and biomarkers is not a
bottleneck.</li>
</ul>
</li>
<li>
<strong>Practical Application:</strong>
<ul>
<li><p><strong>Design a Neural Network:</strong> Create a simple
convolutional neural network (CNN) architecture using tools like
TensorFlow or PyTorch. Use a dataset of labeled chest X-ray images to
train and validate the model.</p></li>
<li>
<p><strong>Example Model:</strong> Here is a <a href="https://ars.els-cdn.com/content/image/1-s2.0-S0306987720307702-ga1.jpg" class="external-link">model
proposed by Ucar and Korkmaz</a></p>
<ul>
<li>
<strong>Evaluate the Model:</strong> Train the model on your dataset
and evaluate its performance. Discuss how this model can help healthcare
providers make quick and accurate diagnoses.</li>
</ul>
</li>
</ul>
</li>
</ol>
</div>
</div>
</div>
</div></section><section id="aio-5a-explainable-AI-method-overview"><p>Content from <a href="5a-explainable-AI-method-overview.html">Explainability methods overview</a></p>
<hr>
<p>Last updated on 2024-07-10 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/5a-explainable-AI-method-overview.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="fantastic-explainability-methods-and-where-to-use-them">Fantastic Explainability Methods and Where to Use Them<a class="anchor" aria-label="anchor" href="#fantastic-explainability-methods-and-where-to-use-them"></a>
<a class="anchor" aria-label="anchor" href="#fantastic-explainability-methods-and-where-to-use-them"></a>
</h2>
<hr class="half-width">
<p>We will now take a bird’s-eye view of explainability methods that are
widely applied on complex models like neural networks. We will get a
sense of when to use which kind of method, and what the tradeoffs
between these methods are.</p>
</section><section><h2 class="section-heading" id="three-axes-of-use-cases-for-understanding-model-behavior">Three axes of use cases for understanding model behavior<a class="anchor" aria-label="anchor" href="#three-axes-of-use-cases-for-understanding-model-behavior"></a>
<a class="anchor" aria-label="anchor" href="#three-axes-of-use-cases-for-understanding-model-behavior"></a>
</h2>
<hr class="half-width">
<p>When deciding which explainability method to use, it is helpful to
define your setting along three axes. This helps in understanding the
context in which the model is being used, and the kind of insights you
are looking to gain from the model.</p>
<div class="section level3">
<h3 id="inherently-interpretable-vs-post-hoc-explainable">Inherently Interpretable vs Post Hoc Explainable<a class="anchor" aria-label="anchor" href="#inherently-interpretable-vs-post-hoc-explainable"></a>
</h3>
<p>Understanding the tradeoff between interpretability and complexity is
crucial in machine learning. Simple models like decision trees, random
forests, and linear regression offer transparency and ease of
understanding, making them ideal for explaining predictions to
stakeholders. In contrast, neural networks, while powerful, lack
interpretability due to their complexity. Post hoc explainable
techniques can be applied to neural networks to provide explanations for
predictions, but it’s essential to recognize that using such methods
involves a tradeoff between model complexity and interpretability.</p>
<p>Striking the right balance between these factors is key to selecting
the most suitable model for a given task, considering both its
predictive performance and the need for interpretability.</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-interpretability-vs-complexity.png" alt="_Credits: AAAI 2021 Tutorial on Explaining Machine Learning Predictions: State of the Art, Challenges, Opportunities._" class="figure mx-auto d-block"><div class="figcaption">The tradeoff between Interpretability and
Complexity</div>
</figure>
</div>
<div class="section level3">
<h3 id="local-vs-global-explanations">Local vs Global Explanations<a class="anchor" aria-label="anchor" href="#local-vs-global-explanations"></a>
</h3>
<p>Local explanations focus on describing model behavior within a
specific neighborhood, providing insights into individual predictions.
Conversely, global explanations aim to elucidate overall model behavior,
offering a broader perspective. While global explanations may be more
comprehensive, they run the risk of being overly complex.</p>
<p>Both types of explanations are valuable for uncovering biases and
ensuring that the model makes predictions for the right reasons. The
tradeoff between local and global explanations has a long history in
statistics, with methods like linear regression (global) and kernel
smoothing (local) illustrating the importance of considering both
perspectives in statistical analysis.</p>
</div>
<div class="section level3">
<h3 id="black-box-vs-white-box-approaches">Black box vs White Box Approaches<a class="anchor" aria-label="anchor" href="#black-box-vs-white-box-approaches"></a>
</h3>
<p>Techniques that require access to model internals (e.g., model
architecture and model weights) are called “white box” while techniques
that only need query access to the model are called “black box”. Even
without access to the model weights, black box or top down approaches
can shed a lot of light on model behavior. For example, by simply
evaluating the model on certain kinds of data, high level biases or
trends in the model’s decision making process can be unearthed.</p>
<p>White box approaches use the weights and activations of the model to
understand its behavior. These classes or methods are more complex and
diverse, and we will discuss them in more detail later in this episode.
Some large models are closed-source due to commercial or safety
concerns; for example, users can’t get access to the weights of GPT-4.
This limits the use of white box explanations for such models.</p>
</div>
</section><section><h2 class="section-heading" id="classes-of-explainability-methods-for-understanding-model-behavior">Classes of Explainability Methods for Understanding Model
Behavior<a class="anchor" aria-label="anchor" href="#classes-of-explainability-methods-for-understanding-model-behavior"></a>
<a class="anchor" aria-label="anchor" href="#classes-of-explainability-methods-for-understanding-model-behavior"></a>
</h2>
<hr class="half-width">
<div class="section level3">
<h3 id="diagnostic-testing">Diagnostic Testing<a class="anchor" aria-label="anchor" href="#diagnostic-testing"></a>
</h3>
<p>This is the simplest approach towards explaining model behavior. This
involves applying a series of unit tests to the model, where each test
is a sample input where you know what the correct output should be. By
identifying test examples that break the heuristics the model relies on
(called counterfactuals), you can gain insights into the high-level
behavior of the model.</p>
<p><strong>Example Methods:</strong> <a href="https://arxiv.org/abs/1902.01007" class="external-link">Counterfactuals</a>, <a href="https://arxiv.org/abs/2005.04118" class="external-link">Unit tests</a></p>
<p><strong>Pros and Cons:</strong> These methods allow for gaining
insights into the high-level behavior of the model without the needing
access to model weights. This is especially useful with recent powerful
closed-source models like GPT-4. One challenge with this approach is
that it is hard to identify in advance what heuristics a model may
depend on.</p>
</div>
<div class="section level3">
<h3 id="baking-interpretability-into-models">Baking interpretability into models<a class="anchor" aria-label="anchor" href="#baking-interpretability-into-models"></a>
</h3>
<p>Some recent research has focused on tweaking highly complex models
like neural networks, towards making them more interpretable inherently.
One such example with language models involves training the model to
generate rationales for its prediction, in addition to its original
prediction. This approach has gained some traction, and there are even
<a href="https://arxiv.org/abs/1911.03429" class="external-link">public benchmarks</a> for
evaluating the quality of these generated rationales.</p>
<p><strong>Example methods:</strong> <a href="https://arxiv.org/abs/2004.14546" class="external-link">Rationales with WT5</a>, <a href="https://arxiv.org/abs/1606.04155" class="external-link">Older approaches for
rationales</a></p>
<p><strong>Pros and cons:</strong> These models hope to achieve the best
of both worlds: complex models that are also inherently interpretable.
However, research in this direction is still new, and there are no
established and reliable approaches for real world applications just
yet.</p>
</div>
<div class="section level3">
<h3 id="identifying-decision-rules-of-the-model">Identifying Decision Rules of the Model:<a class="anchor" aria-label="anchor" href="#identifying-decision-rules-of-the-model"></a>
</h3>
<p>In this class of methods, we try find a set of rules that generally
explain the decision making process of the model. Loosely, these rules
would be of the form “if a specific condition is met, then the model
will predict a certain class”.</p>
<p><strong>Example methods:</strong> <a href="https://aaai.org/papers/11491-anchors-high-precision-model-agnostic-explanations/" class="external-link">Anchors</a>,
<a href="https://arxiv.org/abs/1908.07125" class="external-link">Universal Adversarial
Triggers</a></p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-anchors-example.png" alt='Table caption: "Generated anchors for Tabular datasets". Table shows the following rules: for the adult dataset, predict less than 50K if no capital gain or loss and never married. Predict over 50K if country is US, married, and work hours over 45. For RCDV dataset, predict not rearrested if person has no priors, no prison violations, and crime not against property. Predict re-arrested if person is male, black, has 1-5 priors, is not married, and the crime not against property. For the Lending dataset, predict bad loan if FICO score is less than 650. Predict good loan if FICO score is between 650 and 700 and loan amount is between 5400 and 10000.' class="figure mx-auto d-block"><div class="figcaption">Example use of anchors (table from <a href="https://aaai.org/papers/11491-anchors-high-precision-model-agnostic-explanations/" class="external-link">Ribeiro
et al.</a>)</div>
</figure><p><strong>Pros and cons:</strong> Some global rules help find “bugs” in
the model, or identify high level biases. But finding such broad
coverage rules is challenging. Furthermore, these rules only showcase
the model’s weaknesses, but give next to no insight as to why these
weaknesses exist.</p>
</div>
<div class="section level3">
<h3 id="visualizing-model-weights-or-representations">Visualizing model weights or representations<a class="anchor" aria-label="anchor" href="#visualizing-model-weights-or-representations"></a>
</h3>
<p>Just like how a picture tells a thousand words, visualizations can
help encapsulate complex model behavior in a simple image.
Visualizations are commonly used in explaining neural networks, where
the weights or data representations of the model are directly
visualized. Many such approaches involve reducing the high-dimensional
weights or representations to a 2D or 3D space, using techniques like
PCA, tSNE, or UMAP. Alternatively, these visualizations can retain their
high dimensional representation, but use color or size to identify which
dimensions or neurons are more important.</p>
<p><strong>Example methods:</strong> <a href="https://arxiv.org/abs/1612.08220" class="external-link">Visualizing attention
heatmaps</a>, Weight visualizations, Model activation visualizations</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-visualization-heatmap.png" alt="Image shows a grid with 3 rows and 50 columns. Each cell is colored on a scale of -1.5 (white) to 0.9 (dark blue). Darker colors are concentrated in the first row in seemingly-random columns." class="figure mx-auto d-block"><div class="figcaption">Example usage of visualizing attention heatmaps
for part-of-speech (POS) identification task using word2vec-encoded
vectors. Each cell is a unit in a neural network (each row is a layer
and each column is a dimension). Darker colors indicates that a unit is
more importance for predictive accuracy (table from <a href="https://arxiv.org/pdf/1612.08220" class="external-link">Li et al.</a>.)</div>
</figure><p><strong>Pros and cons:</strong> Gleaning model behaviour from
visualizations is very intuitive and user-friendly, and visualizations
sometimes have interactive interfaces. However, visualizations can be
misleading, especially when high-dimensional vectors are reduced to 2D,
leading to a loss of information (crowding issue).</p>
<p>An iconic debate exemplifying the validity of visualizations has
centered around attention heatmaps. Research has shown them to be <a href="https://arxiv.org/abs/1902.10186" class="external-link">unreliable</a>, and then <a href="https://arxiv.org/abs/1908.04626" class="external-link">reliable again</a>. (Check out
the titles of these papers!) Thus, visualization can only be used as an
additional step in an analysis, and not as a standalone method.</p>
</div>
<div class="section level3">
<h3 id="understanding-the-impact-of-training-examples">Understanding the impact of training examples<a class="anchor" aria-label="anchor" href="#understanding-the-impact-of-training-examples"></a>
</h3>
<p>These techniques unearth which training data instances caused the
model to generate a specific prediction for a given sample. At a high
level, these techniques mathematically identify what training samples
that – if removed from the training process – are most influential for
causing a particular prediction.</p>
<p><strong>Example methods:</strong> <a href="https://arxiv.org/abs/1703.04730" class="external-link">Influence functions</a>, <a href="https://arxiv.org/abs/1811.09720" class="external-link">Representer point
selection</a></p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-influence.png" alt="Two images. On the left, several antelope are standing in the background on a grassy field. On the right, several zebra graze in a field in the background, while there is one antelope in the foreground and other antelope in the background." class="figure mx-auto d-block"><div class="figcaption">Example usage of representer point selection.
The image on the left is a test image that is misclassified as a deer
(the true label is antelope). The image on the right is the most
influential training point. We see that this image is labeled “zebra,”
but contains both zebras and antelopes. (example adapted from <a href="https://arxiv.org/pdf/1811.09720" class="external-link">Yeh et al.</a>.)</div>
</figure><p><strong>Pros and cons:</strong> The insights from these approaches
are actionable - by identifying the data responsible for a prediction,
it can help correct labels or annotation artifacts in that data.
Unfortunately, these methods scale poorly with the size of the model and
training data, quickly becoming computationally expensive. Furthermore,
even knowing which datapoints had a high influence on a prediction, we
don’t know what it was about that datapoint that caused the
influence.</p>
</div>
<div class="section level3">
<h3 id="understanding-the-impact-of-a-single-example">Understanding the impact of a single example:<a class="anchor" aria-label="anchor" href="#understanding-the-impact-of-a-single-example"></a>
</h3>
<p>For a single input, what parts of the input were most important in
generating the model’s prediction? These methods study the signal sent
by various features to the model, and observe how the model reacts to
changes in these features.</p>
<p><strong>Example methods:</strong> <a href="https://arxiv.org/abs/1312.6034" class="external-link">Saliency Maps</a>, <a href="https://arxiv.org/abs/1602.04938" class="external-link">LIME</a>/<a href="https://arxiv.org/abs/1705.07874" class="external-link">SHAP</a>, Perturbations (<a href="https://arxiv.org/abs/1804.07781" class="external-link">Input reduction</a>, <a href="https://arxiv.org/abs/1712.06751" class="external-link">Adversarial
Perturbations</a>)</p>
<p>These methods can be further subdivided into two categories:
gradient-based methods that rely on white-box model access to directly
see the impact of changing a single input, and perturbation-based
methods that manually perturb an input and re-query the model to see how
the prediction changes.</p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-smoothgrad.png" alt='Two rows images (5 images per row). Leftmost column shows two different pictures, each containing a cat and a dog. Remaining columns show the saliency maps using different techniques (VanillaGrad, InteGrad, GuidedBackProp, and SmoothGrad). Each saliency map has red dots (indicated regions that are influential for predicting "dog") and blue dots (influential for predicting "cat"). All methods except GuidedBackProp have good overlap between the respective dots and where the animals appear in the image. SmoothGrad has the most precise mapping.' class="figure mx-auto d-block"><div class="figcaption">Example saliency maps. The right 4 columns show
the result of different saliency method techniques, where red dots
indicate regions that are influential for predicting “dog” and blue dots
indicate regions that are influential for predicting “cat”. The image
creators argue that their method, SmoothGrad, is most effective at
mapping model behavior to images. (Image taken from <a href="https://arxiv.org/pdf/1706.03825" class="external-link">Smilkov et al.</a>)</div>
</figure><p><strong>Pros and cons:</strong> These methods are fast to compute,
and flexible in their use across models. However, the insights gained
from these methods are not actionable - knowing which part of the input
caused the prediction does not highlight why that part caused it. On
finding issues in the prediction process, it is also hard to pick up on
if there is an underlying issue in the model, or just the specific
inputs tested on. Relatedly, these methods can be unstable, and can even
be <a href="https://proceedings.neurips.cc/paper_files/paper/2019/hash/7fea637fd6d02b8f0adf6f7dc36aed93-Abstract.html" class="external-link">fooled
by adversarial examples</a>.</p>
</div>
<div class="section level3">
<h3 id="probing-internal-representations">Probing internal representations<a class="anchor" aria-label="anchor" href="#probing-internal-representations"></a>
</h3>
<p>As the name suggests, this class of methods aims to probe the
internals of a model, to discover what kind of information or knowledge
is stored inside the model. Probes are often administered to a specific
component of the model, like a set of neurons or layers within a neural
network.</p>
<p><strong>Example methods:</strong> <a href="https://direct.mit.edu/coli/article/48/1/207/107571/Probing-Classifiers-Promises-Shortcomings-and" class="external-link">Probing
classifiers</a>, <a href="https://proceedings.neurips.cc/paper/2020/hash/92650b2e92217715fe312e6fa7b90d82-Abstract.html" class="external-link">Causal
tracing</a></p>
<figure><img src="https://raw.githubusercontent.com/carpentries-incubator/fair-explainable-ml/main/images/e5-probe.png" alt='The phrase "The nurse examined the farmer for injuries because PRONOUN" is shown twice, once with PRONOUN=she and once with PRONOUN=he. Each word is annotated with the importance of three different attention heads. The distribution of which heads are important with each pronoun differs for all words, but especially for nurse and farmer.' class="figure mx-auto d-block"><div class="figcaption">Example probe output. The image shows the result
from probing three attention heads. We see that gender stereotypes are
encoded into the model because the heads that are important for nurse
and farmer change depending on the final pronoun. Specifically, Head
5-10 attends to the stereotypical gender assignment while Head 4-6
attends to the anti-stereotypical gender assignment. (Image taken from
<a href="https://proceedings.neurips.cc/paper/2020/hash/92650b2e92217715fe312e6fa7b90d82-Abstract.html" class="external-link">Vig
et al.</a>)</div>
</figure><p><strong>Pros and cons:</strong> Probes have shown that it is possible
to find highly interpretable components in a complex model, e.g., MLP
layers in transformers have been shown to store factual knowledge in a
structured manner. However, there is no systematic way of finding
interpretable components, and many components may remain elusive to
humans to understand. Furthermore, the model components that have been
shown to contain certain knowledge may not actually play a role in the
model’s prediction.</p>
<div id="is-that-all" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="is-that-all" class="callout-inner">
<h3 class="callout-title">Is that all?<a class="anchor" aria-label="anchor" href="#is-that-all"></a>
</h3>
<div class="callout-content">
<p>Nope! We’ve discussed a few of the common explanation techniques, but
many others exist. In particular, specialized model architectures often
need their own explanation algorithms. For instance, <a href="https://ieeexplore.ieee.org/abstract/document/9875989?casa_token=BiFHRXv7_9gAAAAA:wPV-PXOpCLFg2g1qYgEQ7QF_LKZs32cOXEJBvwjK3z43sXeaGfvQ9e1QePW03MTLq4lrUsh4Jw" class="external-link">Yuan
et al.</a> give an overview of different explanation techniques for
graph neural networks (GNNs).</p>
</div>
</div>
</div>
<div id="classifying-explanation-techniques" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="classifying-explanation-techniques" class="callout-inner">
<h3 class="callout-title">Classifying explanation techniques<a class="anchor" aria-label="anchor" href="#classifying-explanation-techniques"></a>
</h3>
<div class="callout-content">
<p>For each of the explanation techniques described above, discuss the
following with a partner:</p>
<ul>
<li>Does it require black-box or white-box model access?</li>
<li>Are the explanations it provides global or local?</li>
<li>Is the technique post-hoc or does it rely on inherent
interpretability of the model?</li>
</ul>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<table class="table">
<colgroup>
<col width="54%">
<col width="21%">
<col width="10%">
<col width="13%">
</colgroup>
<thead><tr class="header">
<th>Approach</th>
<th>Post Hoc or Inherently Interpretable?</th>
<th>Local or Global?</th>
<th>White Box or Black Box?</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><a href="#diagnostic-testing">Diagnostic Testing</a></td>
<td>Post Hoc</td>
<td>Global</td>
<td>Black Box</td>
</tr>
<tr class="even">
<td><a href="#baking-interpretability-into-models">Baking
interpretability into models</a></td>
<td>Inherently Interpretable</td>
<td>Local</td>
<td>White Box</td>
</tr>
<tr class="odd">
<td><a href="#identifying-decision-rules-of-the-model">Identifying
Decision Rules of the Model</a></td>
<td>Post Hoc</td>
<td>Both</td>
<td>White Box</td>
</tr>
<tr class="even">
<td><a href="#visualizing-model-weights-or-representations">Visualizing
model weights or representations</a></td>
<td>Post Hoc</td>
<td>Global</td>
<td>White Box</td>
</tr>
<tr class="odd">
<td><a href="#understanding-the-impact-of-training-examples">Understanding the
impact of training examples</a></td>
<td>Post Hoc</td>
<td>Local</td>
<td>White Box</td>
</tr>
<tr class="even">
<td><a href="#understanding-the-impact-of-a-single-example">Understanding the
impact of a single example</a></td>
<td>Post Hoc</td>
<td>Local</td>
<td>Both</td>
</tr>
<tr class="odd">
<td><a href="#probing-internal-representations">Probing internal
representations of a model</a></td>
<td>Post Hoc</td>
<td>Global/Local</td>
<td>White Box</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<p>What explanation should you use when? There is no simple answer, as
it depends upon your goals (i.e., why you need an explanation), who the
audience is, the model architecture, and the availability of model
internals (e.g., there is no white-box access to ChatGPT unless you work
for Open AI!). The next exercise asks you to consider different
scenarios and discuss what explanation techniques are appropriate.</p>
<div id="discussion2" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge<a class="anchor" aria-label="anchor" href="#discussion2"></a>
</h3>
<div class="callout-content">
<p>Think about the following scenarios and suggest which explainability
method would be most appropriate to use, and what information could be
gained from that method. Furthermore, think about the limitations of
your findings.</p>
<p><em>Note:</em> These are open-ended questions, and there is no
correct answer. Feel free to break into discussion groups to discuss the
scenarios.</p>
<p><strong>Scenario 1</strong>: Suppose that you are an ML engineer
working at a tech company. A fast-food chain company consults with you
about sentimental analysis based on feedback they collected on Yelp and
their survey. You use an open sourced LLM such as Llama-2 and finetune
it on the review text data. The fast-food company asks to provide
explanations for the model: Is there any outlier review? How does each
review in the data affect the finetuned model? Which part of the
language in the review indicates that a customer likes or dislikes the
food? Can you score the food quality according to the reviews? Does the
review show a trend over time? What item is gaining popularity or losing
popularity? Q: Can you suggest a few explainability methods that may be
useful for answering these questions?</p>
<p><strong>Scenario 2</strong>: Suppose that you are a radiologist who
analyzes medical images of patients with the help of machine learning
models. You use black-box models (e.g., CNNs, Vision Transformers) to
complement human expertise and get useful information before making
high-stake decisions. Which areas of a medical image most likely
explains the output of a black-box? Can we visualize and understand what
features are captured by the intermediate components of the black-box
models? How do we know if there is a distribution shift? How can we tell
if an image is an out-of-distribution example? Q: Can you suggest a few
explainability methods that may be useful for answering these
questions?</p>
<p><strong>Scenario 3</strong>: Suppose that you work on genomics and
you just collected samples of single-cell data into a table: each row
records gene expression levels, and each column represents a single
cell. You are interested in scientific hypotheses about evolution of
cells. You believe that only a few genes are playing a role in your
study. What exploratory data analysis techniques would you use to
examine the dataset? How do you check whether there are potential
outliers, irregularities in the dataset? You believe that only a few
genes are playing a role in your study. What can you do to find the set
of most explanatory genes? How do you know if there is clustering, and
if there is a trajectory of changes in the cells? Q: Can you explain the
decisions you make for each method you use?</p>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<p>There are many available explanation techniques and they differ along
three dimensions: model access (white-box or black-box), explanation
scope (global or local), and approach (inherently interpretable or
post-hoc). There’s often no objectively-right answer of which
explanation technique to use in a given situation, as the different
methods have different tradeoffs.</p>
<div class="section level3">
<h3 id="references-and-further-reading">References and Further Reading<a class="anchor" aria-label="anchor" href="#references-and-further-reading"></a>
</h3>
<p>This lesson provides a gentle overview into the world of
explainability methods. If you’d like to know more, here are some
resources to get you started:</p>
<ul>
<li>Tutorials on Explainability:
<ul>
<li><a href="https://github.com/Eric-Wallace/interpretability-tutorial-emnlp2020/blob/master/tutorial_slides.pdf" class="external-link">Wallace,
E., Gardner, M., &amp; Singh, S. (2020, November). Interpreting
predictions of NLP models. In Proceedings of the 2020 Conference on
Empirical Methods in Natural Language Processing: Tutorial Abstracts
(pp. 20-23).</a></li>
<li><a href="https://explainml-tutorial.github.io/aaai21" class="external-link">Lakkaraju, H.,
Adebayo, J., &amp; Singh, S. (2020). Explaining machine learning
predictions: State-of-the-art, challenges, and opportunities. NeurIPS
Tutorial.</a></li>
<li><a href="https://sebastiangehrmann.github.io/assets/files/acl_2020_interpretability_tutorial.pdf" class="external-link">Belinkov,
Y., Gehrmann, S., &amp; Pavlick, E. (2020, July). Interpretability and
analysis in neural NLP. In Proceedings of the 58th annual meeting of the
association for computational linguistics: tutorial abstracts
(pp. 1-5).</a></li>
</ul>
</li>
<li>Research papers:
<ul>
<li><a href="https://arxiv.org/abs/2308.00189" class="external-link">Holtzman, A., West, P.,
&amp; Zettlemoyer, L. (2023). Generative Models as a Complex Systems
Science: How can we make sense of large language model behavior?. arXiv
preprint arXiv:2308.00189.</a></li>
</ul>
</li>
</ul>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-5b-deep-dive-into-methods"><p>Content from <a href="5b-deep-dive-into-methods.html">Explainability methods: deep dive</a></p>
<hr>
<p>Last updated on 2024-07-03 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/5b-deep-dive-into-methods.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="a-deep-dive-into-methods-for-understanding-model-behaviour">A Deep Dive into Methods for Understanding Model Behaviour<a class="anchor" aria-label="anchor" href="#a-deep-dive-into-methods-for-understanding-model-behaviour"></a>
<a class="anchor" aria-label="anchor" href="#a-deep-dive-into-methods-for-understanding-model-behaviour"></a>
</h2>
<hr class="half-width">
<p>In the previous section, we scratched the surface of explainability
methods, introducing you to the broad classes of methods designed to
understand different aspects of a model’s behavior.</p>
<p>Now, we will dive deeper into two widely used methods, each one which
answers one key question:</p>
</section><section><h2 class="section-heading" id="what-part-of-my-input-causes-this-prediction">What part of my input causes this prediction?<a class="anchor" aria-label="anchor" href="#what-part-of-my-input-causes-this-prediction"></a>
<a class="anchor" aria-label="anchor" href="#what-part-of-my-input-causes-this-prediction"></a>
</h2>
<hr class="half-width">
<p>When a model makes a prediction, we often want to know which parts of
the input were most important in generating that prediction. This helps
confirm if the model is making its predictions for the right reasons.
Sometimes, models use features totally unrelated to the task for their
prediction - these are known as ‘spurious correlations’. For example, a
model might predict that a picture contains a dog because it was taken
in a park, and not because there is actually a dog in the picture.</p>
<p><strong><a href="https://arxiv.org/abs/1312.6034" class="external-link">Saliency
Maps</a></strong> are among the most simple and popular methods used
towards this end. We will be working with a more sophisticated version
of this method, known as <strong><a href="https://arxiv.org/abs/1610.02391" class="external-link">GradCAM</a></strong>.</p>
<div class="section level4">
<h4 id="method-and-examples">Method and Examples<a class="anchor" aria-label="anchor" href="#method-and-examples"></a>
</h4>
<p>A saliency map is a kind of visualization - it is a heatmap across
the input that shows which parts of the input are most important in
generating the model’s prediction. They can be calculated using the
gradients of a neural network, or by perturbing the input to any ML
model and observing how the model reacts to these perturbations. The key
intuition is that if a small change in a part of the input causes a
large change in the model’s prediction, then that part of the input is
important for the prediction. Gradients are useful in this because they
provide a signal towards how much the model’s prediction would change if
the input was changed slightly.</p>
<p>For example, in an image classification task, a saliency map can be
used to highlight the parts of the image that the model is focusing on
to make its prediction. In a text classification task, a saliency map
can be used to highlight the words or phrases that are most important
for the model’s prediction.</p>
<p>GradCAM is an extension of this idea, which uses the gradients of the
final layer of a convolutional neural network to generate a heatmap that
highlights the important regions of an image. This heatmap can be
overlaid on the original image to visualize which parts of the image are
most important for the model’s prediction.</p>
<p>Other variants of this method include <a href="https://arxiv.org/abs/1703.01365" class="external-link">Integrated Gradients</a>, <a href="https://arxiv.org/pdf/1806.03000" class="external-link">SmoothGrad</a>, and others,
which are designed to provide more robust and reliable explanations for
model predictions. However, GradCAM is a good starting point for
understanding how saliency maps work, and is a popularly used
approach.</p>
<p>Alternative approaches, which may not directly generate heatmaps,
include <a href="https://arxiv.org/abs/1602.04938" class="external-link">LIME</a> and <a href="https://arxiv.org/abs/1705.07874" class="external-link">SHAP</a>, which are also popular
and recommended for further reading.</p>
</div>
<div class="section level4">
<h4 id="limitations-and-extensions">Limitations and Extensions<a class="anchor" aria-label="anchor" href="#limitations-and-extensions"></a>
</h4>
<p>Gradient based saliency methods like GradCam are fast to compute,
requiring only a handful of backpropagation steps on the model to
generate the heatmap. The method is also model-agnostic, meaning it can
be applied to any model that can be trained using gradient descent.
Additionally, the results obtained from these methods are intuitive and
easy to understand, making them useful for explaining model predictions
to non-experts.</p>
<p>However, their use is limited to models that can be trained using
gradient descent, and have white-box access. It is also difficult to
apply these methods to tasks beyond classification, making their
application limited with many recent generative models (think LLMs).</p>
<p>Another limitation is that the insights gained from these methods are
not actionable - knowing which part of the input caused the prediction
does not highlight why that part caused it. On finding issues in the
prediction process, it is also hard to pick up on if there is an
underlying issue in the model, or just the specific inputs tested
on.</p>
</div>
</section><section><h2 class="section-heading" id="what-part-of-my-model-causes-this-prediction">What part of my model causes this prediction?<a class="anchor" aria-label="anchor" href="#what-part-of-my-model-causes-this-prediction"></a>
<a class="anchor" aria-label="anchor" href="#what-part-of-my-model-causes-this-prediction"></a>
</h2>
<hr class="half-width">
<p>When a model makes a correct prediction on a task it has been trained
on (known as a ‘downstream task’), <strong><a href="https://direct.mit.edu/coli/article/48/1/207/107571/Probing-Classifiers-Promises-Shortcomings-and" class="external-link">Probing
classifiers</a></strong> can be used to identify if the model actually
contains the relevant information or knowledge required to make that
prediction, or if it is just making a lucky guess. Furthermore, probes
can be used to identify the specific components of the model that
contain this relevant information, providing crucial insights for
developing better models over time.</p>
<div class="section level4">
<h4 id="method-and-examples-1">Method and Examples<a class="anchor" aria-label="anchor" href="#method-and-examples-1"></a>
</h4>
<p>A neural network takes its input as a series of vectors, or
representations, and transforms them through a series of layers to
produce an output. The job of the main body of the neural network is to
develop representations that are as useful for the downstream task as
possible, so that the final few layers of the network can make a good
prediction.</p>
<p>This essentially means that a good quality representation is one that
<em>already</em> contains all the information required to make a good
prediction. In other words, the features or representations from the
model are easily separable by a simple classifier. And that classifier
is what we call a ‘probe’. A probe is a simple model that uses the
representations of the model as input, and tries to learn the downstream
task from them. The probe itself is designed to be too easy to learn the
task on its own. This means, that the only way the probe get perform
well on this task is if the representations it is given are already good
enough to make the prediction.</p>
<p>These representations can be taken from any part of the model.
Generally, using representations from the last layer of a neural network
help identify if the model even contains the information to make
predictions for the downstream task. However, this can be extended
further: probing the representations from different layers of the model
can help identify where in the model the information is stored, and how
it is transformed through the model.</p>
<p>Probes have been frequently used in the domain of NLP, where they
have been used to check if language models contain certain kinds of
linguistic information. These probes can be designed with varying levels
of complexity. For example, simple probes have shown language models to
contain information about simple syntactical features like <a href="https://aclanthology.org/D15-1246.pdf" class="external-link">Part of Speech tags</a>,
and more complex probes have shown models to contain entire <a href="https://aclanthology.org/N19-1419.pdf" class="external-link">Parse trees</a> of
sentences.</p>
</div>
<div class="section level4">
<h4 id="limitations-and-extensions-1">Limitations and Extensions<a class="anchor" aria-label="anchor" href="#limitations-and-extensions-1"></a>
</h4>
<p>One large challenge in using probes is identifying the correct
architectural design of the probe. Too simple, and it may not be able to
learn the downstream task at all. Too complex, and it may be able to
learn the task even if the model does not contain the information
required to make the prediction.</p>
<p>Another large limitation is that even if a probe is able to learn the
downstream task, it does not mean that the model is actually using the
information contained in the representations to make the prediction. So
essentially, a probe can only tell us if a part of the model
<em>can</em> make the prediction, not if it <em>does</em> make the
prediction.</p>
<p>A new approach known as <strong><a href="https://proceedings.neurips.cc/paper/2020/hash/92650b2e92217715fe312e6fa7b90d82-Abstract.html" class="external-link">Causal
Tracing</a></strong> addresses this limitation. The objective of this
approach is similar to probes: attempting to understand which part of a
model contains information relevant to a downstream task. The approach
involves iterating through all parts of the model being examined
(e.g. all layers of a model), and disrupting the information flow
through that part of the model. (This could be as easy as adding some
kind of noise on top of the weights of that model component). If the
model performance on the downstream task suddenly drops on disrupting a
specific model component, we know for sure that that component not only
contains the information required to make the prediction, but that the
model is actually using that information to make the prediction.</p>
<div id="discussion1" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Challenge<a class="anchor" aria-label="anchor" href="#discussion1"></a>
</h3>
<div class="callout-content">
<p>Now, it’s time to try implementing these methods yourself! Pick one
of the following problems to work on:</p>
<ul>
<li><a href="code/5b-probes.ipynb">Train your own linear probe to check
if BERT stores the required knowledge for sentiment analysis.</a></li>
<li><a href="code/5b-gradcam.ipynb">Use GradCAM on a trained model to
check if the model is using the right features to make
predictions.</a></li>
</ul>
<p>It’s time to get your hands dirty now. Good luck, and have fun!</p>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-5c-probes"><p>Content from <a href="5c-probes.html">Explainability methods: linear probe</a></p>
<hr>
<p>Last updated on 2024-07-03 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/5c-probes.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># Let's start by importing the necessary libraries.</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="im">import</span> logging</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Tuple</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="im">from</span> sklearn.manifold <span class="im">import</span> TSNE</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="im">from</span> datasets <span class="im">import</span> load_dataset, Dataset</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> AutoModel, AutoTokenizer, AutoConfig</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>logging.basicConfig(level<span class="op">=</span>logging.INFO)</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>os.environ[<span class="st">'TOKENIZERS_PARALLELISM'</span>] <span class="op">=</span> <span class="st">'false'</span>  <span class="co"># This is needed to avoid a warning from huggingface</span></span></code></pre>
</div>
<p>Now, let’s set the random seed to ensure reproducibility. Setting
random seeds is like setting a starting point for your machine learning
adventure. It ensures that every time you train your model, it starts
from the same place, using the same random numbers, making your results
consistent and comparable.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Set random seeds for reproducibility - pick any number of your choice to set the seed. We use 42, since that is the answer to everything, after all.</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>torch.manual_seed(<span class="dv">42</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># Set the GPU to use</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>os.environ[<span class="st">'CUDA_VISIBLE_DEVICES'</span>] <span class="op">=</span> <span class="st">'0'</span>  </span></code></pre>
</div>
<div class="section level5">
<h5 id="loading-the-dataset">Loading the Dataset<a class="anchor" aria-label="anchor" href="#loading-the-dataset"></a>
</h5>
<p>Let’s load our data: the IMDB Movie Review dataset. The dataset
contains text reviews and their corresponding sentiment labels (positive
or negative). The label 1 corresponds to a positive review, and 0
corresponds to a negative review.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="kw">def</span> load_imdb_dataset(keep_samples: <span class="bu">int</span> <span class="op">=</span> <span class="dv">100</span>) <span class="op">-&gt;</span> Tuple[Dataset, Dataset, Dataset]:</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co">    Load the IMDB dataset from huggingface.</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="co">    The dataset contains text reviews and their corresponding sentiment labels (positive or negative).</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="co">    The label 1 corresponds to a positive review, and 0 corresponds to a negative review.</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="co">    :param keep_samples: Number of samples to keep, for faster training.</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="co">    :return: train, dev, test datasets. Each can be treated as a dictionary with keys 'text' and 'label'.</span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>    dataset <span class="op">=</span> load_dataset(<span class="st">'imdb'</span>)</span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a>    <span class="co"># Keep only a subset of the data for faster training</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a>    train_dataset <span class="op">=</span> Dataset.from_dict(dataset[<span class="st">'train'</span>].shuffle(seed<span class="op">=</span><span class="dv">42</span>)[:keep_samples])</span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a>    dev_dataset <span class="op">=</span> Dataset.from_dict(dataset[<span class="st">'test'</span>].shuffle(seed<span class="op">=</span><span class="dv">42</span>)[:keep_samples])</span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a>    test_dataset <span class="op">=</span> Dataset.from_dict(dataset[<span class="st">'test'</span>].shuffle(seed<span class="op">=</span><span class="dv">42</span>)[keep_samples:<span class="dv">2</span><span class="op">*</span>keep_samples])</span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a>    <span class="co"># train_dataset[0] will return {'text': ...., 'label': 0}</span></span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a>    logging.info(<span class="ss">f'Loaded IMDB dataset: </span><span class="sc">{</span><span class="bu">len</span>(train_dataset)<span class="sc">}</span><span class="ss"> training samples, </span><span class="sc">{</span><span class="bu">len</span>(dev_dataset)<span class="sc">}</span><span class="ss"> dev samples, </span><span class="sc">{</span><span class="bu">len</span>(test_dataset)<span class="sc">}</span><span class="ss"> test samples.'</span>)</span>
<span id="cb4-18"><a href="#cb4-18" tabindex="-1"></a>    <span class="cf">return</span> train_dataset, dev_dataset, test_dataset</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>train_dataset, dev_dataset, test_dataset <span class="op">=</span> load_imdb_dataset(keep_samples<span class="op">=</span><span class="dv">50</span>)</span></code></pre>
</div>
</div>
<div class="section level5">
<h5 id="loading-the-model">Loading the Model<a class="anchor" aria-label="anchor" href="#loading-the-model"></a>
</h5>
<p>We will load a model from huggingface, and use this model to get the
embeddings for the probe. We use BERT for this example, but feel free to
explore other models from huggingface after the exercise.</p>
<p>BERT is a transformer-based model, and is known to perform well on a
variety of NLP tasks. The model is pre-trained on a large corpus of
text, and can be fine-tuned for specific tasks.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="kw">def</span> load_model(model_name: <span class="bu">str</span>) <span class="op">-&gt;</span> Tuple[AutoModel, AutoTokenizer]:</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co">    Load a model from huggingface.</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co">    :param model_name: Check huggingface for acceptable model names.</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="co">    :return: Model and tokenizer.</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>    tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(model_name)</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>    config <span class="op">=</span> AutoConfig.from_pretrained(model_name)</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>    model <span class="op">=</span> AutoModel.from_pretrained(model_name, config<span class="op">=</span>config)</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>    model.config.max_position_embeddings <span class="op">=</span> <span class="dv">128</span>  <span class="co"># Reducing from default 512 to 128 for computational efficiency</span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>    logging.info(<span class="ss">f'Loaded model and tokenizer: </span><span class="sc">{</span>model_name<span class="sc">}</span><span class="ss"> with </span><span class="sc">{</span>model<span class="sc">.</span>config<span class="sc">.</span>num_hidden_layers<span class="sc">}</span><span class="ss"> layers, '</span></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>                 <span class="ss">f'hidden size </span><span class="sc">{</span>model<span class="sc">.</span>config<span class="sc">.</span>hidden_size<span class="sc">}</span><span class="ss"> and sequence length </span><span class="sc">{</span>model<span class="sc">.</span>config<span class="sc">.</span>max_position_embeddings<span class="sc">}</span><span class="ss">.'</span>)</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>    <span class="cf">return</span> model, tokenizer</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># To play around with other models, find a list of models and their model_ids at: https://huggingface.co/models</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>model, tokenizer <span class="op">=</span> load_model(<span class="st">'bert-base-uncased'</span>)</span></code></pre>
</div>
<p>Let’s see what the model’s architecture looks like. How many layers
does it have?</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="bu">print</span>(model)</span></code></pre>
</div>
<p>Let’s see if your answer matches the actual number of layers in the
model.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>num_layers <span class="op">=</span> model.config.num_hidden_layers</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'The model has </span><span class="sc">{</span>num_layers<span class="sc">}</span><span class="ss"> layers.'</span>)</span></code></pre>
</div>
</div>
<div class="section level5">
<h5 id="setting-up-the-probe">Setting up the Probe<a class="anchor" aria-label="anchor" href="#setting-up-the-probe"></a>
</h5>
<p>Before we define the probing classifier or probe, let’s set up some
utility functions the probe will use. The probe will be trained from
hidden representations from a specific layer of the BERT model. The
<code>get_embeddings_from_model</code> function will retrieve the
intermediate layer representations (also known as embeddings) from a
user defined layer number.</p>
<p>The <code>visualize_embeddings</code> method can be used to see what
these high dimensional hidden embeddings would look like when converted
into a 2D view. The visualization is not intended to be informative in
itself, and is only an additional tool used to get a sense of what the
inputs to the probing classifier may look like.</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="kw">def</span> get_embeddings_from_model(model: AutoModel, tokenizer: AutoTokenizer, layer_num: <span class="bu">int</span>, data: <span class="bu">list</span>[<span class="bu">str</span>]) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a><span class="co">    Get the embeddings from a model.</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="co">    :param model: The model to use. This is needed to get the embeddings.</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="co">    :param tokenizer: The tokenizer to use. This is needed to convert the data to input IDs.</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="co">    :param layer_num: The layer to get embeddings from. 0 is the input embeddings, and the last layer is the output embeddings.</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="co">    :param data: The data to get embeddings for. A list of strings.</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="co">    :return: The embeddings. Shape is N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a>    logging.info(<span class="ss">f'Getting embeddings from layer </span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss"> for </span><span class="sc">{</span><span class="bu">len</span>(data)<span class="sc">}</span><span class="ss"> samples...'</span>)</span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>    <span class="co"># Batch the data for computational efficiency</span></span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a>    batch_size <span class="op">=</span> <span class="dv">32</span></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a>    batch_num <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(data), batch_size):</span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a>        batch <span class="op">=</span> data[i:i<span class="op">+</span>batch_size]</span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a>        logging.info(<span class="ss">f'Getting embeddings for batch </span><span class="sc">{</span>batch_num<span class="sc">}</span><span class="ss">...'</span>)</span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a>        batch_num <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a>        <span class="co"># Tokenize the batch of data</span></span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a>        inputs <span class="op">=</span> tokenizer(batch, return_tensors<span class="op">=</span><span class="st">'pt'</span>, padding<span class="op">=</span><span class="va">True</span>, truncation<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a>        <span class="co"># Get the embeddings from the model</span></span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a>        outputs <span class="op">=</span> model(<span class="op">**</span>inputs, output_hidden_states<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a></span>
<span id="cb10-26"><a href="#cb10-26" tabindex="-1"></a>        <span class="co"># Get the embeddings for the specific the layer</span></span>
<span id="cb10-27"><a href="#cb10-27" tabindex="-1"></a>        embeddings <span class="op">=</span> outputs.hidden_states[layer_num]</span>
<span id="cb10-28"><a href="#cb10-28" tabindex="-1"></a></span>
<span id="cb10-29"><a href="#cb10-29" tabindex="-1"></a>        <span class="co"># Concatenate the embeddings from each batch</span></span>
<span id="cb10-30"><a href="#cb10-30" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb10-31"><a href="#cb10-31" tabindex="-1"></a>            all_embeddings <span class="op">=</span> embeddings</span>
<span id="cb10-32"><a href="#cb10-32" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb10-33"><a href="#cb10-33" tabindex="-1"></a>            all_embeddings <span class="op">=</span> torch.cat([all_embeddings, embeddings], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb10-34"><a href="#cb10-34" tabindex="-1"></a></span>
<span id="cb10-35"><a href="#cb10-35" tabindex="-1"></a>    logging.info(<span class="ss">f'Got embeddings for </span><span class="sc">{</span><span class="bu">len</span>(data)<span class="sc">}</span><span class="ss"> samples from layer </span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss">. Shape: </span><span class="sc">{</span>all_embeddings<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb10-36"><a href="#cb10-36" tabindex="-1"></a>    <span class="cf">return</span> all_embeddings</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="kw">def</span> visualize_embeddings(embeddings: torch.Tensor, labels: <span class="bu">list</span>, layer_num: <span class="bu">int</span>, save_plot: <span class="bu">bool</span> <span class="op">=</span> <span class="va">False</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="co">    Visualize the embeddings using t-SNE.</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="co">    :param embeddings: The embeddings to visualize. Shape is N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a><span class="co">    :param labels: The labels for the embeddings. A list of integers.</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="co">    :return: None</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>    <span class="co"># Since we are working with sentiment analysis, which is sentence based task, we can use sentence embeddings.</span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>    <span class="co"># The sentence embeddings are simply the mean of the token embeddings of that sentence.</span></span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>    sentence_embeddings <span class="op">=</span> torch.mean(embeddings, dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># N, D</span></span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a>    <span class="co"># Convert to numpy</span></span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a>    sentence_embeddings <span class="op">=</span> sentence_embeddings.detach().numpy()</span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a>    labels <span class="op">=</span> np.array(labels)</span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a>    <span class="co"># Visualize the embeddings using t-SNE</span></span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a>    tsne <span class="op">=</span> TSNE(n_components<span class="op">=</span><span class="dv">2</span>, random_state<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb11-19"><a href="#cb11-19" tabindex="-1"></a>    embeddings_2d <span class="op">=</span> tsne.fit_transform(sentence_embeddings)</span>
<span id="cb11-20"><a href="#cb11-20" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" tabindex="-1"></a>    negative_points <span class="op">=</span> embeddings_2d[labels <span class="op">==</span> <span class="dv">0</span>]</span>
<span id="cb11-22"><a href="#cb11-22" tabindex="-1"></a>    positive_points <span class="op">=</span> embeddings_2d[labels <span class="op">==</span> <span class="dv">1</span>]</span>
<span id="cb11-23"><a href="#cb11-23" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" tabindex="-1"></a>    <span class="co"># Plot the embeddings. We want to colour the datapoints by label.</span></span>
<span id="cb11-25"><a href="#cb11-25" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb11-26"><a href="#cb11-26" tabindex="-1"></a>    ax.scatter(negative_points[:, <span class="dv">0</span>], negative_points[:, <span class="dv">1</span>], label<span class="op">=</span><span class="st">'Negative'</span>, color<span class="op">=</span><span class="st">'red'</span>, marker<span class="op">=</span><span class="st">'o'</span>, s<span class="op">=</span><span class="dv">10</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb11-27"><a href="#cb11-27" tabindex="-1"></a>    ax.scatter(positive_points[:, <span class="dv">0</span>], positive_points[:, <span class="dv">1</span>], label<span class="op">=</span><span class="st">'Positive'</span>, color<span class="op">=</span><span class="st">'blue'</span>, marker<span class="op">=</span><span class="st">'o'</span>, s<span class="op">=</span><span class="dv">10</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb11-28"><a href="#cb11-28" tabindex="-1"></a>    plt.xlabel(<span class="st">'t-SNE dimension 1'</span>)</span>
<span id="cb11-29"><a href="#cb11-29" tabindex="-1"></a>    plt.ylabel(<span class="st">'t-SNE dimension 2'</span>)</span>
<span id="cb11-30"><a href="#cb11-30" tabindex="-1"></a>    plt.title(<span class="ss">f't-SNE of Sentence Embeddings - Layer</span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb11-31"><a href="#cb11-31" tabindex="-1"></a>    plt.legend()</span>
<span id="cb11-32"><a href="#cb11-32" tabindex="-1"></a></span>
<span id="cb11-33"><a href="#cb11-33" tabindex="-1"></a>    <span class="co"># Save the plot if needed, then display it</span></span>
<span id="cb11-34"><a href="#cb11-34" tabindex="-1"></a>    <span class="cf">if</span> save_plot:</span>
<span id="cb11-35"><a href="#cb11-35" tabindex="-1"></a>        plt.savefig(<span class="ss">f'tsne_layer_</span><span class="sc">{</span>layer_num<span class="sc">}</span><span class="ss">.png'</span>)</span>
<span id="cb11-36"><a href="#cb11-36" tabindex="-1"></a>    plt.show()</span>
<span id="cb11-37"><a href="#cb11-37" tabindex="-1"></a></span>
<span id="cb11-38"><a href="#cb11-38" tabindex="-1"></a>    logging.info(<span class="st">'Visualized embeddings using t-SNE.'</span>)</span></code></pre>
</div>
<p>Now, it’s finally time to define our probe! We set this up as a
class, where the probe itself is an object of this class. The class also
contains methods used to train and evaluate the probe.</p>
<p>Read through this code block in a bit more detail - from this whole
exercise, this part provides you with the most useful takeaways on ways
to define and train neural networks!</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="kw">class</span> Probe():</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, hidden_dim: <span class="bu">int</span> <span class="op">=</span> <span class="dv">768</span>, class_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">2</span>)  <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="co">        Initialize the probe.</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a><span class="co">        :param hidden_dim: The dimensionality of the hidden layer of the probe.</span></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a><span class="co">        :param num_layers: The number of layers in the probe.</span></span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a><span class="co">        :return: None</span></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>        <span class="co"># The probe is a simple linear classifier, with a hidden layer and an output layer.</span></span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a>        <span class="co"># The input to the probe is the embeddings from the model, and the output is the predicted class.</span></span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a>        <span class="co"># Exercise: Try playing around with the hidden_dim and num_layers to see how it affects the probe's performance.</span></span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a>        <span class="co"># But watch out: if a complex probe performs well on the task, we don't know if the performance</span></span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a>        <span class="co"># is because of the model embeddings, or the probe itself learning the task!</span></span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a>        <span class="va">self</span>.probe <span class="op">=</span> torch.nn.Sequential(</span>
<span id="cb12-18"><a href="#cb12-18" tabindex="-1"></a>            torch.nn.Linear(hidden_dim, hidden_dim),</span>
<span id="cb12-19"><a href="#cb12-19" tabindex="-1"></a>            torch.nn.ReLU(),</span>
<span id="cb12-20"><a href="#cb12-20" tabindex="-1"></a>            torch.nn.Linear(hidden_dim, class_size),</span>
<span id="cb12-21"><a href="#cb12-21" tabindex="-1"></a></span>
<span id="cb12-22"><a href="#cb12-22" tabindex="-1"></a>            <span class="co"># Add more layers here if needed</span></span>
<span id="cb12-23"><a href="#cb12-23" tabindex="-1"></a></span>
<span id="cb12-24"><a href="#cb12-24" tabindex="-1"></a>            <span class="co"># Sigmoid is used to convert the hidden states into a probability distribution over the classes</span></span>
<span id="cb12-25"><a href="#cb12-25" tabindex="-1"></a>            torch.nn.Sigmoid()</span>
<span id="cb12-26"><a href="#cb12-26" tabindex="-1"></a>        )</span>
<span id="cb12-27"><a href="#cb12-27" tabindex="-1"></a></span>
<span id="cb12-28"><a href="#cb12-28" tabindex="-1"></a></span>
<span id="cb12-29"><a href="#cb12-29" tabindex="-1"></a>    <span class="kw">def</span> train(<span class="va">self</span>, data_embeddings: torch.Tensor, labels: torch.Tensor, num_epochs: <span class="bu">int</span> <span class="op">=</span> <span class="dv">10</span>,</span>
<span id="cb12-30"><a href="#cb12-30" tabindex="-1"></a>              learning_rate: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.001</span>, batch_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">32</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb12-31"><a href="#cb12-31" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb12-32"><a href="#cb12-32" tabindex="-1"></a><span class="co">        Train the probe on the embeddings of data from the model.</span></span>
<span id="cb12-33"><a href="#cb12-33" tabindex="-1"></a><span class="co">        :param data_embeddings: A tensor of shape N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb12-34"><a href="#cb12-34" tabindex="-1"></a><span class="co">        :param labels: A tensor of shape N, where N is the number of samples. Each element is the label for the corresponding sample.</span></span>
<span id="cb12-35"><a href="#cb12-35" tabindex="-1"></a><span class="co">        :param num_epochs: The number of epochs to train the probe for. An epoch is one pass through the entire dataset.</span></span>
<span id="cb12-36"><a href="#cb12-36" tabindex="-1"></a><span class="co">        :param learning_rate: How fast the probe learns. A hyperparameter.</span></span>
<span id="cb12-37"><a href="#cb12-37" tabindex="-1"></a><span class="co">        :param batch_size: Used to batch the data for computational efficiency. A hyperparameter.</span></span>
<span id="cb12-38"><a href="#cb12-38" tabindex="-1"></a><span class="co">        :return:</span></span>
<span id="cb12-39"><a href="#cb12-39" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb12-40"><a href="#cb12-40" tabindex="-1"></a></span>
<span id="cb12-41"><a href="#cb12-41" tabindex="-1"></a>        <span class="co"># Setup the loss function (training objective) for the training process.</span></span>
<span id="cb12-42"><a href="#cb12-42" tabindex="-1"></a>        <span class="co"># The cross-entropy loss is used for multi-class classification, and represents the negative log likelihood of the true class.</span></span>
<span id="cb12-43"><a href="#cb12-43" tabindex="-1"></a>        criterion <span class="op">=</span> torch.nn.CrossEntropyLoss()</span>
<span id="cb12-44"><a href="#cb12-44" tabindex="-1"></a></span>
<span id="cb12-45"><a href="#cb12-45" tabindex="-1"></a>        <span class="co"># Setup the optimization algorithm to update the probe's parameters during training.</span></span>
<span id="cb12-46"><a href="#cb12-46" tabindex="-1"></a>        <span class="co"># The Adam optimizer is an extension to stochastic gradient descent, and is a popular choice.</span></span>
<span id="cb12-47"><a href="#cb12-47" tabindex="-1"></a>        optimizer <span class="op">=</span> torch.optim.Adam(<span class="va">self</span>.probe.parameters(), lr<span class="op">=</span>learning_rate)</span>
<span id="cb12-48"><a href="#cb12-48" tabindex="-1"></a></span>
<span id="cb12-49"><a href="#cb12-49" tabindex="-1"></a>        <span class="co"># Train the probe</span></span>
<span id="cb12-50"><a href="#cb12-50" tabindex="-1"></a>        logging.info(<span class="st">'Training the probe...'</span>)</span>
<span id="cb12-51"><a href="#cb12-51" tabindex="-1"></a>        <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(num_epochs):  <span class="co"># Pass over the data num_epochs times</span></span>
<span id="cb12-52"><a href="#cb12-52" tabindex="-1"></a></span>
<span id="cb12-53"><a href="#cb12-53" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(data_embeddings), batch_size):</span>
<span id="cb12-54"><a href="#cb12-54" tabindex="-1"></a></span>
<span id="cb12-55"><a href="#cb12-55" tabindex="-1"></a>                <span class="co"># Iterate through one batch of data at a time</span></span>
<span id="cb12-56"><a href="#cb12-56" tabindex="-1"></a>                batch_embeddings <span class="op">=</span> data_embeddings[i:i<span class="op">+</span>batch_size].detach()</span>
<span id="cb12-57"><a href="#cb12-57" tabindex="-1"></a>                batch_labels <span class="op">=</span> labels[i:i<span class="op">+</span>batch_size]</span>
<span id="cb12-58"><a href="#cb12-58" tabindex="-1"></a></span>
<span id="cb12-59"><a href="#cb12-59" tabindex="-1"></a>                <span class="co"># Convert to sentence embeddings, since we are performing a sentence classification task</span></span>
<span id="cb12-60"><a href="#cb12-60" tabindex="-1"></a>                batch_embeddings <span class="op">=</span> torch.mean(batch_embeddings, dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># N, D</span></span>
<span id="cb12-61"><a href="#cb12-61" tabindex="-1"></a></span>
<span id="cb12-62"><a href="#cb12-62" tabindex="-1"></a>                <span class="co"># Get the probe's predictions, given the embeddings from the model</span></span>
<span id="cb12-63"><a href="#cb12-63" tabindex="-1"></a>                outputs <span class="op">=</span> <span class="va">self</span>.probe(batch_embeddings)</span>
<span id="cb12-64"><a href="#cb12-64" tabindex="-1"></a></span>
<span id="cb12-65"><a href="#cb12-65" tabindex="-1"></a>                <span class="co"># Calculate the loss of the predictions, against the true labels</span></span>
<span id="cb12-66"><a href="#cb12-66" tabindex="-1"></a>                loss <span class="op">=</span> criterion(outputs, batch_labels)</span>
<span id="cb12-67"><a href="#cb12-67" tabindex="-1"></a></span>
<span id="cb12-68"><a href="#cb12-68" tabindex="-1"></a>                <span class="co"># Backward pass - update the probe's parameters</span></span>
<span id="cb12-69"><a href="#cb12-69" tabindex="-1"></a>                optimizer.zero_grad()</span>
<span id="cb12-70"><a href="#cb12-70" tabindex="-1"></a>                loss.backward()</span>
<span id="cb12-71"><a href="#cb12-71" tabindex="-1"></a>                optimizer.step()</span>
<span id="cb12-72"><a href="#cb12-72" tabindex="-1"></a></span>
<span id="cb12-73"><a href="#cb12-73" tabindex="-1"></a>        logging.info(<span class="st">'Trained the probe.'</span>)</span>
<span id="cb12-74"><a href="#cb12-74" tabindex="-1"></a></span>
<span id="cb12-75"><a href="#cb12-75" tabindex="-1"></a></span>
<span id="cb12-76"><a href="#cb12-76" tabindex="-1"></a>    <span class="kw">def</span> predict(<span class="va">self</span>, data_embeddings: torch.Tensor, batch_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">32</span>) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb12-77"><a href="#cb12-77" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb12-78"><a href="#cb12-78" tabindex="-1"></a><span class="co">        Get the probe's predictions on the embeddings from the model, for unseen data.</span></span>
<span id="cb12-79"><a href="#cb12-79" tabindex="-1"></a><span class="co">        :param data_embeddings: A tensor of shape N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb12-80"><a href="#cb12-80" tabindex="-1"></a><span class="co">        :param batch_size: Used to batch the data for computational efficiency.</span></span>
<span id="cb12-81"><a href="#cb12-81" tabindex="-1"></a><span class="co">        :return: A tensor of shape N, where N is the number of samples. Each element is the predicted class for the corresponding sample.</span></span>
<span id="cb12-82"><a href="#cb12-82" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb12-83"><a href="#cb12-83" tabindex="-1"></a></span>
<span id="cb12-84"><a href="#cb12-84" tabindex="-1"></a>        <span class="co"># Iterate through batches</span></span>
<span id="cb12-85"><a href="#cb12-85" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(data_embeddings), batch_size):</span>
<span id="cb12-86"><a href="#cb12-86" tabindex="-1"></a></span>
<span id="cb12-87"><a href="#cb12-87" tabindex="-1"></a>            <span class="co"># Iterate through one batch of data at a time</span></span>
<span id="cb12-88"><a href="#cb12-88" tabindex="-1"></a>            batch_embeddings <span class="op">=</span> data_embeddings[i:i<span class="op">+</span>batch_size]</span>
<span id="cb12-89"><a href="#cb12-89" tabindex="-1"></a></span>
<span id="cb12-90"><a href="#cb12-90" tabindex="-1"></a>            <span class="co"># Get the probe's predictions</span></span>
<span id="cb12-91"><a href="#cb12-91" tabindex="-1"></a>            outputs <span class="op">=</span> <span class="va">self</span>.probe(batch_embeddings)</span>
<span id="cb12-92"><a href="#cb12-92" tabindex="-1"></a></span>
<span id="cb12-93"><a href="#cb12-93" tabindex="-1"></a>            <span class="co"># Get the predicted class for each sample</span></span>
<span id="cb12-94"><a href="#cb12-94" tabindex="-1"></a>            _, predicted <span class="op">=</span> torch.<span class="bu">max</span>(outputs, <span class="dv">1</span>)</span>
<span id="cb12-95"><a href="#cb12-95" tabindex="-1"></a></span>
<span id="cb12-96"><a href="#cb12-96" tabindex="-1"></a>            <span class="co"># Concatenate the predictions from each batch</span></span>
<span id="cb12-97"><a href="#cb12-97" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb12-98"><a href="#cb12-98" tabindex="-1"></a>                all_predicted <span class="op">=</span> predicted</span>
<span id="cb12-99"><a href="#cb12-99" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb12-100"><a href="#cb12-100" tabindex="-1"></a>                all_predicted <span class="op">=</span> torch.cat([all_predicted, predicted], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-101"><a href="#cb12-101" tabindex="-1"></a></span>
<span id="cb12-102"><a href="#cb12-102" tabindex="-1"></a>        <span class="cf">return</span> all_predicted</span>
<span id="cb12-103"><a href="#cb12-103" tabindex="-1"></a></span>
<span id="cb12-104"><a href="#cb12-104" tabindex="-1"></a></span>
<span id="cb12-105"><a href="#cb12-105" tabindex="-1"></a>    <span class="kw">def</span> evaluate(<span class="va">self</span>, data_embeddings: torch.tensor, labels: torch.tensor, batch_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">32</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb12-106"><a href="#cb12-106" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb12-107"><a href="#cb12-107" tabindex="-1"></a><span class="co">        Evaluate the probe's performance by testing it on unseen data.</span></span>
<span id="cb12-108"><a href="#cb12-108" tabindex="-1"></a><span class="co">        :param data_embeddings: A tensor of shape N, L, D, where N is the number of samples, L is the length of the sequence, and D is the dimensionality of the embeddings.</span></span>
<span id="cb12-109"><a href="#cb12-109" tabindex="-1"></a><span class="co">        :param labels: A tensor of shape N, where N is the number of samples. Each element is the label for the corresponding sample.</span></span>
<span id="cb12-110"><a href="#cb12-110" tabindex="-1"></a><span class="co">        :return: The accuracy of the probe on the unseen data.</span></span>
<span id="cb12-111"><a href="#cb12-111" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb12-112"><a href="#cb12-112" tabindex="-1"></a></span>
<span id="cb12-113"><a href="#cb12-113" tabindex="-1"></a>        <span class="co"># Iterate through batches</span></span>
<span id="cb12-114"><a href="#cb12-114" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(data_embeddings), batch_size):</span>
<span id="cb12-115"><a href="#cb12-115" tabindex="-1"></a></span>
<span id="cb12-116"><a href="#cb12-116" tabindex="-1"></a>            <span class="co"># Iterate through one batch of data at a time</span></span>
<span id="cb12-117"><a href="#cb12-117" tabindex="-1"></a>            batch_embeddings <span class="op">=</span> data_embeddings[i:i<span class="op">+</span>batch_size]</span>
<span id="cb12-118"><a href="#cb12-118" tabindex="-1"></a>            batch_labels <span class="op">=</span> labels[i:i<span class="op">+</span>batch_size]</span>
<span id="cb12-119"><a href="#cb12-119" tabindex="-1"></a></span>
<span id="cb12-120"><a href="#cb12-120" tabindex="-1"></a>            <span class="co"># Convert to sentence embeddings, since we are performing a sentence classification task</span></span>
<span id="cb12-121"><a href="#cb12-121" tabindex="-1"></a>            batch_embeddings <span class="op">=</span> torch.mean(batch_embeddings, dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># N, D</span></span>
<span id="cb12-122"><a href="#cb12-122" tabindex="-1"></a></span>
<span id="cb12-123"><a href="#cb12-123" tabindex="-1"></a>            <span class="co"># Get the probe's predictions</span></span>
<span id="cb12-124"><a href="#cb12-124" tabindex="-1"></a>            <span class="cf">with</span> torch.no_grad():</span>
<span id="cb12-125"><a href="#cb12-125" tabindex="-1"></a>                outputs <span class="op">=</span> <span class="va">self</span>.probe(batch_embeddings)</span>
<span id="cb12-126"><a href="#cb12-126" tabindex="-1"></a></span>
<span id="cb12-127"><a href="#cb12-127" tabindex="-1"></a>            <span class="co"># Get the predicted class for each sample</span></span>
<span id="cb12-128"><a href="#cb12-128" tabindex="-1"></a>            _, predicted <span class="op">=</span> torch.<span class="bu">max</span>(outputs, dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb12-129"><a href="#cb12-129" tabindex="-1"></a></span>
<span id="cb12-130"><a href="#cb12-130" tabindex="-1"></a>            <span class="co"># Concatenate the predictions from each batch</span></span>
<span id="cb12-131"><a href="#cb12-131" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb12-132"><a href="#cb12-132" tabindex="-1"></a>                all_predicted <span class="op">=</span> predicted</span>
<span id="cb12-133"><a href="#cb12-133" tabindex="-1"></a>                all_labels <span class="op">=</span> batch_labels</span>
<span id="cb12-134"><a href="#cb12-134" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb12-135"><a href="#cb12-135" tabindex="-1"></a>                all_predicted <span class="op">=</span> torch.cat([all_predicted, predicted], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-136"><a href="#cb12-136" tabindex="-1"></a>                all_labels <span class="op">=</span> torch.cat([all_labels, batch_labels], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-137"><a href="#cb12-137" tabindex="-1"></a></span>
<span id="cb12-138"><a href="#cb12-138" tabindex="-1"></a>        <span class="co"># Calculate the accuracy of the probe</span></span>
<span id="cb12-139"><a href="#cb12-139" tabindex="-1"></a>        correct <span class="op">=</span> (all_predicted <span class="op">==</span> all_labels).<span class="bu">sum</span>().item()</span>
<span id="cb12-140"><a href="#cb12-140" tabindex="-1"></a>        accuracy <span class="op">=</span> correct <span class="op">/</span> all_labels.shape[<span class="dv">0</span>]</span>
<span id="cb12-141"><a href="#cb12-141" tabindex="-1"></a>        logging.info(<span class="ss">f'Probe accuracy: </span><span class="sc">{</span>accuracy<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb12-142"><a href="#cb12-142" tabindex="-1"></a></span>
<span id="cb12-143"><a href="#cb12-143" tabindex="-1"></a>        <span class="cf">return</span> accuracy</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="co"># Initialize the probing classifier (or probe)</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>probe <span class="op">=</span> Probe()</span></code></pre>
</div>
</div>
<div class="section level5">
<h5 id="analysing-the-model-using-probes">Analysing the model using Probes<a class="anchor" aria-label="anchor" href="#analysing-the-model-using-probes"></a>
</h5>
<p>Time to start evaluating the model using our probing tool! Let’s see
which layer has most information about sentiment analysis on IMDB. For
this, we will train the probe on embeddings from each layer of the
model, and see which layer performs the best on the dev set.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>layer_wise_accuracies <span class="op">=</span> []</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>best_probe, best_layer, best_accuracy <span class="op">=</span> <span class="va">None</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="cf">for</span> layer_num <span class="kw">in</span> <span class="bu">range</span>(num_layers):</span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>    logging.info(<span class="ss">f'</span><span class="ch">\n\n</span><span class="ss">Evaluating representations of layer </span><span class="sc">{</span>layer_num<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">...'</span>)</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>    train_embeddings <span class="op">=</span> get_embeddings_from_model(model, tokenizer, layer_num<span class="op">=</span>layer_num, data<span class="op">=</span>train_dataset[<span class="st">'text'</span>])</span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a>    dev_embeddings <span class="op">=</span> get_embeddings_from_model(model, tokenizer, layer_num<span class="op">=</span>layer_num, data<span class="op">=</span>dev_dataset[<span class="st">'text'</span>])</span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>    train_labels, dev_labels <span class="op">=</span> torch.tensor(train_dataset[<span class="st">'label'</span>],  dtype<span class="op">=</span>torch.<span class="bu">long</span>), torch.tensor(dev_dataset[<span class="st">'label'</span>],  dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a>    <span class="co"># Before training the probe, let's visualize the embeddings using t-SNE.</span></span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a>    <span class="co"># If the layer has information about sentiment analysis, would we see some structure in the embeddings?</span></span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a>    <span class="co"># Compare plots from layers where the probe does poorly, with ones where it does well. What do you notice?</span></span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a>    visualize_embeddings(embeddings<span class="op">=</span>train_embeddings, labels<span class="op">=</span>train_dataset[<span class="st">'label'</span>], layer_num<span class="op">=</span>layer_num, save_plot<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb14-15"><a href="#cb14-15" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" tabindex="-1"></a>    <span class="co"># Now, let's train the probe on the embeddings from the model.</span></span>
<span id="cb14-17"><a href="#cb14-17" tabindex="-1"></a>    <span class="co"># Feel free to play around with the training hyperparameters, and see what works best for your probe.</span></span>
<span id="cb14-18"><a href="#cb14-18" tabindex="-1"></a>    probe <span class="op">=</span> Probe()</span>
<span id="cb14-19"><a href="#cb14-19" tabindex="-1"></a>    probe.train(data_embeddings<span class="op">=</span>train_embeddings, labels<span class="op">=</span>train_labels,</span>
<span id="cb14-20"><a href="#cb14-20" tabindex="-1"></a>                num_epochs<span class="op">=</span><span class="dv">5</span>, learning_rate<span class="op">=</span><span class="fl">0.001</span>, batch_size<span class="op">=</span><span class="dv">32</span>)</span>
<span id="cb14-21"><a href="#cb14-21" tabindex="-1"></a></span>
<span id="cb14-22"><a href="#cb14-22" tabindex="-1"></a>    <span class="co"># Let's see how well our probe does on a held out dev set</span></span>
<span id="cb14-23"><a href="#cb14-23" tabindex="-1"></a>    accuracy <span class="op">=</span> probe.evaluate(data_embeddings<span class="op">=</span>dev_embeddings, labels<span class="op">=</span>dev_labels)</span>
<span id="cb14-24"><a href="#cb14-24" tabindex="-1"></a>    layer_wise_accuracies.append(accuracy)</span>
<span id="cb14-25"><a href="#cb14-25" tabindex="-1"></a></span>
<span id="cb14-26"><a href="#cb14-26" tabindex="-1"></a>    <span class="co"># Keep track of the best probe</span></span>
<span id="cb14-27"><a href="#cb14-27" tabindex="-1"></a>    <span class="cf">if</span> accuracy <span class="op">&gt;</span> best_accuracy:</span>
<span id="cb14-28"><a href="#cb14-28" tabindex="-1"></a>        best_probe, best_layer, best_accuracy <span class="op">=</span> probe, layer_num, accuracy</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="co"># Seeing a list of accuracies can be hard to interpret. Let's plot the layer-wise accuracies to see which layer is best.</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>plt.plot(layer_wise_accuracies)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>plt.xlabel(<span class="st">'Layer'</span>)</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>plt.ylabel(<span class="st">'Accuracy'</span>)</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>plt.title(<span class="st">'Probe Accuracy by Layer'</span>)</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>plt.grid(alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>plt.show()</span></code></pre>
</div>
<p>Which layer has the best accuracy? What does this tell us about the
model?</p>
<p>Let’s go ahead and stress test this. Is the best layer able to
predict sentiment for sentences outside the IMDB dataset?</p>
<p>For answering this question, you are the test set! Try to think of
challenging sequences for which the model may not be able to predict
sentiment.</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>test_sequences <span class="op">=</span> [<span class="st">'Your sentence here'</span>, <span class="st">'Here is another sentence'</span>]</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>embeddings <span class="op">=</span> get_embeddings_from_model(model<span class="op">=</span>model, tokenizer<span class="op">=</span>tokenizer, layer_num<span class="op">=</span>best_layer, data<span class="op">=</span>test_sequences)</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>preds <span class="op">=</span> probe.predict(data_embeddings<span class="op">=</span>embeddings)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>predictions <span class="op">=</span> [<span class="st">'Positive'</span> <span class="cf">if</span> pred <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="st">'Negative'</span> <span class="cf">for</span> pred <span class="kw">in</span> preds]</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Predictions for test sequences: </span><span class="sc">{</span>predictions<span class="sc">}</span><span class="ss">'</span>)</span></code></pre>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div></section><section id="aio-5d-gradcam"><p>Content from <a href="5d-gradcam.html">Explainability methods: GradCAM</a></p>
<hr>
<p>Last updated on 2024-07-03 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/5d-gradcam.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># Let's begin by installing the grad-cam package - this will significantly simplify our implementation</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="op">!</span>pip install grad<span class="op">-</span>cam</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Packages to download test images</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="im">import</span> requests</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="co"># Packages to view and process images</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="im">import</span> cv2</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="im">from</span> google.colab.patches <span class="im">import</span> cv2_imshow</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a><span class="co"># Packages to load the model</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a><span class="im">from</span> torchvision.models <span class="im">import</span> resnet50</span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a><span class="co"># GradCAM Packaes</span></span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a><span class="im">from</span> pytorch_grad_cam <span class="im">import</span> GradCAM</span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a><span class="im">from</span> pytorch_grad_cam.utils.model_targets <span class="im">import</span> ClassifierOutputTarget</span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a><span class="im">from</span> pytorch_grad_cam.utils.image <span class="im">import</span> show_cam_on_image, preprocess_image</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>device <span class="op">=</span> <span class="st">'gpu'</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">'cpu'</span></span></code></pre>
</div>
<div class="section level5">
<h5 id="load-model">Load Model<a class="anchor" aria-label="anchor" href="#load-model"></a>
</h5>
<p>We’ll load the ResNet-50 model from torchvision. This model is
pre-trained on the ImageNet dataset, which contains 1.2 million images
across 1000 classes. ResNet-50 is popular model that is a type of
convolutional neural network. You can learn more about it here: <a href="https://pytorch.org/hub/pytorch_vision_resnet/" class="external-link uri">https://pytorch.org/hub/pytorch_vision_resnet/</a></p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>model <span class="op">=</span> resnet50(pretrained<span class="op">=</span><span class="va">True</span>).to(device).<span class="bu">eval</span>()</span></code></pre>
</div>
</div>
<div class="section level5">
<h5 id="load-test-image">Load Test Image<a class="anchor" aria-label="anchor" href="#load-test-image"></a>
</h5>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># Let's first take a look at the image, which we source from the GradCAM package</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/jacobgil/pytorch-grad-cam/master/examples/both.png"</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>Image.<span class="bu">open</span>(requests.get(url, stream<span class="op">=</span><span class="va">True</span>).raw)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># Cute, isn't it? Do you prefer dogs or cats?</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co"># We will need to convert the image into a tensor to feed it into the model.</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co"># Let's create a function to do this for us.</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="kw">def</span> load_image(url):</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>    rgb_img <span class="op">=</span> np.array(Image.<span class="bu">open</span>(requests.get(url, stream<span class="op">=</span><span class="va">True</span>).raw))</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>    rgb_img <span class="op">=</span> np.float32(rgb_img) <span class="op">/</span> <span class="dv">255</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>    input_tensor <span class="op">=</span> preprocess_image(rgb_img).to(device)</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>    <span class="cf">return</span> input_tensor, rgb_img</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>input_tensor, rgb_image <span class="op">=</span> load_image(url)</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="grad-cam-time">Grad-CAM Time!<a class="anchor" aria-label="anchor" href="#grad-cam-time"></a>
</h3>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co"># Let's start by selecting which layers of the model we want to use to generate the CAM.</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="co"># For that, we will need to inspect the model architecture.</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="co"># We can do that by simply printing the model object.</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="bu">print</span>(model)</span></code></pre>
</div>
<p>Here we want to interpret what the model as a whole is doing (not
what a specific layer is doing). That means that we want to use the
embeddings of the last layer before the final classification layer. This
is the layer that contains the information about the image encoded by
the model as a whole.</p>
<p>Looking at the model, we can see that the last layer before the final
classification layer is <code>layer4</code>.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>target_layers <span class="op">=</span> [model.layer4]</span></code></pre>
</div>
<p>We also want to pick a label for the CAM - this is the class we want
to visualize the activation for. Essentially, we want to see what the
model is looking at when it is predicting a certain class.</p>
<p>Since ResNet was trained on the ImageNet dataset with 1000 classes,
let’s get an indexed list of those classes. We can then pick the index
of the class we want to visualize.</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>imagenet_categories_url <span class="op">=</span> <span class="op">\</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>     <span class="st">"https://gist.githubusercontent.com/yrevar/942d3a0ac09ec9e5eb3a/raw/238f720ff059c1f82f368259d1ca4ffa5dd8f9f5/imagenet1000_clsidx_to_labels.txt"</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>labels <span class="op">=</span> <span class="bu">eval</span>(requests.get(imagenet_categories_url).text)</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>labels</span></code></pre>
</div>
<p>Well, that’s a lot! To simplify things, we have already picked out
the indices of a few interesting classes.</p>
<ul>
<li>157: Siberian Husky</li>
<li>162: Beagle</li>
<li>245: French Bulldog</li>
<li>281: Tabby Cat</li>
<li>285: Egyptian cat</li>
<li>360: Otter</li>
<li>537: Dog Sleigh</li>
<li>799: Sliding Door</li>
<li>918: Street Sign</li>
</ul>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="co"># Specify the target class for visualization here. If you set this to None, the class with the highest score from the model will automatically be used.</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>visualized_class_id <span class="op">=</span> <span class="dv">245</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="kw">def</span> viz_gradcam(model, target_layers, class_id):</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>  <span class="cf">if</span> class_id <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>    targets <span class="op">=</span> <span class="va">None</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>    targets <span class="op">=</span> [ClassifierOutputTarget(class_id)]</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>  cam_algorithm <span class="op">=</span> GradCAM</span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>  <span class="cf">with</span> cam_algorithm(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers) <span class="im">as</span> cam:</span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>      grayscale_cam <span class="op">=</span> cam(input_tensor<span class="op">=</span>input_tensor,</span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a>                          targets<span class="op">=</span>targets)</span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a>      grayscale_cam <span class="op">=</span> grayscale_cam[<span class="dv">0</span>, :]</span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a></span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a>      cam_image <span class="op">=</span> show_cam_on_image(rgb_image, grayscale_cam, use_rgb<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a>      cam_image <span class="op">=</span> cv2.cvtColor(cam_image, cv2.COLOR_RGB2BGR)</span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a></span>
<span id="cb12-18"><a href="#cb12-18" tabindex="-1"></a>  cv2_imshow(cam_image)</span></code></pre>
</div>
<p>Finally, we can start visualizing! Let’s begin by seeing what parts
of the image the model looks at to make its most confident
prediction.</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="va">None</span>)</span></code></pre>
</div>
<p>Interesting, it looks like the model totally ignores the cat and
makes a prediction based on the dog. If we set the output class to
“French Bulldog” (<code>class_id=245</code>), we see the same
visualization - meaning that the model is indeed looking at the correct
part of the image to make the correct prediction.</p>
<p>Let’s see what the heatmap looks like when we force the model to look
at the cat.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">281</span>)</span></code></pre>
</div>
<p>The model is indeed looking at the cat when asked to predict the
class “Tabby Cat” (<code>class_id=281</code>)! But why is it still
predicting the dog? Well, the model was trained on the ImageNet dataset,
which contains a lot of images of dogs and cats. The model has learned
that the dog is a better indicator of the class “Tabby Cat” than the cat
itself.</p>
<p>Let’s see another example of this. The image has not only a dog and a
cat, but also a items in the background. Can the model correctly
identify the door?</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">799</span>)</span></code></pre>
</div>
<p>It can! However, it seems to also think of the shelf behind the dog
as a door.</p>
<p>Let’s try an unrelated object now. Where in the image does the model
see a street sign?</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">918</span>)</span></code></pre>
</div>
<p>Looks like our analysis has revealed a shortcoming of the model! It
seems to percieve cats and street signs similarly.</p>
<p>Ideally, when the target class is some unrelated object, a good model
will look at no significant part of the image. For example, the model
does a good job with the class for Dog Sleigh.</p>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>viz_gradcam(model<span class="op">=</span>model, target_layers<span class="op">=</span>target_layers, class_id<span class="op">=</span><span class="dv">537</span>)</span></code></pre>
</div>
<p>Explaining model predictions though visualization techniques like
this can be very subjective and prone to error. However, this still
provides some degree of insight a completely black box model would not
provide.</p>
<p>Spend some time playing around with different classes and seeing
which part of the image the model looks at. Feel free to play around
with other base images as well. Have fun! <!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 --></p>
</div></section><section id="aio-6-confidence-intervals"><p>Content from <a href="6-confidence-intervals.html">Estimating model uncertainty</a></p>
<hr>
<p>Last updated on 2024-06-19 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/6-confidence-intervals.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div></section><section id="aio-7-distribution-shift-OOD-detection"><p>Content from <a href="7-distribution-shift-OOD-detection.html">Distribution shift and OOD detection</a></p>
<hr>
<p>Last updated on 2024-06-19 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/7-distribution-shift-OOD-detection.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What is distribution shift and what are its implications in machine
learning models?</li>
<li>How can AI systems be deployed while ensuring that they do not break
when encountered with new data?</li>
<li>What are some of the latest methods in detecting out-of-distribution
data during inference?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand the concept of distribution shift in the context of
machine learning.</li>
<li>Identify the factors that can lead to distribution shift.</li>
<li>Explain the implications of distribution shift on the performance
and reliability of machine learning models.</li>
<li>Discuss strategies for detecting and mitigating distribution shift
in machine learning applications.</li>
<li>Identify best practices for robust model deployment and
monitoring.</li>
<li>Examine the importance of detecting out-of-distribution data in
machine learning applications.</li>
<li>Explore the limitations of traditional methods for detecting
out-of-distribution data.</li>
<li>Investigate state-of-the-art techniques for out-of-distribution
detection.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>TODO</li>
</ul>
</div>
</div>
</div>
<p>Lesson content is being drafted here: <a href="https://docs.google.com/document/d/1BpNwJK4jRhnNJCzZSFaueMOB7jKJJHupZ92bLmQlqYQ/edit?usp=sharing" class="external-link uri">https://docs.google.com/document/d/1BpNwJK4jRhnNJCzZSFaueMOB7jKJJHupZ92bLmQlqYQ/edit?usp=sharing</a></p>
<section><h2 class="section-heading" id="distribution-shift-and-its-implications">Distribution shift and its implications<a class="anchor" aria-label="anchor" href="#distribution-shift-and-its-implications"></a>
<a class="anchor" aria-label="anchor" href="#distribution-shift-and-its-implications"></a>
</h2>
<hr class="half-width"></section><section><h2 class="section-heading" id="overview-of-out-of-distribution-ood-detection-methods">Overview of out-of-distribution (OOD) detection methods<a class="anchor" aria-label="anchor" href="#overview-of-out-of-distribution-ood-detection-methods"></a>
<a class="anchor" aria-label="anchor" href="#overview-of-out-of-distribution-ood-detection-methods"></a>
</h2>
<hr class="half-width"></section><section><h2 class="section-heading" id="glossary">Glossary<a class="anchor" aria-label="anchor" href="#glossary"></a>
<a class="anchor" aria-label="anchor" href="#glossary"></a>
</h2>
<hr class="half-width">
<ul>
<li>ID/OOD: In-distribution, out-of-distribution. Generally, the OOD
instances can be defined as instances (x, y) sampled from an underlying
distribution other than the training distribution P(Xtrain, Ytrain),
where Xtrain and Ytrain are the training corpus and training label set,
respectively.</li>
<li>OOD instances with semantic shift: OOD instances with semantic shift
refer to instances that do not belong to y_train. More specifically,
instances with semantic shift may come from unknown categories or
irrelevant tasks.</li>
<li>OOD instances with non-semantic shift: OOD instances with
non-semantic shift refer to the instances that belong to Ytrain but are
sampled from a distribution other than Xtrain, e.g., a different
corpus.</li>
<li>Closed-world assumption: an assumption that the training and test
data are sampled from the same distribution. However, training data can
rarely capture the entire distribution. In real-world scenarios,
out-of-distribution (OOD) instances, which come from categories that are
not known to the model, can often be present in inference phases</li>
</ul></section><section><h2 class="section-heading" id="references-learn-more">References / Learn more<a class="anchor" aria-label="anchor" href="#references-learn-more"></a>
<a class="anchor" aria-label="anchor" href="#references-learn-more"></a>
</h2>
<hr class="half-width">
<ul>
<li>Zhou et al., Contrastive Out-of-Distribution Detection for
Pretrained Transformers, <a href="https://aclanthology.org/2021.emnlp-main.84.pdf" class="external-link uri">https://aclanthology.org/2021.emnlp-main.84.pdf</a>
</li>
<li>Uppaal et al., Is Fine-tuning Needed? Pre-trained Language Models
Are Near Perfect for Out-of-Domain Detection; <a href="https://aclanthology.org/2023.acl-long.717.pdf" class="external-link uri">https://aclanthology.org/2023.acl-long.717.pdf</a> <!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</li>
</ul></section></section><section id="aio-8-releasing-a-model"><p>Content from <a href="8-releasing-a-model.html">Documenting and releasing a model</a></p>
<hr>
<p>Last updated on 2024-07-16 |

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/episodes/8-releasing-a-model.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Why is model sharing important in the context of reproducibility and
responsible use?</li>
<li>What are the challenges, risks, and ethical considerations related
to sharing models?</li>
<li>How can model-sharing best practices be applied using tools like
model cards and the Hugging Face platform?</li>
<li>What is distribution shift and what are its implications in machine
learning models?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand the importance of model sharing and best practices to
ensure reproducibility and responsible use of models.</li>
<li>Understand the challenges, risks, and ethical concerns associated
with model sharing.</li>
<li>Apply model-sharing best practices through using model cards and the
Hugging Face platform.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>Model cards are the standard technique for communicating information
about how machine learning systems were trained and how they should and
should not be used.</li>
<li>Models can be shared and reused via the Hugging Face platform.</li>
</ul>
</div>
</div>
</div>
<div id="why-should-we-share-trained-models" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="why-should-we-share-trained-models" class="callout-inner">
<h3 class="callout-title">Why should we share trained models?<a class="anchor" aria-label="anchor" href="#why-should-we-share-trained-models"></a>
</h3>
<div class="callout-content">
<p>Discuss in small groups and report out: <em>Why do you believe it is
or isn’t important to share ML models? How has model-sharing contributed
to your experiences or projects?</em></p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<ul>
<li>
<strong>Accelerating research</strong>: Sharing models allows
researchers and practitioners to build upon existing work, accelerating
the pace of innovation in the field.</li>
<li>
<strong>Knowledge exchange</strong>: Model sharing promotes
knowledge exchange and collaboration within the machine learning
community, fostering a culture of open science.</li>
<li>
<strong>Reproducibility</strong>: Sharing models, along with
associated code and data, enhances reproducibility, enabling others to
validate and verify the results reported in research papers.</li>
<li>
<strong>Benchmarking</strong>: Shared models serve as benchmarks for
comparing new models and algorithms, facilitating the evaluation and
improvement of state-of-the-art techniques.</li>
<li>
<strong>Education / Accessibility to state-of-the-art
architectures</strong>: Shared models provide valuable resources for
educational purposes, allowing students and learners to explore and
experiment with advanced machine learning techniques.</li>
<li>
<strong>Repurpose (transfer learning and finetuning)</strong>: Some
models (i.e., foundation models) can be repurposed for a wide variety of
tasks. This is especially useful when working with limited data. Data
scarcity</li>
<li>
<strong>Resource efficiency</strong>: Instead of training a model
from the ground up, practitioners can use existing models as a starting
point, saving time, computational resources, and energy.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="challenges-and-risks-of-model-sharing" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="challenges-and-risks-of-model-sharing" class="callout-inner">
<h3 class="callout-title">Challenges and risks of model sharing<a class="anchor" aria-label="anchor" href="#challenges-and-risks-of-model-sharing"></a>
</h3>
<div class="callout-content">
<p>Discuss in small groups and report out: <em>What are some potential
challenges, risks, or ethical concerns associated with model sharing and
reproducing ML workflows?</em></p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<ul>
<li>
<strong>Privacy concerns</strong>: Sharing models that were trained
on sensitive or private data raises privacy concerns. The potential
disclosure of personal information through the model poses a risk to
individuals and can lead to unintended consequences.</li>
<li>
<strong>Informed consent</strong>: If models involve user data,
ensuring informed consent is crucial. Sharing models trained on
user-generated content without clear consent may violate privacy norms
and regulations.</li>
<li>
<strong>Data bias and fairness</strong>: Models trained on biased
datasets may perpetuate or exacerbate existing biases. Reproducing
workflows without addressing bias in the data may result in unfair
outcomes, particularly in applications like hiring or criminal
justice.</li>
<li>
<strong>Intellectual property</strong>: Models may be developed
within organizations with proprietary data and methodologies. Sharing
such models without proper consent or authorization may lead to
intellectual property disputes and legal consequences.</li>
<li>
<strong>Model robustness and generalization</strong>: Reproduced
models may not generalize well to new datasets or real-world scenarios.
Failure to account for the limitations of the original model can result
in reduced performance and reliability in diverse settings.</li>
<li>
<strong>Lack of reproducibility</strong>: Incomplete documentation,
missing details, or changes in dependencies over time can hinder the
reproducibility of ML workflows. This lack of reproducibility can impede
scientific progress and validation of research findings.</li>
<li>
<strong>Unintended use and misuse</strong>: Shared models may be
used in unintended ways, leading to ethical concerns. Developers should
consider the potential consequences of misuse, particularly in
applications with societal impact, such as healthcare or law
enforcement.</li>
<li>
<strong>Responsible AI considerations</strong>: Ethical
considerations, such as fairness, accountability, and transparency,
should be addressed during model sharing. Failing to consider these
aspects can result in models that inadvertently discriminate or lack
interpretability. Models used for decision-making, especially in
critical areas like healthcare or finance, should be ethically deployed.
Transparent documentation and disclosure of how decisions are made are
essential for responsible AI adoption.</li>
</ul>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="saving-model-locally">Saving model locally<a class="anchor" aria-label="anchor" href="#saving-model-locally"></a>
<a class="anchor" aria-label="anchor" href="#saving-model-locally"></a>
</h2>
<hr class="half-width">
<p>Let’s review the simplest method for sharing a model first — saving
the model locally. When working with PyTorch, it’s important to know how
to save and load models efficiently. This process ensures that you can
pause your work, share your models, or deploy them for inference without
having to retrain them from scratch each time.</p>
<div class="section level3">
<h3 id="define-model">Define model<a class="anchor" aria-label="anchor" href="#define-model"></a>
</h3>
<p>As an example, we’ll configure a simple perceptron (single hidden
layer) in PyTorch. We’ll define a bare bones class for this just so we
can initialize the model.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Dict, Any</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="kw">class</span> MyModel(nn.Module):</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, config: Dict[<span class="bu">str</span>, <span class="bu">int</span>]):</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>        <span class="co"># Parameter is a trainable tensor initialized with random values</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>        <span class="va">self</span>.param <span class="op">=</span> nn.Parameter(torch.rand(config[<span class="st">"num_channels"</span>], config[<span class="st">"hidden_size"</span>]))</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>        <span class="co"># Linear layer (fully connected layer) for the output</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>        <span class="va">self</span>.linear <span class="op">=</span> nn.Linear(config[<span class="st">"hidden_size"</span>], config[<span class="st">"num_classes"</span>])</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>        <span class="co"># Store the configuration</span></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>        <span class="va">self</span>.config <span class="op">=</span> config</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x: torch.Tensor) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>        <span class="co"># Forward pass: Add the input to the param tensor, then pass through the linear layer</span></span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.linear(x <span class="op">+</span> <span class="va">self</span>.param)</span></code></pre>
</div>
<p>Initialize model by calling the class with configuration
settings.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Create model instance with specific configuration</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>config <span class="op">=</span> {<span class="st">"num_channels"</span>: <span class="dv">3</span>, <span class="st">"hidden_size"</span>: <span class="dv">32</span>, <span class="st">"num_classes"</span>: <span class="dv">10</span>}</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>model <span class="op">=</span> MyModel(config<span class="op">=</span>config)</span></code></pre>
</div>
<p>We can then write a function to save out the model. We’ll need both
the model weights and the model’s configuration (hyperparameter
settings). We’ll saving the configurations as a json since a key/value
format is convenient here.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="im">import</span> json</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="co"># Function to save model and config locally</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="kw">def</span> save_model(model: nn.Module, model_path: <span class="bu">str</span>, config_path: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>    <span class="co"># Save model state dict (weights and biases) as a .pth file</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>    torch.save(model.state_dict(), model_path) <span class="co">#</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>    <span class="co"># Save config</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(config_path, <span class="st">'w'</span>) <span class="im">as</span> f:</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>        json.dump(model.config, f)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Save the model and config locally</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>save_model(model, <span class="st">"my_awesome_model.pth"</span>, <span class="st">"my_awesome_model_config.json"</span>)</span></code></pre>
</div>
<p>To load the model back in, we can write another function</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># Function to load model and config locally</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="kw">def</span> load_model(model_class: Any, model_path: <span class="bu">str</span>, config_path: <span class="bu">str</span>) <span class="op">-&gt;</span> nn.Module:</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>    <span class="co"># Load config</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(config_path, <span class="st">'r'</span>) <span class="im">as</span> f:</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>        config <span class="op">=</span> json.load(f)</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>    <span class="co"># Create model instance with config</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>    model <span class="op">=</span> model_class(config<span class="op">=</span>config)</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>    <span class="co"># Load model state dict</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>    model.load_state_dict(torch.load(model_path))</span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>    <span class="cf">return</span> model</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># Load the model and config locally</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>loaded_model <span class="op">=</span> load_model(MyModel, <span class="st">"my_awesome_model.pth"</span>, <span class="st">"my_awesome_model_config.json"</span>)</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co"># Verify the loaded model</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="bu">print</span>(loaded_model)</span></code></pre>
</div>
</div>
</section><section><h2 class="section-heading" id="saving-a-model-to-hugging-face">Saving a model to Hugging Face<a class="anchor" aria-label="anchor" href="#saving-a-model-to-hugging-face"></a>
<a class="anchor" aria-label="anchor" href="#saving-a-model-to-hugging-face"></a>
</h2>
<hr class="half-width">
<p>To share your model with a wider audience, we recommend uploading
your model to Hugging Face. Hugging Face is a very popular machine
learning (ML) platform and community that helps users build, deploy,
share, and train machine learning models. It has quickly become the
go-to option for sharing models with the public.</p>
<div class="section level3">
<h3 id="create-a-hugging-face-account-and-access-token">Create a Hugging Face account and access Token<a class="anchor" aria-label="anchor" href="#create-a-hugging-face-account-and-access-token"></a>
</h3>
<p>If you haven’t completed these steps from the setup, make sure to do
this now.</p>
<p><strong>Create account</strong>: To create an account on Hugging
Face, visit: <a href="https://huggingface.co/join" class="external-link">huggingface.co/join</a>. Enter an
email address and password, and follow the instructions provided via
Hugging Face (you may need to verify your email address) to complete the
process.</p>
<p><strong>Setup access token</strong>: Once you have your account
created, you’ll need to generate an access token so that you can
upload/share models to your Hugging Face account during the workshop. To
generate a token, visit the <a href="https://huggingface.co/settings/tokens" class="external-link">Access Tokens setting
page</a> after logging in.</p>
</div>
<div class="section level3">
<h3 id="login-to-hugging-face-account">Login to Hugging Face account<a class="anchor" aria-label="anchor" href="#login-to-hugging-face-account"></a>
</h3>
<p>To login, you will need to retrieve your access token from the <a href="https://huggingface.co/settings/tokens" class="external-link">Access Tokens setting
page</a></p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="op">!</span>huggingface<span class="op">-</span>cli login</span></code></pre>
</div>
<p>You might get a message saying you cannot authenticate through
git-credential as no helper is defined on your machine. TODO: What does
this warning mean?</p>
<p>Once logged in, we will need to edit our model class defnition to
include Hugging Face’s “push_to_hub” attribe. To enable the push_to_hub
functionality, you’ll need to include the PyTorchModelHubMixin “mixin
class” provided by the huggingface_hub library. A mixin class is a type
of class used in object-oriented programming to “mix in” additional
properties and methods into a class. The PyTorchModelHubMixin class adds
methods to your PyTorch model to enable easy saving and loading from the
Hugging Face Model Hub.</p>
<p>Here’s how you can adjust the code to incorporate both saving/loading
locally and pushing the model to the Hugging Face Hub.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="im">from</span> huggingface_hub <span class="im">import</span> PyTorchModelHubMixin <span class="co"># NEW</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="kw">class</span> MyModel(nn.Module, PyTorchModelHubMixin): <span class="co"># PyTorchModelHubMixin is new</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, config: Dict[<span class="bu">str</span>, Any]):</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>        <span class="co"># Initialize layers and parameters</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>        <span class="va">self</span>.param <span class="op">=</span> nn.Parameter(torch.rand(config[<span class="st">"num_channels"</span>], config[<span class="st">"hidden_size"</span>]))</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>        <span class="va">self</span>.linear <span class="op">=</span> nn.Linear(config[<span class="st">"hidden_size"</span>], config[<span class="st">"num_classes"</span>])</span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>        <span class="va">self</span>.config <span class="op">=</span> config</span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x: torch.Tensor) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.linear(x <span class="op">+</span> <span class="va">self</span>.param)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># Create model instance with specific configuration</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>config <span class="op">=</span> {<span class="st">"num_channels"</span>: <span class="dv">3</span>, <span class="st">"hidden_size"</span>: <span class="dv">32</span>, <span class="st">"num_classes"</span>: <span class="dv">10</span>}</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>model <span class="op">=</span> MyModel(config<span class="op">=</span>config)</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="bu">print</span>(model)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co"># push to the hub</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>model.push_to_hub(<span class="st">"my-awesome-model"</span>, config<span class="op">=</span>config)</span></code></pre>
</div>
<p><strong>Verifying</strong>: To check your work, head back over to
your Hugging Face and click your profile icon in the top-right of the
website. Click “Profile” from there to view all of your uploaded models.
Alternatively, you can search for your username (or model name) from the
<a href="https://huggingface.co/models" class="external-link">Model Hub</a>.</p>
<div class="section level4">
<h4 id="loading-the-model-from-hugging-face">Loading the model from Hugging Face<a class="anchor" aria-label="anchor" href="#loading-the-model-from-hugging-face"></a>
</h4>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="co"># reload</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>model <span class="op">=</span> MyModel.from_pretrained(<span class="st">"your-username/my-awesome-model"</span>)</span></code></pre>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="uploading-transformer-models-to-hugging-face">Uploading transformer models to Hugging Face<a class="anchor" aria-label="anchor" href="#uploading-transformer-models-to-hugging-face"></a>
<a class="anchor" aria-label="anchor" href="#uploading-transformer-models-to-hugging-face"></a>
</h2>
<hr class="half-width">
<p>Key Differences * <strong>Saving and Loading the Tokenizer</strong>:
Transformer models require a tokenizer that needs to be saved and loaded
with the model. This is not necessary for custom PyTorch models that
typically do not require a separate tokenizer. * <strong>Using
Pre-trained Classes</strong>: Transformer models use classes like
AutoModelForSequenceClassification and AutoTokenizer from the
transformers library, which are pre-built and designed for specific
tasks (e.g., sequence classification). * <strong>Methods for Saving and
Loading</strong>: The transformers library provides save_pretrained and
from_pretrained methods for both models and tokenizers, which handle the
serialization and deserialization processes seamlessly.</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> AutoModelForSequenceClassification, AutoTokenizer</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="co"># Load a pre-trained model and tokenizer</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>model_name <span class="op">=</span> <span class="st">"bert-base-uncased"</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>model <span class="op">=</span> AutoModelForSequenceClassification.from_pretrained(model_name, num_labels<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(model_name)</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a><span class="co"># Save the model and tokenizer locally</span></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>model.save_pretrained(<span class="st">"my_transformer_model"</span>)</span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>tokenizer.save_pretrained(<span class="st">"my_transformer_model"</span>)</span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a><span class="co"># Load the model and tokenizer from the saved directory</span></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a>loaded_model <span class="op">=</span> AutoModelForSequenceClassification.from_pretrained(<span class="st">"my_transformer_model"</span>)</span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a>loaded_tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(<span class="st">"my_transformer_model"</span>)</span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a><span class="co"># Verify the loaded model and tokenizer</span></span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a><span class="bu">print</span>(loaded_model)</span>
<span id="cb12-18"><a href="#cb12-18" tabindex="-1"></a><span class="bu">print</span>(loaded_tokenizer)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="co"># Push the model and tokenizer to Hugging Face Hub</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>model.push_to_hub(<span class="st">"my-awesome-transformer-model"</span>)</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>tokenizer.push_to_hub(<span class="st">"my-awesome-transformer-model"</span>)</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a><span class="co"># Load the model and tokenizer from the Hugging Face Hub</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>hub_model <span class="op">=</span> AutoModelForSequenceClassification.from_pretrained(<span class="st">"user-name/my-awesome-transformer-model"</span>)</span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a>hub_tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(<span class="st">"user-name/my-awesome-transformer-model"</span>)</span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a><span class="co"># Verify the model and tokenizer loaded from the hub</span></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="bu">print</span>(hub_model)</span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a><span class="bu">print</span>(hub_tokenizer)</span></code></pre>
</div>
<div id="what-pieces-must-be-well-documented-to-ensure-reproducible-and-responsible-model-sharing" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="what-pieces-must-be-well-documented-to-ensure-reproducible-and-responsible-model-sharing" class="callout-inner">
<h3 class="callout-title">What pieces must be well-documented to ensure reproducible and responsible model sharing?<a class="anchor" aria-label="anchor" href="#what-pieces-must-be-well-documented-to-ensure-reproducible-and-responsible-model-sharing"></a>
</h3>
<div class="callout-content">
<p>Discuss in small groups and report out: <em>Why do you believe it is
or isn’t important to share ML models? How has model-sharing contributed
to your experiences or projects?</em></p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" aria-labelledby="headingSolution3" data-bs-parent="#accordionSolution3">
<div class="accordion-body">
<ul>
<li>Environment setup</li>
<li>Training data
<ul>
<li>How the data was collected</li>
<li>Who owns the data: data license and usage terms</li>
<li>Basic descriptive statistics: number of samples, features, classes,
etc.</li>
<li>Note any class imbalance or general bias issues</li>
<li>Description of data distribution to help prevent out-of-distribution
failures.</li>
</ul>
</li>
<li>Preprocessing steps.
<ul>
<li>Data splitting</li>
<li>Standardization method</li>
<li>Feature selection</li>
<li>Outlier detection and other filters</li>
</ul>
</li>
<li>Model architecture, hyperparameters and, training procedure (e.g.,
dropout or early stopping)</li>
<li>Model weights</li>
<li>Evaluation metrics. Results and performance. The more tasks/datasets
you can evaluate on, the better.</li>
<li>Ethical considerations: Include investigations of bias/fairness when
applicable (i.e., if your model involves human data or affects
decision-making involving humans)</li>
<li>Contact info</li>
<li>Acknowledgments</li>
<li>Examples and demos (highly recommended)</li>
</ul>
</div>
</div>
</div>
</div>
<div id="document-your-model" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="document-your-model" class="callout-inner">
<h3 class="callout-title">Document your model<a class="anchor" aria-label="anchor" href="#document-your-model"></a>
</h3>
<div class="callout-content">
<p>TODO</p>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" aria-labelledby="headingSolution4" data-bs-parent="#accordionSolution4">
<div class="accordion-body">
<p>TODO</p>
</div>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section>
</div>
    </main>
</div>
<!-- END  : inst/pkgdown/templates/content-extra.html -->

      </div>
<!--/div.row-->
      		<footer class="row footer mx-md-3"><hr>
<div class="col-md-6">
        <p>This lesson is subject to the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a></p>
        <p>

        <a href="https://github.com/carpentries-incubator/fair-explainable-ml/edit/main/README.md" class="external-link">Edit on GitHub</a>

	
        | <a href="https://github.com/carpentries-incubator/fair-explainable-ml/blob/main/CONTRIBUTING.md" class="external-link">Contributing</a>
        | <a href="https://github.com/carpentries-incubator/fair-explainable-ml/" class="external-link">Source</a></p>
				<p><a href="https://github.com/carpentries-incubator/fair-explainable-ml/blob/main/CITATION" class="external-link">Cite</a> | <a href="mailto:apmeyer4@wisc.edu">Contact</a> | <a href="https://carpentries.org/about/" class="external-link">About</a></p>
			</div>
			<div class="col-md-6">

        <p>Materials licensed under <a href="LICENSE.html">CC-BY 4.0</a> by the authors</p>

        <p>Template licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/" class="external-link">CC-BY 4.0</a> by <a href="https://carpentries.org/" class="external-link">The Carpentries</a></p>
        <p>Built with <a href="https://github.com/carpentries/sandpaper/tree/0.16.5" class="external-link">sandpaper (0.16.5)</a>, <a href="https://github.com/carpentries/pegboard/tree/0.7.6" class="external-link">pegboard (0.7.6)</a>, and <a href="https://github.com/carpentries/varnish/tree/1.0.3" class="external-link">varnish (1.0.3)</a></p>
			</div>
		</footer>
</div> <!-- / div.container -->
	<div id="to-top">
		<a href="#top">
      <i class="search-icon" data-feather="arrow-up" role="img" aria-label="Back To Top"></i><br><!-- <span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top --><span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top
		</a>
	</div>
  <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "TrainingMaterial",
  "@id": "https://carpentries-incubator.github.io/fair-explainable-ml/aio.html",
  "inLanguage": "en",
  "dct:conformsTo": "https://bioschemas.org/profiles/TrainingMaterial/1.0-RELEASE",
  "description": "A Carpentries Lesson teaching foundational data and coding skills to researchers worldwide",
  "keywords": "fairness, explainability, fair machine learning, interpretable machine learning, xai, lesson, The Carpentries",
  "name": "All in One View",
  "creativeWorkStatus": "active",
  "url": "https://carpentries-incubator.github.io/fair-explainable-ml/aio.html",
  "identifier": "https://carpentries-incubator.github.io/fair-explainable-ml/aio.html",
  "dateCreated": "2023-12-05",
  "dateModified": "2024-07-31",
  "datePublished": "2024-07-31"
}

  </script><script>
		feather.replace();
	</script>
</body>
</html><!-- END:   inst/pkgdown/templates/layout.html-->

